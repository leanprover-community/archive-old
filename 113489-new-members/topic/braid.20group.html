---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/braid.20group.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html">braid group</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="249142825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249142825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249142825">(Aug 11 2021 at 17:45)</a>:</h4>
<p>i've been struggling a bit to define braid group and properties. i wanted to double check that this is the way to define a braid group using presented groups: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">braid_group</span> <span class="o">(</span><span class="n">σ</span><span class="bp">ᵢ</span> <span class="n">σₖ</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">multiplicative</span> <span class="n">ℤ</span> <span class="bp">≃*</span> <span class="n">presented_group</span> <span class="o">(</span><span class="n">braid_rels</span> <span class="n">σ</span><span class="bp">ᵢ</span> <span class="n">σₖ</span><span class="o">)</span>
</code></pre></div>
<p>is this saying that <code>multiplicative ℤ</code> and <code>presented_group (braid_rels σᵢ σₖ)</code> are both braid groups?</p>



<a name="249143575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249143575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249143575">(Aug 11 2021 at 17:49)</a>:</h4>
<p>Your <code>def</code> says that <code>multiplicative ℤ</code> is isomorphic to the group <code>presented_group (braid_rels σᵢ σₖ)</code>.</p>



<a name="249143583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249143583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249143583">(Aug 11 2021 at 17:50)</a>:</h4>
<p>What is <code>braid_rels</code>?</p>



<a name="249143942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249143942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249143942">(Aug 11 2021 at 17:52)</a>:</h4>
<p>those are braid relations which i tried to write as so:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm">`σₖ⁻¹ * σᵢ⁻¹ * σₖ⁻¹ * σᵢ * σₖ * σᵢ = 1` and `σᵢ⁻¹ * σₖ⁻¹ * σᵢ * σₖ = 1`</span>
<span class="cm">1 ≤ i - k for the second one.  -/</span>
<span class="kd">def</span> <span class="n">braid_rels</span> <span class="o">(</span><span class="n">σ</span><span class="bp">ᵢ</span> <span class="n">σₖ</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{(</span><span class="n">free_group.of</span> <span class="n">σₖ</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">free_group.of</span> <span class="n">σ</span><span class="bp">ᵢ</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">free_group.of</span> <span class="n">σₖ</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span>
<span class="o">(</span><span class="n">free_group.of</span> <span class="n">σ</span><span class="bp">ᵢ</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">free_group.of</span> <span class="n">σₖ</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">free_group.of</span> <span class="n">σ</span><span class="bp">ᵢ</span><span class="o">),</span>
<span class="o">(</span><span class="n">free_group.of</span> <span class="n">σ</span><span class="bp">ᵢ</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">free_group.of</span> <span class="n">σₖ</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">free_group.of</span> <span class="n">σ</span><span class="bp">ᵢ</span><span class="o">)</span> <span class="bp">*</span>
<span class="o">(</span><span class="n">free_group.of</span> <span class="n">σₖ</span><span class="o">)}</span>
</code></pre></div>



<a name="249144148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249144148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249144148">(Aug 11 2021 at 17:54)</a>:</h4>
<p>so <code>σᵢ * σₖ * σᵢ = σₖ * σᵢ * σₖ </code> and <code>σᵢ * σₖ = σₖ * σᵢ</code> for braid crossings <code>σᵢ </code>,<code> σₖ</code></p>



<a name="249144246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249144246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249144246">(Aug 11 2021 at 17:55)</a>:</h4>
<p>These aren't the correct relations for the braid group -- you're inadvertently defining the symmetric group <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">S_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, and that's definitely not isomorphic to <code>multiplicative ℤ</code>.</p>



<a name="249144334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249144334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249144334">(Aug 11 2021 at 17:55)</a>:</h4>
<p>I'm wrong, it's not <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">S_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, but I'm not sure what it is.</p>



<a name="249144938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249144938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249144938">(Aug 11 2021 at 17:59)</a>:</h4>
<p>I see, the relations imply that <code>σᵢ = σₖ</code>, and then it's an infinite cyclic group.  It's not the three-strand braid group, though, which is what you'd expect from two generators.</p>



<a name="249145074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249145074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249145074">(Aug 11 2021 at 18:00)</a>:</h4>
<p>Do you want to define the 3-strand braid group or the general one?</p>



<a name="249145147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249145147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249145147">(Aug 11 2021 at 18:00)</a>:</h4>
<p>yes i think i don't yet have <code>1 &lt; i &lt; n-2</code>for the first relation and <code>i - k ≥ 2</code> for the second one and my indexing is incorrect. how do i say that <code>i</code> and <code>i + 1</code> are the indices rather than <code>i</code>, <code>k</code>?</p>



<a name="249145197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249145197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249145197">(Aug 11 2021 at 18:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113489-new-members/topic/braid.20group/near/249145074">said</a>:</p>
<blockquote>
<p>Do you want to define the 3-strand braid group or the general one?</p>
</blockquote>
<p>i think both</p>



<a name="249145227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249145227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249145227">(Aug 11 2021 at 18:01)</a>:</h4>
<p>The main problem is that <code>σᵢ</code> is just a notation, it has nothing to do with <code>i</code>.</p>



<a name="249145712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249145712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249145712">(Aug 11 2021 at 18:04)</a>:</h4>
<p>You can start with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">of</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">braids_rel3</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{(</span><span class="n">of</span> <span class="mi">0</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">of</span> <span class="mi">1</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">of</span> <span class="mi">0</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">of</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">of</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">of</span> <span class="mi">1</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">braids_group3</span> <span class="o">:=</span> <span class="n">presented_group</span> <span class="n">braids_rel3</span>
</code></pre></div>



<a name="249146295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249146295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249146295">(Aug 11 2021 at 18:08)</a>:</h4>
<p>oh ok</p>



<a name="249146340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249146340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249146340">(Aug 11 2021 at 18:08)</a>:</h4>
<p>In the general case you need something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">of</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">braids_rel</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">i</span> <span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">k</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">(</span><span class="n">of</span> <span class="n">i</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">of</span> <span class="n">k</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">of</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">of</span> <span class="n">k</span><span class="o">)</span> <span class="bp">∨</span> <span class="bp">∃</span> <span class="n">i</span> <span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">k</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">(</span><span class="n">of</span> <span class="n">i</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">of</span> <span class="n">k</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">of</span> <span class="n">i</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">of</span> <span class="n">k</span> <span class="bp">*</span> <span class="n">of</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">of</span> <span class="n">k</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">brais_group</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">presented_group</span> <span class="o">(</span><span class="n">braids_rel</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>



<a name="249146660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249146660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249146660">(Aug 11 2021 at 18:11)</a>:</h4>
<p>I see <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> already came up with a short definition, but this is what I came up with:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.presented_group</span>

<span class="sd">/-- For the n-strand braid group, we will have 1,...,n-1 be the generators. -/</span>
<span class="kd">def</span> <span class="n">braid_gens</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">|</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">i</span> <span class="bp">∧</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">σ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">braid_gens</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">braid_gens</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">free_group.of</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span>

<span class="sd">/-- Generators commute if they have to do with strands at least two away. -/</span>
<span class="kd">def</span> <span class="n">braid_rel_A</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">i</span> <span class="bp">+</span> <span class="n">k</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">braid_gens</span> <span class="n">n</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hj</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">∈</span> <span class="n">braid_gens</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">braid_gens</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">σ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">σ</span> <span class="n">j</span> <span class="n">hj</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">σ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">σ</span> <span class="n">j</span> <span class="n">hj</span><span class="o">)</span>

<span class="sd">/-- The braid relation for adjacent generators. -/</span>
<span class="kd">def</span> <span class="n">braid_rel_B</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">braid_gens</span> <span class="n">n</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hj</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">∈</span> <span class="n">braid_gens</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">braid_gens</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">σ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">σ</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">hj</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">σ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">σ</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">hj</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">σ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">σ</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">hj</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">braid_rels</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="o">(</span><span class="n">braid_gens</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">g</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">h</span> <span class="n">hi</span> <span class="n">hj</span><span class="o">,</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">braid_rel_A</span> <span class="n">n</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">h</span> <span class="n">hi</span> <span class="n">hj</span><span class="o">}</span>
  <span class="bp">∪</span> <span class="o">{</span><span class="n">g</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">i</span> <span class="n">hi</span> <span class="n">hj</span><span class="o">,</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">braid_rel_B</span> <span class="n">n</span> <span class="n">i</span> <span class="n">hi</span> <span class="n">hj</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">braid_group</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">presented_group</span> <span class="o">(</span><span class="n">braid_rels</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>



<a name="249146850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249146850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249146850">(Aug 11 2021 at 18:12)</a>:</h4>
<p>If recommend using <code>fin n</code> instead of <code>braid_gens n</code> because we have more <code>def</code>s and theorems about <code>fin n</code>.</p>



<a name="249146880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249146880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249146880">(Aug 11 2021 at 18:13)</a>:</h4>
<p>It looks like you defined the (n+1)-strand braid group</p>



<a name="249147139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249147139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249147139">(Aug 11 2021 at 18:14)</a>:</h4>
<p>But I like your idea to split the definition into several smaller defs.</p>



<a name="249147293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249147293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249147293">(Aug 11 2021 at 18:16)</a>:</h4>
<p>Do we have that an iso between types induces a group iso between free groups over those types?</p>



<a name="249147407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249147407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249147407">(Aug 11 2021 at 18:16)</a>:</h4>
<p>Either we do, or we should.</p>



<a name="249147494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249147494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249147494">(Aug 11 2021 at 18:17)</a>:</h4>
<p>It'd be nice to define <a href="https://en.wikipedia.org/wiki/Artin%E2%80%93Tits_group">Artin-Tits groups</a> and have the braid groups be a special case.</p>



<a name="249149317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249149317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249149317">(Aug 11 2021 at 18:30)</a>:</h4>
<p>Here's Artin-Tits groups and the braid group:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">alt</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">free_group</span> <span class="n">S</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">s</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">free_group.of</span> <span class="n">s</span> <span class="bp">*</span> <span class="n">alt</span> <span class="n">n</span> <span class="n">t</span> <span class="n">s</span>

<span class="kd">def</span> <span class="n">artin_tits_rels</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="n">S</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">g</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="n">g</span> <span class="bp">=</span> <span class="o">(</span><span class="n">alt</span> <span class="o">(</span><span class="n">m</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">alt</span> <span class="o">(</span><span class="n">m</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span> <span class="n">t</span> <span class="n">s</span><span class="o">)}</span>

<span class="sd">/-- Artin-Tits groups.  Traditionally we require that</span>
<span class="sd">`∀ s t, m s t = m t s` but the hypothesis isn't used in the definition. -/</span>
<span class="kd">def</span> <span class="n">artin_tits</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">presented_group</span> <span class="o">(</span><span class="n">artin_tits_rels</span> <span class="n">S</span> <span class="n">m</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">braid_group</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">artin_tits</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">))</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="k">if</span> <span class="n">abs</span> <span class="o">((</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">-</span> <span class="n">j</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">3</span> <span class="k">else</span> <span class="mi">2</span><span class="o">)</span>
</code></pre></div>



<a name="249150662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249150662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249150662">(Aug 11 2021 at 18:40)</a>:</h4>
<p>Walking through this, <code>alt n s t</code> gives an n-term product starting with <code>s * t * s * t * ...</code>.  The <code>artin_tits</code> group is defined using a matrix <code>m</code> of natural numbers with one row and column per generator, where for <code>s</code> and <code>t</code> there is a relation <code>s * t * s * t * ... = t * s * t * s * ...</code> with <code>m s t</code> terms in the first product and <code>m t s</code> terms in the second.  In the usual definition, the matrix has entries from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">2,3,\dots,\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∞</span></span></span></span>, but (1) you can use <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> instead of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span> and have the same result and (2) there's no harm in allowing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, since it just means you could have written the group with fewer generators.  Also, in the usual definition the matrix is supposed to be symmetric, but that's not used in the definition.</p>
<p>Then the braid group is where for neighboring generators you use 3 terms in the relation, and for non-neighboring generators you use 2 terms.</p>



<a name="249151797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249151797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249151797">(Aug 11 2021 at 18:48)</a>:</h4>
<p>what does <code>m s t</code> and <code>m t s</code> mean? i'm confused on what writing the matrix <code>m</code> next to <code>s</code> <code>t </code> does here</p>



<a name="249151913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249151913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249151913">(Aug 11 2021 at 18:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/braid.20group/near/249147293">said</a>:</p>
<blockquote>
<p>Do we have that an iso between types induces a group iso between free groups over those types?</p>
</blockquote>
<p>I'm fairly sure we have this...</p>



<a name="249152078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249152078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249152078">(Aug 11 2021 at 18:50)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/free_group.free_group_congr">docs#free_group.free_group_congr</a></p>



<a name="249152134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249152134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249152134">(Aug 11 2021 at 18:50)</a>:</h4>
<p>The name should be changed to <code>free_group.congr</code>;)</p>



<a name="249152244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249152244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249152244">(Aug 11 2021 at 18:51)</a>:</h4>
<p><span class="user-mention" data-user-id="418958">@Holly Liu</span> The type of <code>m</code> is <code>m : S → S → ℕ</code>, which is a type commonly thought of as being a matrix.  The two <code>S</code> arguments are like the two indices for the matrix.</p>



<a name="249152620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249152620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249152620">(Aug 11 2021 at 18:53)</a>:</h4>
<p>oh i see. i am also confused about why we want to use a matrix <code>m</code> of natural numbers to contain the generators</p>



<a name="249153101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249153101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249153101">(Aug 11 2021 at 18:57)</a>:</h4>
<p>Braid groups are an example of Artin-Tits groups, and this is how Artin-Tits groups are defined.  (Also, the matrix does not contain the generators, the entries sort of describe "how much the generators commute" so to speak.)</p>



<a name="249153268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249153268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249153268">(Aug 11 2021 at 18:58)</a>:</h4>
<p>In my earlier code, <code>braid_rel_A</code> corresponds to a matrix entry of 2, and <code>braid_rel_B</code> corresponds to a matrix entry of 3</p>



<a name="249153514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249153514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249153514">(Aug 11 2021 at 19:00)</a>:</h4>
<p>I like the artin-tits presentation, it's much more symmetric!</p>



<a name="249153822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249153822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249153822">(Aug 11 2021 at 19:01)</a>:</h4>
<p>hmm ok, i still don't know what commuting generators mean in the context of the matrix. i'll have to read up a bit on artin-tits groups</p>



<a name="249155125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249155125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249155125">(Aug 11 2021 at 19:11)</a>:</h4>
<p>thank you all for the input. it was incredibly helpful <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span></p>



<a name="249155560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249155560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249155560">(Aug 11 2021 at 19:14)</a>:</h4>
<p><span class="user-mention" data-user-id="418958">@Holly Liu</span> Here's half the proof that the 2-strand braid group is infinite cyclic.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">braid_group_2_to_mul_ℤ'</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">multiplicative</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">multiplicative.of_add</span> <span class="mi">1</span>

<span class="kd">def</span> <span class="n">braid_group_2_to_mul_ℤ</span> <span class="o">:</span> <span class="n">braid_group</span> <span class="mi">2</span> <span class="bp">→*</span> <span class="n">multiplicative</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">presented_group.to_group</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">braid_group_2_to_mul_ℤ'</span> <span class="n">_</span> <span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">r</span> <span class="n">hr</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">artin_tits_rels</span><span class="o">]</span> <span class="n">at</span> <span class="n">hr</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">hr</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">fin_cases</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">fin_cases</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">braid_group_2_is_cyclic</span> <span class="o">:</span> <span class="n">braid_group</span> <span class="mi">2</span> <span class="bp">≃*</span> <span class="n">multiplicative</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">braid_group_2_to_mul_ℤ</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">presented_group.of</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">^</span> <span class="n">x.to_add</span><span class="o">,</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="n">braid_group_2_to_mul_ℤ.map_mul</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="249156842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249156842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249156842">(Aug 11 2021 at 19:25)</a>:</h4>
<p>(By the way, I had to make the definitions of <code>braid_group</code> and <code>artin_tits</code> reducible (I used <code>abbreviation</code>) to make Lean see that they're groups. I edited that message.)</p>



<a name="249176973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249176973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249176973">(Aug 11 2021 at 22:19)</a>:</h4>
<p>oh wow ok thanks</p>



<a name="249180415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249180415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249180415">(Aug 11 2021 at 22:59)</a>:</h4>
<p>I'd recommend using <a href="https://leanprover-community.github.io/mathlib_docs/find/monoid_hom.to_mul_equiv">docs#monoid_hom.to_mul_equiv</a> if possible there, because usually the two proofs fall out with <code>ext, simp</code></p>



<a name="249180606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249180606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249180606">(Aug 11 2021 at 23:01)</a>:</h4>
<p>And if they don't, then you should add the lemmas needed so that they do!</p>



<a name="249188178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249188178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249188178">(Aug 12 2021 at 01:04)</a>:</h4>
<p>Only partially following <span class="user-mention" data-user-id="310045">@Eric Wieser</span>'s advice (and it'd be better to follow all of it), here's an unrefined proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- import algebra.group_power</span>

<span class="kd">def</span> <span class="n">braid_group_2_to_mul_ℤ'</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">multiplicative</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">multiplicative.of_add</span> <span class="mi">1</span>

<span class="kd">def</span> <span class="n">braid_group_2_to_mul_ℤ</span> <span class="o">:</span> <span class="n">braid_group</span> <span class="mi">2</span> <span class="bp">→*</span> <span class="n">multiplicative</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">presented_group.to_group</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">braid_group_2_to_mul_ℤ'</span> <span class="n">_</span> <span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">r</span> <span class="n">hr</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">artin_tits_rels</span><span class="o">]</span> <span class="n">at</span> <span class="n">hr</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">hr</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">fin_cases</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">fin_cases</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">mul_ℤ_to_braid_group_2</span> <span class="o">:</span> <span class="n">multiplicative</span> <span class="n">ℤ</span> <span class="bp">→*</span> <span class="n">braid_group</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="n">gpowers_hom</span> <span class="o">(</span><span class="n">braid_group</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">presented_group.of</span> <span class="mi">0</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">braid_group_2_is_cyclic</span> <span class="o">:</span> <span class="n">braid_group</span> <span class="mi">2</span> <span class="bp">≃*</span> <span class="n">multiplicative</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="n">monoid_hom.to_mul_equiv</span> <span class="n">braid_group_2_to_mul_ℤ</span> <span class="n">mul_ℤ_to_braid_group_2</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">braid_group_2_to_mul_ℤ</span><span class="o">,</span> <span class="n">mul_ℤ_to_braid_group_2</span><span class="o">,</span> <span class="n">monoid_hom.id_apply</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">,</span> <span class="n">monoid_hom.coe_comp</span><span class="o">,</span>
    <span class="n">gpowers_hom_apply</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">quotient_group.induction_on</span> <span class="n">x</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">refine</span> <span class="n">free_group.induction_on</span> <span class="n">x</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">fin_cases</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">fin_cases</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">change</span> <span class="n">_</span> <span class="bp">=</span> <span class="o">(</span><span class="n">quotient_group.mk</span> <span class="o">(</span><span class="n">pure</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">braid_group</span> <span class="mi">2</span><span class="o">)</span><span class="bp">⁻¹</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">h</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">change</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">quotient_group.mk</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">quotient_group.mk</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">h1</span><span class="o">,</span> <span class="bp">←</span><span class="n">h2</span><span class="o">],</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">gpow_add</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">to_add_mul</span><span class="o">,</span>
    <span class="n">congr'</span> <span class="mi">2</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">presented_group.to_group</span><span class="o">,</span> <span class="n">monoid_hom.map_mul</span><span class="o">,</span> <span class="n">quotient_group.lift_mk'</span><span class="o">],</span> <span class="o">},</span>
<span class="kd">end</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="249188429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249188429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249188429">(Aug 12 2021 at 01:10)</a>:</h4>
<p>This really shouldn't be the proof -- instead it should be that it's a group presentation with to relations, so it's a free group, and it's a free group with one generator, so it's isomorphic to <code>multiplicative ℤ</code>.</p>
<p>(It doesn't apply here, but it would be nice if there were things like <a href="https://en.wikipedia.org/wiki/Tietze_transformations">Tietze transformations</a> for group presentations.)</p>



<a name="249189533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249189533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249189533">(Aug 12 2021 at 01:35)</a>:</h4>
<p>A good relevant test of such transformations would be to show that <code>braid_group 3</code> is isomorphic to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∣</mo><msup><mi>x</mi><mn>2</mn></msup><mo>=</mo><msup><mi>y</mi><mn>3</mn></msup><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle x,y \mid x^2 = y^3\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">⟩</span></span></span></span>.</p>



<a name="249202812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249202812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249202812">(Aug 12 2021 at 06:53)</a>:</h4>
<p>There's definitely an ext lemma missing on quotient_group that that proof would benefit from</p>



<a name="249209986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249209986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249209986">(Aug 12 2021 at 08:40)</a>:</h4>
<p>Added those lemmas in <a href="https://github.com/leanprover-community/mathlib/issues/8641">#8641</a></p>



<a name="249302260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249302260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249302260">(Aug 12 2021 at 22:38)</a>:</h4>
<p>why does this result in <code>free_group S</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">alt</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">free_group</span> <span class="n">S</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">s</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">free_group.of</span> <span class="n">s</span> <span class="bp">*</span> <span class="n">alt</span> <span class="n">n</span> <span class="n">t</span> <span class="n">s</span>
</code></pre></div>



<a name="249303737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249303737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249303737">(Aug 12 2021 at 22:57)</a>:</h4>
<p>why wouldn't it?</p>



<a name="249304464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249304464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249304464">(Aug 12 2021 at 23:06)</a>:</h4>
<p><span class="user-mention" data-user-id="418958">@Holly Liu</span> Are you familiar with how to write recursive definitions in Lean? This is recursing on the natural number argument to create a product of the form <code>free_group.of s * free_group.of t * free_group.of s * ...</code> with <code>n</code> terms.</p>



<a name="249304514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249304514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249304514">(Aug 12 2021 at 23:07)</a>:</h4>
<p>Well, technically it has n+1 terms with the last term being <code>1</code>. For example, <code>alt 2 s t</code> is <code>free_group.of s * free_group.of t * 1</code>.</p>



<a name="249308724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249308724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249308724">(Aug 13 2021 at 00:14)</a>:</h4>
<p>oh ok, i think i understand the recursive part. i've been using <code>free_group.of</code> to define the generators but i don't actually know why we do this. this seems to be saying a generator is a free group and the product <code>free_group.of s * free_group.of t * ...</code> is also a free group, but this looks like a word to me.</p>



<a name="249308932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249308932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249308932">(Aug 13 2021 at 00:18)</a>:</h4>
<p>Have you studied free groups and their universal property?  <code>free_group.of</code> is the function <code>S → free_group S</code> that is part of the universal property.</p>



<a name="249308961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249308961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249308961">(Aug 13 2021 at 00:19)</a>:</h4>
<p>The result of <code>free_group.of s</code> is not a free group, it's an element of the free group.  A word of length 1 in particular.</p>



<a name="249309050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249309050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249309050">(Aug 13 2021 at 00:21)</a>:</h4>
<p><code>alt n s t</code> is creating a word of length n that looks like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>s</mi><mi>t</mi><mi>s</mi><mi>t</mi><mo>…</mo></mrow><annotation encoding="application/x-tex">ststst\dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span> in math.</p>



<a name="249309483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249309483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249309483">(Aug 13 2021 at 00:29)</a>:</h4>
<p>ah so if it's of type <code>free_group S</code> then it is an element? that makes more sense and probably something fundamental i should know...<br>
i know a bit about free groups and haven't yet studied them rigorously. i've also just been reading the manuals on lean and lack a lot of practice coding with it, though the proofs you gave me are helpful</p>



<a name="249309665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249309665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249309665">(Aug 13 2021 at 00:33)</a>:</h4>
<p>Yeah, <code>free_group S</code> is <em>the</em> free group generated by <code>S</code>.  There's only one group (up to isomorphism) freely generated by <code>S</code>, so it wouldn't be very useful having a whole type of free groups.  Mathlib chooses just one of them (representing elements by words) and calls it <code>free_group S</code>.</p>



<a name="249310553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249310553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249310553">(Aug 13 2021 at 00:51)</a>:</h4>
<p>so then this isn't true for sets right? if something is of type <code>set (free_group S)</code> then it's an element of this set of sets? i vaguely remember reading something about for <code>U : Type</code>, <code>A : set U</code> is a set.</p>



<a name="249311353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249311353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249311353">(Aug 13 2021 at 01:04)</a>:</h4>
<p>an element of <code>set (free_group S)</code> is a subset of the free group</p>



<a name="249311655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249311655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249311655">(Aug 13 2021 at 01:09)</a>:</h4>
<p>in your example, <code>A</code> is a subset of <code>U</code>.  (I'm using "subset" like how we mean it in math.  A type <code>U</code> is basically a set, and things with type <code>set U</code> are sets whose elements have type <code>U</code>, or in other words things with type <code>set U</code> are subsets of <code>U</code>.  Don't take this too literally, since <code>example (U : Type) (A : set U) : A ⊆ U := sorry</code> gives a type error -- the subset-of relation is only for subsets of the same type.  <code>set.univ</code> is the name for the subset of <code>U</code> that represents <code>U</code> being a subset of itself, so <code>example (U : Type) (A : set U) : A ⊆ set.univ := sorry</code> resolves that type error.)</p>



<a name="249312081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249312081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249312081">(Aug 13 2021 at 01:16)</a>:</h4>
<p>that makes sense. thanks.</p>



<a name="249400848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249400848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249400848">(Aug 13 2021 at 19:11)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>, would you mind trying out your proof above with the now-merged ext lemmas? I don't have a mwe to hand.</p>



<a name="249405713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249405713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249405713">(Aug 13 2021 at 19:53)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> Nice, those worked great (with a bit of heavy refling):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">braid_group_2_is_cyclic</span> <span class="o">:</span> <span class="n">braid_group</span> <span class="mi">2</span> <span class="bp">≃*</span> <span class="n">multiplicative</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="n">monoid_hom.to_mul_equiv</span> <span class="n">braid_group_2_to_mul_ℤ</span> <span class="n">mul_ℤ_to_braid_group_2</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">fin_cases</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>MWE:</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">group_theory.presented_group</span>
<span class="kn">import</span> <span class="n">algebra.group_power</span>

<span class="kd">def</span> <span class="n">alt</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">free_group</span> <span class="n">S</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">s</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">free_group.of</span> <span class="n">s</span> <span class="bp">*</span> <span class="n">alt</span> <span class="n">n</span> <span class="n">t</span> <span class="n">s</span>

<span class="kd">def</span> <span class="n">artin_tits_rels</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="n">S</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">g</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="n">g</span> <span class="bp">=</span> <span class="o">(</span><span class="n">alt</span> <span class="o">(</span><span class="n">m</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">alt</span> <span class="o">(</span><span class="n">m</span> <span class="n">t</span> <span class="n">s</span><span class="o">)</span> <span class="n">t</span> <span class="n">s</span><span class="o">)}</span>

<span class="sd">/-- Artin-Tits groups.  Traditionally we require that</span>
<span class="sd">`∀ s t, m s t = m t s` but the hypothesis isn't used in the definition. -/</span>
<span class="kd">abbreviation</span> <span class="n">artin_tits</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">presented_group</span> <span class="o">(</span><span class="n">artin_tits_rels</span> <span class="n">S</span> <span class="n">m</span><span class="o">)</span>

<span class="kd">abbreviation</span> <span class="n">braid_group</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">artin_tits</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">))</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="k">if</span> <span class="n">abs</span> <span class="o">((</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">-</span> <span class="n">j</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">3</span> <span class="k">else</span> <span class="mi">2</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">braid_group_2_to_mul_ℤ'</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">multiplicative</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">multiplicative.of_add</span> <span class="mi">1</span>

<span class="kd">def</span> <span class="n">braid_group_2_to_mul_ℤ</span> <span class="o">:</span> <span class="n">braid_group</span> <span class="mi">2</span> <span class="bp">→*</span> <span class="n">multiplicative</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">presented_group.to_group</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">braid_group_2_to_mul_ℤ'</span> <span class="n">_</span> <span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">r</span> <span class="n">hr</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">artin_tits_rels</span><span class="o">]</span> <span class="n">at</span> <span class="n">hr</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">hr</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">fin_cases</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">fin_cases</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">mul_ℤ_to_braid_group_2</span> <span class="o">:</span> <span class="n">multiplicative</span> <span class="n">ℤ</span> <span class="bp">→*</span> <span class="n">braid_group</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="n">gpowers_hom</span> <span class="o">(</span><span class="n">braid_group</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">presented_group.of</span> <span class="mi">0</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">braid_group_2_is_cyclic</span> <span class="o">:</span> <span class="n">braid_group</span> <span class="mi">2</span> <span class="bp">≃*</span> <span class="n">multiplicative</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="n">monoid_hom.to_mul_equiv</span> <span class="n">braid_group_2_to_mul_ℤ</span> <span class="n">mul_ℤ_to_braid_group_2</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">fin_cases</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="249407499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249407499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249407499">(Aug 13 2021 at 20:08)</a>:</h4>
<p>how do i resolve red underlines for <code>fin_cases</code>?</p>



<a name="249408330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249408330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249408330">(Aug 13 2021 at 20:14)</a>:</h4>
<p><code>import tactic</code>?</p>



<a name="249408953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249408953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249408953">(Aug 13 2021 at 20:19)</a>:</h4>
<p>thanks</p>



<a name="249410559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249410559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249410559">(Aug 13 2021 at 20:32)</a>:</h4>
<p>I wonder if <code>ext</code> should know about <code>fin 1</code> too...</p>



<a name="249667294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249667294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249667294">(Aug 17 2021 at 01:00)</a>:</h4>
<p>for the line <code>(λ i j, if abs ((i : ℤ) - j) = 1 then 3 else 2)</code> in this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">abbreviation</span> <span class="n">artin_tits</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">presented_group</span> <span class="o">(</span><span class="n">artin_tits_rels</span> <span class="n">S</span> <span class="n">m</span><span class="o">)</span>

<span class="kd">abbreviation</span> <span class="n">braid_group</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">artin_tits</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">))</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="k">if</span> <span class="n">abs</span> <span class="o">((</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">-</span> <span class="n">j</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">3</span> <span class="k">else</span> <span class="mi">2</span><span class="o">)</span>
</code></pre></div>
<p>why do we have <code>i : ℤ</code> if <code>i</code> is also of type <code>fin (n-1)</code>?</p>



<a name="249667633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249667633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249667633">(Aug 17 2021 at 01:07)</a>:</h4>
<p>The <code>(i : ℤ)</code> is casting from <code>fin (n-1)</code> to <code>ℤ</code>, so that the subtraction happens in <code>ℤ</code>, rather than in <code>fin (n-1)</code> (where subtraction means truncated subtraction).</p>



<a name="249667643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249667643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249667643">(Aug 17 2021 at 01:07)</a>:</h4>
<p>This is not obviously the ideal way to do this!</p>



<a name="249667691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249667691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249667691">(Aug 17 2021 at 01:08)</a>:</h4>
<p>I wonder if <code>fin n</code> has a <code>dist</code> function (or should have)?</p>



<a name="249668565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249668565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249668565">(Aug 17 2021 at 01:25)</a>:</h4>
<p>what is truncated subtraction?</p>



<a name="249668586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249668586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249668586">(Aug 17 2021 at 01:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/braid.20group/near/249667633">said</a>:</p>
<blockquote>
<p>in <code>fin (n-1)</code> (where subtraction means truncated subtraction).</p>
</blockquote>
<p>(I'd thought so too, but it seems to be subtraction mod <code>n - 1</code>! <a href="https://leanprover-community.github.io/mathlib_docs/find/fin.sub">docs#fin.sub</a>)</p>



<a name="249668758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249668758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249668758">(Aug 17 2021 at 01:28)</a>:</h4>
<p>A subtlety, by the way, with <code>(i : ℤ) - j</code> is that it's actually casting both <code>i</code> and <code>j</code>, so it could also have been written more clearly as <code>(i : ℤ) - (j : ℤ)</code>.  I shouldn't have saved those handful of characters since it makes it less clear.</p>



<a name="249669065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249669065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249669065">(Aug 17 2021 at 01:35)</a>:</h4>
<p>why would we need to cast it here? wouldn't any number in <code>fin (n-1)</code> subtracted by another number from <code>fin (n-1)</code> always be less than <code>fin (n-1)</code>?</p>



<a name="249669125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249669125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249669125">(Aug 17 2021 at 01:37)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">test</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">5</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">-</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">5</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">test</span> <span class="mi">0</span>
<span class="c1">-- shows 3</span>
</code></pre></div>



<a name="249669283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249669283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249669283">(Aug 17 2021 at 01:40)</a>:</h4>
<p>oh got it, thanks</p>



<a name="249687427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249687427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249687427">(Aug 17 2021 at 07:39)</a>:</h4>
<p>I'd argue <code>(i - j : ℤ)</code> would be the clearest way to spell the cast</p>



<a name="249691394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249691394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249691394">(Aug 17 2021 at 08:35)</a>:</h4>
<p>No, that version is very confusing for beginners.</p>



<a name="249691545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249691545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249691545">(Aug 17 2021 at 08:37)</a>:</h4>
<p>It is very unintuitive for most people that the casts happen as early as possible, rather than "at the moment indicated by the typography".</p>



<a name="249692476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249692476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249692476">(Aug 17 2021 at 08:50)</a>:</h4>
<p>The Perl part of Lean.  (It's very reminiscent of scalar/list contexts.)</p>



<a name="249694086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249694086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249694086">(Aug 17 2021 at 09:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/braid.20group/near/249691394">said</a>:</p>
<blockquote>
<p>No, that version is very confusing for beginners.</p>
</blockquote>
<p>Yes, but if you start preferring the spelling <code>(i : ℤ)- j</code> instead of <code>(i - j : ℤ)</code> to make things "easier" for beginners, you've given those beginners exactly the wrong intuition as to how to read casts, and the non-intuitiveness is self-fulfilling. I guess the way to avoid that while also not confusing beginners is <code>(↑i - ↑j : ℤ)</code>, which reads as <code>(_ : ℤ)</code> ("lean I am telling you an integer") and <code>↑i</code> ("do a cast for me").</p>



<a name="249927653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249927653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249927653">(Aug 19 2021 at 00:19)</a>:</h4>
<p>i am getting an error here:<br>
<a href="/user_uploads/3121/AQN46v9Ce7wrV7K36XcvuOsR/image.png">image.png</a> <br>
this is the message:<br>
<a href="/user_uploads/3121/rjCE48X78F4nRRP8TwEluTrN/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/AQN46v9Ce7wrV7K36XcvuOsR/image.png" title="image.png"><img src="/user_uploads/3121/AQN46v9Ce7wrV7K36XcvuOsR/image.png"></a></div><div class="message_inline_image"><a href="/user_uploads/3121/rjCE48X78F4nRRP8TwEluTrN/image.png" title="image.png"><img src="/user_uploads/3121/rjCE48X78F4nRRP8TwEluTrN/image.png"></a></div>



<a name="249927716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249927716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249927716">(Aug 19 2021 at 00:20)</a>:</h4>
<p>these are my imports:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.zmod.basic</span>
<span class="kn">import</span> <span class="n">group_theory.presented_group</span>
<span class="kn">import</span> <span class="n">group_theory.free_group</span>
<span class="kn">import</span> <span class="n">data.equiv.mul_add</span>
<span class="kn">import</span> <span class="n">algebra.group.defs</span>
<span class="kn">import</span> <span class="n">algebra.group_power</span>
<span class="kn">import</span> <span class="n">tactic</span>
</code></pre></div>



<a name="249927859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249927859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249927859">(Aug 19 2021 at 00:22)</a>:</h4>
<p>It says it can't prove that <code>braid_group 2</code> is finite. I don't know much about braid groups but considering that you are trying to prove it's isomorphic to <code>multiplicative int</code> I would guess this is false</p>



<a name="249928012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249928012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249928012">(Aug 19 2021 at 00:25)</a>:</h4>
<p>I see you picked this theorem from up-thread. I guess <code>ext</code> is finding the wrong extensionality lemma - there is probably an extensionality lemma saying that functions out of <code>braid_group 2</code> are determined by their values on <code>x : fin 2</code> but you are getting a more generic <code>ext</code> lemma</p>



<a name="249928998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249928998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249928998">(Aug 19 2021 at 00:42)</a>:</h4>
<p>Perhaps the ext lemma isn't matching because Holly's <code>braid_group</code> isn't an abbreviation like the one upthread</p>



<a name="249929012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249929012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249929012">(Aug 19 2021 at 00:43)</a>:</h4>
<p>(who can say without a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>)</p>



<a name="249930930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/249930930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#249930930">(Aug 19 2021 at 01:20)</a>:</h4>
<p>The braid group is not finite.</p>



<a name="250047000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250047000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250047000">(Aug 19 2021 at 20:49)</a>:</h4>
<p>ah ok. how do i add the updated <code>ext</code> to the mathlib version on my desktop?</p>



<a name="250049571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250049571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250049571">(Aug 19 2021 at 21:09)</a>:</h4>
<p>(For those who missed it, the <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> is in the spoiler tag upthread at <a href="#narrow/stream/113489-new-members/topic/braid.20group/near/249405713">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/braid.20group/near/249405713</a> and the reason <code>fin_cases</code> isn't working is because <span class="user-mention" data-user-id="310045">@Eric Wieser</span> added some new <code>ext</code> lemmas.)</p>



<a name="250049723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250049723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250049723">(Aug 19 2021 at 21:10)</a>:</h4>
<p><span class="user-mention" data-user-id="418958">@Holly Liu</span> How is your project set up? Are you editing inside mathlib itself (that's what I normally do) or do you have a separate project that just uses mathlib?</p>



<a name="250050539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250050539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250050539">(Aug 19 2021 at 21:16)</a>:</h4>
<p>If it's the second, I think <code>leanproject up</code> (short for <code>leanproject upgrade-mathlib</code>) will update mathlib.</p>



<a name="250051889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250051889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250051889">(Aug 19 2021 at 21:29)</a>:</h4>
<p>Wait, did I break it?</p>



<a name="250052178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250052178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250052178">(Aug 19 2021 at 21:32)</a>:</h4>
<p>No, the <code>fin_cases</code> that doesn't work is because it relies on your <code>ext</code> lemmas, and <span class="user-mention" data-user-id="418958">@Holly Liu</span> hasn't updated mathlib. (You only broke it if somehow you're Merlin-like, living backwards in time.)</p>



<a name="250058082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250058082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250058082">(Aug 19 2021 at 22:41)</a>:</h4>
<p>i am still getting the error after doing <code>leanproject up</code>. maybe i should just copy paste the lemma into the file, or try editing inside mathlib itself?</p>



<a name="250141085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250141085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250141085">(Aug 20 2021 at 16:31)</a>:</h4>
<p>hello again. i am trying to prove the following</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"> Every 2-braid can be written in the form `σ₁^n` for some integer `n`. -/</span>
<span class="kd">lemma</span> <span class="n">n_form</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">braid_group</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">0</span><span class="bp">^</span><span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">braid_group</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>

<span class="kd">end</span>
</code></pre></div>
<p>i'm trying to say <code>0^n</code> is a type of <code>braid_group 2</code>, however i'm not able to declare the generator <code>0</code>. i get the error <code>invalid binder, identifier expected</code>. how do i go about this?</p>



<a name="250141189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250141189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250141189">(Aug 20 2021 at 16:32)</a>:</h4>
<p>i think the <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> is upthread in the spoiler tag, as mentioned before</p>



<a name="250142788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250142788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250142788">(Aug 20 2021 at 16:46)</a>:</h4>
<p>Your statement is nonsensical to me; do you understand how <code>:</code> works in a lemma statement? In particular, everything before the colon should be of the form <code>(name : type)</code> or similar. Lean is complaining that <code>0</code> is not a name.</p>



<a name="250143546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250143546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250143546">(Aug 20 2021 at 16:53)</a>:</h4>
<p>oh ok i see. is there a way to declare just the element <code>0</code> of <code>braid_group 2</code>?</p>



<a name="250143677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250143677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250143677">(Aug 20 2021 at 16:54)</a>:</h4>
<p>It depends what you mean by declare. You can maybe write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">another_spelling_of_zero</span> <span class="o">:</span> <span class="n">braid_group</span> <span class="mi">2</span> <span class="o">:=</span> <span class="mi">0</span>
</code></pre></div>



<a name="250143704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250143704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250143704">(Aug 20 2021 at 16:54)</a>:</h4>
<p><code>(0 : braid_group 2)^n</code> would be a way to use <code>0</code> in <code>braid_group 2</code> (though it doesn't have <code>0</code>)</p>



<a name="250143751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250143751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250143751">(Aug 20 2021 at 16:55)</a>:</h4>
<p>Maybe you mean this <code>0</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">σ₁</span> <span class="o">:</span> <span class="n">braid_group</span> <span class="mi">2</span> <span class="o">:=</span> <span class="n">presented_group.of</span> <span class="mi">0</span>
</code></pre></div>



<a name="250143911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250143911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250143911">(Aug 20 2021 at 16:56)</a>:</h4>
<p>oh yes i think that's the one i meant.</p>



<a name="250143915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250143915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250143915">(Aug 20 2021 at 16:56)</a>:</h4>
<p>And maybe you mean this lemma?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">σ₁</span> <span class="o">:</span> <span class="n">braid_group</span> <span class="mi">2</span> <span class="o">:=</span> <span class="n">presented_group.of</span> <span class="mi">0</span>

<span class="c">/-</span><span class="cm"> Every 2-braid can be written in the form `σ₁^n` for some integer `n`. -/</span>
<span class="kd">lemma</span> <span class="n">n_form</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">braid_group</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">σ₁</span> <span class="bp">^</span> <span class="o">(</span><span class="n">braid_group_2_is_cyclic</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="kd">end</span>
</code></pre></div>



<a name="250144459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250144459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250144459">(Aug 20 2021 at 17:00)</a>:</h4>
<p>what is the <code>(braid_group_2_is_cyclic x).to_add</code> doing?</p>



<a name="250144830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250144830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250144830">(Aug 20 2021 at 17:03)</a>:</h4>
<p>This proof that the braid group was equivalent to the infinite cyclic group was much stronger than just saying they're equivalent -- it is an explicit isomorphism between them.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">braid_group_2_is_cyclic</span> <span class="o">:</span> <span class="n">braid_group</span> <span class="mi">2</span> <span class="bp">≃*</span> <span class="n">multiplicative</span> <span class="n">ℤ</span>
</code></pre></div>
<p>So <code>braid_group_2_is_cyclic x</code> gives the image of <code>x</code> in the cyclic group.  If you convert that element to <code>ℤ</code> (using <code>to_add</code>) you get the power you need to construct <code>x</code> from the generator.</p>
<p>The proof of <code>n_form</code> should probably be one line, but I'm not sure what that one line is.</p>



<a name="250145441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250145441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250145441">(Aug 20 2021 at 17:09)</a>:</h4>
<p>ok i think i understand. thanks!</p>



<a name="250148312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250148312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250148312">(Aug 20 2021 at 17:33)</a>:</h4>
<p>Probably you want to use <a href="https://leanprover-community.github.io/mathlib_docs/find/gpowers_hom">docs#gpowers_hom</a> to make it an equality of monoid_homs, then use <code>ext</code></p>



<a name="250148529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250148529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250148529">(Aug 20 2021 at 17:34)</a>:</h4>
<p>(deleted)</p>



<a name="250148765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250148765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250148765">(Aug 20 2021 at 17:36)</a>:</h4>
<p>Oh, the proof will just be <code>braid_group_2_is_cyclic.apply_symm_apply x</code> or <code>braid_group_2_is_cyclic.symm_apply_apply x</code></p>



<a name="250149105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250149105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250149105">(Aug 20 2021 at 17:38)</a>:</h4>
<p>tada:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">n_form</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">braid_group</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">σ₁</span> <span class="bp">^</span> <span class="o">(</span><span class="n">braid_group_2_is_cyclic</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">braid_group_2_is_cyclic.symm_apply_apply</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
</code></pre></div>



<a name="250150919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250150919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250150919">(Aug 20 2021 at 17:53)</a>:</h4>
<p><del>is it using the <code>mul_equiv.symm_apply_apply</code> or the <code>equiv.symm_apply_apply</code>? or does it matter</del> nvm</p>



<a name="250163599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250163599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250163599">(Aug 20 2021 at 19:40)</a>:</h4>
<p>i seem to be getting errors with the above code:<br>
<a href="/user_uploads/3121/c5RyH6Zj5NjUX0VFY2HmHPDC/image.png">image.png</a> <br>
these are the messages:<br>
<a href="/user_uploads/3121/rkcZFIXnyt7eQk0VRtBJLUty/image.png">image.png</a> <br>
i wonder if this is because a part of the proof in <code>braid_group_2_is_cyclic</code> is not working in my project?</p>
<div class="message_inline_image"><a href="/user_uploads/3121/c5RyH6Zj5NjUX0VFY2HmHPDC/image.png" title="image.png"><img src="/user_uploads/3121/c5RyH6Zj5NjUX0VFY2HmHPDC/image.png"></a></div><div class="message_inline_image"><a href="/user_uploads/3121/rkcZFIXnyt7eQk0VRtBJLUty/image.png" title="image.png"><img src="/user_uploads/3121/rkcZFIXnyt7eQk0VRtBJLUty/image.png"></a></div>



<a name="250164847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250164847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250164847">(Aug 20 2021 at 19:52)</a>:</h4>
<p>Either remove the begin/end or put <code>exact</code> at the beginning of that line.</p>



<a name="250164892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250164892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250164892">(Aug 20 2021 at 19:52)</a>:</h4>
<p>The one-line proof is a "term-mode" proof</p>



<a name="250234140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250234140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250234140">(Aug 21 2021 at 19:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/braid.20group/near/250149105">said</a>:</p>
<blockquote>
<p>tada:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">n_form</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">braid_group</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">σ₁</span> <span class="bp">^</span> <span class="o">(</span><span class="n">braid_group_2_is_cyclic</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">braid_group_2_is_cyclic.symm_apply_apply</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
</code></pre></div><br>
</p>
</blockquote>
<p>what is <code>braid_group_2_is_cyclic.symm_apply_apply x</code> doing?</p>



<a name="250235104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250235104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250235104">(Aug 21 2021 at 20:17)</a>:</h4>
<p>Have you followed the definition for <code>symm_apply_apply</code> yet?</p>



<a name="250235937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250235937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250235937">(Aug 21 2021 at 20:38)</a>:</h4>
<p>i think it is saying perform <code>braid_group_2_is_cyclic.symm : multiplicative ℤ ≃* braid_group 2 </code> then map <code>x : braid_group 2</code> to it's corresponding element in <code>multiplicative ℤ</code> then map that back to <code>braid_group_2_is_cyclic.symm</code> to get <code>x</code> again?</p>



<a name="250237805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/braid%20group/near/250237805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/braid.20group.html#250237805">(Aug 21 2021 at 21:23)</a>:</h4>
<p>essentially i think it's saying <code>for sets M,N, M ≃* N → N ≃* M, N(M(x)) = x</code> and then you flip it to get <code>x = N(M(x)) </code>. if this is correct, i'm a bit confused about how this is of type <code>x = 0 * 0 * ... * 0</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
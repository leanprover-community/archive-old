---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Prove.20sizeof.20small.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html">Prove sizeof small</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="215216116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215216116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215216116">(Oct 31 2020 at 23:06)</a>:</h4>
<p>I feel like the theorem below is "obvious" since a subinterval should have smaller <code>sizeof</code>, but how to prove?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="kd">def</span> <span class="n">excess_left_parens</span><span class="o">:</span> <span class="n">list</span> <span class="n">char</span> <span class="bp">→</span> <span class="n">ℤ</span>
<span class="c1">-- excess_left_parens ['(','(',')'] = 1</span>
 <span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="mi">0</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">if</span> <span class="n">c</span><span class="bp">=</span><span class="sc">'('</span> <span class="k">then</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">excess_left_parens</span> <span class="n">x</span> <span class="k">else</span>
    <span class="k">if</span> <span class="n">c</span><span class="bp">=</span><span class="sc">')'</span> <span class="k">then</span> <span class="bp">-</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">excess_left_parens</span> <span class="n">x</span> <span class="k">else</span>
    <span class="n">excess_left_parens</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">last_balanced_suffix</span> <span class="o">:</span> <span class="n">list</span> <span class="n">char</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">char</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span><span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">last_balanced_suffix</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">[]</span> <span class="k">then</span>
    <span class="k">if</span> <span class="n">excess_left_parens</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="k">then</span>
        <span class="k">if</span> <span class="n">c</span><span class="bp">=</span><span class="sc">'('</span> <span class="k">then</span> <span class="o">(</span><span class="n">append</span> <span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="n">x</span><span class="o">)</span> <span class="k">else</span> <span class="o">[]</span>
    <span class="k">else</span> <span class="o">[]</span>
<span class="k">else</span> <span class="o">(</span><span class="n">last_balanced_suffix</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">maybe</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="n">char</span><span class="o">}</span>  <span class="o">:</span> <span class="o">(</span><span class="n">last_balanced_suffix</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">≤</span> <span class="n">x.sizeof</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">sorry</span>
</code></pre></div>



<a name="215217113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215217113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215217113">(Oct 31 2020 at 23:38)</a>:</h4>
<p>You probably shouldn't be proving any theorems directly about <code>sizeof</code>, it's mostly an implementation detail</p>



<a name="215217117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215217117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215217117">(Oct 31 2020 at 23:38)</a>:</h4>
<p>why do you want this theorem?</p>



<a name="215217180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215217180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215217180">(Oct 31 2020 at 23:40)</a>:</h4>
<p><code>(append [c] x)</code> could be written just <code>c::x</code></p>



<a name="215217193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215217193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215217193">(Oct 31 2020 at 23:41)</a>:</h4>
<p>and it appears that you can prove that it is a suffix of the original list, <code>list_balanced_suffix x &lt;:+ x</code></p>



<a name="215217239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215217239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215217239">(Oct 31 2020 at 23:42)</a>:</h4>
<p>from which it follows that <code>(list_balanced_suffix x).length &lt;= x.length</code>, which should be used in preference to a theorem about <code>sizeof</code></p>



<a name="215217428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215217428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215217428">(Oct 31 2020 at 23:48)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  it seemed that the unproved goal in another definition required proving something about <code>sizeof</code> but I'll see what I can do with your hints</p>



<a name="215217452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215217452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215217452">(Oct 31 2020 at 23:49)</a>:</h4>
<p>Usually <code>sizeof</code> comes up when you want to write a recursive function and the automatic well founded recursion proof technique fails. In that case you should just replace the well founded metric with the right one for the definition, in this case something involving <code>list.length</code></p>



<a name="215219634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215219634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215219634">(Nov 01 2020 at 00:59)</a>:</h4>
<p>Now how do we tell Lean to use <code>length</code> instead of <code>sizeof</code>?</p>



<a name="215219798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215219798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215219798">(Nov 01 2020 at 01:03)</a>:</h4>
<p>Can you share the other goal in the form of a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> ? <a href="https://leanprover-community.github.io/extras/well_founded_recursion.html">This page on well-founded recursion</a> on the community website might be useful.</p>



<a name="215220040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215220040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215220040">(Nov 01 2020 at 01:10)</a>:</h4>
<p>Is this an equivalent defn?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">excess_left_parens</span><span class="o">:</span> <span class="n">list</span> <span class="n">char</span> <span class="bp">→</span> <span class="n">ℤ</span>
<span class="c1">-- excess_left_parens ['(','(',')'] = 1</span>
 <span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="mi">0</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">if</span> <span class="n">c</span><span class="bp">=</span><span class="sc">'('</span> <span class="k">then</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">excess_left_parens</span> <span class="n">x</span> <span class="k">else</span>
    <span class="k">if</span> <span class="n">c</span><span class="bp">=</span><span class="sc">')'</span> <span class="k">then</span> <span class="bp">-</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">excess_left_parens</span> <span class="n">x</span> <span class="k">else</span>
    <span class="n">excess_left_parens</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">last_balanced_suffix</span> <span class="o">:</span> <span class="n">list</span> <span class="n">char</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">char</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="sc">'('</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ite</span> <span class="o">(</span><span class="n">last_balanced_suffix</span> <span class="n">l</span> <span class="bp">=</span> <span class="o">[]</span> <span class="bp">∧</span> <span class="n">excess_left_parens</span> <span class="n">l</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="sc">'('</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span> <span class="n">_</span> <span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">last_balanced_suffix</span> <span class="n">l</span>
</code></pre></div>



<a name="215220121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215220121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215220121">(Nov 01 2020 at 01:13)</a>:</h4>
<p>Oh that's too bad, that doesn't work because the eq compiler seems to freak out at the decidable equality of char</p>



<a name="215220236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215220236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215220236">(Nov 01 2020 at 01:17)</a>:</h4>
<p>OK, this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">excess_left_parens</span><span class="o">:</span> <span class="n">list</span> <span class="n">char</span> <span class="bp">→</span> <span class="n">ℤ</span>
<span class="c1">-- excess_left_parens ['(','(',')'] = 1</span>
 <span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="mi">0</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="n">excess_left_parens</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">ite</span> <span class="o">(</span><span class="n">c</span> <span class="bp">=</span> <span class="sc">'('</span><span class="o">)</span> <span class="mi">1</span> <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="n">c</span> <span class="bp">=</span> <span class="sc">')'</span><span class="o">)</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="mi">0</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">last_balanced_suffix</span> <span class="o">:</span> <span class="n">list</span> <span class="n">char</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">char</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ite</span> <span class="o">(</span><span class="n">last_balanced_suffix</span> <span class="n">l</span> <span class="bp">=</span> <span class="o">[])</span>
  <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="n">c</span> <span class="bp">=</span> <span class="sc">'('</span> <span class="bp">∧</span> <span class="n">excess_left_parens</span> <span class="n">l</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="sc">'('</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="o">[])</span>
  <span class="o">(</span><span class="n">last_balanced_suffix</span> <span class="n">l</span><span class="o">)</span>
</code></pre></div>



<a name="215220244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215220244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215220244">(Nov 01 2020 at 01:17)</a>:</h4>
<p>Here's a minimal example that doesn't work (although it is so minimal that it no longer tries to do anything useful).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">last_balanced_suffix</span> <span class="o">:</span> <span class="n">list</span> <span class="n">char</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">char</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span><span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[]</span>

<span class="kd">def</span> <span class="n">truth_value</span> <span class="o">:</span> <span class="n">list</span> <span class="n">char</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span>   <span class="o">[]</span> <span class="n">n</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span>   <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">(</span><span class="n">truth_value</span> <span class="o">(</span><span class="n">last_balanced_suffix</span> <span class="n">x</span><span class="o">)</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div>



<a name="215220286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215220286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215220286">(Nov 01 2020 at 01:18)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">excess_left_parens</span><span class="o">:</span> <span class="n">list</span> <span class="n">char</span> <span class="bp">→</span> <span class="n">ℤ</span>
<span class="c1">-- excess_left_parens ['(','(',')'] = 1</span>
 <span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="mi">0</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="n">excess_left_parens</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">ite</span> <span class="o">(</span><span class="n">c</span> <span class="bp">=</span> <span class="sc">'('</span><span class="o">)</span> <span class="mi">1</span> <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="n">c</span> <span class="bp">=</span> <span class="sc">')'</span><span class="o">)</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="mi">0</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">last_balanced_suffix</span> <span class="o">:</span> <span class="n">list</span> <span class="n">char</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">char</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ite</span> <span class="o">(</span><span class="n">last_balanced_suffix</span> <span class="n">l</span> <span class="bp">=</span> <span class="o">[])</span>
  <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="n">c</span> <span class="bp">=</span> <span class="sc">'('</span> <span class="bp">∧</span> <span class="n">excess_left_parens</span> <span class="n">l</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="sc">'('</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="o">[])</span>
  <span class="o">(</span><span class="n">last_balanced_suffix</span> <span class="n">l</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">1</span>
<span class="cm">-/</span>

<span class="k">#eval</span> <span class="n">excess_left_parens</span> <span class="o">[</span><span class="sc">'('</span><span class="o">,</span><span class="sc">'('</span><span class="o">,</span><span class="sc">')'</span><span class="o">]</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">['(', ')']</span>
<span class="cm">-/</span>

<span class="k">#eval</span> <span class="n">last_balanced_suffix</span> <span class="o">[</span><span class="sc">'('</span><span class="o">,</span><span class="sc">'('</span><span class="o">,</span><span class="sc">')'</span><span class="o">]</span>
</code></pre></div>



<a name="215220368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215220368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215220368">(Nov 01 2020 at 01:20)</a>:</h4>
<p>Let's try slim_check</p>



<a name="215220428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215220428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215220428">(Nov 01 2020 at 01:22)</a>:</h4>
<p>Yes <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> that has the desired behavior. The problem is when I then add say</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">truth_value</span> <span class="o">:</span> <span class="n">list</span> <span class="n">char</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span>   <span class="o">[]</span> <span class="n">n</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span>   <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">(</span><span class="n">truth_value</span> <span class="o">(</span><span class="n">last_balanced_suffix</span> <span class="n">x</span><span class="o">)</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div>



<a name="215220614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215220614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215220614">(Nov 01 2020 at 01:28)</a>:</h4>
<p>I'm not particularly good at solving those sorts of well-foundedness problems. Seems like your minimal example is a bit removed from what you're trying to do -- so maybe we can fix the actual issue? Otherwise, I'm not sure what to do about this failing example.</p>



<a name="215220840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215220840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215220840">(Nov 01 2020 at 01:36)</a>:</h4>
<p>OK I'll make a minimal but still purposeful example...</p>



<a name="215220855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215220855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215220855">(Nov 01 2020 at 01:37)</a>:</h4>
<p>I managed to solve it, following the last bit of the well-foundedness tutorial I linked above:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">def</span> <span class="n">excess_left_parens</span><span class="o">:</span> <span class="n">list</span> <span class="n">char</span> <span class="bp">→</span> <span class="n">ℤ</span>
<span class="c1">-- excess_left_parens ['(','(',')'] = 1</span>
 <span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="mi">0</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="n">excess_left_parens</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">ite</span> <span class="o">(</span><span class="n">c</span> <span class="bp">=</span> <span class="sc">'('</span><span class="o">)</span> <span class="mi">1</span> <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="n">c</span> <span class="bp">=</span> <span class="sc">')'</span><span class="o">)</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="mi">0</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">last_balanced_suffix</span> <span class="o">:</span> <span class="n">list</span> <span class="n">char</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">char</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ite</span> <span class="o">(</span><span class="n">last_balanced_suffix</span> <span class="n">l</span> <span class="bp">=</span> <span class="o">[])</span>
  <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="n">c</span> <span class="bp">=</span> <span class="sc">'('</span> <span class="bp">∧</span> <span class="n">excess_left_parens</span> <span class="n">l</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="sc">'('</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="o">[])</span>
  <span class="o">(</span><span class="n">last_balanced_suffix</span> <span class="n">l</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">truth_value</span> <span class="o">:</span> <span class="n">list</span> <span class="n">char</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span>   <span class="o">[]</span> <span class="n">n</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span>   <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="n">n</span> <span class="o">:=</span>
  <span class="k">have</span> <span class="o">(</span><span class="n">last_balanced_suffix</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">&lt;</span> <span class="n">x.length</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">induction</span> <span class="n">x</span> <span class="k">with</span> <span class="n">c'</span> <span class="n">x'</span> <span class="n">hx'</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">last_balanced_suffix</span><span class="o">,</span> <span class="n">nat.zero_lt_one</span><span class="o">],</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">last_balanced_suffix</span><span class="o">],</span> <span class="n">split_ifs</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
      <span class="o">{</span> <span class="k">calc</span> <span class="n">_</span> <span class="bp">&lt;</span> <span class="n">_</span> <span class="o">:</span> <span class="n">hx'</span>
        <span class="bp">...</span> <span class="bp">&lt;</span> <span class="n">_</span> <span class="o">:</span> <span class="n">lt_add_one</span> <span class="n">_</span><span class="o">,</span> <span class="o">}</span> <span class="o">}</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="o">(</span><span class="n">truth_value</span> <span class="o">(</span><span class="n">last_balanced_suffix</span> <span class="n">x</span><span class="o">)</span> <span class="mi">0</span><span class="o">)</span>
  <span class="c1">-- I copied this from the last part of the well-foundedness doc</span>
  <span class="c1">-- except that I replaced `card` with a type using `length`</span>
  <span class="n">using_well_founded</span> <span class="o">{</span><span class="n">rel_tac</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">measure_wf</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">list.length</span> <span class="n">x.1</span><span class="o">)⟩]}</span>
</code></pre></div>



<a name="215220988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215220988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215220988">(Nov 01 2020 at 01:42)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.basic</span>

  <span class="kd">def</span> <span class="n">excess_left_parens</span><span class="o">:</span> <span class="n">list</span> <span class="n">char</span> <span class="bp">→</span> <span class="n">ℤ</span>
<span class="c1">-- excess_left_parens ['(','(',')'] = 1</span>
 <span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="mi">0</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">if</span> <span class="n">c</span><span class="bp">=</span><span class="sc">'('</span> <span class="k">then</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">excess_left_parens</span> <span class="n">x</span> <span class="k">else</span>
    <span class="k">if</span> <span class="n">c</span><span class="bp">=</span><span class="sc">')'</span> <span class="k">then</span> <span class="bp">-</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">excess_left_parens</span> <span class="n">x</span> <span class="k">else</span>
    <span class="n">excess_left_parens</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">last_balanced_suffix</span> <span class="o">:</span> <span class="n">list</span> <span class="n">char</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">char</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">last_balanced_suffix</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">[]</span> <span class="k">then</span>
    <span class="k">if</span> <span class="n">excess_left_parens</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">=</span> <span class="sc">'('</span> <span class="k">then</span> <span class="n">c</span> <span class="o">::</span> <span class="n">x</span> <span class="k">else</span> <span class="o">[]</span>
  <span class="k">else</span> <span class="n">last_balanced_suffix</span> <span class="n">x</span>

<span class="kd">theorem</span> <span class="n">last_balanced_suffix_is_suffix</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="n">last_balanced_suffix</span> <span class="n">l</span> <span class="bp">&lt;</span><span class="o">:</span><span class="bp">+</span> <span class="n">l</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">list.nil_suffix</span> <span class="n">_</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">last_balanced_suffix</span><span class="o">,</span> <span class="n">split_ifs</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">list.nil_suffix</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">last_balanced_suffix_is_suffix</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">list.suffix_cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">truth_value</span> <span class="o">:</span> <span class="n">list</span> <span class="n">char</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">(</span><span class="n">last_balanced_suffix</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span><span class="o">,</span> <span class="k">from</span>
    <span class="n">nat.lt_succ_of_le</span> <span class="bp">$</span> <span class="n">list.length_le_of_infix</span> <span class="bp">$</span>
    <span class="n">list.infix_of_suffix</span> <span class="bp">$</span> <span class="n">last_balanced_suffix_is_suffix</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">truth_value</span> <span class="o">(</span><span class="n">last_balanced_suffix</span> <span class="n">x</span><span class="o">)</span> <span class="mi">0</span>
<span class="n">using_well_founded</span> <span class="o">{</span><span class="n">rel_tac</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">measure_wf</span> <span class="n">list.length</span><span class="o">⟩]</span> <span class="o">}</span>
</code></pre></div>



<a name="215221027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215221027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215221027">(Nov 01 2020 at 01:42)</a>:</h4>
<p>ah, brian beat me</p>



<a name="215221035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215221035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215221035">(Nov 01 2020 at 01:42)</a>:</h4>
<p>Ah, but your proof is much nicer.</p>



<a name="215221232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215221232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215221232">(Nov 01 2020 at 01:49)</a>:</h4>
<p>Hey, it just occurred to me that we could improve the ergonomics of that <code>using_well_founded</code> bit using something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">using_well_founded</span> <span class="kd">by</span> <span class="n">wf</span> <span class="n">on</span> <span class="n">list.length</span>
</code></pre></div>



<a name="215221279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215221279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215221279">(Nov 01 2020 at 01:50)</a>:</h4>
<p>There are a bunch of messy arguments in <code>using_well_founded</code> that we could paper over with a custom tactic parser</p>



<a name="215221287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215221287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215221287">(Nov 01 2020 at 01:50)</a>:</h4>
<p>For example <code>rel_tac</code> takes two arguments that I have never ever used because I only ever want to use <code>exact</code></p>



<a name="215221411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215221411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215221411">(Nov 01 2020 at 01:54)</a>:</h4>
<p>Ooh, that'd be great. Then we could change the error message in core Lean to mention <code>wf</code>.</p>



<a name="215221641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215221641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215221641">(Nov 01 2020 at 02:01)</a>:</h4>
<p>Thanks a lot, I almost have my version working except for this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">measure_wf</span> <span class="n">list.length</span>
<span class="n">term</span>
  <span class="n">list.length</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">list</span> <span class="bp">?</span><span class="n">m_1</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="o">(</span><span class="bp">Σ'</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">list</span> <span class="n">char</span><span class="o">),</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:</span> <span class="kt">Type</span>
</code></pre></div>



<a name="215221699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215221699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215221699">(Nov 01 2020 at 02:03)</a>:</h4>
<p>Try replacing <code>measure_wf list.length</code> with <code>measure_wf (λ x, list.length x.1)</code>.</p>



<a name="215222321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215222321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215222321">(Nov 01 2020 at 02:20)</a>:</h4>
<p>Or do induction only on the first argument by using lambda for the second</p>



<a name="215232197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prove%20sizeof%20small/near/215232197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prove.20sizeof.20small.html#215232197">(Nov 01 2020 at 07:39)</a>:</h4>
<p>Case closed. <span aria-label="briefcase" class="emoji emoji-1f4bc" role="img" title="briefcase">:briefcase:</span></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
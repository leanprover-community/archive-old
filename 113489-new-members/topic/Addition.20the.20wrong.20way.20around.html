---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Addition.20the.20wrong.20way.20around.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Addition.20the.20wrong.20way.20around.html">Addition the wrong way around</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="209072071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Addition%20the%20wrong%20way%20around/near/209072071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Addition.20the.20wrong.20way.20around.html#209072071">(Sep 04 2020 at 09:27)</a>:</h4>
<p>I am new to lean and already discovered my new pet hate with the standard library definition of +. Recursion over the 2nd argument is a bad idea because it means that addition is not the same as append on a list of units. Also it means that you have to turn around the order of indices in vector append (if you want to be definitional). Minor issue but bad choice.</p>



<a name="209072735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Addition%20the%20wrong%20way%20around/near/209072735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Addition.20the.20wrong.20way.20around.html#209072735">(Sep 04 2020 at 09:34)</a>:</h4>
<p>Ha, we have symmetric pet hates</p>



<a name="209072868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Addition%20the%20wrong%20way%20around/near/209072868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Addition.20the.20wrong.20way.20around.html#209072868">(Sep 04 2020 at 09:35)</a>:</h4>
<p>To your points, I can only say that append on a list of units doesn't matter, and vector append (and vector in general) is avoided</p>



<a name="209073281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Addition%20the%20wrong%20way%20around/near/209073281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Addition.20the.20wrong.20way.20around.html#209073281">(Sep 04 2020 at 09:40)</a>:</h4>
<p>But really, we're doing all we can to not "be definitional", so it really shouldn't matter. We're still a ways from achieving freedom from defeq, but I regard it as a flaw in lean that you can even tell which way it's been defined (short of reading the definition)</p>



<a name="209074072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Addition%20the%20wrong%20way%20around/near/209074072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Addition.20the.20wrong.20way.20around.html#209074072">(Sep 04 2020 at 09:49)</a>:</h4>
<p>I personally have a problem with multiplication the wrong way around (both in nats and ints), as it implies that the two semimodule structures on nat (the one coming from the fact that any semigroup is a nat-semimodule, and the other one coming from the fact that a semiring is a semimodule over itself) are not defeq (and same for int).</p>



<a name="209075766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Addition%20the%20wrong%20way%20around/near/209075766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Addition.20the.20wrong.20way.20around.html#209075766">(Sep 04 2020 at 10:08)</a>:</h4>
<p>In math it's probably more common to make inductive arguments about the end of a list/vector/tuple (it presents fewer notational difficulties when your idea of a list is "<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_1, \ldots, x_n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>"), so really it's <code>list</code> that is the wrong way around.</p>



<a name="209082172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Addition%20the%20wrong%20way%20around/near/209082172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Addition.20the.20wrong.20way.20around.html#209082172">(Sep 04 2020 at 11:29)</a>:</h4>
<p>(un?)related: The fact that nat.pow and monoid.pow were defined as x*x^n and x^n*x always made me wonder whether in time we'd realise which one was best -- but I never got to the bottom of this.</p>



<a name="209082391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Addition%20the%20wrong%20way%20around/near/209082391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Addition.20the.20wrong.20way.20around.html#209082391">(Sep 04 2020 at 11:32)</a>:</h4>
<p><code>list</code> being the wrong way around can be fixed by defining <code>L ::: a</code> to mean <code>a :: L</code> and then just imagining that Wiggler is looking the other way. <a href="http://learnyouahaskell.com/starting-out#an-intro-to-lists">http://learnyouahaskell.com/starting-out#an-intro-to-lists</a> <a href="https://www.mariowiki.com/Wiggler">https://www.mariowiki.com/Wiggler</a></p>



<a name="209082628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Addition%20the%20wrong%20way%20around/near/209082628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Addition.20the.20wrong.20way.20around.html#209082628">(Sep 04 2020 at 11:35)</a>:</h4>
<p>Thorsten, you'll probably find that Lean and mathlib have a very different feel from Agda. In part this is because <code>mathlib</code> has been developed with mathematical applications in mind, rather than Agda-style software verification. In contrast to most proof assistants, the community of computer scientists using Lean is currently smaller than the community of mathematicians. So the CS side of the library needs some love. We will all be interested to hear whether you can make it work for you.</p>



<a name="209106012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Addition%20the%20wrong%20way%20around/near/209106012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Addition.20the.20wrong.20way.20around.html#209106012">(Sep 04 2020 at 15:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110865">Jeremy Avigad</span> <a href="#narrow/stream/113489-new-members/topic/Addition.20the.20wrong.20way.20around/near/209082628">said</a>:</p>
<blockquote>
<p>Thorsten, you'll probably find that Lean and mathlib have a very different feel from Agda. In part this is because <code>mathlib</code> has been developed with mathematical applications in mind, rather than Agda-style software verification. In contrast to most proof assistants, the community of computer scientists using Lean is currently smaller than the community of mathematicians. So the CS side of the library needs some love. We will all be interested to hear whether you can make it work for you.</p>
</blockquote>
<p>Yes, I realise this. But changing directions is never a good idea. It leads to subtle errors.</p>



<a name="209106306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Addition%20the%20wrong%20way%20around/near/209106306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Addition.20the.20wrong.20way.20around.html#209106306">(Sep 04 2020 at 15:17)</a>:</h4>
<p>Actually in the moment I will see wether I can use it for teaching basic logic and verification. But yes one reason to switch to lean is to find out more about it.</p>



<a name="209106462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Addition%20the%20wrong%20way%20around/near/209106462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Addition.20the.20wrong.20way.20around.html#209106462">(Sep 04 2020 at 15:18)</a>:</h4>
<p>Actually once you fix lists to snoc lists the definition of addition is the right way around. :-)</p>



<a name="209106495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Addition%20the%20wrong%20way%20around/near/209106495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Addition.20the.20wrong.20way.20around.html#209106495">(Sep 04 2020 at 15:18)</a>:</h4>
<p>Thorsten I'm a mathematician and in some sense I wouldn't be able to tell you which side addition is defined on. I know that 0+x and x+0 are both lemmas known to the simplifier, and I don't care about definitional equality because it goes against how mathematicians think about things. I think we might want to use these systems to do different things (to put it mildly ;-) ).</p>



<a name="209110696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Addition%20the%20wrong%20way%20around/near/209110696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Addition.20the.20wrong.20way.20around.html#209110696">(Sep 04 2020 at 15:54)</a>:</h4>
<p>Even Mathematicians prefer if things work by definition instead of requiring proof. Even Mathematicans can get confused by a change of direction in definitions. I think the difference you are trying to construct here simply doesn't exist. You seem to think, ah if a computer scientist says something it only matters to computer scientists. This may be a bit of an over generalisation.</p>



<a name="209149697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Addition%20the%20wrong%20way%20around/near/209149697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Addition.20the.20wrong.20way.20around.html#209149697">(Sep 04 2020 at 23:24)</a>:</h4>
<p>I will point out that addition is defined by recursion on the right in the peano axioms: <a href="https://en.wikipedia.org/wiki/Peano_axioms#Addition">https://en.wikipedia.org/wiki/Peano_axioms#Addition</a> . In fact, it's always been recursion on the right in every logic textbook or discrete math book I have seen. Coq was the first time I saw a definition of addition by recursion on the left.</p>



<a name="209149825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Addition%20the%20wrong%20way%20around/near/209149825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Addition.20the.20wrong.20way.20around.html#209149825">(Sep 04 2020 at 23:27)</a>:</h4>
<p>It's also nicer in lean because it means you can define the partial function <code>add a : nat -&gt; nat</code> by using <code>rec_on</code> directly; this style suggests always putting parameters "left of the colon", and the <code>a</code> in <code>add a b</code> is a parameter, so it should go to the left of the recursion variable <code>b</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
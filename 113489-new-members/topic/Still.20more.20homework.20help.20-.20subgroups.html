---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html">Still more homework help - subgroups</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="265677026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265677026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265677026">(Dec 21 2021 at 11:58)</a>:</h4>
<p>I'm working through <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> 's course and I'm looking at </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">ext'</span> <span class="o">{</span><span class="n">H</span> <span class="n">K</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">H.carrier</span> <span class="bp">=</span> <span class="n">K.carrier</span><span class="o">)</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">=</span> <span class="n">K</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- first take H and K apart</span>
  <span class="n">cases</span> <span class="n">H</span><span class="o">,</span> <span class="c1">-- H now broken up into its underlying 3-tuple.</span>
  <span class="n">cases</span> <span class="n">K</span><span class="o">,</span>
  <span class="c1">-- and now it must be obvious, so let's see if the simplifier can do it.</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>For the life of me I cannot figure out what <code>simp</code> is doing here.  The context is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">G</span><span class="o">:</span> <span class="kt">Type</span>
<span class="n">_inst_1</span><span class="o">:</span> <span class="n">group</span> <span class="n">G</span>
<span class="n">H_carrier</span><span class="o">:</span> <span class="n">set</span> <span class="n">G</span>
<span class="n">H_one_mem'</span><span class="o">:</span> <span class="mi">1</span> <span class="bp">∈</span> <span class="n">H_carrier</span>
<span class="n">H_mul_mem'</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">G</span><span class="o">},</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">H_carrier</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">H_carrier</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">H_carrier</span>
<span class="n">H_inv_mem'</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">},</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">H_carrier</span> <span class="bp">→</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">∈</span> <span class="n">H_carrier</span>
<span class="n">K_carrier</span><span class="o">:</span> <span class="n">set</span> <span class="n">G</span>
<span class="n">K_one_mem'</span><span class="o">:</span> <span class="mi">1</span> <span class="bp">∈</span> <span class="n">K_carrier</span>
<span class="n">K_mul_mem'</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">G</span><span class="o">},</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">K_carrier</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">K_carrier</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">K_carrier</span>
<span class="n">K_inv_mem'</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">},</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">K_carrier</span> <span class="bp">→</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">∈</span> <span class="n">K_carrier</span>
<span class="n">h</span><span class="o">:</span> <span class="o">{</span><span class="n">carrier</span> <span class="o">:=</span> <span class="n">H_carrier</span><span class="o">,</span> <span class="n">one_mem'</span> <span class="o">:=</span> <span class="n">H_one_mem'</span><span class="o">,</span> <span class="n">mul_mem'</span> <span class="o">:=</span> <span class="n">H_mul_mem'</span><span class="o">,</span> <span class="n">inv_mem'</span> <span class="o">:=</span> <span class="n">H_inv_mem'</span><span class="o">}</span><span class="bp">.</span><span class="n">carrier</span> <span class="bp">=</span> <span class="o">{</span><span class="n">carrier</span> <span class="o">:=</span> <span class="n">K_carrier</span><span class="o">,</span> <span class="n">one_mem'</span> <span class="o">:=</span> <span class="n">K_one_mem'</span><span class="o">,</span> <span class="n">mul_mem'</span> <span class="o">:=</span> <span class="n">K_mul_mem'</span><span class="o">,</span> <span class="n">inv_mem'</span> <span class="o">:=</span> <span class="n">K_inv_mem'</span><span class="o">}</span><span class="bp">.</span><span class="n">carrier</span>
<span class="bp">⊢</span> <span class="o">{</span><span class="n">carrier</span> <span class="o">:=</span> <span class="n">H_carrier</span><span class="o">,</span> <span class="n">one_mem'</span> <span class="o">:=</span> <span class="n">H_one_mem'</span><span class="o">,</span> <span class="n">mul_mem'</span> <span class="o">:=</span> <span class="n">H_mul_mem'</span><span class="o">,</span> <span class="n">inv_mem'</span> <span class="o">:=</span> <span class="n">H_inv_mem'</span><span class="o">}</span> <span class="bp">=</span> <span class="o">{</span><span class="n">carrier</span> <span class="o">:=</span> <span class="n">K_carrier</span><span class="o">,</span> <span class="n">one_mem'</span> <span class="o">:=</span> <span class="n">K_one_mem'</span><span class="o">,</span> <span class="n">mul_mem'</span> <span class="o">:=</span> <span class="n">K_mul_mem'</span><span class="o">,</span> <span class="n">inv_mem'</span> <span class="o">:=</span> <span class="n">K_inv_mem'</span><span class="o">}</span>
</code></pre></div>
<p>I <em>think</em> the idea is: since the carriers are the same by <code>h</code>, you can use all the other hypotheses to show equality of the other components and get the result.  But what are the actual manipulations to do this?</p>



<a name="265677337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265677337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265677337">(Dec 21 2021 at 12:02)</a>:</h4>
<p>Hmm, I would think <code>congr</code> in place of <code>simp</code> should also work.</p>



<a name="265677440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265677440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265677440">(Dec 21 2021 at 12:02)</a>:</h4>
<p>Which roughly means: "match the LHS up with the RHS, and turn all their differences into new subgoals"</p>



<a name="265677499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265677499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265677499">(Dec 21 2021 at 12:03)</a>:</h4>
<p>Note that all other fields are proofs, so they are equal in a very  strong sense as soon as they prove the same thing.</p>



<a name="265677736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265677736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265677736">(Dec 21 2021 at 12:07)</a>:</h4>
<p>So Lean is applying injectivity of constructors of inductive types for you, as well as the proof irrelevance axiom.</p>



<a name="265677928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265677928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265677928">(Dec 21 2021 at 12:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups/near/265677499">said</a>:</p>
<blockquote>
<p>Note that all other fields are proofs, so they are equal in a very  strong sense as soon as they prove the same thing.</p>
</blockquote>
<p>Can you say a little bit more? about this?  It seems like if you have a compound object and you want to prove equality, you need to prove<br>
equality of the components.  So the idea that <code>congr</code> would split the situation up into subgoals makes sense to me, with a subgoal for each component.  But the equality of the component<br>
proofs depends on equality of the carriers.  It all seems magic.</p>



<a name="265678321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265678321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265678321">(Dec 21 2021 at 12:14)</a>:</h4>
<p>It is indeed a bit subtle. But you really don't need to understand this in order to use Lean. That kind of extensionality lemma is automatically generated in practice.</p>



<a name="265678497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265678497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265678497">(Dec 21 2021 at 12:17)</a>:</h4>
<p>OK, I will table this for now and hope that clarity emerges from experience.</p>



<a name="265679371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265679371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265679371">(Dec 21 2021 at 12:27)</a>:</h4>
<p>Yeah I had a choice here. I could either have written <code>@[ext] structure subgroup...</code> on line 26 of that file, which would have generated <code>xena.subgroup.ext</code> automatically (and which up to choice of brackets would be the same as <code>ext'</code> above) or I could have done it this way. In my copy of the repo I just seem to finish the proof with <code>simp * at *</code>. My take on this is "the thing is mathematically entirely trivial, the goal follows from <code>h</code>, I don't quite understand equality of structures and furthermore I even know that whatever equality of structures means it will change in Lean 4 (we'll have <a href="#narrow/stream/116290-rss/topic/Recent.20Commits.20to.20lean4.3Amaster/near/262736535">eta for structures</a>, whatever that means), but I do know that the simplifier will know all the relevant lemmas so let's just use it"</p>



<a name="265679542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265679542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265679542">(Dec 21 2021 at 12:29)</a>:</h4>
<p><a href="https://github.com/leanprover/lean4/issues/777">This</a> is the relevant Lean 4 issue.</p>



<a name="265679728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265679728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265679728">(Dec 21 2021 at 12:31)</a>:</h4>
<p>PS Lean does not do magic, but on the other hand I don't understand what it's doing (and don't need to understand). Others here will if you really want to know what's going on. You could ask in <a class="stream" data-stream-id="113488" href="/#narrow/stream/113488-general">#general</a> what is happening under the hood and some expert will explain (Patrick probably knows but I don't know how often he frequents <a class="stream" data-stream-id="113489" href="/#narrow/stream/113489-new-members">#new members</a> )</p>



<a name="265680012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265680012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265680012">(Dec 21 2021 at 12:35)</a>:</h4>
<p>The line I don't fully understand is <code>congr</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">ext'</span> <span class="o">{</span><span class="n">H</span> <span class="n">K</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">H.carrier</span> <span class="bp">=</span> <span class="n">K.carrier</span><span class="o">)</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">=</span> <span class="n">K</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- first take H and K apart</span>
  <span class="n">cases</span> <span class="n">H</span><span class="o">,</span> <span class="c1">-- H now broken up into its underlying 3-tuple.</span>
  <span class="n">cases</span> <span class="n">K</span><span class="o">,</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="265680977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265680977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265680977">(Dec 21 2021 at 12:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups/near/265679728">said</a>:</p>
<blockquote>
<p>PS Lean does not do magic, </p>
</blockquote>
<p>Any sufficiently advanced technology is indistinguishable from magic.</p>



<a name="265681055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265681055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265681055">(Dec 21 2021 at 12:47)</a>:</h4>
<p>I often feel that stuff like this is type theory 101 and the reason I don't know it is that I never went to any computer science courses, so it might just be my backwardness rather than the advancedness of the technology in this case.</p>



<a name="265681133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265681133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265681133">(Dec 21 2021 at 12:48)</a>:</h4>
<p>But I'll be teaching this again in about a month so I'd be interested in hearing any more details if you get to the bottom of them!</p>



<a name="265681321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265681321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265681321">(Dec 21 2021 at 12:50)</a>:</h4>
<p>I've taken CS courses, and even taught them, but  this is all very new to me and feels very strange.   I think I just don't have any real understanding of what "dependent type theory" really is.  But I guess that is what makes it interesting.</p>



<a name="265681405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265681405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265681405">(Dec 21 2021 at 12:51)</a>:</h4>
<p>I like your utilitarian attitude though, it's inspiring.</p>



<a name="265681414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265681414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265681414">(Dec 21 2021 at 12:51)</a>:</h4>
<p><em>You</em> get to decide why stuff is interesting to <em>you</em>.</p>



<a name="265681532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265681532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265681532">(Dec 21 2021 at 12:52)</a>:</h4>
<p>And you can choose to spend time thinking about foundational stuff. What Kevin and I are saying is that you don't <em>need</em> to, at least if you only want to formalize math.</p>



<a name="265683641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265683641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265683641">(Dec 21 2021 at 13:17)</a>:</h4>
<p>I'm living proof that you don't need to understand the details of equality of structures in order to formalise maths! On the other hand I am curious. It might be something to do with <a href="https://leanprover-community.github.io/mathlib_docs/find/heq">docs#heq</a> <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p>



<a name="265685332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265685332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265685332">(Dec 21 2021 at 13:37)</a>:</h4>
<p>Not sure if it helps, but this also works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
<span class="kd">theorem</span> <span class="n">ext'</span> <span class="o">{</span><span class="n">H</span> <span class="n">K</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">H.carrier</span> <span class="bp">=</span> <span class="n">K.carrier</span><span class="o">)</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">=</span> <span class="n">K</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- first take H and K apart</span>
  <span class="n">cases</span> <span class="n">H</span><span class="o">,</span> <span class="c1">-- H now broken up into its underlying 3-tuple.</span>
  <span class="n">cases</span> <span class="n">K</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">subst</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="265685957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265685957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265685957">(Dec 21 2021 at 13:42)</a>:</h4>
<p>So I guess the question is: equality is defined as an inductive type and its recursor, automatically generated, is the substitution property <code>a = b -&gt; P a -&gt; P b</code>. Can one now write down an explicit <code>P</code> such that if <code>a=H.carrier</code> and <code>b=K.carrier</code> then <code>P a</code> can be proved by <code>rfl</code> and <code>P b</code> is the equality we want?</p>



<a name="265688766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265688766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265688766">(Dec 21 2021 at 14:09)</a>:</h4>
<p>Another way to write it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
<span class="kd">theorem</span> <span class="n">ext'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">H</span> <span class="n">K</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">H.carrier</span> <span class="bp">=</span> <span class="n">K.carrier</span><span class="o">),</span> <span class="n">H</span> <span class="bp">=</span> <span class="n">K</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">Hc</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Kc</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="n">rfl</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="265688776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265688776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265688776">(Dec 21 2021 at 14:09)</a>:</h4>
<p>(but that's worse because you have to count the <code>_</code>s)</p>



<a name="265696881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265696881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265696881">(Dec 21 2021 at 15:22)</a>:</h4>
<p>I am going to try to make sense of Chapter 8 of TPIL and then come back to this discussion.</p>



<a name="265698101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Still%20more%20homework%20help%20-%20subgroups/near/265698101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Still.20more.20homework.20help.20-.20subgroups.html#265698101">(Dec 21 2021 at 15:32)</a>:</h4>
<p>The equation compiler is pretty spectacularly good at this sort of thing but I wanted to keep all proofs within <code>begin end</code> blocks for my students</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
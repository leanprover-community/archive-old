---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Terms.20vs.20expressions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html">Terms vs expressions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="283990599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/283990599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Malcolm Langfield <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#283990599">(May 26 2022 at 10:21)</a>:</h4>
<p>I'm slightly confused by terminology while reading Theorem Proving in Lean 4. The authors refer to some things as terms and some things as expressions, and I'm not sure if these are synonyms or if there is an informal or formal distinction. Can anyone shed some light on this?</p>
<p>In the <code>lean4</code> source, there is a namespace <code>Term</code>, but unless I missed it, there doesn't appear to be a type called <code>Term</code>. There is, however, an inductive type called <code>Expr</code>.</p>
<p>There is a related question here: <a href="https://cs.stackexchange.com/questions/64699/are-the-words-expression-and-term-interchangeable-in-programming-language-th">https://cs.stackexchange.com/questions/64699/are-the-words-expression-and-term-interchangeable-in-programming-language-th</a></p>
<p>But I'm looking for a lean-specific answer if possible.</p>
<p>Thanks!</p>



<a name="283995328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/283995328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#283995328">(May 26 2022 at 11:28)</a>:</h4>
<p>I think of a "term" in the context of a given "type". For instance, <code>0</code> is a <em>term</em> of <em>type</em> <code>Nat</code></p>
<p><code>Expr</code> is an inductive type used to implement more user-defined terms and types in Lean 4. Maybe <a href="https://github.com/arthurpaulino/lean4-metaprogramming-book/blob/master/md/main/expressions.md">this link</a> can help you <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="283995936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/283995936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Malcolm Langfield <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#283995936">(May 26 2022 at 11:37)</a>:</h4>
<p>Thanks for the link! Does it make sense to ask which is more general? In the metaprogramming book, it says</p>
<blockquote>
<p>Expressions (terms of type Expr)</p>
</blockquote>
<p>which makes it sound like all expressions are terms. But there is also</p>
<blockquote>
<p>In Lean, terms and types are represented by expressions.</p>
</blockquote>
<p>which makes it sound like all terms are expressions.</p>



<a name="283996357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/283996357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#283996357">(May 26 2022 at 11:43)</a>:</h4>
<p>You have to differentiate between the meta level and the language itself.</p>
<p>In Lean we talk about something being a term as soon as it has a type, so <code>0</code> is a term of type <code>Nat</code> as explained above.</p>
<p>In order to perform meta programming we require a representation of all terms as some Lean data type, we call this data type <code>Expr</code>. So what we can say is that <code>0</code> is a term of type <code>Nat</code> that is in the meta world represented by a term of type <code>Expr</code> (more specifically by an <code>Expr.lit</code>). This means that on the meta level all lean terms have a <em>representation</em> as a term of type <code>Expr</code> that meta programs can operate on.</p>



<a name="283996368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/283996368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#283996368">(May 26 2022 at 11:43)</a>:</h4>
<p>Good questions. I think there's a confusion regarding the abstract ideas from type theory and their implementations in Lean</p>



<a name="283997264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/283997264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#283997264">(May 26 2022 at 11:56)</a>:</h4>
<p>Maybe it's better to actually stay away from metaprogramming concepts in the beginning because it may create more confusion.</p>
<p>This example may clarify a few things:</p>
<ul>
<li><code>Nat</code> is a type</li>
<li><code>0</code> is a term of type <code>Nat</code></li>
<li><code>0 + 0</code> is an expression that, when reduced, yields the term <code>0</code> of type <code>Nat</code></li>
</ul>
<p>We sometimes take the mental shortcut of talking about an expression <em>as if</em> it were already reduced because some expressions are just too trivial for our brains</p>



<a name="284003763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284003763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Malcolm Langfield <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284003763">(May 26 2022 at 13:11)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="395550">@Henrik Böving</span> <span class="user-mention" data-user-id="451983">@Arthur Paulino</span> , this distinction between the meta level and the "ordinary" level is helpful to know about. Is it correct to say that a term is a single identifier or literal? That they're atomic, in syntax terms?</p>



<a name="284003942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284003942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284003942">(May 26 2022 at 13:13)</a>:</h4>
<p>No, everything that has a type counts as terms, that can be function applications, even types themselves (since in Lean types have types and are thus just terms of other types as well) so a function type <code>Nat -&gt; Nat -&gt; Nat</code> is a term as well etc.</p>
<p>Maybe as a general rule of thumb, if you can <code>#check</code> it it is a term.</p>



<a name="284005189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284005189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284005189">(May 26 2022 at 13:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/113489-new-members/topic/Terms.20vs.20expressions/near/283996357">said</a>:</p>
<blockquote>
<p>This means that on the meta level all lean terms have a <em>representation</em> as a term of type <code>Expr</code> that meta programs can operate on.</p>
</blockquote>
<p>I don't think that is true. There are countably many meta-level representations of Lean terms, but there are object-level types that have uncountably many terms (such as <code>Nat -&gt; Bool</code>), so not all of them can be represented as <code>Expr</code> terms.</p>



<a name="284006082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284006082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284006082">(May 26 2022 at 13:33)</a>:</h4>
<p>But in the end all terms of type<code>Nat -&gt; Bool</code> will be represented as an identifier, a lambda abstraction, a function application a let abstraction or a combination of them wont they? And that's what <code>Expr</code> (mostly) is.</p>
<p>You can also see that  the compiler thinks that all terms can be represented by <code>Expr</code> because <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.elabTerm#doc">docs4#Lean.Elab.Term.elabTerm</a> returns an <code>Expr</code> in the term elaboration monad.</p>



<a name="284007885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284007885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284007885">(May 26 2022 at 13:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/113489-new-members/topic/Terms.20vs.20expressions/near/284006082">said</a>:</p>
<blockquote>
<p>But in the end all terms of type <code>Nat -&gt; Bool</code> will be represented as an identifier, a lambda abstraction, a function application a let abstraction or a combination of them wont they?</p>
</blockquote>
<p>Yes, but that's not enough to represent <em>all</em> terms of type <code>Nat -&gt; Bool</code>, we can only represent a countable subset of them.</p>



<a name="284008199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284008199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284008199">(May 26 2022 at 13:51)</a>:</h4>
<p>I'm not a mathematician so this is not obvious to me:</p>
<blockquote>
<p>There are countably many meta-level representations of Lean terms</p>
</blockquote>
<p>But it's already out of scope of the thread. Can someone split this thread in two, please? It got me curious <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="284012862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284012862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Malcolm Langfield <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284012862">(May 26 2022 at 14:29)</a>:</h4>
<p>Is e.g. <code>#print</code> itself an expression? What about keywords like <code>def</code>, or <code>theorem</code>?</p>



<a name="284014295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284014295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284014295">(May 26 2022 at 14:41)</a>:</h4>
<p><code>#print</code> <code>def</code> and <code>theorem</code> is what we call a command not an expression, they dont carry any value themselves they are used to communicate to the Lean compiler that it is supposed to perform a certain action (in the case of <code>#print</code> that is printing something, in the case of <code>def</code> and <code>theorem</code> that is registering a new valid identifier to the <code>Environment</code>)</p>



<a name="284031146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284031146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin C. Martin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284031146">(May 26 2022 at 16:55)</a>:</h4>
<p>Let me see if I understand.  "term" is similar to "instance" in object oriented programing: <code>SS0</code> is a term (instance) of type <code>Nat</code>.  Also, the type of all real numbers (i.e. the set of all reals) has uncountably infinitely many terms (elements), even though only countably many are expressible in Lean.  Is that right?  So "term" is closer to  a mathematical object (e.g. a real number) than what people in logic or parsers call a term.</p>



<a name="284032414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284032414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284032414">(May 26 2022 at 17:05)</a>:</h4>
<p>It can get a bit uncomfortable because <code>Nat</code> is a type, yes, but it's also a term of type <code>Type</code>. That's why I said in the beginning that I think of "term" in the context of a given "type"</p>



<a name="284034548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284034548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284034548">(May 26 2022 at 17:23)</a>:</h4>
<p>I said earlier that <code>0</code> is a term of type <code>Nat</code> because I got used to Lean's default way to infer it. But <code>0</code> can also be inferred as <code>Int</code>. And <code>0 : Nat</code> and <code>0 : Int</code> are different things in type theory, although you can coerce a term of a type to a term of another type.</p>
<p>So in short, "<code>0</code> is a term of type <code>Nat</code>" is not an absolute fact. There <em>is</em> a <code>0</code> of type <code>Nat</code></p>



<a name="284036819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284036819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284036819">(May 26 2022 at 17:41)</a>:</h4>
<p>A better way to put it is that <code>Nat.zero</code> is a <code>Nat</code>, and when you write the literal <code>0</code> it elaborates to (some wrappers around) <code>Nat.zero</code> if you say you want <code>0</code> to be treated as an element of <code>Nat</code>. If you say <code>0 : Int</code> then you get <code>Int.zero</code> instead and this is a different term with a different type. The underlying type theory is all talking about expressions post-elaboration.</p>



<a name="284037677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284037677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284037677">(May 26 2022 at 17:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="348963">Martin C. Martin</span> <a href="#narrow/stream/113489-new-members/topic/Terms.20vs.20expressions/near/284031146">said</a>:</p>
<blockquote>
<p>Let me see if I understand.  "term" is similar to "instance" in object oriented programing: <code>SS0</code> is a term (instance) of type <code>Nat</code>.  Also, the type of all real numbers (i.e. the set of all reals) has uncountably infinitely many terms (elements), even though only countably many are expressible in Lean.  Is that right?  So "term" is closer to  a mathematical object (e.g. a real number) than what people in logic or parsers call a term.</p>
</blockquote>
<p>When you are proving theorems or constructing functions, you generally want to have the "semantic" view, so if you have <code>def foo (x: Real) := ...</code> then <code>x</code> is imagined to range over <em>all</em> real numbers. This is the easiest way to make sense of the theorem that asserts that <code>Real</code> is uncountable. This is only an interpretation though, there isn't anything in the system itself that demands this perspective, and you can also consistently imagine <code>x</code> to range over all definable real numbers instead (of which there are only countably many, although the system can't prove this on pain of contradiction).</p>
<p>The term "term" is generally used to connote the more syntactic view of things. There <code>x</code> is just a variable with name <code>"x"</code> that the typechecker knows has type <code>Real</code> in this context. This is the level that tactics generally work at, because they can look at the expression of the goal and reassociate things or do other syntactic manipulations that would not be possible with the semantic view.</p>



<a name="284128278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284128278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Malcolm Langfield <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284128278">(May 27 2022 at 12:54)</a>:</h4>
<p>From a more pedagogical point of view, how do we want new users (like me) to talk about things? I have seen, in various parts of TPIL, the Lean 4 manual, and people's project READMEs, all of the words <code>term</code>, <code>expression</code>, <code>identifier</code>, <code>name</code>, <code>object</code>, <code>variable</code>. It also doesn't help that in typical usage, a ton of things you're talking about are also types, so that word gets thrown around a lot as well. If you're writing a README or docs for a project? What's best? For example, when you're talking about something that can be <code>#check</code>ed, we could call that an expression or a term, if I understood the discussion above correctly. But <code>expression</code> is going to confuse programmers coming from a more run-of-the-mill language a lot less than <code>term</code>. That's not necessarily a definitive reason to use <code>expression</code> unilaterally. Just something to keep in mind.</p>



<a name="284130299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284130299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284130299">(May 27 2022 at 13:13)</a>:</h4>
<p>My proposal to this issue would be:</p>
<ul>
<li>a term is anything that has a type, they can be recognized because they can be <code>#check</code>ed</li>
<li>a type is in fact a term on its own since types have a type themselves, this is one of the fundamental distinctions between Lean and more popular programming languages, the term and the type level are not separate, all types are also terms that can be operated on, you can even compute a type with a function dynamically. What exactly a type is beyond being a term is hard to pin down precisely, an explanation I've seen working well for beginners is to handwave it and say "its like a set" although this is of course a lie (that tends to work out well for a while), otherwise we could be doing just set theory</li>
<li>expression should be disconnected from term and be used a Lean meta programming term (pun intended) we probably don't want to tell new comers right away</li>
<li>an identifier is a name that has a type attached, identifiers are one of the many kinds of terms.</li>
<li>object can be seen synonymous with term, we could get rid off it but mathematicians like to talk about mathematical objects and for OOP programmers it is nice to have some familiar name</li>
<li>variables are placeholders, like in regular mathematics</li>
</ul>



<a name="284135262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284135262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Malcolm Langfield <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284135262">(May 27 2022 at 13:50)</a>:</h4>
<p><span class="user-mention" data-user-id="395550">@Henrik Böving</span>  Would you make a distinction between a variable and an identifier?</p>



<a name="284140807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284140807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284140807">(May 27 2022 at 14:32)</a>:</h4>
<p>I'd say that all variables are identifiers, but not all identifiers are variables, e.g.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">natId</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">x</span>
</code></pre></div>
<p><code>x</code> is an identifier (and variable) with type <code>Nat</code>and  <code>Nat</code> is an identifier (and type) with type <code>Type</code>, you would however agree that <code>Nat</code> is clearly not a variable here.</p>



<a name="284141110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284141110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284141110">(May 27 2022 at 14:34)</a>:</h4>
<p>Can't we say that a variable is a bound identifier?</p>



<a name="284141358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284141358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284141358">(May 27 2022 at 14:36)</a>:</h4>
<p>Not necessarily, Lean has a concept of free (not bound) variables as well which are visible to the user in the tactic state (and of course also meta variables but those are a different thing newcomers shouldn't be concerned with)</p>



<a name="284158071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284158071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284158071">(May 27 2022 at 16:55)</a>:</h4>
<p>If you work with macros/parser there you have <code>ident</code>(identifiers). I think for example custom attributes are parsed with <code>ident</code> and they do not have a type. I think an identifier is just a string of characters made out of specific subset of unicode characters, like excluding white space or '+', '-' ...</p>



<a name="284200367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284200367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Max Glick <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284200367">(May 28 2022 at 01:01)</a>:</h4>
<p>As a new person who craves a certain amount of "okay but what is really going on here" information, I am enjoying looking through the <a href="https://leanprover.github.io/reference/index.html">manual</a>.  It has a definition of expression in Section 3.2.</p>



<a name="284207737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Terms%20vs%20expressions/near/284207737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Malcolm Langfield <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Terms.20vs.20expressions.html#284207737">(May 28 2022 at 03:49)</a>:</h4>
<p>Thanks, this is very helpful!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
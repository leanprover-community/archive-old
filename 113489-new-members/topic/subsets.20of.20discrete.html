---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/subsets.20of.20discrete.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html">subsets of discrete</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="229129619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229129619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229129619">(Mar 06 2021 at 21:12)</a>:</h4>
<p>Dear All,</p>
<p>since it seems that today I am fighting with sets in Lean, I would like to know if anyone can suggest a simple proof of the lemma below.  I have a truly terrible proof, that you can see below!</p>
<p>More generally, I imagine that there will be a "lattice of discrete topological subspaces" in Lean, but I was not able to find it.</p>
<p>Thanks!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.separation</span>

<span class="kd">lemma</span> <span class="n">discrete_topology.of_subset</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span>
  <span class="o">(</span><span class="n">ds</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">ts</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">⊆</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">discrete_topology</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">singletons_open_iff_discrete</span><span class="o">,</span> <span class="n">set_coe.forall</span><span class="o">]</span> <span class="n">at</span> <span class="bp">⊢</span> <span class="n">ds</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">ta</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">ds</span> <span class="n">a</span> <span class="o">(</span><span class="n">ts</span> <span class="n">ta</span><span class="o">)</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">sa</span><span class="o">,</span> <span class="n">osa</span><span class="o">,</span> <span class="n">csa</span><span class="o">⟩,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">sa</span><span class="o">,</span> <span class="n">osa</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">obtain</span> <span class="n">F</span> <span class="o">:</span> <span class="n">coe</span> <span class="bp">''</span> <span class="o">(</span><span class="n">coe</span> <span class="bp">⁻¹'</span> <span class="n">sa</span><span class="o">)</span> <span class="bp">=</span> <span class="n">coe</span> <span class="bp">''</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">ss</span><span class="o">,</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="bp">''</span> <span class="n">ss</span><span class="o">)</span> <span class="n">csa</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">set.image_singleton</span><span class="o">,</span> <span class="n">subtype.image_preimage_coe</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">]</span> <span class="n">at</span> <span class="n">F</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">sat</span> <span class="o">:</span> <span class="n">sa</span> <span class="bp">∩</span> <span class="n">t</span> <span class="bp">⊆</span> <span class="n">sa</span> <span class="bp">∩</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">set.inter_subset_inter_right</span> <span class="n">sa</span> <span class="n">ts</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">sata</span> <span class="o">:</span> <span class="n">sa</span> <span class="bp">∩</span> <span class="n">t</span> <span class="bp">=</span> <span class="o">{</span><span class="n">a</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">set.subset.antisymm</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">a</span><span class="o">),</span> <span class="n">_</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">F</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">sat</span> <span class="n">hx</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">subst</span> <span class="n">hx</span><span class="o">,</span>
      <span class="n">refine</span> <span class="o">⟨</span><span class="n">set.mem_of_mem_inter_left</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">sa</span> <span class="bp">∩</span> <span class="n">s</span><span class="o">),</span> <span class="n">ta</span><span class="o">⟩,</span>
      <span class="n">exact</span> <span class="n">set.singleton_subset_iff.mp</span> <span class="o">(</span><span class="n">set.subset.antisymm_iff.mp</span> <span class="n">F.symm</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">ext1</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">x</span> <span class="k">with</span> <span class="n">x</span> <span class="n">xt</span><span class="o">,</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">sa</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">a</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_singleton_iff</span><span class="o">],</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">xa</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">sa</span> <span class="bp">∩</span> <span class="n">t</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">xa</span><span class="o">,</span> <span class="n">xt</span><span class="o">⟩,</span>
    <span class="n">rwa</span> <span class="n">sata</span> <span class="n">at</span> <span class="n">this</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">set.singleton_subset_iff.mp</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">el</span> <span class="n">elx</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">exact</span> <span class="n">set.mem_of_mem_inter_left</span> <span class="o">((</span><span class="n">set.subset.antisymm_iff.mp</span> <span class="n">sata.symm</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">elx</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="229137575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229137575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229137575">(Mar 06 2021 at 23:18)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.separation</span>

<span class="kd">lemma</span> <span class="n">discrete_topology.of_subset</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span>
  <span class="o">(</span><span class="n">ds</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">ts</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">⊆</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">discrete_topology</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">singletons_open_iff_discrete</span><span class="o">,</span> <span class="n">set_coe.forall</span><span class="o">]</span> <span class="n">at</span> <span class="bp">⊢</span> <span class="n">ds</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">ta</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">ds</span> <span class="n">a</span> <span class="o">(</span><span class="n">ts</span> <span class="n">ta</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">is_open_induced_iff</span> <span class="n">at</span> <span class="bp">⊢</span> <span class="n">ds</span><span class="o">,</span>  <span class="c1">-- don't just unfold</span>
  <span class="n">rcases</span> <span class="n">ds</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">sa</span><span class="o">,</span> <span class="n">osa</span><span class="o">,</span> <span class="n">csa</span><span class="o">⟩,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">sa</span><span class="o">,</span> <span class="n">osa</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="o">(</span><span class="n">function.injective.image_injective</span> <span class="n">subtype.coe_injective</span><span class="o">)</span><span class="bp">.</span><span class="n">eq_iff</span><span class="o">,</span>
      <span class="n">set.image_preimage_eq_inter_range</span><span class="o">,</span> <span class="n">subtype.range_coe</span><span class="o">,</span> <span class="n">set.image_singleton</span><span class="o">,</span>
      <span class="n">subtype.coe_mk</span><span class="o">]</span> <span class="n">at</span> <span class="n">csa</span> <span class="bp">⊢</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">set.inter_eq_self_of_subset_right</span> <span class="n">ts</span><span class="o">,</span> <span class="bp">←</span> <span class="n">set.inter_assoc</span><span class="o">,</span> <span class="n">csa</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">set.subset.antisymm</span> <span class="o">(</span><span class="n">set.inter_subset_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>
    <span class="o">(</span><span class="n">set.singleton_subset_iff.2</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">ta</span><span class="o">⟩)</span>
<span class="kd">end</span>
</code></pre></div>



<a name="229138880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229138880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229138880">(Mar 06 2021 at 23:40)</a>:</h4>
<p>Are you really sure you need this and can't get away with types instead of sets?</p>



<a name="229138977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229138977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229138977">(Mar 06 2021 at 23:43)</a>:</h4>
<p>It seems we are missing discrete space API anyway.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.separation</span>

<span class="kd">lemma</span> <span class="n">truc</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">tX</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">ts</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">⊆</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="n">subtype.topological_space</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">subtype.topological_space</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">induced</span> <span class="o">(</span><span class="n">set.inclusion</span> <span class="n">ts</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">change</span> <span class="n">tX.induced</span> <span class="o">((</span><span class="n">coe</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">set.inclusion</span> <span class="n">ts</span><span class="o">))</span> <span class="bp">=</span> <span class="n">topological_space.induced</span> <span class="o">(</span><span class="n">set.inclusion</span> <span class="n">ts</span><span class="o">)</span> <span class="o">(</span><span class="n">tX.induced</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">induced_compose</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">discrete_topology_iff_nhds</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">discrete_topology</span> <span class="n">X</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">nhds</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">filter</span> <span class="n">X</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pure</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">introI</span> <span class="n">hX</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">nhds_discrete</span> <span class="n">X</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">eq_of_nhds_eq_nhds</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">nhds_bot</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">induced_bot</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">topological_space.induced</span> <span class="n">f</span> <span class="bp">⊥</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span>
<span class="n">eq_of_nhds_eq_nhds</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">nhds_induced</span><span class="o">,</span> <span class="bp">←</span> <span class="n">set.image_singleton</span><span class="o">,</span> <span class="n">hf.preimage_image</span><span class="o">,</span> <span class="n">nhds_bot</span><span class="o">])</span>

<span class="kd">lemma</span> <span class="n">discrete_topology_induced</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">tY</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_topology</span> <span class="n">Y</span><span class="o">]</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="bp">@</span><span class="n">discrete_topology</span> <span class="n">X</span> <span class="o">(</span><span class="n">topological_space.induced</span> <span class="n">f</span> <span class="n">tY</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">discrete_topology.eq_bot</span> <span class="n">Y</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">induced_bot</span> <span class="n">hf</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">discrete_topology.of_subset</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span>
  <span class="o">(</span><span class="n">ds</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">ts</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">⊆</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">discrete_topology</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">truc</span> <span class="n">ts</span><span class="o">,</span> <span class="n">ds.eq_bot</span><span class="o">],</span>
  <span class="n">exact</span> <span class="o">{</span><span class="n">eq_bot</span> <span class="o">:=</span> <span class="n">induced_bot</span> <span class="o">(</span><span class="n">set.inclusion_injective</span> <span class="n">ts</span><span class="o">)}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="229161085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229161085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229161085">(Mar 07 2021 at 06:11)</a>:</h4>
<p>Dear Kenny and Patrick,</p>
<p>thank you so much for your proofs!</p>
<p>Kenny -- I really enjoy seeing how you can get Lean to do what you want!</p>
<p>Patrick -- you are right that I got stuck in some weird type-theory issue with sets and a strange up-arrow with a horizontal line below it.  I am happy to see different solutions and will now take some time going through yours!</p>
<p>On a separate note, I had already struggled to use the <code>discrete_topology</code> stuff when mixing it with finiteness.  I am now hoping to be able to prove that the intersection of a compact subset with a discrete subset of a topological space is finite.  While I found a lemma that claims exactly this, I have yet been unable to use it.  I hope that with these hints, I will manage it!</p>
<p>Thank you so much again!</p>



<a name="229163561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229163561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229163561">(Mar 07 2021 at 06:56)</a>:</h4>
<p>Patrick, I like your "API proof"!  In particular, I find the line </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">rw</span> <span class="o">[</span><span class="n">topological_space.subset_trans</span> <span class="n">ts</span><span class="o">,</span> <span class="n">ds.eq_bot</span><span class="o">],</span>
</code></pre></div>
<p>in your proof of <code>discrete_topology.of_subset</code> really informative for how type theory works.  I had realized that I was mostly playing around with coercions, but I had no idea how to really deal with them!</p>



<a name="229163662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229163662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229163662">(Mar 07 2021 at 06:58)</a>:</h4>
<p>Also, if you want, I can PR some of these lemmas.  I also added some comments to them, but I do not understand the one below, since I have never seen <code>pure</code> before and I do not know what it means.</p>
<p>Is what I wrote a reasonable description?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- I imagine that this lemma characterizes discrete topological spaces as those having</span>
<span class="sd">every as a neighbourhood of its points. -/</span>
<span class="kd">lemma</span> <span class="n">discrete_topology_iff_nhds</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">discrete_topology</span> <span class="n">X</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">nhds</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">filter</span> <span class="n">X</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pure</span> <span class="o">:=</span>
</code></pre></div>



<a name="229165193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229165193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229165193">(Mar 07 2021 at 07:24)</a>:</h4>
<p>I went ahead and made a PR: <a href="https://github.com/leanprover-community/mathlib/issues/6570">#6570</a>.</p>



<a name="229171339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229171339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229171339">(Mar 07 2021 at 09:05)</a>:</h4>
<p><code>filter</code> is a monad. The best introduction I have ever read for these is in a little-known pdf called Programming in Lean which is probably out of date when it comes to the code but which in 2017 was basically one of two pdf sources for learning about lean, the other one being TPIL. Monads are functions from Type to Type with some extra structure which makes them useful for programming or something. Examples are <code>option</code>, <code>list</code>, <code>set</code> and <code>filter</code>. The API for monads involves some standard names like <code>pure</code> and <code>bind</code> which are data (ie definitions) but if you know the types of the data you can usually guess what the definitions are, like us mathematicians say "the complexes are defined to be R^2" and then we say "the complexes are a field" but then the user has to guess what 0,1,+,-,* are. For a monad <code>m</code> there is <code>pure : X -&gt; m X</code> (which is usually easy) and <code>bind : m (m X) -&gt; m X</code> which is usually more fun and is often some sort of concatenation or union, and there are probably some axioms but I forgot them (and whether there are axioms might depend on whether you're a mathematician or a computer scientist). I think that pure is like the identity in a monoid and bind is like multiplication. </p>
<p>For lists, pure x will just be the list [x] and bind L will take a list of lists and just concatenate them. For filters, pure x will just be the principal filter generated by the set {x}.</p>
<p>A topological space is determined by its neighborhood filters. For me recently a really helpful mental model of a filter on X is that it is a generalized subset of X. The neighborhood filter of a point p should be thought of as the infinitesimal open neighbourhood of p, containing all the points infinitely close to p which Isaac Newton wondered about when he was developing calculus but which ultimately were rejected in the 19th century model of the real numbers which we use today. There's an inequality on filters which extends inclusion of subsets. Any subset of X is a filter on X or more precisely corresponds to a filter on X, namely the principal filter associated to this subset. No doubt this is a morphism of monads, if such a concept exists. If X is a topological space then you can easily recover the topology from the neighbourhood filter function: a set U is open iff for every x in U, the neighborhood filter N x is a subset of U. This corresponds to Newton's intuition. Saying that the neighborhood filter is <code>pure</code> just then says that U is open iff for every x in U we have that {x} is a subset of U, ie no extra condition.</p>



<a name="229171705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229171705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229171705">(Mar 07 2021 at 09:10)</a>:</h4>
<blockquote>
<p>I think that pure is like the identity in a monoid and bind is like multiplication. </p>
</blockquote>
<p>This is how I remember the monad axioms: just pretend it's a monoid, and play type tetris with the monoid axioms</p>



<a name="229171753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229171753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229171753">(Mar 07 2021 at 09:11)</a>:</h4>
<p>Ok, this clarifies the meaning of <code>pure</code>... a little!</p>
<p>Your generalized subsets seem close to germs to me: something that looks like an "inverse limit" in the making!</p>



<a name="229172156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229172156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229172156">(Mar 07 2021 at 09:18)</a>:</h4>
<p>You should read the monad chapter of <a href="https://leanprover.github.io/programming_in_lean/programming_in_lean.pdf">PIL</a> Damiano. Pure for a concrete monad like filter is just like multiplication in a concrete field -- the definition depends on the field.</p>



<a name="229172332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229172332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229172332">(Mar 07 2021 at 09:21)</a>:</h4>
<p>Kevin, I will take a look, thanks for the suggestion!</p>



<a name="229172668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229172668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229172668">(Mar 07 2021 at 09:27)</a>:</h4>
<p>(deleted)</p>



<a name="229188106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229188106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229188106">(Mar 07 2021 at 13:35)</a>:</h4>
<p>Kevin, your "something" is called <code>join</code> in generality, and in Lean, for an arbitrary monad, is called <code>mjoin</code>. Additionally, <code>list.join</code> and <code>option.join</code> are also defined, and lemmas are usually about them and not the more general <code>mjoin</code>. The same is true for <code>&gt;&gt;=</code> (read as <code>bind</code>).</p>



<a name="229188211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229188211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229188211">(Mar 07 2021 at 13:37)</a>:</h4>
<p>The <code>pure</code> actually comes from a generalization of monads: <code>applicative</code> functors. The naming choice for <code>pure</code> for monads is really unfortunate, and I won't even mention it here because it is quite confusing in a programming language context.</p>



<a name="229190327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229190327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229190327">(Mar 07 2021 at 14:09)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/02251b1ed3544ae658f687eb332f7627fff47f57/src/category_theory/monad/equiv_mon.lean#L108">https://github.com/leanprover-community/mathlib/blob/02251b1ed3544ae658f687eb332f7627fff47f57/src/category_theory/monad/equiv_mon.lean#L108</a></p>
<p>(sorry)</p>



<a name="229213887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229213887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229213887">(Mar 07 2021 at 20:03)</a>:</h4>
<p>One really fun algebro-geometric example of a monad is given by taking the albanese variety of a pointed variety to get another pointed variety, then pure is the albanese map and the join is the natural map  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>l</mi><mi>b</mi><mo stretchy="false">(</mo><mi>A</mi><mi>l</mi><mi>b</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>→</mo><mi>A</mi><mi>l</mi><mi>b</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Alb(Alb(X)) \to Alb(X)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> you get by applying the universal property to the identity map. <a href="https://mathoverflow.net/questions/247104/is-forming-the-albanese-variety-a-monad">https://mathoverflow.net/questions/247104/is-forming-the-albanese-variety-a-monad</a></p>



<a name="229215898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229215898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229215898">(Mar 07 2021 at 20:34)</a>:</h4>
<p>One topology that I had never considered is the co-discrete topology: closed sets are, beside the whole space, the subsets whose induced topology is discrete.  In a sequentially compact space, this should be simply the cofinite topology, but in general they are different.</p>
<p>This really is a topology, right?  A proof-checking community is a good place to ask these questions, I guess!</p>



<a name="229216441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229216441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229216441">(Mar 07 2021 at 20:43)</a>:</h4>
<p>I'm not so sure. Any one-point subset is discrete but I don't see why the union of two one-point subsets should be discrete in a random non-Hausdorff topological space.</p>



<a name="229216896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229216896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229216896">(Mar 07 2021 at 20:50)</a>:</h4>
<p>You are right, Kevin, I had Hausdorff spaces in mind: the spectrum of a DVR is a counterxample!</p>



<a name="229216947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229216947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229216947">(Mar 07 2021 at 20:52)</a>:</h4>
<p>E.g. a two-point space, whose topology is neither \top nor \bot works.</p>



<a name="229217053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229217053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229217053">(Mar 07 2021 at 20:53)</a>:</h4>
<p>Still, in a Hausdorff space, the co-discrete topology may make sense and I had never thought about it!</p>



<a name="229221556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229221556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229221556">(Mar 07 2021 at 22:06)</a>:</h4>
<p>How do you prove that a union of two discrete subspaces is discrete? Take for example the union of {1/n, n&gt;0 an integer} and {0} in the reals.</p>



<a name="229237789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subsets%20of%20discrete/near/229237789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subsets.20of.20discrete.html#229237789">(Mar 08 2021 at 02:18)</a>:</h4>
<p>Kevin, you are right: I had never heard of the co-discrete topology, since it does not make sense!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
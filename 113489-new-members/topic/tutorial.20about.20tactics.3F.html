---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html">tutorial about tactics?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="176424597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176424597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176424597">(Sep 24 2019 at 01:22)</a>:</h4>
<p>I am trying to understand tatics, how to prove the second lemma below? How to introduce a term <code>f a</code>? Does anyone have any additional tutorial about tatics? </p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">lx1</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
 <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
 <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">intro</span> <span class="n">a</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">lx2</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
 <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
 <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
 <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>



<a name="176424694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176424694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176424694">(Sep 24 2019 at 01:25)</a>:</h4>
<p>The second lemma is false: the assumption is weaker than the conclusion.</p>



<a name="176424802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176424802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176424802">(Sep 24 2019 at 01:28)</a>:</h4>
<p>For some basics on tactics, you can take a look at the reference manual: <a href="https://leanprover.github.io/reference/tactics.html" target="_blank" title="https://leanprover.github.io/reference/tactics.html">https://leanprover.github.io/reference/tactics.html</a></p>



<a name="176424814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176424814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176424814">(Sep 24 2019 at 01:28)</a>:</h4>
<p>if you also knew that <code>f</code> was surjective, then you could case on that hypothesis to "introduce" a term of the form <code>f a</code></p>
<p>(as it is, you could apply <code>lx2</code> to the constant function to zero)</p>



<a name="176424818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176424818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176424818">(Sep 24 2019 at 01:28)</a>:</h4>
<p>Yep, this is the one I am reading. I was wondering if someone have any additional material.</p>



<a name="176424900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176424900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176424900">(Sep 24 2019 at 01:31)</a>:</h4>
<p>There is a list of all tactics defined in mathlib here: <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md">https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md</a><br>
But that is not at all a tutorial, more like a reference guide (and most tactics in it are very specialized).</p>



<a name="176425143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425143">(Sep 24 2019 at 01:36)</a>:</h4>
<p>You've presumably read the chapter in Theorem Proving In Lean on tactics?</p>



<a name="176425309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425309">(Sep 24 2019 at 01:40)</a>:</h4>
<p>Yes, as I said above this is the one I am reading now.</p>



<a name="176425325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425325">(Sep 24 2019 at 01:41)</a>:</h4>
<p>My crappy notes from last year: <a href="http://wwwf.imperial.ac.uk/~buzzard/xena/html/source/M1F_introduction/prop_exercises.html" target="_blank" title="http://wwwf.imperial.ac.uk/~buzzard/xena/html/source/M1F_introduction/prop_exercises.html">http://wwwf.imperial.ac.uk/~buzzard/xena/html/source/M1F_introduction/prop_exercises.html</a> <a href="http://wwwf.imperial.ac.uk/~buzzard/xena/html/source/M1F_sheet_1/M1F_sheet_1_part_1.html" target="_blank" title="http://wwwf.imperial.ac.uk/~buzzard/xena/html/source/M1F_sheet_1/M1F_sheet_1_part_1.html">http://wwwf.imperial.ac.uk/~buzzard/xena/html/source/M1F_sheet_1/M1F_sheet_1_part_1.html</a></p>



<a name="176425329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425329">(Sep 24 2019 at 01:41)</a>:</h4>
<p>I will hopefully get something better written this year; I have some time later on in the week.</p>



<a name="176425331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425331">(Sep 24 2019 at 01:41)</a>:</h4>
<p>My real goal is to prove</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span><span class="n">x</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span><span class="n">x</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
 <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>

<span class="kn">end</span>
</pre></div>


<p>proving lemma <code>lx1</code> was just one exercise. But yes, you are right, <code>lx2</code> is not a theorem without assuming more about f.</p>



<a name="176425381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425381">(Sep 24 2019 at 01:43)</a>:</h4>
<p>Do all of the exercises in TPIL and then discover your own exercises (e.g. work through a book). Just practice and keep asking here. That's my advice.</p>



<a name="176425449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425449">(Sep 24 2019 at 01:45)</a>:</h4>
<blockquote>
<p>My real goal is to prove</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span><span class="n">x</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span><span class="n">x</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
 <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>

<span class="kn">end</span>
</pre></div>


</blockquote>
<p><code>h</code> is a proof, but it's a proof of something quite messy. Do you know what the "head symbol" of h is? Is it called that? The "head term" or something? What tactic can you do to change <code>h</code>?</p>



<a name="176425451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425451">(Sep 24 2019 at 01:45)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span></p>



<a name="176425502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425502">(Sep 24 2019 at 01:46)</a>:</h4>
<p>the head symbol of h is the conjunction.</p>



<a name="176425514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425514">(Sep 24 2019 at 01:46)</a>:</h4>
<p>And do you know the tactic which will replace h by its two parts?</p>



<a name="176425526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425526">(Sep 24 2019 at 01:47)</a>:</h4>
<p>could you be more explicit of the precedence of the first conjunct of h? I'm not sure if it's the one you want</p>



<a name="176425537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425537">(Sep 24 2019 at 01:47)</a>:</h4>
<p>From the left of the conjunction of h, we can obtain <code>forall x : nat, p f x</code> and using MP I hope to obtain the conclusion,</p>



<a name="176425579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425579">(Sep 24 2019 at 01:48)</a>:</h4>
<p>yep, that's not the precedence you wrote</p>



<a name="176425582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425582">(Sep 24 2019 at 01:48)</a>:</h4>
<p>Looking at the tactic state I am inclined to agree with Mario. My tactic state looks like this:</p>
<div class="codehilite"><pre><span></span>1 goal
p q : ℕ → Prop,
f : ℕ → ℕ,
h1 : ∀ (x : ℕ), p (f x) → ∀ (x : ℕ), q (f x),
h2 : ∀ (x : ℕ), p x
⊢ ∃ (x : ℕ), q x
</pre></div>



<a name="176425586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425586">(Sep 24 2019 at 01:48)</a>:</h4>
<p>you need parentheses around <code>(∀ (x : ℕ), p (f x))</code></p>



<a name="176425599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425599">(Sep 24 2019 at 01:49)</a>:</h4>
<p>That first "forall x : nat" stretches a long way otherwise</p>



<a name="176425603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425603">(Sep 24 2019 at 01:49)</a>:</h4>
<p>I have this parenthesis. My state after the intro is </p>
<div class="codehilite"><pre><span></span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span>
<span class="err">⊢</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span>
</pre></div>



<a name="176425652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425652">(Sep 24 2019 at 01:50)</a>:</h4>
<p><code>h1 : ∀ (x : ℕ), (p (f x) → ∀ (y : ℕ), q (f y))</code></p>



<a name="176425658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425658">(Sep 24 2019 at 01:50)</a>:</h4>
<p>split your <code>h</code> with the <code>split</code> tactic so you can see what's going on a bit better.</p>



<a name="176425663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425663">(Sep 24 2019 at 01:50)</a>:</h4>
<p>We have an operator precedence issue.</p>



<a name="176425665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425665">(Sep 24 2019 at 01:50)</a>:</h4>
<p>not split, that splits the goal</p>



<a name="176425667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425667">(Sep 24 2019 at 01:50)</a>:</h4>
<p><code>cases h with h1 h2</code> should do</p>



<a name="176425668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425668">(Sep 24 2019 at 01:50)</a>:</h4>
<p>yeah, <code>cases h</code></p>



<a name="176425669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425669">(Sep 24 2019 at 01:50)</a>:</h4>
<p>sorry</p>



<a name="176425676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425676">(Sep 24 2019 at 01:51)</a>:</h4>
<p>I'm rubbish at Lean</p>



<a name="176425681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425681">(Sep 24 2019 at 01:51)</a>:</h4>
<p>maybe <code>split at h</code> should mean <code>cases h</code></p>



<a name="176425690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425690">(Sep 24 2019 at 01:52)</a>:</h4>
<p>Your problem is that your <code>h</code> is of this type: <code>(∀ (x : ℕ), (p (f x) → ∀ (x : ℕ), q (f x))) ∧ ∀ (x : ℕ), p x</code></p>



<a name="176425731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425731">(Sep 24 2019 at 01:52)</a>:</h4>
<p>and this is independent of the fact that half of us don't know how to use basic tactics.</p>



<a name="176425751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425751">(Sep 24 2019 at 01:53)</a>:</h4>
<p>Hum, cases worked somehow. Now I have </p>
<div class="codehilite"><pre><span></span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">h1</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
<span class="n">h2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span>
<span class="err">⊢</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span>
</pre></div>



<a name="176425752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425752">(Sep 24 2019 at 01:53)</a>:</h4>
<p>that looks better</p>



<a name="176425797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425797">(Sep 24 2019 at 01:54)</a>:</h4>
<p>now what's the maths proof?</p>



<a name="176425801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425801">(Sep 24 2019 at 01:54)</a>:</h4>
<p>I'm on steadier ground there.</p>



<a name="176425819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425819">(Sep 24 2019 at 01:54)</a>:</h4>
<p>Now I need to work with h2 to obtain the premisse of h1 to apply MP. With that result, I can obtain the conclusion.</p>



<a name="176425841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425841">(Sep 24 2019 at 01:55)</a>:</h4>
<p>You can try working from the end, or <code>have</code>ing an intermediate state</p>



<a name="176425844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425844">(Sep 24 2019 at 01:55)</a>:</h4>
<p>That's right. In Lean many tactics work backwords from the goal. Do you think you could write the entire argument backwards?</p>



<a name="176425846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425846">(Sep 24 2019 at 01:55)</a>:</h4>
<p>working from the end, what's the existential witness here?</p>



<a name="176425897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425897">(Sep 24 2019 at 01:56)</a>:</h4>
<p>And then what's the tactic you can use to proceed?</p>



<a name="176425943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176425943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176425943">(Sep 24 2019 at 01:57)</a>:</h4>
<p>I like to think that every head symbol has a "tactic-constructor" and a "tactic-eliminator" -- the first is the tactic you use if you want to move on <code>blah</code> and <code>blah</code> is in the goal, and the second is the tactic you use if you want to use <code>blah</code> and <code>blah</code> is in a hypothesis.</p>



<a name="176426357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176426357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176426357">(Sep 24 2019 at 02:08)</a>:</h4>
<p>Hum, almost there... </p>
<div class="codehilite"><pre><span></span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">h1</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
<span class="n">h2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span>
<span class="n">h3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
<span class="n">h4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span>
<span class="err">⊢</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span>
</pre></div>



<a name="176426847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176426847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176426847">(Sep 24 2019 at 02:21)</a>:</h4>
<p>Try using the <code>existsi</code> tactic (I think it's deprecated in favor of <code>use</code> now though).</p>



<a name="176428734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176428734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176428734">(Sep 24 2019 at 03:10)</a>:</h4>
<p>can you post precisely what you are now trying to prove?</p>



<a name="176428735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176428735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176428735">(Sep 24 2019 at 03:10)</a>:</h4>
<p>It would be interesting to see your proof.</p>



<a name="176447920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176447920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176447920">(Sep 24 2019 at 09:47)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> , my current state is the following. I am just trying to complete this proof. </p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="bp">∀</span><span class="n">x</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span><span class="n">x</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)))</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
 <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
 <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
 <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span> <span class="k">assume</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">h2</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">),</span>
 <span class="k">have</span> <span class="n">h4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span> <span class="k">from</span> <span class="o">(</span><span class="n">h1</span> <span class="n">h3</span><span class="o">),</span>

<span class="kn">end</span>
</pre></div>



<a name="176448156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176448156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176448156">(Sep 24 2019 at 09:51)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> , if I try <code>existsi (f a)</code> it says that <code>a</code> is unknow.</p>



<a name="176448281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176448281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176448281">(Sep 24 2019 at 09:53)</a>:</h4>
<p>There's no variable called <code>a</code> in your context. Try <code>existsi (f 0)</code></p>



<a name="176449311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176449311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176449311">(Sep 24 2019 at 10:09)</a>:</h4>
<p>Wow! It worked!! So happy!! ;-) It looks like I have a proof. But why I can't use a generic term of type <code>nat</code> instead of <code>0</code> in the last step? It should be possible to prove <code>∀ (x : ℕ), q (f x) ⊢ ∃ (x : ℕ), q x</code> for any nat, right?</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="bp">∀</span><span class="n">x</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span><span class="n">x</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)))</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
 <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
 <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
 <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span> <span class="k">assume</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">h2</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">),</span>
 <span class="k">have</span> <span class="n">h4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span> <span class="k">from</span> <span class="o">(</span><span class="n">h1</span> <span class="n">h3</span><span class="o">),</span>
 <span class="n">existsi</span> <span class="o">(</span><span class="n">f</span> <span class="mi">0</span><span class="o">),</span> <span class="n">exact</span> <span class="o">(</span><span class="n">h4</span> <span class="mi">0</span><span class="o">)</span>
<span class="kn">end</span>
</pre></div>



<a name="176449657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176449657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176449657">(Sep 24 2019 at 10:14)</a>:</h4>
<p>You could use any <code>nat</code> other than <code>0</code> for the proof. Using an arbitrary <code>nat</code> when there isn't one in your context could cause problems if the type <code>nat</code> was empty. Your example is actually false with <code>nat</code> substituted for <code>empty</code> in the statement.</p>



<a name="176449940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176449940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176449940">(Sep 24 2019 at 10:19)</a>:</h4>
<p>Sorry, I didn’t understand. The reason for my question is that it should be possible to replace the type <code>nat</code> with a generic type <code>U : Type</code>, right?</p>



<a name="176450897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176450897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176450897">(Sep 24 2019 at 10:34)</a>:</h4>
<p>Only if <code>U</code> is nonempty</p>



<a name="176450962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176450962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176450962">(Sep 24 2019 at 10:35)</a>:</h4>
<p>....</p>



<a name="176451196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176451196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176451196">(Sep 24 2019 at 10:39)</a>:</h4>
<p>Yes, if U is nonempty, an usual assumption for domains in first order logic. In that case, how can I replace nat by U saying that U is nonempty?</p>



<a name="176451384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176451384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176451384">(Sep 24 2019 at 10:42)</a>:</h4>
<p>To minimally change your existing proof:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">hne</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="bp">∀</span><span class="n">x</span><span class="o">:</span><span class="n">α</span><span class="o">,</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span><span class="n">x</span><span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)))</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
 <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
 <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
 <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span> <span class="k">assume</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">h2</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">),</span>
 <span class="k">have</span> <span class="n">h4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span> <span class="k">from</span> <span class="o">(</span><span class="n">h1</span> <span class="n">h3</span><span class="o">),</span>

 <span class="k">have</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="n">hne</span><span class="o">,</span>
 <span class="n">existsi</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">),</span> <span class="n">exact</span> <span class="o">(</span><span class="n">h4</span> <span class="n">a</span><span class="o">),</span>
<span class="kn">end</span>
</pre></div>



<a name="176451454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176451454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176451454">(Sep 24 2019 at 10:43)</a>:</h4>
<p>If you would like a witness to the nonemptiness of the type <code>α</code> to actually be provided, use <code>inhabited</code> instead of <code>nonempty</code></p>



<a name="176451682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176451682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176451682">(Sep 24 2019 at 10:46)</a>:</h4>
<p>Wow! Too many new things! I am curious why this discussion of nonempty types didn't appear in the <a href="https://leanprover.github.io/logic_and_proof/first_order_logic_in_lean.html#using-the-universal-quantifier" target="_blank" title="https://leanprover.github.io/logic_and_proof/first_order_logic_in_lean.html#using-the-universal-quantifier">chapter 9 of Logic and Proof</a>!</p>
<p>Thank you <span class="user-mention" data-user-id="110111">@Keeley Hoek</span> ! Now I have to understand why the <code>{ ...}</code>, the use of <code>[...]</code>  in the declaration instead of <code>(...)</code> and the <code>classical.choice</code> operator.</p>



<a name="176451720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176451720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176451720">(Sep 24 2019 at 10:47)</a>:</h4>
<p>What I've done is just replaced each use of nat with an arbitrary type <code>α</code>, but have required that a proof that <code>α</code> is <code>nonempty</code> is also provided.</p>



<a name="176451774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176451774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176451774">(Sep 24 2019 at 10:48)</a>:</h4>
<p>To obtain an actual element <code>a</code> of <code>α</code> based on the proof of nonemptiness <code>hne</code>, we appeal to the axiom of choice.</p>



<a name="176451868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176451868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176451868">(Sep 24 2019 at 10:50)</a>:</h4>
<p>nonempty is also introduced here: <a href="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#choice" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#choice">https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#choice</a></p>



<a name="176451921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176451921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176451921">(Sep 24 2019 at 10:51)</a>:</h4>
<p>The curly and square brackets aren't necessary. They would be instructions to lean for anyone trying to use your proof, if it was a <code>def</code>, and not an <code>example</code>. The curly braces instruct lean to always guess <code>α</code> and never ask for it to be provided. The square brackets are trickier, and ask lean to perform so-called typeclass inference to obtain the proof of nonemptiness. You can read more about both of these in the book.</p>



<a name="176451926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176451926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176451926">(Sep 24 2019 at 10:51)</a>:</h4>
<p>So, they just make it easier to use. There are no implications for your actual proof.</p>



<a name="176451981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176451981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176451981">(Sep 24 2019 at 10:52)</a>:</h4>
<p>I didn't understand the difference between nonempty and inhabited! hne isn't a witness?</p>



<a name="176451989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176451989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176451989">(Sep 24 2019 at 10:52)</a>:</h4>
<p>No. It is a proof that it is nonempty. The witness has been forgotten.</p>



<a name="176451997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176451997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176451997">(Sep 24 2019 at 10:53)</a>:</h4>
<p>It's because <code>nonempty</code> is defined to live in the universe <code>Prop</code>, but <code>inhabited</code> lives in <code>Type</code> (roughly speaking).</p>



<a name="176452016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176452016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176452016">(Sep 24 2019 at 10:53)</a>:</h4>
<p>So <code>inhabited</code> instances can be deconstructed, but <code>nonempty</code> instances cannot be deconstructed once built.</p>



<a name="176452020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176452020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176452020">(Sep 24 2019 at 10:53)</a>:</h4>
<p>Otherwise, they have the same definition exactly.</p>



<a name="176452034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176452034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176452034">(Sep 24 2019 at 10:54)</a>:</h4>
<p>{...} and [...] are also explained here: <br>
<a href="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#implicit-arguments" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#implicit-arguments">https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#implicit-arguments</a><br>
<a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html</a></p>



<a name="176452267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176452267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176452267">(Sep 24 2019 at 10:55)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="221921">@Marc Huisinga</span> for the links.</p>



<a name="176454532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176454532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176454532">(Sep 24 2019 at 11:36)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="110111">@Keeley Hoek</span> for the solution and detailed explanation.</p>



<a name="176488804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176488804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176488804">(Sep 24 2019 at 17:57)</a>:</h4>
<p>Since it wasn't mentioned: it is not necessary to use choice to extract a witness here, because the theorem being proved is itself a prop, so you can use <code>cases hne with a</code> in place of <code>have a : α := classical.choice hne</code> in Keeley's proof.</p>



<a name="176488957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176488957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176488957">(Sep 24 2019 at 17:58)</a>:</h4>
<p>You probably have to do <code>have := hne, cases this with a</code> (or <code>unfreezeI, cases hne with a</code>) for technical reasons.</p>



<a name="176522198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176522198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176522198">(Sep 25 2019 at 00:29)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> and <span class="user-mention" data-user-id="111080">@Floris van Doorn</span> , the final proof is below. I prefer explicit identifiers, that is why I used y. I am not sure if I understood the intuition behind this <code>have ... cases ... with ...</code>! The <code>unfreezeI</code> is probably from the mathlib, right? I didn't find it in my system.</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">hne</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)))</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
 <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
 <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
 <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span> <span class="k">assume</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">h2</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">),</span>
 <span class="k">have</span> <span class="n">h4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span> <span class="k">from</span> <span class="o">(</span><span class="n">h1</span> <span class="n">h3</span><span class="o">),</span>

 <span class="k">have</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">hne</span><span class="o">,</span> <span class="n">cases</span> <span class="n">y</span> <span class="k">with</span> <span class="n">a</span><span class="o">,</span>
 <span class="n">existsi</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">),</span> <span class="n">exact</span> <span class="o">(</span><span class="n">h4</span> <span class="n">a</span><span class="o">),</span>
<span class="kn">end</span>
</pre></div>



<a name="176522270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176522270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176522270">(Sep 25 2019 at 00:30)</a>:</h4>
<p>you can also use <code>cases id hne with a</code></p>



<a name="176522367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176522367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176522367">(Sep 25 2019 at 00:32)</a>:</h4>
<p>The technical reason is that <code>nonempty A</code> is a class, which means that that argument is "frozen" in the local context in order to cache and speed up typeclass searches. There are several mathlib tactics ending in <code>*I</code> that unfreeze these instances so that you can remove them from the context (which is what <code>cases hne</code> wants to do)</p>



<a name="176522396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176522396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176522396">(Sep 25 2019 at 00:33)</a>:</h4>
<p>they are available via <code>import tactic.cache</code></p>



<a name="176522466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176522466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176522466">(Sep 25 2019 at 00:35)</a>:</h4>
<p>If you don't have mathlib, you can also use <code>tactic.unfreeze_local_instances</code> for which <code>unfreezeI</code> is a synonym</p>



<a name="176622350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176622350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176622350">(Sep 26 2019 at 02:03)</a>:</h4>
<p>Hum, <code>case id hne with a</code> is simpler than <code>have y := hne, cases y with a</code>, but I am still trying to understand the rationality of this tactic <code>case</code>. The docstring of <code>case</code> if not very informative! To close this thread, I need to make one additional question. I started the proof using the type <code>nat</code>, when we moved to the arbitrary <code>α</code> type above, we had to say that it is nonempty and we used <code>hne</code> (the proof of its nonemptiness) to obtain an arbitrary element. If we go back to the <code>nat</code>, how could I use an arbitrary natural number instead of <code>0</code> or any other magically available number already defined in the Lean environment? In the proof using <code>nat</code> below, I didn't need to introduce <code>[hne : nonempty ℕ]</code>, this type is probably already defined elsewhere as nonempty, right?  That is, it works with any already defined number but I would like to have a more 'general' proof in <code>nat</code>, saying that ANY number (like an <code>a</code>) would work.</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)))</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
 <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
 <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
 <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span> <span class="k">assume</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">h2</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">),</span>
 <span class="k">have</span> <span class="n">h4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span> <span class="k">from</span> <span class="o">(</span><span class="n">h1</span> <span class="n">h3</span><span class="o">),</span>
 <span class="n">existsi</span> <span class="o">(</span><span class="n">f</span> <span class="mi">10</span><span class="o">),</span> <span class="n">exact</span> <span class="o">(</span><span class="n">h4</span> <span class="mi">10</span><span class="o">),</span>
<span class="kn">end</span>
</pre></div>


<p>Does it make sense?</p>



<a name="176623042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176623042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176623042">(Sep 26 2019 at 02:20)</a>:</h4>
<p>You can use <code>apply_instance</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)))</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
 <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
 <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
 <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span> <span class="k">assume</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">h2</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">),</span>
 <span class="k">have</span> <span class="n">h4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span> <span class="k">from</span> <span class="o">(</span><span class="n">h1</span> <span class="n">h3</span><span class="o">),</span>

 <span class="k">have</span> <span class="n">y</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span><span class="o">,</span> <span class="n">cases</span> <span class="n">y</span> <span class="k">with</span> <span class="n">a</span><span class="o">,</span>
 <span class="n">existsi</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">),</span> <span class="n">exact</span> <span class="o">(</span><span class="n">h4</span> <span class="n">a</span><span class="o">),</span>
<span class="kn">end</span>
</pre></div>


<p>(assuming I understood what you want)</p>



<a name="176623044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176623044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176623044">(Sep 26 2019 at 02:21)</a>:</h4>
<p>It doesn't really make sense. The proof requires you to use <em>some</em> natural number to do the cut, and if you want to quantify over different witnesses you have to change the theorem statement</p>



<a name="176623124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176623124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176623124">(Sep 26 2019 at 02:22)</a>:</h4>
<p>One way to express this is to add an argument <code>n</code> to the theorem:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)))</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
 <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
 <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
 <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span> <span class="k">assume</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">h2</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">),</span>
 <span class="k">have</span> <span class="n">h4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span> <span class="k">from</span> <span class="o">(</span><span class="n">h1</span> <span class="n">h3</span><span class="o">),</span>
 <span class="n">existsi</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">),</span> <span class="n">exact</span> <span class="o">(</span><span class="n">h4</span> <span class="n">n</span><span class="o">),</span>
<span class="kn">end</span>
</pre></div>


<p>But no one would want to use this theorem because the argument <code>n</code> is useless (has no bearing on the fact to be proven)</p>



<a name="176623149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176623149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176623149">(Sep 26 2019 at 02:23)</a>:</h4>
<p>This sort of thing is often done for functions, where we actually care about dependence of the definition on the argument even if the type is fixed, but for proofs we want to minimize assumptions because proofs are irrelevant</p>



<a name="176670625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176670625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176670625">(Sep 26 2019 at 15:56)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> , nice I learned one more thing! The <code>apply_instance</code> tactic seems to use the previous definition of <code>nat</code> as non empty right? Trying it with the type <code>α</code> didn't work. </p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)))</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
 <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
 <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
 <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span> <span class="k">assume</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">h2</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">),</span>
 <span class="k">have</span> <span class="n">h4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span> <span class="k">from</span> <span class="o">(</span><span class="n">h1</span> <span class="n">h3</span><span class="o">),</span>

 <span class="k">have</span> <span class="n">hne</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">α</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span><span class="o">,</span> <span class="n">cases</span> <span class="n">hne</span> <span class="k">with</span> <span class="n">a</span><span class="o">,</span>
 <span class="n">existsi</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">),</span> <span class="n">exact</span> <span class="o">(</span><span class="n">h4</span> <span class="n">a</span><span class="o">),</span>
<span class="kn">end</span>
</pre></div>


<p>causes the error:</p>
<div class="codehilite"><pre><span></span>tactic.mk_instance failed to generate instance for
  nonempty α
</pre></div>


<p>In other words, the line <code>have hne : nonempty α := by apply_instance, cases hne with a,</code> is not a replacement of <code>[hne : nonempty α]</code> in the lemma declaration.  Sorry for so many questions. I am just trying to understand what is going on.</p>



<a name="176670693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176670693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176670693">(Sep 26 2019 at 15:57)</a>:</h4>
<p>Yes, <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I got your point. I am just trying to use the example to understand what is going on. But you are right about the example itself. It would not make sense to depend on an additional parameter.</p>



<a name="176670993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176670993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176670993">(Sep 26 2019 at 16:01)</a>:</h4>
<p>If alpha is empty (which is fine in Lean) then the goal is false, right? Lean's type class inference system knows that nat is non-empty, but it won't know that alpha is non-empty unless you prove it first.</p>



<a name="176671054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176671054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176671054">(Sep 26 2019 at 16:02)</a>:</h4>
<p><code>[hne : nonempty α]</code> is an assumption; <code>have hne : nonempty α := ...</code> is an unjustified claim.</p>



<a name="176671118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176671118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176671118">(Sep 26 2019 at 16:03)</a>:</h4>
<p>PS in case I misunderstood -- it's very hard to debug your code if you just post random error messages. Can you post complete minimal working examples which other people can just cut and paste?</p>



<a name="176671254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176671254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176671254">(Sep 26 2019 at 16:04)</a>:</h4>
<p>In addition to what Kevin said, you can also see <a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html">this chapter of TPiL</a> for some more info about instances.</p>



<a name="176673014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176673014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176673014">(Sep 26 2019 at 16:27)</a>:</h4>
<p>Sorry <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> , it edited my previous message. I thought it was clear from the rest of the thread what I am trying to do. Interesting, I thought that <code>apply_instance, cases hne with a</code> is proving/justifying the <code>hne : nonempty α</code> claim, but it would be introducing some circularity...</p>



<a name="176673268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176673268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176673268">(Sep 26 2019 at 16:30)</a>:</h4>
<p>I am too lazy to refresh my memory of the thread by reading it all through again, and too forgetful to remember what its main points are :-)</p>



<a name="176673303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176673303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176673303">(Sep 26 2019 at 16:31)</a>:</h4>
<p>it can't prove that claim, because it isn't true in general</p>



<a name="176673309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176673309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176673309">(Sep 26 2019 at 16:31)</a>:</h4>
<p>not every α is nonempty</p>



<a name="176673532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176673532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176673532">(Sep 26 2019 at 16:34)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">empty_type</span> <span class="bp">.</span> <span class="c1">-- no constructors, so no terms.</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">nonempty</span> <span class="n">empty_type</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h2</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>



<a name="176673577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176673577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176673577">(Sep 26 2019 at 16:35)</a>:</h4>
<p>The first <code>cases</code> uses the fact that there is only one constructor for <code>nonempty X</code>, which needs a term of type <code>X</code>; this is <code>h2</code>. And then <code>cases h2</code> breaks up into one case per constructor; there are no constructors, so the proof is over.</p>



<a name="176674100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176674100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176674100">(Sep 26 2019 at 16:43)</a>:</h4>
<p>You mean "here is only ONE constructor for <code>nonempty X</code>"? I found in <code>logic.lean</code>:</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="kn">inductive</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">nonempty</span>
</pre></div>


<p>Thank you for the example! I am learning a lot here.</p>



<a name="176674212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176674212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176674212">(Sep 26 2019 at 16:44)</a>:</h4>
<p>Yes, sorry! I edited. The <code>cases</code> tactic takes a term of type <code>I</code>, with <code>I</code> an inductive type, and then creates one goal per constructor.</p>



<a name="176674939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176674939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176674939">(Sep 26 2019 at 16:52)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> for the link. Yes, I need to finish to read the TPiL.</p>



<a name="176845507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176845507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176845507">(Sep 28 2019 at 23:01)</a>:</h4>
<p>I must admit, tactics is a complicate stuff! No clue how to prove using tactics the following two theorems:</p>
<div class="codehilite"><pre><span></span><span class="kn">constant</span> <span class="n">U</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kn">constants</span> <span class="n">p</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:=</span>
 <span class="k">assume</span> <span class="n">y</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span>
 <span class="k">assume</span> <span class="n">h₂</span> <span class="o">:</span> <span class="n">p</span> <span class="n">y</span><span class="o">,</span> <span class="n">h</span> <span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">y</span> <span class="n">h₂</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">classical</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:=</span>
 <span class="n">by_contradiction</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">h₁</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span>
   <span class="n">h</span> <span class="o">(</span><span class="k">assume</span> <span class="n">b</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span>
      <span class="n">by_contradiction</span>
      <span class="o">(</span><span class="k">assume</span> <span class="n">h₂</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">b</span><span class="o">,</span> <span class="n">h₁</span> <span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">b</span> <span class="n">h₂</span><span class="o">))))</span>
</pre></div>


<p>It is not clear how to deal with exists.intro and negation in the hypothesis...</p>



<a name="176845731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176845731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176845731">(Sep 28 2019 at 23:09)</a>:</h4>
<p>There's <code>use</code>, <code>rintro</code>, <code>rcases</code>, <code>push_neg</code>, <code>contrapose!</code></p>



<a name="176845734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176845734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176845734">(Sep 28 2019 at 23:09)</a>:</h4>
<p>nice and powerful tactics (-;</p>



<a name="176845785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176845785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176845785">(Sep 28 2019 at 23:10)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span> <span class="c1">-- mathlib, so I can use &quot;use&quot;</span>
<span class="kn">variable</span> <span class="n">U</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kn">variable</span> <span class="n">p</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h₂</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">assumption</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>If you don't like <code>use</code>, you can use <code>existsi</code> in core.</p>



<a name="176845790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176845790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176845790">(Sep 28 2019 at 23:10)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>
<span class="kn">constant</span> <span class="n">U</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kn">constants</span> <span class="n">p</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">y</span> <span class="n">h₂</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h₂</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">by_contra</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">by_contra</span> <span class="n">h₂</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h₂</span>
<span class="kn">end</span>
</pre></div>



<a name="176845803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176845803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176845803">(Sep 28 2019 at 23:11)</a>:</h4>
<p>I probably would not have used tactics for some of these, but this is a pure-tactic style</p>



<a name="176845846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176845846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176845846">(Sep 28 2019 at 23:12)</a>:</h4>
<p>for example the existsi, exact is easier to write as <code>refine ⟨b, h₂⟩</code></p>



<a name="176845855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176845855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176845855">(Sep 28 2019 at 23:12)</a>:</h4>
<p>I use the <code>classical</code> tactic (in mathlib) when lean complains about this and that not being decidable</p>



<a name="176845919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176845919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176845919">(Sep 28 2019 at 23:15)</a>:</h4>
<p>here's a more hybrid approach:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">y</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">h</span> <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">h₂</span><span class="bp">⟩</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">by_contra</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span>
  <span class="n">by_contra</span> <span class="n">h₂</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h₁</span> <span class="bp">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">h₂</span><span class="bp">⟩</span>
<span class="kn">end</span>
</pre></div>



<a name="176846767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176846767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176846767">(Sep 28 2019 at 23:45)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> ! <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> , is there any alternative to the classical mathlib tactic? I am trying to avoid introduce mathlib before get things more clear.</p>



<a name="176846810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176846810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176846810">(Sep 28 2019 at 23:46)</a>:</h4>
<p><code>classical</code> is the same as <code>haveI := classical.prop_decidable</code></p>



<a name="176846814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176846814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176846814">(Sep 28 2019 at 23:46)</a>:</h4>
<p>but <code>haveI</code> is another mathlib tactic</p>



<a name="176846817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176846817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176846817">(Sep 28 2019 at 23:46)</a>:</h4>
<p>What's <code>not not P -&gt; P</code> called in Lean? For some reason I can't find it with library_search</p>



<a name="176846820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176846820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176846820">(Sep 28 2019 at 23:46)</a>:</h4>
<p>you can use <code>local attribute [instance] classical.prop_decidable</code> outside the proof instead</p>



<a name="176846828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176846828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176846828">(Sep 28 2019 at 23:47)</a>:</h4>
<p><code>classical.by_contradiction</code></p>



<a name="176846837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176846837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176846837">(Sep 28 2019 at 23:47)</a>:</h4>
<p>I like the compact notation of <code>⟨y, h₂⟩</code> but it is confusing since the same par of symbols is used to the <code>and.intro</code>.</p>



<a name="176846879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176846879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176846879">(Sep 28 2019 at 23:48)</a>:</h4>
<p>it works with any inductive type with one constructor</p>



<a name="176846882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176846882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176846882">(Sep 28 2019 at 23:48)</a>:</h4>
<p>That's not confusing -- those are two instances of the same phenomenon. It's unifying :-)</p>



<a name="176846884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176846884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176846884">(Sep 28 2019 at 23:48)</a>:</h4>
<p>or any <code>structure</code></p>



<a name="176846898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176846898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176846898">(Sep 28 2019 at 23:50)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">classical</span><span class="bp">.</span><span class="n">by_contradiction</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">classical</span><span class="bp">.</span><span class="n">by_contradiction</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h₂</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">assumption</span>
<span class="kn">end</span>
</pre></div>


<p>There's a mathlib-free proof of the second one in tactic mode.</p>



<a name="176846946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176846946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176846946">(Sep 28 2019 at 23:50)</a>:</h4>
<p>(with thanks to Mario for <code>classical.by_contradiction</code>)</p>



<a name="176846971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176846971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176846971">(Sep 28 2019 at 23:51)</a>:</h4>
<p>Hum, but the signatures returned by the check command are quite different. In the type theory level both are constructors, I see.</p>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span>
</pre></div>



<a name="176847014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847014">(Sep 28 2019 at 23:52)</a>:</h4>
<p>This isn't notation overloading - the parser has special support for constructing tuple-like inductives</p>



<a name="176847030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847030">(Sep 28 2019 at 23:53)</a>:</h4>
<p>You can also use the <code>{foo := ... , bar := ...}</code> notation, although I've never used it with exists or and before</p>



<a name="176847041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847041">(Sep 28 2019 at 23:53)</a>:</h4>
<p><code>not not P -&gt; P</code> is the <code>by_contradiction</code>, right?</p>



<a name="176847042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847042">(Sep 28 2019 at 23:53)</a>:</h4>
<p>yes</p>



<a name="176847085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847085">(Sep 28 2019 at 23:54)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">foo</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">bar</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">baz</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="o">(</span><span class="n">erm</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span>

<span class="n">def</span> <span class="n">x</span> <span class="o">:</span> <span class="n">foo</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">7</span><span class="o">,</span> <span class="n">tt</span><span class="o">,</span> <span class="bp">-</span><span class="mi">5</span><span class="bp">⟩</span>
</pre></div>



<a name="176847091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847091">(Sep 28 2019 at 23:54)</a>:</h4>
<p>oh, my mistake, apparently <code>{}</code> structure notation only works with actual <code>structure</code>s, so <code>exists</code> doesn't permit it, although <code>and</code> does</p>



<a name="176847159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847159">(Sep 28 2019 at 23:56)</a>:</h4>
<p><code>exists</code> is so horrible for beginners. <code>#print notation ∃</code> gives garbage, and <code>#check exists</code> fails -- Lean wants another term so just looks at the next token and gives a confusing error.</p>



<a name="176847171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847171">(Sep 28 2019 at 23:57)</a>:</h4>
<p>You're best off just finding the definitions in core (if you can figure out how to get to them)</p>



<a name="176847220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847220">(Sep 28 2019 at 23:58)</a>:</h4>
<p>Now I am starting to make sense with negation and exists in tactics!! Tomorrow more exercises!! After months in the 'term-mode', it is taking time to flip my mind to the tactic-mode.</p>



<a name="176847221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847221">(Sep 28 2019 at 23:58)</a>:</h4>
<p>Try <code>#check Exists</code></p>



<a name="176847224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847224">(Sep 28 2019 at 23:59)</a>:</h4>
<p>Why is <code>Exists</code> an inductive type with one constructor and not a structure?</p>
<p>Wooah, and what does</p>
<div class="codehilite"><pre><span></span><span class="n">attribute</span> <span class="o">[</span><span class="n">intro</span><span class="o">]</span> <span class="n">Exists</span><span class="bp">.</span><span class="n">intro</span>
</pre></div>


<p>mean?</p>



<a name="176847235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847235">(Sep 28 2019 at 23:59)</a>:</h4>
<p>I know that <code>[intro]</code> (and <code>[intro!]</code>) exist, but I'm not sure what they do</p>



<a name="176847371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847371">(Sep 29 2019 at 00:02)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> what does <code>local attribute [instance] classical.prop_decidable</code> make?</p>



<a name="176847381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847381">(Sep 29 2019 at 00:03)</a>:</h4>
<p>it causes all instances of the form <code>[decidable p]</code> to be solvable</p>



<a name="176847384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847384">(Sep 29 2019 at 00:03)</a>:</h4>
<p>using the law of excluded middle</p>



<a name="176847390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847390">(Sep 29 2019 at 00:03)</a>:</h4>
<p>It just adds the <code>instance</code> tag to <code>classical.prop_decidable</code> meaning that the type class inference system can see it.</p>



<a name="176847500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847500">(Sep 29 2019 at 00:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> <code>[intro]</code> is used as part of the <code>back_chaining</code> tactic infrastructure</p>



<a name="176847513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847513">(Sep 29 2019 at 00:07)</a>:</h4>
<p>This was in core, right? So this is nothing to do with Scott's fancy tactics I guess. What is <code>back_chaining</code>?</p>



<a name="176847563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847563">(Sep 29 2019 at 00:09)</a>:</h4>
<p>That's a good question, I'm looking through tests and things to find out what it's for</p>



<a name="176847564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847564">(Sep 29 2019 at 00:09)</a>:</h4>
<p>well there you go, core has a file called <code>backward.lean</code>. Not one I'd ever looked at before.</p>



<a name="176847565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847565">(Sep 29 2019 at 00:09)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm"> Lean has a backward chaining tactic that can be configured using</span>
<span class="cm">   attributes. -/</span>
<span class="kn">open</span> <span class="n">list</span> <span class="n">tactic</span>

<span class="kn">universe</span> <span class="kn">variable</span> <span class="n">u</span>
<span class="kn">lemma</span> <span class="n">in_tail</span>  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span>        <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">b</span><span class="bp">::</span><span class="n">l</span>   <span class="o">:=</span> <span class="n">mem_cons_of_mem</span> <span class="bp">_</span>
<span class="kn">lemma</span> <span class="n">in_head</span>  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>                <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">a</span><span class="bp">::</span><span class="n">l</span>           <span class="o">:=</span> <span class="n">mem_cons_self</span> <span class="bp">_</span> <span class="bp">_</span>
<span class="kn">lemma</span> <span class="n">in_left</span>  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>   <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">l</span> <span class="bp">++</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">mem_append_left</span> <span class="bp">_</span>
<span class="kn">lemma</span> <span class="n">in_right</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>   <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">l</span> <span class="bp">++</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">mem_append_right</span> <span class="bp">_</span>

<span class="c">/-</span><span class="cm"> It is trivial to define mk_mem_list using backward chaining -/</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">intro</span><span class="o">]</span> <span class="n">in_tail</span> <span class="n">in_head</span> <span class="n">in_left</span> <span class="n">in_right</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">mk_mem_list</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">solve1</span> <span class="o">(</span><span class="n">back_chaining</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="o">[</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">]</span> <span class="bp">++</span> <span class="o">[</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">]</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">mk_mem_list</span>

<span class="kn">set_option</span> <span class="n">trace</span><span class="bp">.</span><span class="n">tactic</span><span class="bp">.</span><span class="n">back_chaining</span> <span class="n">true</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="o">[</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">]</span> <span class="bp">++</span> <span class="o">[</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">]</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">mk_mem_list</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="o">[</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">]</span> <span class="bp">++</span> <span class="o">[</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">c</span><span class="o">]</span> <span class="bp">++</span> <span class="o">[</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">]</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">mk_mem_list</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">a</span> <span class="err">∈</span> <span class="o">[</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">]</span> <span class="bp">++</span> <span class="n">b</span><span class="bp">::</span><span class="n">l</span> <span class="o">:=</span>
<span class="k">begin</span> <span class="n">intros</span><span class="o">,</span> <span class="n">mk_mem_list</span> <span class="kn">end</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">l₁</span> <span class="bp">→</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">b</span><span class="bp">::</span><span class="n">b</span><span class="bp">::</span><span class="n">c</span><span class="bp">::</span><span class="n">l₂</span> <span class="bp">++</span> <span class="n">b</span><span class="bp">::</span><span class="n">c</span><span class="bp">::</span><span class="n">l₁</span> <span class="bp">++</span> <span class="o">[</span><span class="n">c</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">]</span> <span class="o">:=</span>
<span class="k">begin</span> <span class="n">intros</span><span class="o">,</span> <span class="n">mk_mem_list</span> <span class="kn">end</span>
</pre></div>



<a name="176847572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847572">(Sep 29 2019 at 00:09)</a>:</h4>
<p>it looks a lot like <code>solve_by_elim</code></p>



<a name="176847681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847681">(Sep 29 2019 at 00:12)</a>:</h4>
<p>Interestingly it doesn't do definitional unfolding (the <code>a ∈ [b, c] ++ [b, a, b]</code> example fails without the <code>in_left</code> and <code>in_right</code> examples), which is probably a good thing</p>



<a name="176847732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847732">(Sep 29 2019 at 00:14)</a>:</h4>
<p>it actually works in some cases where one expects <code>solve_by_elim</code> to work, but doesn't</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">Hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">H₁</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">H₂</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">H₃</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">solve_by_elim</span> <span class="c1">-- fails</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">Hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">H₁</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">H₂</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">H₃</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">back_chaining_using_hs</span> <span class="c1">-- works</span>
</pre></div>



<a name="176847748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/tutorial%20about%20tactics%3F/near/176847748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/tutorial.20about.20tactics.3F.html#176847748">(Sep 29 2019 at 00:15)</a>:</h4>
<p>it has a lot of examples in the tests that look like that - lots of implication chains</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
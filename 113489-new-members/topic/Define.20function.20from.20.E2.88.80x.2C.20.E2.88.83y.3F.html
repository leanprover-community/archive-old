---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html">Define function from ∀x, ∃y?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="193598774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193598774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193598774">(Apr 10 2020 at 18:00)</a>:</h4>
<p>Suppose I have a theorem of the form:</p>
<div class="codehilite"><pre><span></span>constant P : X → Y → Prop
theorem existenceresult : ∀x:X, ∃y:Y, P x y := sorry
</pre></div>


<p>How can I define a function <code>f: X → Y</code> on the basis of <code>existenceresult</code>, such that <code>∀x:X, P x f(x)</code>?<br>
I've looked at the reference manual on the axiom of choice, but I can't actually see how to do this using Lean's choice.</p>



<a name="193598831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193598831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193598831">(Apr 10 2020 at 18:01)</a>:</h4>
<p>You can use the <code>choose</code> tactic: <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#choose" title="https://leanprover-community.github.io/mathlib_docs/tactics.html#choose">https://leanprover-community.github.io/mathlib_docs/tactics.html#choose</a></p>



<a name="193599007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193599007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193599007">(Apr 10 2020 at 18:02)</a>:</h4>
<p>Is there a way to do it without tactics? (I a tactic is just a command for Lean to search for a proof that doesn't contain tactics, isn't it?)</p>



<a name="193599232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193599232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193599232">(Apr 10 2020 at 18:05)</a>:</h4>
<p>There is, you can use <code>classical.some</code> to define the function, and <code>classical.some_spec</code> to prove it has the property you want.</p>



<a name="193599343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193599343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193599343">(Apr 10 2020 at 18:05)</a>:</h4>
<p>What you posted doesn't make sense right now, you have a theorem, but its conclusion isn't a Proposition.</p>



<a name="193599422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193599422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193599422">(Apr 10 2020 at 18:06)</a>:</h4>
<p>Also see <code>classical.choice</code></p>



<a name="193599434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193599434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193599434">(Apr 10 2020 at 18:06)</a>:</h4>
<p>Yeah sorry, typo.</p>



<a name="193599512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193599512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193599512">(Apr 10 2020 at 18:07)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hP</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">x</span><span class="o">:</span><span class="n">X</span><span class="o">,</span> <span class="bp">∃</span><span class="n">y</span><span class="o">:</span><span class="n">Y</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>

<span class="n">include</span> <span class="n">P</span> <span class="n">hP</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="o">(</span><span class="n">hP</span> <span class="n">x</span><span class="o">)</span>
</pre></div>



<a name="193599669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193599669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193599669">(Apr 10 2020 at 18:08)</a>:</h4>
<p>People around here get edgy about constants and axioms</p>



<a name="193599795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193599795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193599795">(Apr 10 2020 at 18:09)</a>:</h4>
<p>Oh, why is that ?</p>



<a name="193599804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193599804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193599804">(Apr 10 2020 at 18:09)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hP</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">x</span><span class="o">:</span><span class="n">X</span><span class="o">,</span> <span class="bp">∃</span><span class="n">y</span><span class="o">:</span><span class="n">Y</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>

<span class="n">include</span> <span class="n">P</span> <span class="n">hP</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="o">(</span><span class="n">hP</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="o">(</span><span class="n">f</span> <span class="n">P</span> <span class="n">hP</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="o">(</span><span class="n">hP</span> <span class="n">x</span><span class="o">)</span>
</pre></div>



<a name="193599881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193599881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193599881">(Apr 10 2020 at 18:10)</a>:</h4>
<p>Mathlib doesn't have any and we don't really see why we need any.</p>



<a name="193599907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193599907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193599907">(Apr 10 2020 at 18:10)</a>:</h4>
<p>But note that I just had to write <code>f P hP</code> instead of <code>f</code> :-)</p>



<a name="193599984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193599984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193599984">(Apr 10 2020 at 18:11)</a>:</h4>
<p>I think once someone told me that they were problematic in some other way, maybe something doesn't work very well with them, but I was a beginner at the time and probably didn't understand what they were talking about</p>



<a name="193600208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193600208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193600208">(Apr 10 2020 at 18:13)</a>:</h4>
<p>Why is <code>f P hP x</code> well formed? <code>f</code> takes an <code>X</code> but <code>P : X \to Y \to Prop</code>, and <code>P</code> can't take <code>hP</code> either right?</p>



<a name="193600284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193600284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193600284">(Apr 10 2020 at 18:14)</a>:</h4>
<p>I changed the brackets round X and Y to be the squiggly "Lean will fill these in using unification" brackets</p>



<a name="193600364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193600364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193600364">(Apr 10 2020 at 18:15)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">section</span>

<span class="kn">parameters</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hP</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">x</span><span class="o">:</span><span class="n">X</span><span class="o">,</span> <span class="bp">∃</span><span class="n">y</span><span class="o">:</span><span class="n">Y</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="o">(</span><span class="n">hP</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="o">(</span><span class="n">hP</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">end</span>
</pre></div>


<p>Here's another way which now looks beautiful</p>



<a name="193600472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193600472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193600472">(Apr 10 2020 at 18:16)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">section</span>

<span class="kn">parameters</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hP</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">x</span><span class="o">:</span><span class="n">X</span><span class="o">,</span> <span class="bp">∃</span><span class="n">y</span><span class="o">:</span><span class="n">Y</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="o">(</span><span class="n">hP</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="o">(</span><span class="n">hP</span> <span class="n">x</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">foo</span> <span class="c1">-- foo : ∀ (x : X), P x (f x)</span>

<span class="kn">end</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">foo</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">foo : ∀ (X Y : Type) (P : X → Y → Prop) (hP : ∀ (x : X), ∃ (y : Y), P x y)</span>
<span class="cm">  (x : X), P x (f X Y P hP x)</span>
<span class="cm">-/</span>
</pre></div>


<p>Inside the section the parameters are suppressed.</p>



<a name="193600565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193600565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193600565">(Apr 10 2020 at 18:17)</a>:</h4>
<p>I think there's some kind of "real Lean programmers don't use constants" thing going on, and I don't really know why, but I try and stick to the general principle of no constants and no axioms</p>



<a name="193602049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193602049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193602049">(Apr 10 2020 at 18:33)</a>:</h4>
<p><code>constant</code> is just another name for <code>axiom</code>, isn't it? So when you write <code>constant P : ...</code>, you're postulating the existence of such a <code>P</code> rather than stating a result about any such <code>P</code> (if they exist). The former is dangerous since you could postulate something that contradicts Lean's other axioms.</p>



<a name="193602198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193602198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193602198">(Apr 10 2020 at 18:34)</a>:</h4>
<p>The last couple of files make sense to me, thanks! I'm surprised though, after having just read about <code>{}</code> in the docs, that <code>f P hP x</code> works. I would have guessed that since <code>X,Y</code> are in <code>{}</code> brackets, but <code>P</code> and <code>hP</code> are not. I would have guessed that <code>f X Y x</code> would work, but it gives me "<em>can't synthesize placeholder</em>"</p>



<a name="193602306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193602306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193602306">(Apr 10 2020 at 18:35)</a>:</h4>
<p><span class="user-mention" data-user-id="256311">@Jannis Limperg</span>, is that different from assuming a <code>variable</code> that contradicts one of Lean's axioms?</p>



<a name="193602324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193602324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193602324">(Apr 10 2020 at 18:35)</a>:</h4>
<p>You're talking about before I switched to parameters? <code>{}</code> means "just leave this out completely, I'll guess what it is".</p>



<a name="193602407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193602407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193602407">(Apr 10 2020 at 18:36)</a>:</h4>
<p>So when Lean sees <code>f P hP x</code> it reads <code>f _ _ P hP x</code> and then has to guess what the missing things are, and this is easy: for things to typecheck, if you look at the type of P, the missing things must be X and Y</p>



<a name="193602482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193602482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193602482">(Apr 10 2020 at 18:37)</a>:</h4>
<p>The risk of using a constant is that you might be able to prove <code>false</code> outright. With a variable you can't, you can only prove "forall (something), false".</p>



<a name="193602514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193602514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193602514">(Apr 10 2020 at 18:37)</a>:</h4>
<p>and if you can't actually feed in an example of the something, which you can't if Lean is consistent, then you can't prove false.</p>



<a name="193602675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193602675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193602675">(Apr 10 2020 at 18:39)</a>:</h4>
<p>yeah, but since <code>P</code> and <code>hP</code> are NOT in <code>{}</code> but in <code>()</code>, I would guess that <code>f</code> would implicitly take the type <code>f: {X Y :Type} \to (X\to Y)</code>, so that <code>P</code> and <code>hP</code> can't be arguments.</p>



<a name="193602707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193602707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193602707">(Apr 10 2020 at 18:39)</a>:</h4>
<p>Oh that makes sense.</p>



<a name="193603053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193603053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193603053">(Apr 10 2020 at 18:42)</a>:</h4>
<p>Ok tomorrow I'll look at how to do it with classical.choice. Going to bed now, thanks a lot for the help!</p>



<a name="193603432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193603432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193603432">(Apr 10 2020 at 18:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284606">Chris M</span> <a href="#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193602306" title="#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193602306">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="256311">Jannis Limperg</span>, is that different from assuming a <code>variable</code> that contradicts one of Lean's axioms?</p>
</blockquote>
<p>Yes! Consider this example:</p>
<div class="codehilite"><pre><span></span><span class="kn">section</span>

<span class="kn">variable</span> <span class="n">FALSE</span> <span class="o">:</span> <span class="n">false</span>

<span class="kn">lemma</span> <span class="n">everything_is_true</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">false</span><span class="bp">.</span><span class="n">rec</span> <span class="bp">_</span> <span class="n">FALSE</span>

<span class="kn">end</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">everything_is_true</span>
<span class="c1">-- `everything_is_true` says: Under the assumption that we have something of</span>
<span class="c1">-- type `false`, we can prove anything.</span>

<span class="kn">lemma</span> <span class="n">zero_eq_one</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">everything_is_true</span><span class="o">,</span>
  <span class="c1">-- To apply everything_is_true, we need to exhibit something of type `false`,</span>
  <span class="c1">-- but thankfully there&#39;s no such thing.</span>
  <span class="n">sorry</span>
<span class="kn">end</span>


<span class="kn">constant</span> <span class="n">FALSE</span> <span class="o">:</span> <span class="n">false</span>

<span class="kn">lemma</span> <span class="n">everything_is_true&#39;</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">false</span><span class="bp">.</span><span class="n">rec</span> <span class="bp">_</span> <span class="n">FALSE</span>
<span class="c1">-- `everything_is_true&#39;` says: we can prove anything, no extra assumptions</span>
<span class="c1">-- needed. So now we&#39;re inconsistent.</span>

<span class="kn">lemma</span> <span class="n">zero_eq_one&#39;</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">everything_is_true&#39;</span>
<span class="kn">end</span>
</pre></div>



<a name="193604844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193604844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193604844">(Apr 10 2020 at 18:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193599669" title="#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193599669">said</a>:</p>
<blockquote>
<p>People around here get edgy about constants and axioms</p>
</blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193599984" title="#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193599984">said</a>:</p>
<blockquote>
<p>I think once someone told me that they were problematic in some other way, maybe something doesn't work very well with them, but I was a beginner at the time and probably didn't understand what they were talking about</p>
</blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193600565" title="#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193600565">said</a>:</p>
<blockquote>
<p>I think there's some kind of "real Lean programmers don't use constants" thing going on, and I don't really know why, but I try and stick to the general principle of no constants and no axioms</p>
</blockquote>
<p>Variables can be substituted. If you prove that "for any variable G, a group structure on G induces a semigroup structure on G", then you can use this "theorem" to deduce a semigroup structure on <code>units \Z</code>; but if you have a constant G, a constant group structure on G, and a theorem that G has a semigroup structure, then you're in effect introducing to the world of Lean a new constant G that exists per fiat, and you cannot substitute it with <code>units \Z</code></p>



<a name="193692849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193692849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193692849">(Apr 12 2020 at 04:01)</a>:</h4>
<p>Is it actually possible to define a function from ∀x, ∃y using <code>classical.choice</code>, instead of <code>classical.some</code>? I haven't heard of the <code>some</code> axiom in math, so it must be Lean-specific, and in math one would use choice for this.</p>



<a name="193693103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193693103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193693103">(Apr 12 2020 at 04:09)</a>:</h4>
<p>choice is a derived theorem from some more fundamental axioms assumed in Lean's classical library</p>



<a name="193693104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193693104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193693104">(Apr 12 2020 at 04:09)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">axiom_of_choice</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">β</span> <span class="n">x</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">β</span> <span class="n">x</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">some_spec</span> <span class="o">(</span><span class="n">h</span> <span class="n">x</span><span class="o">)</span><span class="bp">⟩</span>
</pre></div>



<a name="193693155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193693155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193693155">(Apr 12 2020 at 04:10)</a>:</h4>
<p>er, I mean, the axiom of choice you are familiar with is derived from classical.choice. <code>classical.some</code> is similarly</p>



<a name="193693201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193693201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193693201">(Apr 12 2020 at 04:12)</a>:</h4>
<p>if I remember correctly, old versions of Lean didn't even use <code>classical.choice</code>, it was all derived from</p>



<a name="193693202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193693202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193693202">(Apr 12 2020 at 04:12)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">axiom</span> <span class="n">strong_indefinite_description</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">//</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">x</span><span class="o">}</span>
</pre></div>



<a name="193693213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193693213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193693213">(Apr 12 2020 at 04:13)</a>:</h4>
<p>then at some point it got simplified because it was confusing people</p>



<a name="193693530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193693530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193693530">(Apr 12 2020 at 04:23)</a>:</h4>
<p>My first impression is that the problem with this is that we don't actually strictly speaking know that <code>strong_indefinite_description</code> is not stronger than choice? If we want to rigorously know that the <code>classical</code> axioms actually correspond to the classical axioms, then we should build <code>classical</code> from the same axioms that are used in mathematics?</p>



<a name="193693826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193693826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193693826">(Apr 12 2020 at 04:32)</a>:</h4>
<p>what is mathematics?</p>



<a name="193693827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193693827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193693827">(Apr 12 2020 at 04:33)</a>:</h4>
<p>ZFC set theory?</p>



<a name="193693836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193693836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193693836">(Apr 12 2020 at 04:33)</a>:</h4>
<p>but Lean's foundations are in the type theory, specifically the calculus of inductive constructions</p>



<a name="193693889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193693889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193693889">(Apr 12 2020 at 04:34)</a>:</h4>
<p>applying the axiom of choice as defined in set theory</p>



<a name="193693890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193693890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193693890">(Apr 12 2020 at 04:34)</a>:</h4>
<p>doesn't really make much sense</p>



<a name="193694012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193694012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193694012">(Apr 12 2020 at 04:39)</a>:</h4>
<p>I see</p>



<a name="193695252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193695252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193695252">(Apr 12 2020 at 05:18)</a>:</h4>
<p>In lean, it is easy to prove that <code>classical.choice</code> and <code>strong_indefinite_description</code> are equivalent in strength</p>



<a name="193695254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193695254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193695254">(Apr 12 2020 at 05:18)</a>:</h4>
<p>(actually the proof that <code>strong_indefinite_description</code> follows from <code>choice</code> is not entirely obvious since it requires Diaconescu's proof of EM first)</p>



<a name="193695263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193695263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193695263">(Apr 12 2020 at 05:19)</a>:</h4>
<p>As for whether they are equivalent to the axiom known as the "axiom of choice" in ZFC, this depends on some details of the foundational setup</p>



<a name="193695311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193695311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193695311">(Apr 12 2020 at 05:20)</a>:</h4>
<p>lean's <code>choice</code> is actually closer to Hilbert's epsilon operator, or a variant of AC called "global choice", because it posits a single class function that chooses elements simultaneously from every nonempty set</p>



<a name="193695324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193695324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193695324">(Apr 12 2020 at 05:21)</a>:</h4>
<p>The usual formulation of AC in ZFC puts the function that does the choosing behind an existential</p>



<a name="193695333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193695333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193695333">(Apr 12 2020 at 05:22)</a>:</h4>
<p>However, it is well known that this is a conservative extension; the general process is known as Skolemization</p>



<a name="193695439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193695439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193695439">(Apr 12 2020 at 05:24)</a>:</h4>
<p>In lean you actually can't prove <code>classical.choice</code> from the theorem <code>axiom_of_choice</code> mentioned above because of this</p>



<a name="193701164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193701164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193701164">(Apr 12 2020 at 08:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284606">Chris M</span> <a href="#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193692849" title="#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193692849">said</a>:</p>
<blockquote>
<p>Is it actually possible to define a function from ∀x, ∃y using <code>classical.choice</code>, instead of <code>classical.some</code>? I haven't heard of the <code>some</code> axiom in math, so it must be Lean-specific, and in math one would use choice for this.</p>
</blockquote>
<p><span class="user-mention" data-user-id="284606">@Chris M</span> here are two interesting uses of <code>some</code> in Lean. For the first one, consider the proof that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\to Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> is a surjection then there's an injection <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Y\to X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> which is a one-sided inverse. In Lean this construction is immediate using <code>some</code> -- you pick <code>y : Y</code> and then observe that we have a non-empty type of <code>x : X</code> to choose from and use <code>some</code> to pick one. In ZFC you would use choice for this. Here <code>choice</code> and <code>some</code> seem to be about the same.</p>
<p>For the second one, consider the proof that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\to Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> is a <em>bijection</em> then there's a bijection <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Y\to X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> which is a two-sided inverse. In Lean this construction is also made using <code>some</code> because even though we have a proof that the preimage contains exactly one term, the assertion has type <code>Prop</code>, whereas we need to move into the <code>Type</code> universe if we actually want the element. This whole <code>some</code> business can be thought of as a method of getting from Lean's proof-irrelevant <code>Prop</code> universe to the universe <code>Type</code> where data is remembered. The way <code>Prop</code> is modelled internally in Lean is that you can make a proof that the pre-image has exactly one element, but because this is in <code>Prop</code> the statement is just recorded by Lean as being proved, there is no information in the system as to what that element is and in particular there is no way of extracting it. This is a foundational issue where set theory and type theory seem to me to differ. Here when people talk about choice they often just mean the ability to move from <code>Prop</code> to <code>Type</code>. <code>some</code> is somehow the basic example of this.</p>



<a name="193745488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193745488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193745488">(Apr 13 2020 at 04:57)</a>:</h4>
<p>very interesting. I am actually surprised though that <code>Prop</code> doesn't record that data, i.e. that propositional extentionality is used as an axiom. To put it a different way, I'm surprised that Choice is considered a classical notion. It seems to me that, according to the constructivist notion of <code>$\exists$</code>, we only prove it once we have an example. Hence as soon as we've proven it, we do in fact have aconstructed example somewhere. Hence, shouldn't we be able to choose that example, without leaving constructivist logic? This argument basically makes me think that <code>$\exists$</code> should just be a tuple like <code>$\Sigma$</code>, i.e. that <code>$\exists$</code> should just be syntactic sugar for, but otherwise identical to, <code>$\Sigma$</code>, and that propositional extentionality shouldn't hold. I'm curious where people disagree with my view.</p>



<a name="193745604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193745604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193745604">(Apr 13 2020 at 05:01)</a>:</h4>
<p>This is the approach taken in more hardcore constructivist foundations like HoTT. There, there is no difference between Prop and Type</p>



<a name="193745646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193745646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193745646">(Apr 13 2020 at 05:02)</a>:</h4>
<p>although propositional extensionality still holds in HoTT, for a different reason</p>



<a name="193745661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193745661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193745661">(Apr 13 2020 at 05:03)</a>:</h4>
<p>In HoTT there is a version of choice that is trivial, and then there is another version that is equivalent to the mathematician's axiom of choice, which requires inserting propositional truncations to make the exists have this "forgetting" behavior</p>



<a name="193745705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193745705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193745705">(Apr 13 2020 at 05:04)</a>:</h4>
<p>In lean, the reason we care about having Prop around is <em>so that</em> we can forget about witnesses</p>



<a name="193745711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193745711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193745711">(Apr 13 2020 at 05:04)</a>:</h4>
<p>This has to do with the semantics behind VM computation and "proof erasure"</p>



<a name="193745733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193745733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193745733">(Apr 13 2020 at 05:05)</a>:</h4>
<p>proofs are generally not good for computation so it is nice to be able to forget about them in programs. Reflecting this back into the logic entails that proofs have to be irrelevant, and exists cannot record the witness that proved it</p>



<a name="193745799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193745799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193745799">(Apr 13 2020 at 05:07)</a>:</h4>
<p>If you want a proof relevant version of exists, you can use <code>\Sigma</code>, but it is a conscious decision you have to make. This gives you a little extra bit of expressive power</p>



<a name="193745870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193745870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193745870">(Apr 13 2020 at 05:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193745733" title="#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193745733">said</a>:</p>
<blockquote>
<p>proofs are generally not good for computation so it is nice to be able to forget about them in programs. Reflecting this back into the logic entails that proofs have to be irrelevant, and exists cannot record the witness that proved it</p>
</blockquote>
<p>What do you mean by "proofs are generally not good for computation"? In what sense?</p>



<a name="193746356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193746356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193746356">(Apr 13 2020 at 05:24)</a>:</h4>
<p>They represent pieces of code that have to be evaluated when the code is run; it can lead to large amounts of overhead and inefficiency</p>



<a name="193746777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193746777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193746777">(Apr 13 2020 at 05:36)</a>:</h4>
<p>If I have a vector of length <code>5</code>, say <code>[1,2,3,4,5]</code>, and want to turn it into a vector of length <code>3 + 2</code>, I can do so by applying a theorem that says that <code>3 + 2 = 5</code>. But there is no need to evaluate this proof (which boils down to <code>refl 5</code>) to get the resulting vector, because in memory the resulting vector has the exact same representation <code>[1,2,3,4,5]</code> so it is a no-op in the computer</p>



<a name="193746815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193746815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193746815">(Apr 13 2020 at 05:37)</a>:</h4>
<p>If equality is proof irrelevant, then this "cast" operation is always a no-op, and the computer can just skip the proof, even though it was provided and may very well be computable</p>



<a name="193746866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193746866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193746866">(Apr 13 2020 at 05:38)</a>:</h4>
<p>Here the proof is being used to ensure that the program does not go wrong, but it is not needed for the program to actually get to the end result</p>



<a name="193748285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193748285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193748285">(Apr 13 2020 at 06:23)</a>:</h4>
<p>My impression is that a proof NEVER has to be evaluated. So it seems to me that if Lean just has a general rule that says "never evaluate proofs", then there is no danger of inefficiency. I might have some kind of misconception though.</p>



<a name="193748875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193748875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193748875">(Apr 13 2020 at 06:40)</a>:</h4>
<p>What's your notion of "proof", then, for which they never have to be evaluated?<br>
It sounds like you are suggesting that <code>\exists</code> effectively shouldn't exist; but its purpose is precisely to be usable in this "proof" context.</p>



<a name="193748951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193748951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193748951">(Apr 13 2020 at 06:43)</a>:</h4>
<p>My notion of proof is basically, it's a program that could <em>in principle</em> be evaluated, but we are not actually interested in doing so, we are only interested in <em>type checking</em> it to see if it's correct. Once we know it's correct, we know the theorem is true, and that's all there is to it. No need to actually run the proof. Is that wrong?</p>



<a name="193749026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193749026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193749026">(Apr 13 2020 at 06:44)</a>:</h4>
<p>I'm not an expert in this area, but it sounds to me like this is right. Proofs are typechecked and then instantly forgotten</p>



<a name="193749029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193749029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193749029">(Apr 13 2020 at 06:45)</a>:</h4>
<p>Okay but if you want to extract a function from "∀x, ∃y", then you are actually interested in evaluating the "proof" after all, right?</p>



<a name="193749145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193749145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193749145">(Apr 13 2020 at 06:47)</a>:</h4>
<p>I mean, if you want to be able to evaluate the function, you'd better be able to figure out what <code>y</code> was used to construct the existential and that means evaluating the term of type <code>∃y, ...</code> (we can call it a proof or not).</p>



<a name="193749443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193749443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193749443">(Apr 13 2020 at 06:54)</a>:</h4>
<p>So, in Lean, we do have some things called "proofs" that are never evaluated, namely terms whose type is a proposition, and <code>∃y, P y</code> is a proposition. That means that from <code>h : ∀x, ∃y, P y</code>there is no way to extract the data of "the <code>y</code> for a given <code>x</code>" (or any other data for that matter) and so you need a nonconstructive axiom if you want to obtain a function. Other systems make different choices.</p>



<a name="193749525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193749525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193749525">(Apr 13 2020 at 06:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193749029" title="#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193749029">said</a>:</p>
<blockquote>
<p>Okay but if you want to extract a function from "∀x, ∃y", then you are actually interested in evaluating the "proof" after all, right?</p>
</blockquote>
<p>Well, it seems to me that I want to extract a function but again not actually evaluate that function. I just want to use it to construct further proofs, all of which won't ever be evaluated.</p>



<a name="193749532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193749532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193749532">(Apr 13 2020 at 06:56)</a>:</h4>
<p>Then that's precisely what <code>choice</code> is for</p>



<a name="193749615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193749615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193749615">(Apr 13 2020 at 06:58)</a>:</h4>
<p>But if we're saying "we know that there exists such a function, but we have no access to the function", then I don't see how it could be called constructive</p>



<a name="193750213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193750213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193750213">(Apr 13 2020 at 07:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284606">Chris M</span> <a href="#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193749525" title="#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193749525">said</a>:</p>
<blockquote>
<p>Well, it seems to me that I want to extract a function but again not actually evaluate that function. I just want to use it to construct further proofs, all of which won't ever be evaluated.</p>
</blockquote>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">P</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="c1">-- x is out!</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">1 goal</span>
<span class="cm">X : Type,</span>
<span class="cm">P : X → Prop,</span>
<span class="cm">x : X,</span>
<span class="cm">hx : P x</span>
<span class="cm">⊢ ∃ (x : X), P x ∧ P x</span>
<span class="cm">-/</span>
  <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">tauto</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>



<a name="193750222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193750222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193750222">(Apr 13 2020 at 07:17)</a>:</h4>
<p>You can get to the existential witness without choice if your goal is a proposition.</p>



<a name="193750288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193750288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193750288">(Apr 13 2020 at 07:18)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">|</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">P</span> <span class="n">x</span><span class="o">}</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">induction tactic failed, recursor &#39;Exists.dcases_on&#39; can only eliminate into Prop</span>
<span class="cm">-/</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p>but not if your goal is data.</p>



<a name="193753879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Define%20function%20from%20%E2%88%80x%2C%20%E2%88%83y%3F/near/193753879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F.html#193753879">(Apr 13 2020 at 08:34)</a>:</h4>
<p>I was surprised to see how well Lean can compute, so I just wanted to share this with you. In <a href="https://github.com/leanprover-community/mathlib/issues/2398" title="https://github.com/leanprover-community/mathlib/issues/2398">#2398</a>, I introduce compositions of an integer, i.e., ways to decompose <code>n</code> as a sum of positive integers, as</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">composition</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">blocks_pnat</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ+</span><span class="o">)</span>
<span class="o">(</span><span class="n">blocks_pnat_sum</span> <span class="o">:</span> <span class="o">(</span><span class="n">blocks_pnat</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ+</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)))</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span>
</pre></div>


<p>In the course of the file, I register an explicit equiv between <code>composition n</code> and <code>fin (n-1)</code>, to get that the cardinality of <code>composition n</code> is <code>2^(n-1)</code>. After this, Lean can check numerical stuff on compositions! For instance, if you want to check the number of compositions of 9 with length  4 in which the first term is 2, you can ask</p>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">eval</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">composition</span> <span class="mi">9</span> <span class="bp">//</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="mi">4</span><span class="o">),</span>
  <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">nth_le</span> <span class="n">s</span><span class="bp">.</span><span class="n">blocks</span> <span class="mi">3</span> <span class="o">(</span><span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">composition</span><span class="bp">.</span><span class="n">blocks_length</span><span class="o">,</span> <span class="n">h</span><span class="o">],</span> <span class="n">norm_num</span> <span class="o">}))</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">}</span>
</pre></div>


<p>It works, and answers 15 (I didn't check this is the right answer, but I hope we can trust Lean :). What surprises me is that there is a proof in the definition of the set, needed to show that the set makes sense, but this is not a problem at all for the computation.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
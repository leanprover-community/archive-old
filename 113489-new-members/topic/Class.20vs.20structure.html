---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Class.20vs.20structure.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Class.20vs.20structure.html">Class vs structure</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="242515575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Class%20vs%20structure/near/242515575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Class.20vs.20structure.html#242515575">(Jun 13 2021 at 15:08)</a>:</h4>
<p>What is the convention in mathlib for choosing between using <code>structure</code> and <code>class</code> when defining, say, a group? If i understand correctly <code>class</code> is just syntax for <code>structure</code></p>



<a name="242515852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Class%20vs%20structure/near/242515852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Class.20vs.20structure.html#242515852">(Jun 13 2021 at 15:14)</a>:</h4>
<p>As far as I understand, a <code>class</code> is a <code>structure</code> that you can assume in square brackets, e.g <code>[my_class X]</code>, signaling Lean that it should find that assumption when you call that lemma, instead of having to provide it yourself.</p>



<a name="242516091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Class%20vs%20structure/near/242516091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Class.20vs.20structure.html#242516091">(Jun 13 2021 at 15:19)</a>:</h4>
<p>oh so <code>@[class]</code> tells lean to internalise any <code>instance</code> of the <code>class</code> so we don't have to write out what the lemma proving the <code>instance</code> was called</p>



<a name="242516149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Class%20vs%20structure/near/242516149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Class.20vs.20structure.html#242516149">(Jun 13 2021 at 15:20)</a>:</h4>
<p>There's a longer discussion in chapter 10 of <a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a>: <a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html</a></p>



<a name="242520972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Class%20vs%20structure/near/242520972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Class.20vs.20structure.html#242520972">(Jun 13 2021 at 17:18)</a>:</h4>
<p>One big difference between class and structure is that classes are used in situations where most of the time you expect only one instance per class, and structures are used when there might normally be several instances. For example <code>group G</code>(the type of group structures on G)  is a class because given a set/type G which is going to be a group, one would in general expect there to be only one group structure on G. On the other hand <code>subgroup G</code> (the type of subgroups of G) is a structure not a class, because in general it's completely reasonable to expect there to be more than one subgroup of G showing up in an argument, so you don't want to pick a "special" one.</p>



<a name="242550180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Class%20vs%20structure/near/242550180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Class.20vs.20structure.html#242550180">(Jun 14 2021 at 04:25)</a>:</h4>
<p>Along the lines of what Kevin is saying, something that classes implement is the way we use synecdoche in mathematics.  Synecdoche is a figure of speech where a part stands for the whole (like "nice wheels" to compliment someone's car) or vice versa.  When we say "let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> be a group" we treat <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> as if it were its underlying set, even though a group is actually a structure that includes the set.  This is convenient because we can, for example, seamlessly treat <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> as if it were a monoid, too, even though that's a different structure, because we can infer the intended structure.  So, to implement this, we can translate "let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> be a group" to "let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> be a type that 'is' a group," where 'is' means "has an associated instance" (in code: <code>(G : Type*) [group G]</code>).  This way, we refer to a group by its underlying type, and Lean fills in the rest.</p>
<p>By the way, you can make other things classes, not just structures.  For example, here is an ill-advised thing that's possible:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">attribute</span> <span class="o">[</span><span class="kd">class</span><span class="o">]</span> <span class="n">nat</span>

<span class="kd">instance</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="mi">37</span>

<span class="kd">def</span> <span class="n">bar</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">]</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">h</span>

<span class="k">#reduce</span> <span class="n">bar</span>
<span class="c1">-- results in 37</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
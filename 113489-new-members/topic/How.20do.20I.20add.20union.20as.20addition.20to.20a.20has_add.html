---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html">How do I add union as addition to a has_add</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="219682020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219682020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219682020">(Dec 12 2020 at 01:34)</a>:</h4>
<p>I'm trying to make a <code>has_add</code> instance on a <code>finset</code> where addition is defined as set union.  I know the set union operation exists because I checked it.  Lean is kicking it back:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.defs</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>

<span class="kd">def</span> <span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">X</span> <span class="c1">-- X : set ℕ</span>
<span class="k">#check</span> <span class="n">X</span> <span class="bp">∪</span> <span class="n">X</span> <span class="c1">-- X ∪ X : set ℕ</span>

<span class="kd">instance</span> <span class="n">X_has_add1</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∪</span> <span class="n">y</span> <span class="o">⟩</span>
</code></pre></div>
<p>with error message</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">X</span>
<span class="bp">⊢</span> <span class="n">has_union</span> <span class="bp">↥</span><span class="n">X</span>
</code></pre></div>
<p>How do I do this right?  I'm trying to show that <code>{1,2,3}</code> is an <code>add_semigroup</code> and this is step 1.</p>



<a name="219682140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219682140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219682140">(Dec 12 2020 at 01:37)</a>:</h4>
<p>You want to define the instance on finsets, not on elements of a particular finset <code>X</code>. So you want to show</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>



<a name="219688894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219688894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219688894">(Dec 12 2020 at 04:21)</a>:</h4>
<p>This is easy:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span> <span class="n">finset</span> <span class="n">ℕ</span>  <span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∪</span> <span class="n">y</span> <span class="o">⟩</span>
</code></pre></div>
<p>But what I want to do is:</p>
<ul>
<li>Define a finite set <code>X={1,2,3}</code> as a type so that if I say <code>a : X</code> then <code>a</code> can only take on values 1, 2 or 3.</li>
<li>Define the power set <code>𝒫 X</code> as a type, with a union operation</li>
<li>Use the union operation as addition in <code>has_add (𝒫 X)</code>.</li>
</ul>
<p>... or the equivalent, but the idea is sets of subsets of <code>{1,2,3}</code>.  This is my first crack at it but it doesn't work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span> <span class="n">finset</span> <span class="n">ℕ</span>  <span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∪</span> <span class="n">y</span> <span class="o">⟩</span>

<span class="kd">def</span> <span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="k">#check</span> <span class="n">X</span> <span class="c1">-- X : set ℕ</span>
<span class="k">#reduce</span> <span class="n">X</span> <span class="c1">-- λ (x : ℕ), x = 1 ∨ x = 2 ∨ x = 3 ∨ false</span>

<span class="kd">def</span> <span class="n">A</span> <span class="o">:=</span> <span class="bp">𝒫</span> <span class="n">X</span>
<span class="k">#check</span> <span class="n">A</span> <span class="c1">-- A : set (set ℕ)</span>
<span class="k">#reduce</span> <span class="n">A</span> <span class="c1">-- λ (t : ℕ → Prop), ∀ ⦃a : ℕ⦄, t a → a = 1 ∨ a = 2 ∨ a = 3 ∨ false</span>

<span class="kd">def</span> <span class="n">plus</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="c1">-- FAIL</span>
<span class="c">/-</span><span class="cm"> function expected at</span>
<span class="cm">  x</span>
<span class="cm">term has type</span>
<span class="cm">  {x // x ∈ A} -/</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="n">plus</span> <span class="o">⟩</span>
</code></pre></div>



<a name="219691035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219691035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219691035">(Dec 12 2020 at 05:16)</a>:</h4>
<p>The standard explicit finite set type is <a href="https://leanprover-community.github.io/mathlib_docs/find/fin">docs#fin</a> with <code>fin n</code> being the subtype of natural numbers below <code>n</code>.</p>



<a name="219691124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219691124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219691124">(Dec 12 2020 at 05:19)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="n">fin</span> <span class="mi">3</span>
<span class="k">#reduce</span> <span class="n">fin</span> <span class="mi">3</span>

<span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">set</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span>
<span class="k">#check</span> <span class="n">A</span>
<span class="k">#reduce</span> <span class="n">A</span>

<span class="kd">def</span> <span class="n">plus</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">∪</span> <span class="n">y</span>
</code></pre></div>
<p>might be what you're looking for</p>



<a name="219691206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219691206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219691206">(Dec 12 2020 at 05:20)</a>:</h4>
<p>In this situation it might be best not to define types with names to be explicit things, I had to add the <code>reducible</code> attribute here so that lean still knows how to define a union of terms of type A.</p>



<a name="219691217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219691217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219691217">(Dec 12 2020 at 05:20)</a>:</h4>
<p>I.e. rather than writing <code>def plus (x y : A) := x ∪ y</code> write <code>def plus (x y : set (fin 3)) := x ∪ y</code> if you're playing around with things.</p>



<a name="219693261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219693261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219693261">(Dec 12 2020 at 06:23)</a>:</h4>
<p>In that case you want <code>instance : has_add (set X) := ...</code> (which is equally easy to define, and uses nothing special about <code>X</code>).<br>
I also agree with everything Alex said, though if you just want some example code, your <code>X</code> would work fine as well.</p>



<a name="219693310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219693310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219693310">(Dec 12 2020 at 06:24)</a>:</h4>
<p>Here is a code snippet that works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span> <span class="n">finset</span> <span class="n">ℕ</span>  <span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∪</span> <span class="n">y</span> <span class="o">⟩</span>

<span class="kd">def</span> <span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="k">#check</span> <span class="n">X</span> <span class="c1">-- X : set ℕ</span>
<span class="k">#reduce</span> <span class="n">X</span> <span class="c1">-- λ (x : ℕ), x = 1 ∨ x = 2 ∨ x = 3 ∨ false</span>

<span class="kd">def</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">set</span> <span class="n">X</span>
<span class="k">#check</span> <span class="n">A</span> <span class="c1">-- A : set (set ℕ)</span>
<span class="k">#reduce</span> <span class="n">A</span> <span class="c1">-- λ (t : ℕ → Prop), ∀ ⦃a : ℕ⦄, t a → a = 1 ∨ a = 2 ∨ a = 3 ∨ false</span>

<span class="kd">def</span> <span class="n">plus</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∪</span> <span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">set.union</span> <span class="n">x</span> <span class="n">y</span> <span class="c1">-- alternative</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="n">plus</span> <span class="o">⟩</span>
</code></pre></div>
<p>However, I <em>strongly</em> encourage you to not define <code>A</code> (or define it as local notation or something), and just use <code>set X</code> instead.</p>



<a name="219711099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219711099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219711099">(Dec 12 2020 at 14:27)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="111080">@Floris van Doorn</span>  and <span class="user-mention" data-user-id="127136">@Alex J. Best</span>.  For self-training I am trying fill out a bunch of these intermediary concepts with countable and concrete finite examples.  This really helps me get started on the concrete finite ones.  I got this far and then I got stuck on the case above:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.defs</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kn">import</span> <span class="n">data.nat.basic</span>

<span class="kd">instance</span> <span class="n">X_is_nontrivial</span> <span class="o">:</span> <span class="n">nontrivial</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="n">fin.nontrivial</span>
<span class="k">#check</span> <span class="n">X_is_nontrivial</span> <span class="c1">--X_is_nontrivial : nontrivial X</span>

<span class="kd">instance</span> <span class="n">X_has_add</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">):=</span> <span class="n">fin.has_add</span>
<span class="k">#check</span> <span class="n">X_has_add</span> <span class="c1">-- X_has_add : has_add X</span>

<span class="kd">instance</span> <span class="n">X_has_add_semigroup</span> <span class="o">:</span> <span class="n">add_semigroup</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">nat.add_semigroup</span>
<span class="k">#check</span> <span class="n">X_has_add_semigroup</span> <span class="c1">-- X_has_add_semigroup : add_semigroup X</span>
</code></pre></div>
<p>where the whole homework is:<br>
<a href="/user_uploads/3121/F-zhI-5llQhznVYG7R6Ivq7L/Screenshot-from-2020-12-12-09-15-45.png">Screenshot-from-2020-12-12-09-15-45.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/F-zhI-5llQhznVYG7R6Ivq7L/Screenshot-from-2020-12-12-09-15-45.png" title="Screenshot-from-2020-12-12-09-15-45.png"><img src="/user_uploads/3121/F-zhI-5llQhznVYG7R6Ivq7L/Screenshot-from-2020-12-12-09-15-45.png"></a></div>



<a name="219712417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219712417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219712417">(Dec 12 2020 at 15:03)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.defs</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kn">import</span> <span class="n">data.nat.basic</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">nontrivial</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">):=</span> <span class="kd">by</span> <span class="n">apply_instance</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">add_semigroup</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>
<p>The point of the type class inference framework is that the end user shouldn't have to worry about what these instances are called or where they are. Lean will fill in the "square bracket inputs" to functions automatically. Your <code>#check</code> outputs aren't the same as mine, I don't know what X is, but this is the reason why <code>def X := fin 3</code> might be a bad idea -- because then <code>apply_instance</code> won't work any more when applied to X and you have to unfold the definition to get it working again.</p>



<a name="219712487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219712487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219712487">(Dec 12 2020 at 15:04)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.defs</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kn">import</span> <span class="n">data.nat.basic</span>

<span class="kd">@[derive nontrivial]</span> <span class="kd">def</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">fin</span> <span class="mi">3</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">nontrivial</span> <span class="n">X</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">X</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">unfold</span> <span class="n">X</span><span class="bp">;</span> <span class="n">apply_instance</span> <span class="c1">-- apply_instance by itself won't work</span>
</code></pre></div>



<a name="219714135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219714135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219714135">(Dec 12 2020 at 15:45)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>.  I will replace my uses of <code>instance</code> with <code>lemma</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.defs</span>
<span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kd">lemma</span> <span class="n">X_add_semigroup</span> <span class="o">:</span> <span class="n">add_semigroup</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">nat.add_semigroup</span>
<span class="k">#check</span> <span class="n">X_add_semigroup</span> <span class="c1">-- X_has_add_semigroup : add_semigroup ℕ</span>
</code></pre></div>
<p>I like being able to <code>#check </code> the result because it gives me a little extra positive feedback.  </p>
<p>For <code>fin 3</code>, even though it <code>has_add</code>, it doesn't appear to be an <code>add_semigroup</code>. This fails:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kd">lemma</span> <span class="n">fin3_has_add</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span> <span class="c1">-- OK</span>
<span class="kd">instance</span> <span class="n">fin3_add_semigroup</span> <span class="o">:</span> <span class="n">add_semigroup</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span> <span class="c1">-- FAIL</span>
</code></pre></div>
<p>with error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">tactic.mk_instance</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">generate</span> <span class="kd">instance</span> <span class="n">for</span>
  <span class="n">add_semigroup</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">state</span><span class="o">:</span>
<span class="bp">⊢</span> <span class="n">add_semigroup</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span>
</code></pre></div>
<p>Tactic <code>library_search!</code> also fails.</p>
<p>I tried a slightly different route:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">plus</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∪</span> <span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>
<span class="kd">lemma</span> <span class="n">X_has_add</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="n">plus</span> <span class="o">⟩</span>
<span class="k">#check</span> <span class="n">X_has_add</span> <span class="o">:</span> <span class="n">X_has_add</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">set</span> <span class="bp">↥</span><span class="n">X</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">X_add_semigroup</span><span class="o">:</span> <span class="n">add_semigroup</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="n">plus</span> <span class="o">⟩</span>
</code></pre></div>
<p>this also fails, with error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span><span class="o">,</span> <span class="n">term</span>
  <span class="n">add_semigroup.mk</span> <span class="n">plus</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">↥</span><span class="n">X</span><span class="o">),</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">))</span> <span class="bp">→</span> <span class="n">add_semigroup</span> <span class="o">(</span><span class="n">set</span> <span class="bp">↥</span><span class="n">X</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">add_semigroup</span> <span class="o">(</span><span class="n">set</span> <span class="bp">↥</span><span class="n">X</span><span class="o">)</span>
</code></pre></div>
<p>So now I'm confused again.  <code>∪</code> on sets should give me <code>add_semigroup</code>.  Should I be working with power sets?  That's where I started at the beginning of this thread.  But this also fails with a similar error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span> <span class="n">finset</span> <span class="n">ℕ</span>  <span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∪</span> <span class="n">y</span> <span class="o">⟩</span>
<span class="kd">def</span> <span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">set</span> <span class="n">X</span>
<span class="kd">def</span> <span class="n">plus</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∪</span> <span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">set.union</span> <span class="n">x</span> <span class="n">y</span> <span class="c1">-- alternative</span>
<span class="kd">lemma</span> <span class="n">A_has_add</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="n">plus</span> <span class="o">⟩</span> <span class="c1">-- OK</span>
<span class="kd">lemma</span> <span class="n">A_add_semigroup</span> <span class="o">:</span> <span class="n">add_semigroup</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="n">plus</span> <span class="o">⟩</span> <span class="c1">-- ERROR</span>
</code></pre></div>
<p>namely</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span><span class="o">,</span> <span class="n">term</span>
  <span class="n">add_semigroup.mk</span> <span class="n">plus</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">))</span> <span class="bp">→</span> <span class="n">add_semigroup</span> <span class="n">A</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">add_semigroup</span> <span class="n">A</span>
</code></pre></div>
<p>If I take the <code>def A</code> out, I still get an error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span> <span class="n">finset</span> <span class="n">ℕ</span>  <span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∪</span> <span class="n">y</span> <span class="o">⟩</span>

<span class="kd">def</span> <span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">plus</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∪</span> <span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">set.union</span> <span class="n">x</span> <span class="n">y</span> <span class="c1">-- alternative</span>

<span class="kd">lemma</span> <span class="n">A_has_add</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="n">plus</span> <span class="o">⟩</span> <span class="c1">-- OK</span>

<span class="kd">lemma</span> <span class="n">A_add_semigroup</span> <span class="o">:</span> <span class="n">add_semigroup</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="n">plus</span> <span class="o">⟩</span> <span class="c1">-- ERROR</span>
</code></pre></div>
<p>of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span><span class="o">,</span> <span class="n">term</span>
  <span class="n">add_semigroup.mk</span> <span class="n">plus</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">↥</span><span class="n">X</span><span class="o">),</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">))</span> <span class="bp">→</span> <span class="n">add_semigroup</span> <span class="o">(</span><span class="n">set</span> <span class="bp">↥</span><span class="n">X</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">add_semigroup</span> <span class="o">(</span><span class="n">set</span> <span class="bp">↥</span><span class="n">X</span><span class="o">)</span>
</code></pre></div>
<p>I'm stuck.</p>



<a name="219714687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219714687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219714687">(Dec 12 2020 at 16:01)</a>:</h4>
<p>You shouldn't call them lemmas, the instances contain data and if you call them lemmas then the data will be forgotten and things will break</p>



<a name="219714808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219714808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219714808">(Dec 12 2020 at 16:03)</a>:</h4>
<p>I can scope it out a little bit like this (which makes this a pretty good exercise):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span> <span class="n">finset</span> <span class="n">ℕ</span>  <span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∪</span> <span class="n">y</span> <span class="o">⟩</span>

<span class="kd">def</span> <span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">plus</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∪</span> <span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">set123_has_add</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="n">plus</span> <span class="o">⟩</span> <span class="c1">-- OK</span>

<span class="kd">lemma</span> <span class="n">set123_add_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">sup_assoc</span><span class="o">,</span> <span class="c1">-- FAIL</span>
<span class="kd">end</span>

<span class="kd">instance</span> <span class="n">A_add_semigroup</span> <span class="o">:</span> <span class="n">add_semigroup</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">add</span> <span class="o">:=</span> <span class="n">plus</span><span class="o">,</span>
  <span class="n">add_assoc</span> <span class="o">:=</span> <span class="n">set123_add_assoc</span>
<span class="o">}</span>
</code></pre></div>
<p>the <code>exact sup_assoc</code> came from <code>library_search!</code>.  It fails, but gives a clue maybe as to a sub-lemma to prove (modelled after <code>sup_assoc</code>):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">type</span> <span class="n">ascription</span><span class="o">,</span> <span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m_3</span> <span class="bp">⊔</span> <span class="bp">?</span><span class="n">m_4</span> <span class="bp">⊔</span> <span class="bp">?</span><span class="n">m_5</span> <span class="bp">=</span> <span class="bp">?</span><span class="n">m_3</span> <span class="bp">⊔</span> <span class="o">(</span><span class="bp">?</span><span class="n">m_4</span> <span class="bp">⊔</span> <span class="bp">?</span><span class="n">m_5</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">↥</span><span class="n">X</span><span class="o">),</span> <span class="n">h1</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">h1</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">h1</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">↥</span><span class="n">X</span>
<span class="bp">⊢</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">↥</span><span class="n">X</span><span class="o">),</span> <span class="n">h1</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">h1</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>
</code></pre></div>



<a name="219714861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219714861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219714861">(Dec 12 2020 at 16:04)</a>:</h4>
<p>Do you understand the error message? It gives you enough information about how to try and fix it.</p>



<a name="219714865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219714865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219714865">(Dec 12 2020 at 16:04)</a>:</h4>
<p>It seems like I will have to copy all the <code>sup_assoc</code> machinery and textually replace the <code>⊔</code> with a <code>∪</code>, is that correct?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">sup_assoc</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">⊔</span> <span class="n">b</span> <span class="bp">⊔</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">⊔</span> <span class="o">(</span><span class="n">b</span> <span class="bp">⊔</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">le_antisymm</span>
  <span class="o">(</span><span class="n">sup_le</span>
    <span class="o">(</span><span class="n">sup_le</span> <span class="n">le_sup_left</span> <span class="o">(</span><span class="n">le_sup_right_of_le</span> <span class="n">le_sup_left</span><span class="o">))</span>
    <span class="o">(</span><span class="n">le_sup_right_of_le</span> <span class="n">le_sup_right</span><span class="o">))</span>
  <span class="o">(</span><span class="n">sup_le</span>
    <span class="o">(</span><span class="n">le_sup_left_of_le</span> <span class="n">le_sup_left</span><span class="o">)</span>
    <span class="o">(</span><span class="n">sup_le</span> <span class="o">(</span><span class="n">le_sup_left_of_le</span> <span class="n">le_sup_right</span><span class="o">)</span> <span class="n">le_sup_right</span><span class="o">))</span>
</code></pre></div>



<a name="219714880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219714880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219714880">(Dec 12 2020 at 16:05)</a>:</h4>
<p>I.e. prove all the <code>sup_assoc</code> theorems and supporting lemmas in a union context.</p>



<a name="219714884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219714884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219714884">(Dec 12 2020 at 16:05)</a>:</h4>
<p>All these questions you're asking -- all the errors you're posting are of the form "Lean expected a term of type X and you gave it a term of a completely different type". The errors are telling you what you did wrong.</p>



<a name="219714934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219714934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219714934">(Dec 12 2020 at 16:06)</a>:</h4>
<p>I have to prove set union is associative, is the clue.</p>



<a name="219714944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219714944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219714944">(Dec 12 2020 at 16:07)</a>:</h4>
<p>you have to read the error messages</p>



<a name="219714999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219714999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219714999">(Dec 12 2020 at 16:08)</a>:</h4>
<p>That is, <code>library_search!</code> seems to be looking for something that fits the bill, but I don't know in Lean how to instantiate ⊔ with ∪.  I am not willfully ignoring the error messages, I am trying to figure out why <code>library_search!</code> took me here and what I need to do next.  Naively, it's a copy and replace of all of <code>sup_assoc</code>.</p>



<a name="219715019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219715019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219715019">(Dec 12 2020 at 16:09)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">type</span> <span class="n">ascription</span><span class="o">,</span> <span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m_3</span> <span class="bp">⊔</span> <span class="bp">?</span><span class="n">m_4</span> <span class="bp">⊔</span> <span class="bp">?</span><span class="n">m_5</span> <span class="bp">=</span> <span class="bp">?</span><span class="n">m_3</span> <span class="bp">⊔</span> <span class="o">(</span><span class="bp">?</span><span class="n">m_4</span> <span class="bp">⊔</span> <span class="bp">?</span><span class="n">m_5</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">↥</span><span class="n">X</span><span class="o">),</span> <span class="n">h1</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">h1</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">h1</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">↥</span><span class="n">X</span>
<span class="bp">⊢</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">↥</span><span class="n">X</span><span class="o">),</span> <span class="n">h1</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">h1</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>
</code></pre></div>
<p>says "the term you gave me does not start with "for all" but the term I want starts with "for all".</p>



<a name="219715078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219715078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219715078">(Dec 12 2020 at 16:10)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span><span class="o">,</span> <span class="n">term</span>
  <span class="n">add_semigroup.mk</span> <span class="n">plus</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">↥</span><span class="n">X</span><span class="o">),</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">))</span> <span class="bp">→</span> <span class="n">add_semigroup</span> <span class="o">(</span><span class="n">set</span> <span class="bp">↥</span><span class="n">X</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">add_semigroup</span> <span class="o">(</span><span class="n">set</span> <span class="bp">↥</span><span class="n">X</span><span class="o">)</span>
</code></pre></div>
<p>says "the term you gave me is of the form X -&gt; Y but I was expecting a term of type Y"</p>



<a name="219715089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219715089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219715089">(Dec 12 2020 at 16:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add/near/219714944">said</a>:</p>
<blockquote>
<p>you have to read the error messages</p>
</blockquote>
<p><span class="user-mention" data-user-id="364351">@Lars Ericson</span> I get this sort of error messages <em>all the time</em>. And they help me figure out my next step.<br>
Learning how to read these error messages is <em>not hard</em> and crucial for a happy Lean experience.</p>



<a name="219715110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219715110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219715110">(Dec 12 2020 at 16:11)</a>:</h4>
<p>Basically, these particular error messages are telling you: hey, your answer is almost right, but not quite. If you change it a little bit, I'll be happy.</p>



<a name="219715151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219715151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219715151">(Dec 12 2020 at 16:12)</a>:</h4>
<p>And it gives you very good clues about how you need to change your code.</p>



<a name="219715153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219715153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219715153">(Dec 12 2020 at 16:12)</a>:</h4>
<p>Thank you.  I didn't know how to fix the → message which is why I broke down the problem more.  When I looked at the  ⊔ message I saw the  ⊔ versus + and didn't focus on the  ∀.  I will focus on the  ∀.</p>



<a name="219715162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219715162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219715162">(Dec 12 2020 at 16:12)</a>:</h4>
<p>Those messages are of the form</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">you</span> <span class="n">gave</span> <span class="n">me</span>
  <span class="n">X</span>
<span class="n">I</span> <span class="n">am</span> <span class="n">expecting</span>
  <span class="n">Y</span>
</code></pre></div>



<a name="219715170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219715170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219715170">(Dec 12 2020 at 16:13)</a>:</h4>
<p>It is very important that you compare <code>X</code> and <code>Y</code>.</p>



<a name="219715175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219715175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219715175">(Dec 12 2020 at 16:13)</a>:</h4>
<p><code>⊔</code> and <code>+</code> are probably definitionally the same in your situation.</p>



<a name="219715360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219715360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219715360">(Dec 12 2020 at 16:18)</a>:</h4>
<p>If you give it a term of type X and it was expecting a term of type Y, and X and Y are definitionally equal, this will be fine.</p>



<a name="219716710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219716710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219716710">(Dec 12 2020 at 16:51)</a>:</h4>
<p><code>#print notation</code> tells me that</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">_</span> <span class="bp">`⊔`</span><span class="o">:</span><span class="mi">65</span> <span class="n">_</span><span class="o">:</span><span class="mi">65</span> <span class="o">:=</span> <span class="n">has_sup.sup</span>
<span class="n">_</span> <span class="bp">`+`</span><span class="o">:</span><span class="mi">65</span> <span class="n">_</span><span class="o">:</span><span class="mi">65</span> <span class="o">:=</span> <span class="n">has_add.add</span>
</code></pre></div>
<p>Knowing a little now about <code>mathlib</code> naming conventions, this tells me that I should instead be using <a href="https://leanprover-community.github.io/mathlib_docs/algebra/group/defs.html#add_assoc"><code>add_assoc</code></a>.  If the proofs of <code>add_assoc</code> and <code>sup_assoc</code> are identical up to notation, maybe there is some code factoring that could be done to make one theorem apply to both notations. There is a proof for <code>sup_assoc</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">sup_assoc</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">⊔</span> <span class="n">b</span> <span class="bp">⊔</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">⊔</span> <span class="o">(</span><span class="n">b</span> <span class="bp">⊔</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">le_antisymm</span>
  <span class="o">(</span><span class="n">sup_le</span>
    <span class="o">(</span><span class="n">sup_le</span> <span class="n">le_sup_left</span> <span class="o">(</span><span class="n">le_sup_right_of_le</span> <span class="n">le_sup_left</span><span class="o">))</span>
    <span class="o">(</span><span class="n">le_sup_right_of_le</span> <span class="n">le_sup_right</span><span class="o">))</span>
  <span class="o">(</span><span class="n">sup_le</span>
    <span class="o">(</span><span class="n">le_sup_left_of_le</span> <span class="n">le_sup_left</span><span class="o">)</span>
    <span class="o">(</span><span class="n">sup_le</span> <span class="o">(</span><span class="n">le_sup_left_of_le</span> <span class="n">le_sup_right</span><span class="o">)</span> <span class="n">le_sup_right</span><span class="o">))</span>
</code></pre></div>
<p>The definition of <code>add_assoc</code> is a little more mysterious. It shows as a theorem in the docs:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">add_assoc</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">add_semigroup</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>
</code></pre></div>
<p>but the source is hard to interpret.  This is the only thing I see in <a href="https://github.com/leanprover-community/mathlib/blob/3afdf41fbbe6eb77bce52ea733d1386184552aed/src/algebra/group/defs.lean#L76">the file</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">attribute</span> <span class="o">[</span><span class="n">no_rsimp</span><span class="o">]</span> <span class="n">add_assoc</span> <span class="c1">-- TODO(Mario): find out why this isn't copying</span>
</code></pre></div>
<p>Game theory has it's <a href="https://github.com/leanprover-community/mathlib/blob/3afdf41fbbe6eb77bce52ea733d1386184552aed/src/set_theory/game.lean#L81">own definition</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">add_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">game</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">+</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">x</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">y</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">z</span><span class="o">⟩,</span>
  <span class="n">apply</span> <span class="n">quot.sound</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">add_assoc_equiv</span>
<span class="kd">end</span>
</code></pre></div>
<p>This is fairly compact (unlike the sup definition which relies on a lot of lemmas), so maybe I can just copy this one over and give it a try, if <code>add_assoc</code> on it's own doesn't work.</p>
<p>And actually this comes a lot closer:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span> <span class="n">finset</span> <span class="n">ℕ</span>  <span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∪</span> <span class="n">y</span> <span class="o">⟩</span>

<span class="kd">def</span> <span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">plus</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∪</span> <span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">X_has_add</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="n">plus</span> <span class="o">⟩</span> <span class="c1">-- OK</span>

<span class="kd">instance</span> <span class="n">A_add_semigroup</span> <span class="o">:</span> <span class="n">add_semigroup</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">add</span> <span class="o">:=</span> <span class="n">plus</span><span class="o">,</span>
  <span class="n">add_assoc</span> <span class="o">:=</span> <span class="n">add_assoc</span> <span class="c1">-- ERROR</span>
<span class="o">}</span>
</code></pre></div>
<p>The error message is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">field</span> <span class="bp">'</span><span class="n">add_assoc'</span>
  <span class="n">add_assoc</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">),</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">↥</span><span class="n">X</span><span class="o">),</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>
</code></pre></div>
<p>Now once again I am stumped.  I am looking at the error message.  It says I am really close.  It just doesn't know how to match a type metavariable <code>?m_1</code> with a concrete type <code>set ↥X</code>.</p>
<p>What do I do in this case?  I'm guess I need to use <code>@add_assoc</code> instead</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">add_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">add_semigroup</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>
</code></pre></div>
<p>and fill out each implicit argument explicitly.</p>



<a name="219716985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219716985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219716985">(Dec 12 2020 at 16:58)</a>:</h4>
<p>DONE (with a hybrid approach of copying the technique in the game theory version to fix the ∀ and then finally applying <code>sup_assoc</code> even though <code>⊔</code> and <code>+</code> map to different types):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset.basic</span>

<span class="kd">def</span> <span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">plus</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∪</span> <span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">X_has_add</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="n">plus</span> <span class="o">⟩</span>

<span class="kd">theorem</span> <span class="n">X_add_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">+</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">sup_assoc</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">instance</span> <span class="n">X_add_semigroup</span> <span class="o">:</span> <span class="n">add_semigroup</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">add</span> <span class="o">:=</span> <span class="n">plus</span><span class="o">,</span>
  <span class="n">add_assoc</span> <span class="o">:=</span> <span class="n">X_add_assoc</span>
<span class="o">}</span>
</code></pre></div>



<a name="219717124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219717124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219717124">(Dec 12 2020 at 17:01)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">X_add_assoc</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">+</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sup_assoc</span>
</code></pre></div>
<p>Why not move x,y,z before the colon and then just go full term mode?</p>



<a name="219717180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219717180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219717180">(Dec 12 2020 at 17:02)</a>:</h4>
<p>Thank you.  Shortest version:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kd">def</span> <span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">plus</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∪</span> <span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>
<span class="kd">instance</span> <span class="n">X_has_add</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="n">plus</span> <span class="o">⟩</span>
<span class="kd">theorem</span> <span class="n">X_add_assoc</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span>  <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">+</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sup_assoc</span>
<span class="kd">instance</span> <span class="n">X_add_semigroup</span> <span class="o">:</span> <span class="n">add_semigroup</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="n">plus</span><span class="o">,</span> <span class="n">X_add_assoc</span> <span class="o">⟩</span>
</code></pre></div>



<a name="219718425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20add%20union%20as%20addition%20to%20a%20has_add/near/219718425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add.html#219718425">(Dec 12 2020 at 17:32)</a>:</h4>
<p>I usually stick with the <code>{ ... }</code> notation for making structure instances such as <code>X_add_semigroup</code>, because it's more readable. Note that you don't have to name the instances either -- Lean will find them automatically. The very fact that <code>(x + y) + z</code> typechecks demonstrates this.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
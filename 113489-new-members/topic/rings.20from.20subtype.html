---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/rings.20from.20subtype.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html">rings from subtype</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="228114322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228114322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228114322">(Feb 28 2021 at 08:00)</a>:</h4>
<p>Is something along the lines of the code below available?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ring.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">p0</span> <span class="o">:</span> <span class="n">p</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">p</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">padd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">},</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">))</span>
  <span class="o">(</span><span class="n">pmul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">},</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">))</span>

<span class="kn">section</span> <span class="n">pR</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">p</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">pR</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">r</span><span class="o">}</span>

<span class="kd">end</span> <span class="n">pR</span>

<span class="kd">instance</span> <span class="n">comm_semiring</span> <span class="o">:</span> <span class="n">comm_semiring</span> <span class="o">(</span><span class="n">pR</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="228114605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228114605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228114605">(Feb 28 2021 at 08:06)</a>:</h4>
<p>You know, what you've written is basically the constructor for a subring: <a href="https://leanprover-community.github.io/mathlib_docs/find/subring">docs#subring</a>.  Then we know that a subring of a commutative ring is itself a commutative ring: <a href="https://leanprover-community.github.io/mathlib_docs/find/subring.to_comm_ring">docs#subring.to_comm_ring</a>.</p>



<a name="228114659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228114659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228114659">(Feb 28 2021 at 08:08)</a>:</h4>
<p>Can you adjust your situation to fit this framework?</p>



<a name="228114714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228114714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228114714">(Feb 28 2021 at 08:09)</a>:</h4>
<p>Oh, I see, you want the semiring version, but that exists too: <a href="https://leanprover-community.github.io/mathlib_docs/find/subsemiring.to_comm_semiring">docs#subsemiring.to_comm_semiring</a></p>



<a name="228114793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228114793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228114793">(Feb 28 2021 at 08:10)</a>:</h4>
<p>Ah, Heather, thank you very much!  I did not know about any of these!</p>
<p>I will take a look: the <code>semi</code> issue may not be too relevant for me, I was just creating a template, to fit it later to what I exactly needed!<br>
Already the <code>comm_ring</code> one is a great start!</p>
<p>Thanks!</p>



<a name="228145381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228145381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228145381">(Feb 28 2021 at 17:49)</a>:</h4>
<p>Continuing this conversation, what I would like is to talk about the subsemiring of non-negative elements of an ordered ring <code>R</code>.  The exact assumptions on the initial ordered rings are possibly flexible, but I would certainly like this to work when <code>R</code> is a <code>comm_ring</code> with a compatible order, possibly with no zero divisors.  The most basic setup would be <code>ℤ</code> and <code>ℕ</code>, but I would like something that works simultaneously also for <code>ℚ</code> and <code>ℚ≥0</code> and <code>ℝ</code> and <code>ℝ≥0</code>.</p>
<p>Hence, is what's below already in mathlib?  Is there a simpler way to get Lean to realize all the repetitions in the statements/proofs?</p>
<p>Thanks!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.subring</span>

<span class="kn">section</span> <span class="n">Rnnoneg</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">R</span><span class="o">]</span>

<span class="sd">/--  The subtype of non-negative elements of `R`. -/</span>
<span class="kd">def</span> <span class="n">pR</span> <span class="o">:</span> <span class="n">subsemiring</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">r</span><span class="o">},</span>
  <span class="n">one_mem'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_set_of_eq</span><span class="o">,</span> <span class="n">zero_le_one</span><span class="o">],</span>
  <span class="n">mul_mem'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintros</span> <span class="n">x</span> <span class="n">y</span> <span class="o">(</span><span class="n">x0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">y0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">),</span>
    <span class="n">exact</span> <span class="n">mul_nonneg</span> <span class="n">x0</span> <span class="n">y0</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">zero_mem'</span> <span class="o">:=</span> <span class="n">rfl.le</span><span class="o">,</span>
  <span class="n">add_mem'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintros</span> <span class="n">x</span> <span class="n">y</span> <span class="o">(</span><span class="n">x0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">y0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">),</span>
    <span class="n">exact</span> <span class="n">add_nonneg</span> <span class="n">x0</span> <span class="n">y0</span><span class="o">,</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="sd">/--  The non-negative elements come with a partial order. -/</span>
<span class="kd">def</span> <span class="n">popR</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="o">(</span><span class="n">pR</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">le</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">≤</span><span class="o">),</span>
  <span class="n">lt</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">),</span>
  <span class="n">le_refl</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">le_rfl</span><span class="o">,</span>
  <span class="n">le_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">le_trans</span><span class="o">,</span>
  <span class="n">lt_iff_le_not_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">lt_iff_le_not_le</span><span class="o">,</span>
  <span class="n">le_antisymm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">le_antisymm</span> <span class="o">}</span>

<span class="sd">/--  ... and they form an ordered semiring. -/</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="o">(</span><span class="n">pR</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add_left_cancel</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintros</span> <span class="n">a</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">b0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">c0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">⟩</span> <span class="n">bc</span><span class="o">,</span>
    <span class="n">injection</span> <span class="n">bc</span> <span class="k">with</span> <span class="n">hbc</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">hbc</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">add_right_cancel</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintros</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">a0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">⟩</span> <span class="n">b</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">c0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">⟩</span> <span class="n">ac</span><span class="o">,</span>
    <span class="n">injection</span> <span class="n">ac</span> <span class="k">with</span> <span class="n">hac</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">hac</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">add_le_add_left</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintros</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">a0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">b0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">⟩</span> <span class="o">(</span><span class="n">ab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">c0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">⟩,</span>
    <span class="n">apply</span> <span class="n">add_le_add_left</span> <span class="n">ab</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">le_of_add_le_add_left</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintros</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">a0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">b0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">c0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">⟩</span> <span class="o">(</span><span class="n">hbc</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span><span class="o">),</span>
    <span class="n">change</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">le_of_add_le_add_left</span> <span class="n">hbc</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">zero_le_one</span> <span class="o">:=</span> <span class="n">zero_le_one</span><span class="o">,</span>
  <span class="n">mul_lt_mul_of_pos_left</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">mul_lt_mul_of_pos_left</span><span class="o">,</span>
  <span class="n">mul_lt_mul_of_pos_right</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">mul_lt_mul_of_pos_right</span><span class="o">,</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">infer_instance</span> <span class="o">:</span> <span class="n">semiring</span> <span class="o">(</span><span class="n">pR</span> <span class="n">R</span><span class="o">)),</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">infer_instance</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="o">(</span><span class="n">pR</span> <span class="n">R</span><span class="o">))</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">Rnnoneg</span>
</code></pre></div>



<a name="228145708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228145708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228145708">(Feb 28 2021 at 17:55)</a>:</h4>
<p>I'd expect an instance like <a href="https://leanprover-community.github.io/mathlib_docs/find/subtype.partial_order">docs#subtype.partial_order</a> or something that you could use for at least some of these.</p>



<a name="228145781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228145781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228145781">(Feb 28 2021 at 17:56)</a>:</h4>
<p>Indeed: this seems to work!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">popR</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="o">(</span><span class="n">pR</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>



<a name="228147595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228147595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228147595">(Feb 28 2021 at 18:29)</a>:</h4>
<p>Does your <code>ordered_semiring</code> instance actually use any properties of the subsemiring you chose?</p>



<a name="228147605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228147605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228147605">(Feb 28 2021 at 18:29)</a>:</h4>
<p>Or does it work on an arbitrary sub_semiring</p>



<a name="228147616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228147616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228147616">(Feb 28 2021 at 18:29)</a>:</h4>
<p>If the latter, then mathlib ought to have provided it for you, and you should PR it!</p>



<a name="228147833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228147833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228147833">(Feb 28 2021 at 18:33)</a>:</h4>
<p>I will take a look at this.  most of these properties are simply checked on a subset of the choices, so they should hold no matter what.  I will check later that there are no hidden issues.</p>
<p>Thanks for the comments!  As usual, I always learn a lot!</p>



<a name="228149844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228149844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228149844">(Feb 28 2021 at 19:07)</a>:</h4>
<p>Eric, glancing at the lemmas, you are right that the properties in the <code>ordered_semiring</code> instance above are true since they are true for any subtype of an <code>ordered_semiring</code>: you simply apply the property of the bigger type to the terms of the smaller one.</p>
<p>How does one go about "saying this in Lean"?</p>



<a name="228149908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228149908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228149908">(Feb 28 2021 at 19:08)</a>:</h4>
<p>You should be stating that result for all subsemirings</p>



<a name="228149914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228149914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228149914">(Feb 28 2021 at 19:08)</a>:</h4>
<p>Since it doesnt apply to all subtypes</p>



<a name="228149959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228149959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228149959">(Feb 28 2021 at 19:09)</a>:</h4>
<p>Note that sometimes properties of the bigger one can't always be transferred to the smaller one</p>



<a name="228150019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228150019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228150019">(Feb 28 2021 at 19:10)</a>:</h4>
<p>But when they can, a common approach is to define things like <a href="https://leanprover-community.github.io/mathlib_docs/find/function.injective.semiring">docs#function.injective.semiring</a></p>



<a name="228150047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228150047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228150047">(Feb 28 2021 at 19:10)</a>:</h4>
<p>Do we have <a href="https://leanprover-community.github.io/mathlib_docs/find/function.injective.ordered_semiring">docs#function.injective.ordered_semiring</a>?</p>



<a name="228150050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228150050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228150050">(Feb 28 2021 at 19:10)</a>:</h4>
<p>Ok, this seems like it would take some time: I will take a look at this <code>function.injective.semiring</code>, but probably tomorrow!</p>
<p>Thanks!</p>



<a name="228150073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228150073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228150073">(Feb 28 2021 at 19:11)</a>:</h4>
<p>The link <a href="https://leanprover-community.github.io/mathlib_docs/find/function.injective.ordered_semiring">docs#function.injective.ordered_semiring</a> does not work, so probably not!</p>



<a name="228150366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228150366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228150366">(Feb 28 2021 at 19:15)</a>:</h4>
<p>I assume we have <a href="https://leanprover-community.github.io/mathlib_docs/find/function.injective.preorder">docs#function.injective.preorder</a>?</p>



<a name="228150370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228150370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228150370">(Feb 28 2021 at 19:15)</a>:</h4>
<p>Hmm, also no</p>



<a name="228180798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228180798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228180798">(Mar 01 2021 at 04:30)</a>:</h4>
<p>I am trying to understand how this works.  Is the code below what you had in mind, in the case of a partial order?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">function.injective.partial_order</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">partial_order</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">f</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">lt</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">le_refl</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl.le</span><span class="o">,</span>
  <span class="n">le_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">le_trans</span><span class="o">,</span>
  <span class="n">lt_iff_le_not_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">lt_iff_le_not_le</span><span class="o">,</span>
  <span class="n">le_antisymm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ab</span> <span class="n">ba</span><span class="o">,</span> <span class="n">hf</span> <span class="o">(</span><span class="n">le_antisymm</span> <span class="n">ab</span> <span class="n">ba</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>



<a name="228182321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228182321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228182321">(Mar 01 2021 at 04:59)</a>:</h4>
<p>I tried to extend this, but I am getting stuck: why does the proof below not work?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">function.injective.ordered_semiring</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_zero</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ordered_semiring</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add_left_cancel</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">bc</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">hf</span> <span class="o">((</span><span class="n">add_right_inj</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">))</span><span class="bp">.</span><span class="n">mp</span> <span class="n">_</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">abc</span> <span class="o">:</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">c</span> <span class="o">:=</span> <span class="o">(</span><span class="n">add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">symm.trans</span> <span class="o">((</span><span class="n">congr_arg</span> <span class="n">f</span> <span class="n">bc</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">add</span> <span class="n">a</span> <span class="n">c</span><span class="o">)),</span>
    <span class="n">convert</span> <span class="n">abc</span><span class="o">,</span>
<span class="c1">-- produces two goals.  My understanding is that Lean is not picking up what the various `+` symbols mean</span>
<span class="c1">-- but I am not sure whether this is really the case, nor how to fix it!</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">add_right_cancel</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">add_le_add_left</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">le_of_add_le_add_left</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">zero_le_one</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">mul_lt_mul_of_pos_left</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">mul_lt_mul_of_pos_right</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">hf.partial_order</span> <span class="n">f</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">hf.semiring</span> <span class="n">f</span> <span class="n">zero</span> <span class="n">one</span> <span class="n">add</span> <span class="n">mul</span> <span class="o">}</span>
</code></pre></div>



<a name="228183326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228183326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228183326">(Mar 01 2021 at 05:18)</a>:</h4>
<p>I don't know what's going on exactly but most of the hypotheses can be bundled into <a href="https://leanprover-community.github.io/mathlib_docs/find/ring_hom">docs#ring_hom</a>. Why aren't you using <code>semi_ring \b</code>?</p>



<a name="228187286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228187286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228187286">(Mar 01 2021 at 06:30)</a>:</h4>
<p>It seems to me that <code>semiring_hom</code> requires <code>\b</code> to already be a semiring, whereas I would like to prove that <code>\b</code> is an ordered semiring using this result.  Am I misunderstanding your suggestion?</p>



<a name="228187404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228187404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228187404">(Mar 01 2021 at 06:33)</a>:</h4>
<p>Actually, Lean seems to already know that <code>\b</code> is a semiring, since the last row of the proof above works.  Maybe I should focus on trying to get lean to work out the <code>semiring</code> assumption on <code>\b</code> explicitly?</p>



<a name="228187778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228187778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228187778">(Mar 01 2021 at 06:39)</a>:</h4>
<p>If I try </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">add_left_cancel</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">haveI</span> <span class="o">:</span> <span class="n">semiring</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">hf.semiring</span> <span class="n">f</span> <span class="n">zero</span> <span class="n">one</span> <span class="n">add</span> <span class="n">mul</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">fr</span> <span class="o">:</span> <span class="n">ring_hom</span> <span class="n">β</span> <span class="n">α</span> <span class="o">:=</span>
    <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">f</span><span class="o">,</span>
      <span class="n">map_one'</span> <span class="o">:=</span> <span class="kd">begin</span>
        <span class="n">convert</span> <span class="n">one</span><span class="o">,</span>
        <span class="n">_</span><span class="o">,</span>
      <span class="kd">end</span><span class="o">,</span>
      <span class="n">map_mul'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">map_zero'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">_</span> <span class="o">},</span>
</code></pre></div>
<p>I run into the issue, I think, that Lean now has two <code>1</code>s on <code>β</code>, one from the assumption <code>has_one</code> and one from the instance <code>semiring β</code> and I do not know how to convince it that they are the same.</p>



<a name="228188031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228188031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228188031">(Mar 01 2021 at 06:44)</a>:</h4>
<p>Try adding <code>add := (+)</code> etc to your original version</p>



<a name="228188071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228188071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228188071">(Mar 01 2021 at 06:45)</a>:</h4>
<p>That way lean will use the notation from the has_add argument</p>



<a name="228189634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228189634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228189634">(Mar 01 2021 at 07:12)</a>:</h4>
<p>Hmm, it gets me to the same stage:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">function.injective.ordered_semiring</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_zero</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ordered_semiring</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">+</span><span class="o">),</span>
  <span class="n">add_left_cancel</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">bc</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">hf</span> <span class="o">((</span><span class="n">add_right_inj</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">))</span><span class="bp">.</span><span class="n">mp</span> <span class="n">_</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">abc</span> <span class="o">:</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">c</span> <span class="o">:=</span> <span class="o">(</span><span class="n">add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">symm.trans</span> <span class="o">((</span><span class="n">congr_arg</span> <span class="n">f</span> <span class="n">bc</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">add</span> <span class="n">a</span> <span class="n">c</span><span class="o">)),</span>
    <span class="n">convert</span> <span class="n">abc</span><span class="o">,</span>
<span class="c1">-- two goals: add_semigroup.to_has_add α = distrib.to_has_add α</span>
<span class="c1">-- and: add_semigroup.to_has_add α = distrib.to_has_add α</span>
    <span class="gr">sorry</span><span class="o">,</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">add_right_cancel</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">add_le_add_left</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">le_of_add_le_add_left</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">zero_le_one</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">mul_lt_mul_of_pos_left</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">mul_lt_mul_of_pos_right</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">hf.partial_order</span> <span class="n">f</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">hf.semiring</span> <span class="n">f</span> <span class="n">zero</span> <span class="n">one</span> <span class="n">add</span> <span class="n">mul</span> <span class="o">}</span>
</code></pre></div>



<a name="228190952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228190952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228190952">(Mar 01 2021 at 07:33)</a>:</h4>
<p>Does refl solve those goals?</p>



<a name="228191024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228191024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228191024">(Mar 01 2021 at 07:34)</a>:</h4>
<p>Perhaps after using <code>convert ... using 1</code></p>



<a name="228191027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228191027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228191027">(Mar 01 2021 at 07:34)</a>:</h4>
<p>Or 2</p>



<a name="228191242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228191242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228191242">(Mar 01 2021 at 07:38)</a>:</h4>
<p><code>refl</code> does not work saying that it fails to unify</p>



<a name="228191287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228191287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228191287">(Mar 01 2021 at 07:39)</a>:</h4>
<p><code>convert abc using 1</code> produces</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⊢</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div>
<p>and</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">f</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">c</span>
</code></pre></div>
<p>as subgoals, but again <code>refl</code> fails to unify them.</p>



<a name="228191300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228191300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228191300">(Mar 01 2021 at 07:39)</a>:</h4>
<p><code>convert abc using 2</code> gives the same goals as <code>convert abc</code></p>



<a name="228191832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228191832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228191832">(Mar 01 2021 at 07:47)</a>:</h4>
<p>I am really sorry about the confusion: I had a <code>variables {α β : Type*} [semiring α]</code> floating around, so the two <code>add</code> instances had been artificially introduced by me.<br>
<span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span></p>



<a name="228191962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228191962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228191962">(Mar 01 2021 at 07:49)</a>:</h4>
<p>Indeed, this now works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">function.injective.ordered_semiring</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_zero</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ordered_semiring</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add_left_cancel</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">bc</span><span class="o">,</span>
    <span class="n">hf</span> <span class="o">((</span><span class="n">add_right_inj</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">))</span><span class="bp">.</span><span class="n">mp</span> <span class="o">((</span><span class="n">add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">symm.trans</span> <span class="o">((</span><span class="n">congr_arg</span> <span class="n">f</span> <span class="n">bc</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">add</span> <span class="n">a</span> <span class="n">c</span><span class="o">)))),</span>
<span class="c1">-- [still to finish]</span>
<span class="o">}</span>
</code></pre></div>



<a name="228194245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228194245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228194245">(Mar 01 2021 at 08:18)</a>:</h4>
<p>Finally, this works!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">function.injective.ordered_semiring</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_zero</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ordered_semiring</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add_le_add_left</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ab</span> <span class="n">c</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">change</span> <span class="n">f</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">f</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">b</span><span class="o">),</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">add</span><span class="o">,</span> <span class="n">add</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">add_le_add_left</span> <span class="n">ab</span> <span class="o">(</span><span class="n">f</span> <span class="n">c</span><span class="o">),</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">le_of_add_le_add_left</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">(</span><span class="n">ab</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)),</span> <span class="kd">begin</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">add</span><span class="o">,</span> <span class="n">add</span><span class="o">]</span> <span class="n">at</span> <span class="n">ab</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">le_of_add_le_add_left</span> <span class="n">ab</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">zero_le_one</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">change</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">f</span> <span class="mi">1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">zero</span><span class="o">,</span> <span class="n">one</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">zero_le_one</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">mul_lt_mul_of_pos_left</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">ab</span> <span class="n">c0</span><span class="o">,</span>
    <span class="n">change</span> <span class="n">f</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">),</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">mul</span><span class="o">,</span> <span class="n">mul</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">mul_lt_mul_of_pos_left</span> <span class="n">ab</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="bp">←</span> <span class="n">zero</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">mul_lt_mul_of_pos_right</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">ab</span> <span class="n">c0</span><span class="o">,</span>
    <span class="n">change</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">),</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">mul</span><span class="o">,</span> <span class="n">mul</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">mul_lt_mul_of_pos_right</span> <span class="n">ab</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="bp">←</span> <span class="n">zero</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">hf.partial_order</span> <span class="n">f</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">hf.add_left_cancel_semigroup</span> <span class="n">f</span> <span class="n">add</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">hf.add_right_cancel_semigroup</span> <span class="n">f</span> <span class="n">add</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">hf.semiring</span> <span class="n">f</span> <span class="n">zero</span> <span class="n">one</span> <span class="n">add</span> <span class="n">mul</span> <span class="o">}</span>
</code></pre></div>



<a name="228198811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228198811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228198811">(Mar 01 2021 at 09:05)</a>:</h4>
<p>I now have a bunch of proofs for the results below.  Are people interested in having them in mathlib?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">function.injective.preorder</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">preorder</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="bp">...</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">function.injective.preorder.mono</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">monotone</span> <span class="n">β</span> <span class="n">α</span> <span class="o">(</span><span class="n">hf.preorder</span> <span class="n">f</span><span class="o">)</span> <span class="n">_</span> <span class="n">f</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ab</span><span class="o">,</span> <span class="n">ab</span>

<span class="kd">def</span> <span class="n">function.injective.partial_order</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">partial_order</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="bp">...</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">function.injective.ordered_add_comm_monoid</span> <span class="o">[</span><span class="n">ordered_add_comm_monoid</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_zero</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ordered_add_comm_monoid</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="bp">...</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">function.injective.ordered_cancel_add_comm_monoid</span> <span class="o">[</span><span class="n">ordered_cancel_add_comm_monoid</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_zero</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ordered_cancel_add_comm_monoid</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="bp">...</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">function.injective.ordered_semiring</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_zero</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ordered_semiring</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="bp">...</span> <span class="o">}</span>
</code></pre></div>



<a name="228198994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228198994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228198994">(Mar 01 2021 at 09:07)</a>:</h4>
<p>I can't see why not, we have a precedent for those definitions for other typeclasses</p>



<a name="228199102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228199102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228199102">(Mar 01 2021 at 09:08)</a>:</h4>
<p>Ok, and should they all go in the same file?  Probably <code>algebra.ring.basic</code>?</p>



<a name="228199137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228199137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228199137">(Mar 01 2021 at 09:08)</a>:</h4>
<p>They can't go there, because the ordering classes don't exist yet</p>



<a name="228199154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228199154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228199154">(Mar 01 2021 at 09:09)</a>:</h4>
<p>Try to put each in the same file as the typeclass they implement is defined</p>



<a name="228199286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228199286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228199286">(Mar 01 2021 at 09:10)</a>:</h4>
<p>Ok, good suggestion!</p>



<a name="228199855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228199855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228199855">(Mar 01 2021 at 09:16)</a>:</h4>
<p>You don't need injectivity to pull back a preorder and the pullback is already there</p>



<a name="228200034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228200034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228200034">(Mar 01 2021 at 09:18)</a>:</h4>
<p>Kevin, thanks!  I had split the <code>preorder</code> from the <code>partial_order</code> and did not think back about the assumptions!</p>



<a name="228200070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228200070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228200070">(Mar 01 2021 at 09:19)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/preorder.lift">docs#preorder.lift</a></p>



<a name="228200402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228200402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228200402">(Mar 01 2021 at 09:22)</a>:</h4>
<p>Thanks Rémy!  I see that also <code>partial_order.lift</code> exists: great!</p>



<a name="228200604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228200604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228200604">(Mar 01 2021 at 09:24)</a>:</h4>
<p>I am down to what is below.  Anything else that is already in mathlib?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">function.injective.ordered_add_comm_monoid</span> <span class="o">[</span><span class="n">ordered_add_comm_monoid</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_zero</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ordered_add_comm_monoid</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="bp">...</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">function.injective.ordered_cancel_add_comm_monoid</span> <span class="o">[</span><span class="n">ordered_cancel_add_comm_monoid</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_zero</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ordered_cancel_add_comm_monoid</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="bp">...</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">function.injective.ordered_semiring</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_zero</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ordered_semiring</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="bp">...</span> <span class="o">}</span>
</code></pre></div>



<a name="228200644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228200644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228200644">(Mar 01 2021 at 09:25)</a>:</h4>
<p>It's annoying that the naming convention is different between partial_order.lift and function. Injective.semiring</p>



<a name="228200697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228200697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228200697">(Mar 01 2021 at 09:25)</a>:</h4>
<p>Use library_search to find out?</p>



<a name="228200792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228200792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228200792">(Mar 01 2021 at 09:26)</a>:</h4>
<p><code>library_search</code> is often my first attempt, but I could not find any of these...</p>



<a name="228200927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228200927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228200927">(Mar 01 2021 at 09:27)</a>:</h4>
<p>Did it find partial_order.lift?</p>



<a name="228201078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228201078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228201078">(Mar 01 2021 at 09:29)</a>:</h4>
<p>You raise a good point:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">function.injective.partial_order</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">partial_order</span> <span class="n">β</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">library_search</span>
</code></pre></div>
<p>says</p>
<p><code>library_search</code> failed.</p>



<a name="228201124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228201124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228201124">(Mar 01 2021 at 09:30)</a>:</h4>
<p>Of course it does</p>



<a name="228201175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228201175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228201175">(Mar 01 2021 at 09:30)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/partial_order.lift">docs#partial_order.lift</a> requires injectivity</p>



<a name="228201218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228201218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228201218">(Mar 01 2021 at 09:30)</a>:</h4>
<p>For ordered add comm monoid you have an unneeded mul on beta</p>



<a name="228201236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228201236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228201236">(Mar 01 2021 at 09:30)</a>:</h4>
<p>This also fails:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">function.injective.partial_order</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">):</span>
  <span class="n">partial_order</span> <span class="n">β</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">library_search</span>
</code></pre></div>



<a name="228201297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228201297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228201297">(Mar 01 2021 at 09:31)</a>:</h4>
<p>And a 1 and in the second one too</p>



<a name="228201417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228201417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228201417">(Mar 01 2021 at 09:32)</a>:</h4>
<p>Thanks for the linting!  I cleared unnecessary hypotheses: now only the doc-strings are missing!</p>



<a name="228201492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228201492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228201492">(Mar 01 2021 at 09:33)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.subring</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kn">open</span> <span class="n">function</span>

<span class="sd">/-- Pullback an `ordered_add_comm_monoid` under an injective map. -/</span>
<span class="kd">def</span> <span class="n">function.injective.ordered_add_comm_monoid</span> <span class="o">[</span><span class="n">ordered_add_comm_monoid</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_zero</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ordered_add_comm_monoid</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add_le_add_left</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ab</span> <span class="n">c</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">f</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">f</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">b</span><span class="o">),</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">add</span><span class="o">,</span> <span class="n">add_le_add_left</span> <span class="n">ab</span> <span class="o">(</span><span class="n">f</span> <span class="n">c</span><span class="o">)],</span>
  <span class="n">lt_of_add_lt_add_left</span> <span class="o">:=</span>
    <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">bc</span><span class="o">,</span> <span class="bp">@</span><span class="n">lt_of_add_lt_add_left</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rwa</span> <span class="o">[</span><span class="bp">←</span> <span class="n">add</span><span class="o">,</span> <span class="bp">←</span> <span class="n">add</span><span class="o">]),</span>
  <span class="bp">..</span><span class="n">partial_order.lift</span> <span class="n">f</span> <span class="n">hf</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">hf.add_comm_monoid</span> <span class="n">f</span> <span class="n">zero</span> <span class="n">add</span> <span class="o">}</span>

<span class="sd">/-- Pullback an `ordered_cancel_add_comm_monoid` under an injective map. -/</span>
<span class="kd">def</span> <span class="n">function.injective.ordered_cancel_add_comm_monoid</span> <span class="o">[</span><span class="n">ordered_cancel_add_comm_monoid</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_zero</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ordered_cancel_add_comm_monoid</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">le_of_add_le_add_left</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">(</span><span class="n">ab</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)),</span>
    <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add</span><span class="o">,</span> <span class="n">add</span><span class="o">]</span> <span class="n">at</span> <span class="n">ab</span><span class="o">,</span> <span class="n">exact</span> <span class="n">le_of_add_le_add_left</span> <span class="n">ab</span> <span class="o">}),</span>
  <span class="bp">..</span><span class="n">hf.add_left_cancel_semigroup</span> <span class="n">f</span> <span class="n">add</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">hf.add_right_cancel_semigroup</span> <span class="n">f</span> <span class="n">add</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">hf.ordered_add_comm_monoid</span> <span class="n">f</span> <span class="n">zero</span> <span class="n">add</span> <span class="o">}</span>

<span class="sd">/-- Pullback an `ordered_semiring` under an injective map. -/</span>
<span class="kd">def</span> <span class="n">function.injective.ordered_semiring</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_zero</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ordered_semiring</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">zero_le_one</span> <span class="o">:=</span> <span class="k">show</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">f</span> <span class="mi">1</span><span class="o">,</span> <span class="kd">by</span>  <span class="n">simp</span> <span class="o">[</span><span class="n">zero</span><span class="o">,</span> <span class="n">one</span><span class="o">,</span> <span class="n">zero_le_one</span><span class="o">],</span>
  <span class="n">mul_lt_mul_of_pos_left</span> <span class="o">:=</span> <span class="bp">λ</span>  <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">ab</span> <span class="n">c0</span><span class="o">,</span> <span class="k">show</span> <span class="n">f</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">),</span>
    <span class="kd">begin</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">mul</span><span class="o">,</span> <span class="n">mul</span><span class="o">],</span>
      <span class="n">refine</span> <span class="n">mul_lt_mul_of_pos_left</span> <span class="n">ab</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">rwa</span> <span class="bp">←</span> <span class="n">zero</span><span class="o">,</span>
    <span class="kd">end</span><span class="o">,</span>
  <span class="n">mul_lt_mul_of_pos_right</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">ab</span> <span class="n">c0</span><span class="o">,</span> <span class="k">show</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">),</span>
    <span class="kd">begin</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">mul</span><span class="o">,</span> <span class="n">mul</span><span class="o">],</span>
      <span class="n">refine</span> <span class="n">mul_lt_mul_of_pos_right</span> <span class="n">ab</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">rwa</span> <span class="bp">←</span> <span class="n">zero</span><span class="o">,</span>
    <span class="kd">end</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">hf.ordered_cancel_add_comm_monoid</span> <span class="n">f</span> <span class="n">zero</span> <span class="n">add</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">hf.semiring</span> <span class="n">f</span> <span class="n">zero</span> <span class="n">one</span> <span class="n">add</span> <span class="n">mul</span> <span class="o">}</span>

<span class="bp">#</span><span class="n">lint</span>
</code></pre></div>
<p><code>lint</code> is happy!</p>



<a name="228203787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228203787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228203787">(Mar 01 2021 at 09:54)</a>:</h4>
<p>Can you generate <code>function.injective.ordered_add_comm_monoid</code> from <code>to_additive</code> and <code>function.injective.ordered_comm_monoid</code>?</p>



<a name="228203821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228203821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228203821">(Mar 01 2021 at 09:54)</a>:</h4>
<p>At any rate, this is probably ready for PR comments</p>



<a name="228211927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228211927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228211927">(Mar 01 2021 at 11:03)</a>:</h4>
<p>I think that I managed to get lean to produce the additive version with the proof of the multiplicative ones.  I have the issue now that <code>lint</code> complains about the doc-strings missing from the two automatically generated definitions.</p>
<p>How do I provide doc-strings for the <code>[to_additive]</code> stuff?</p>



<a name="228212375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228212375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228212375">(Mar 01 2021 at 11:07)</a>:</h4>
<p>PR <a href="https://github.com/leanprover-community/mathlib/issues/6489">#6489</a></p>



<a name="228213285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228213285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228213285">(Mar 01 2021 at 11:15)</a>:</h4>
<p>Like that: <code>[to_additive name_for_to_additive_version "Docstring for to_additive version"]</code></p>



<a name="228213347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228213347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228213347">(Mar 01 2021 at 11:15)</a>:</h4>
<p>and the name can most often be omitted. The linter will tell you to remove it if it is the same as the automatically generated one.</p>



<a name="228213745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228213745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228213745">(Mar 01 2021 at 11:19)</a>:</h4>
<p>Rémy, thank you very much!  I will update the PR.  I will wait to see if the linter complains about the autogenerated name, although I imagine that I would want the autogenerated name anyway!</p>



<a name="228216882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228216882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228216882">(Mar 01 2021 at 11:50)</a>:</h4>
<p>I don't think that naming these after <code>function.injective</code> is a good idea if you want consistency, because it's not always a requirement</p>



<a name="228217024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228217024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228217024">(Mar 01 2021 at 11:51)</a>:</h4>
<p>I am happy to give them a different name.  I was simply minimizing the changes from </p>
<p><a href="https://leanprover-community.github.io/mathlib_docs/algebra/ring/basic.html#function.injective.semiring">https://leanprover-community.github.io/mathlib_docs/algebra/ring/basic.html#function.injective.semiring</a></p>
<p>since I was trying to learn at the same time what this all meant</p>



<a name="228217135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228217135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228217135">(Mar 01 2021 at 11:52)</a>:</h4>
<p>perhaps <code>partial_order.comap</code>?</p>



<a name="228217154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228217154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228217154">(Mar 01 2021 at 11:52)</a>:</h4>
<p>What seems to work well with this name is that you can eat the <code>function.injective</code> part with the assumption that the function is injective.  This may not seem like a great deal to you, but I am still not entirely accustomed to dot-notation!</p>



<a name="228217271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228217271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228217271">(Mar 01 2021 at 11:53)</a>:</h4>
<p>No I see that, but like I said you won't get consistent naming that way unless you want <code>function.injective.preorder</code> even though that one doesn't take a <code>function.injective</code> argument</p>



<a name="228217369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228217369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228217369">(Mar 01 2021 at 11:54)</a>:</h4>
<p>Ah, sorry, I think that the part of the thread that talked about <code>partial_orders</code> ended when I was told that <code>partial_order.lift</code> was already a thing!</p>



<a name="228217371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228217371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228217371">(Mar 01 2021 at 11:54)</a>:</h4>
<p>since <span class="user-mention silent" data-user-id="310045">Eric Wieser</span>'s original complaint was about lack of consistency in the naming</p>



<a name="228217374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228217374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228217374">(Mar 01 2021 at 11:54)</a>:</h4>
<p>The partial order one exists already and is <code>partial_order.lift</code>. There is also <code>preorder.lift</code>, <code>linear_order.lift</code>. I suggest keeping those names because they describe well what those lemmas do and using <code>class_name.lift</code></p>



<a name="228217399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228217399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228217399">(Mar 01 2021 at 11:54)</a>:</h4>
<p>The final PR only talks about <code>ordered_stuff_ring/monoid</code>.</p>



<a name="228217446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228217446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228217446">(Mar 01 2021 at 11:55)</a>:</h4>
<p>Those came later, and apparently were written without knowing about the <code>*.lift</code> lemmas</p>



<a name="228217507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228217507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228217507">(Mar 01 2021 at 11:55)</a>:</h4>
<p>So, should the new ones that I PRed contain <code>lift</code> in them?</p>



<a name="228217569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228217569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228217569">(Mar 01 2021 at 11:56)</a>:</h4>
<p>e.g. <code>ordered_comm_monoid.lift</code>, instead of <code>function.injective.ordered_comm_monoid</code>?</p>



<a name="228217664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228217664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228217664">(Mar 01 2021 at 11:57)</a>:</h4>
<p>That looks good to me</p>



<a name="228217708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228217708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228217708">(Mar 01 2021 at 11:57)</a>:</h4>
<p>Looking at the new lemmas, they seem to differ from the <code>*.lift</code> family in that they already expect the domain to have a one and mul</p>



<a name="228217755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228217755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228217755">(Mar 01 2021 at 11:58)</a>:</h4>
<p>I can certainly change the three names (+2) to be of this form: <code>class_name.lift</code> where <code>class_name</code> is going to be <code>ordered_[...]</code>.</p>



<a name="228217886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228217886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228217886">(Mar 01 2021 at 11:59)</a>:</h4>
<p>The point of <code>partial_order.lift</code> for example is to <em>define</em> a <code>&lt;=</code> induced by the <code>&lt;=</code> on the codomain, so we don't assume any structure on the domain a priori</p>



<a name="228218007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228218007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228218007">(Mar 01 2021 at 12:00)</a>:</h4>
<p>When there are more operations, I suppose it becomes a question of which operations you want to pull back and which you expect to already exist</p>



<a name="228218408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228218408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228218408">(Mar 01 2021 at 12:03)</a>:</h4>
<p>In this case there is the issue that I would not want to say that the <code>0</code> ring is a subring of any other ring, since for me a ring map needs to take <code>1</code> to <del><code>0</code></del> <code>1</code> (what a lapsus!)...  so I would not be happy to <em>define</em> 1 and 0 from the map.</p>



<a name="228218639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228218639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228218639">(Mar 01 2021 at 12:05)</a>:</h4>
<p>As far as "algebraic structures" go, though assuming <code>add</code>, <code>mul</code>, <code>0</code> and <code>1</code> seems pretty basic.  In fact, you might even get away with not assuming <code>0</code>, maybe...</p>



<a name="228218856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228218856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228218856">(Mar 01 2021 at 12:06)</a>:</h4>
<p>Ah, except that it is there because of autogeneration from the assumption of <code>1</code>, right?  So, to remove <code>0</code> you would need to not use <code>to_additive</code> (which is what I was going to do anyway, until Eric suggested that I could take advantage of <code>to_additive</code>).</p>



<a name="228219438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228219438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228219438">(Mar 01 2021 at 12:11)</a>:</h4>
<p>Hmm, not so sure about not needing <code>0</code>: should <code>pnat</code> be an <code>ordered_subsemiring</code> of <code>nat</code>?</p>
<p>I would say not...</p>



<a name="228223749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228223749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228223749">(Mar 01 2021 at 12:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/rings.20from.20subtype/near/228216882">said</a>:</p>
<blockquote>
<p>I don't think that naming these after <code>function.injective</code> is a good idea if you want consistency, because it's not always a requirement</p>
</blockquote>
<p>I agree, but I think that <span class="user-mention" data-user-id="321459">@Damiano Testa</span> should continue to use <code>function.injective.ordered_cancel_comm_monoid</code> in their PR, and then someone can rename all of them at once later</p>



<a name="228927557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228927557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228927557">(Mar 05 2021 at 10:02)</a>:</h4>
<p>So the conclusion of this thread is that you can now do:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">section</span> <span class="n">Rnnoneg</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">R</span><span class="o">]</span>

<span class="sd">/--  The subtype of non-negative elements of `R`. -/</span>
<span class="kd">def</span> <span class="n">pR</span> <span class="o">:</span> <span class="n">subsemiring</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">r</span><span class="o">},</span>
  <span class="n">one_mem'</span> <span class="o">:=</span> <span class="n">zero_le_one</span><span class="o">,</span>
  <span class="n">mul_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">mul_nonneg</span><span class="o">,</span>
  <span class="n">zero_mem'</span> <span class="o">:=</span> <span class="n">rfl.le</span><span class="o">,</span>
  <span class="n">add_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="o">(</span><span class="n">x0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="n">y0</span><span class="o">,</span> <span class="n">add_nonneg</span> <span class="n">x0</span> <span class="n">y0</span><span class="o">,</span> <span class="o">}</span>

<span class="sd">/--  ... and they form an ordered semiring. -/</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="o">(</span><span class="n">pR</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span>

<span class="kd">end</span> <span class="n">Rnnoneg</span>
</code></pre></div>
<p>right?</p>



<a name="228927778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228927778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228927778">(Mar 05 2021 at 10:03)</a>:</h4>
<p>Yes, I think we tested this on the <code>toric</code> branch of LTE this morning, and it works</p>



<a name="228927797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228927797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228927797">(Mar 05 2021 at 10:03)</a>:</h4>
<p>Thanks for all your help!</p>



<a name="228929288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228929288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228929288">(Mar 05 2021 at 10:15)</a>:</h4>
<p>You better use all the other ordering classes too to make the scope creep of the PR worthwhile <span aria-label="laughing" class="emoji emoji-1f606" role="img" title="laughing">:laughing:</span></p>



<a name="228935873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228935873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228935873">(Mar 05 2021 at 11:12)</a>:</h4>
<p>I will try to use as many of these as possible!  If needed, I will artificially prove lemmas about ordered_semi_canonical_monoids, just to use the appropriate typeclass!</p>



<a name="228936046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228936046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228936046">(Mar 05 2021 at 11:14)</a>:</h4>
<p>In any case, I confirm that one of the new instances is already in use in the <code>toric</code> branch!</p>



<a name="228988870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228988870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228988870">(Mar 05 2021 at 17:09)</a>:</h4>
<p>Continuing with the <code>instance</code> galore, are the instances below in mathlib?</p>
<p>The proofs are straightforward, but I was wondering if I have simply been unable to find them, or whether there are reasons why having them would cause issues.</p>
<p>Thanks!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">ring_hom.to_algebra</span> <span class="o">{</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">algebra</span> <span class="n">R</span> <span class="n">S</span> <span class="o">:=</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">nnreal.to_real_hom.to_algebra</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">semimodule</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
</code></pre></div>
<p>(In case you are wondering, the <code>apply_instance</code> in the third line above is a consequence of the previous ones, otherwise I could not find it in mathlib.)</p>



<a name="228992454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228992454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228992454">(Mar 05 2021 at 17:31)</a>:</h4>
<p><code>ring_hom.to_algebra</code> already exists (with that name)</p>



<a name="228993363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/228993363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#228993363">(Mar 05 2021 at 17:36)</a>:</h4>
<p>Good on the naming front, not so good on the search front!</p>



<a name="229009088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229009088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229009088">(Mar 05 2021 at 19:18)</a>:</h4>
<p>Ok, so does it make sense to PR the <code>instance</code>s below?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">nnreal.to_real_hom.to_algebra</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">semimodule</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">S</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">one_smul</span><span class="o">,</span> <span class="n">ring_hom.map_one</span><span class="o">],</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">m</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[(</span><span class="bp">•</span><span class="o">),</span> <span class="n">mul_smul</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">S</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">S</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span> <span class="n">m</span><span class="o">],</span>
  <span class="n">smul_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="n">smul_add</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">S</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">smul_zero</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">S</span><span class="o">)</span> <span class="n">r</span><span class="o">),</span>
  <span class="n">add_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">m</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[(</span><span class="bp">•</span><span class="o">),</span> <span class="n">add_smul</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">S</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">S</span><span class="o">)</span> <span class="n">b</span><span class="o">)</span> <span class="n">m</span><span class="o">],</span>
  <span class="n">zero_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ring_hom.map_zero</span><span class="o">,</span> <span class="n">zero_smul</span><span class="o">]}</span>

<span class="kd">instance</span> <span class="n">pro</span> <span class="o">[</span><span class="n">module</span> <span class="n">ℝ</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">semimodule</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">M</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>



<a name="229010384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229010384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229010384">(Mar 05 2021 at 19:26)</a>:</h4>
<p>Nr 1 looks good, nr 2 is <code>by apply_instance</code> so it is redundant, nr 3 should be a <code>def</code>, because the type class search can not determine <code>S</code> from the goal, so it will go crazy; nr 4 looks good (but the proof will have to change to use the def from nr 3).</p>



<a name="229010537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229010537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229010537">(Mar 05 2021 at 19:27)</a>:</h4>
<p>nr 2 is <code>by apply_instance</code> only after nr 1 is in: that does not matter, right?</p>



<a name="229010617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229010617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229010617">(Mar 05 2021 at 19:28)</a>:</h4>
<p>Right, as soon as nr 1 is in mathlib, nr 2 is redundant</p>



<a name="229010995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229010995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229010995">(Mar 05 2021 at 19:30)</a>:</h4>
<p>Better?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">nnreal.to_real_hom.to_algebra</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">N</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">semimodule.of_algebra</span> <span class="o">(</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">S</span><span class="o">]</span>
  <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">semimodule</span> <span class="n">R</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">S</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">one_smul</span><span class="o">,</span> <span class="n">ring_hom.map_one</span><span class="o">],</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">m</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[(</span><span class="bp">•</span><span class="o">),</span> <span class="n">mul_smul</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">S</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">S</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span> <span class="n">m</span><span class="o">],</span>
  <span class="n">smul_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="n">smul_add</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">S</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">smul_zero</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">S</span><span class="o">)</span> <span class="n">r</span><span class="o">),</span>
  <span class="n">add_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">m</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[(</span><span class="bp">•</span><span class="o">),</span> <span class="n">add_smul</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">S</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">S</span><span class="o">)</span> <span class="n">b</span><span class="o">)</span> <span class="n">m</span><span class="o">],</span>
  <span class="n">zero_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ring_hom.map_zero</span><span class="o">,</span> <span class="n">zero_smul</span><span class="o">]}</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">ℝ</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="n">semimodule</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">semimodule.of_algebra</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">ℝ</span>
</code></pre></div>



<a name="229011947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229011947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229011947">(Mar 05 2021 at 19:36)</a>:</h4>
<p>That last one looks dangerous to me</p>



<a name="229011976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229011976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229011976">(Mar 05 2021 at 19:37)</a>:</h4>
<p>Oh sorry, didn't scroll down</p>



<a name="229012229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229012229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229012229">(Mar 05 2021 at 19:38)</a>:</h4>
<p>I don't think <code>semimodule.of_algebra</code> is a great idea, that looks like something <a href="https://leanprover-community.github.io/mathlib_docs/find/is_scalar_tower">docs#is_scalar_tower</a> is intended to solve</p>



<a name="229012313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229012313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229012313">(Mar 05 2021 at 19:39)</a>:</h4>
<p>I would also like to have </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">ist</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">ℝ</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">ℝ</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="k">show</span> <span class="o">(</span><span class="n">a.val</span> <span class="bp">•</span> <span class="n">b</span><span class="o">)</span> <span class="bp">•</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">b</span> <span class="bp">•</span> <span class="n">c</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">smul_assoc</span> <span class="n">a.val</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">congr</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>



<a name="229012657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229012657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229012657">(Mar 05 2021 at 19:41)</a>:</h4>
<p>I thing <a href="https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars">docs#restrict_scalars</a> might be related too</p>



<a name="229012711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229012711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229012711">(Mar 05 2021 at 19:42)</a>:</h4>
<p>(deleted)</p>



<a name="229013159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229013159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229013159">(Mar 05 2021 at 19:44)</a>:</h4>
<p>Eric, I am looking at your suggestions: they do look very close to what I want.  (Although so far I have not been able to make them work "as is".)</p>



<a name="229013480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229013480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229013480">(Mar 05 2021 at 19:47)</a>:</h4>
<p>Can you give two concrete examples for N for your last instance?</p>



<a name="229013678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229013678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229013678">(Mar 05 2021 at 19:48)</a>:</h4>
<p>You mean two ℝ-modules <code>N</code>?  Like some actual real vector spaces?  Or am I misunderstanding what you are asking?</p>



<a name="229013764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229013764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229013764">(Mar 05 2021 at 19:49)</a>:</h4>
<p>In <code>toric</code> I am trying to convert all the time between a vector space and a cone inside it, so I like to take "non-negative" multiples of vectors.  This is the reason why I would like to have this instance.</p>
<p>(I just added a proof of the <code>is_scalar_tower</code> instance.)</p>



<a name="229014862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229014862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229014862">(Mar 05 2021 at 19:57)</a>:</h4>
<p>My claim is that the semimodule instance should appear automatically if you define the scalar_tower one</p>



<a name="229014863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229014863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229014863">(Mar 05 2021 at 19:57)</a>:</h4>
<p>Eg, <a href="https://leanprover-community.github.io/mathlib_docs/find/pi.semimodule">docs#pi.semimodule</a> for the module <code>fin 3-&gt; R</code></p>



<a name="229014927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229014927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229014927">(Mar 05 2021 at 19:58)</a>:</h4>
<p>Will inherit all module structures that R has</p>



<a name="229015137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229015137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229015137">(Mar 05 2021 at 19:59)</a>:</h4>
<p>If I understand you correctly, and I swap the last two like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">ist</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">ℝ</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">ℝ</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="k">show</span> <span class="o">(</span><span class="n">a.val</span> <span class="bp">•</span> <span class="n">b</span><span class="o">)</span> <span class="bp">•</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">b</span> <span class="bp">•</span> <span class="n">c</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">smul_assoc</span> <span class="n">a.val</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">congr</span> <span class="o">}</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">ℝ</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="n">semimodule</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">semimodule.of_algebra</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">ℝ</span>
</code></pre></div>
<p>then, <code>is_scalar_tower</code> wants a <code>has_scalar ℝ≥0 N</code> assumption that it can't find.</p>



<a name="229015342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229015342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229015342">(Mar 05 2021 at 20:00)</a>:</h4>
<p>I think my claim is that all concrete N you care about should be providing that is_scalar_tower instance</p>



<a name="229015444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229015444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229015444">(Mar 05 2021 at 20:01)</a>:</h4>
<p>So in abstract situations you should just have it as a typeclass assumption</p>



<a name="229015542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229015542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229015542">(Mar 05 2021 at 20:01)</a>:</h4>
<p>so, in the <code>toric</code> branch, this is a lemma that does not work without that instance and does with it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">pointed_of_nnreal</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">module</span> <span class="n">ℝ</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">bv</span> <span class="o">:</span> <span class="n">is_basis</span> <span class="n">ℝ</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">pointed</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">submodule.span</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="o">(</span><span class="n">set.range</span> <span class="n">v</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">pointed_of_is_basis_is_inj</span> <span class="o">(</span><span class="n">is_inj_nonneg.pR_ocr</span> <span class="n">ℝ</span><span class="o">)</span> <span class="n">bv</span>
</code></pre></div>



<a name="229015665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229015665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229015665">(Mar 05 2021 at 20:02)</a>:</h4>
<p>I might take a look later. Can you give a github line permalink?</p>



<a name="229015697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229015697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229015697">(Mar 05 2021 at 20:02)</a>:</h4>
<p>It is probably a little cryptic, but you can see the <code>\R</code>module assumption on <code>M</code> which does not automatically get a nnreal <code>is_scalar_tower</code>.</p>



<a name="229015808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229015808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229015808">(Mar 05 2021 at 20:03)</a>:</h4>
<p>would telling you where to find it in <code>lean-liquid</code> be ok?</p>



<a name="229016294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229016294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229016294">(Mar 05 2021 at 20:06)</a>:</h4>
<p><a href="https://github.com/leanprover-community/lean-liquid/blob/55f017b4c2238f7d5891d19b0adcc7c94bc8aa5c/src/toric_2021_02_19/toric.lean#L576">https://github.com/leanprover-community/lean-liquid/blob/55f017b4c2238f7d5891d19b0adcc7c94bc8aa5c/src/toric_2021_02_19/toric.lean#L576</a></p>
<p>The lemma begins on line 575, the instances are before it.</p>



<a name="229016452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229016452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229016452">(Mar 05 2021 at 20:07)</a>:</h4>
<p>(deleted)</p>



<a name="229021059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229021059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229021059">(Mar 05 2021 at 20:41)</a>:</h4>
<p>Lines 559 to 573 should be removed, and replaced with hypotheses for the lemma on line 575</p>



<a name="229021680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229021680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229021680">(Mar 05 2021 at 20:45)</a>:</h4>
<p>That is, assume <code>[semimodule ℝ≥0 N]</code></p>



<a name="229021954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229021954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229021954">(Mar 05 2021 at 20:47)</a>:</h4>
<p>I can certainly assume those instances, instead of proving them in general, but the situation with ℕ and ℤ is that those instances are there automatically (e.g. the lemmas on 537 and 543).</p>



<a name="229022584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229022584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229022584">(Mar 05 2021 at 20:51)</a>:</h4>
<p>I think that Lean also wants me to assume</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">[</span><span class="n">algebra</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">ℝ</span><span class="o">]</span>
<span class="o">[</span><span class="n">semimodule</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">M</span><span class="o">]</span>
<span class="o">[</span><span class="n">is_scalar_tower</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">ℝ</span> <span class="n">M</span><span class="o">]</span>
</code></pre></div>
<p>and then says that it cannot prove the result.  Although, it is getting late, so I may be doing something silly!</p>



<a name="229024262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229024262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229024262">(Mar 05 2021 at 21:02)</a>:</h4>
<p>It seems that making these assumptions creates new instances for what should already be there and then Lean gets stuck on using them and does not find a compatibility among them.  Or maybe, this is what I think at the moment...</p>



<a name="229024430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229024430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229024430">(Mar 05 2021 at 21:04)</a>:</h4>
<p>The first of those three assumptions should be a global instance</p>



<a name="229024514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229024514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229024514">(Mar 05 2021 at 21:04)</a>:</h4>
<p>You should indeed assume the other two</p>



<a name="229024798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229024798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229024798">(Mar 05 2021 at 21:06)</a>:</h4>
<p>Indeed, what is below works!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">nnreal.to_real_hom.to_algebra</span>

<span class="kd">lemma</span> <span class="n">pointed_of_nnreal</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">module</span> <span class="n">ℝ</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">is_scalar_tower</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">ℝ</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">bv</span> <span class="o">:</span> <span class="n">is_basis</span> <span class="n">ℝ</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">pointed</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">submodule.span</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="o">(</span><span class="n">set.range</span> <span class="n">v</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">pointed_of_is_basis_is_inj</span> <span class="o">(</span><span class="n">is_inj_nonneg.pR_ocr</span> <span class="n">ℝ</span><span class="o">)</span> <span class="n">bv</span>
</code></pre></div>



<a name="229024902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229024902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229024902">(Mar 05 2021 at 21:07)</a>:</h4>
<p>Why do you think that <code>algebra =&gt; semimodule</code> and then the nnreal instances are not good?  I am not objecting, I am just trying to understand what goes wrong.</p>



<a name="229025281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229025281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229025281">(Mar 05 2021 at 21:09)</a>:</h4>
<p>I think the key observation is that instead of trying to construct the second module structure to be consistent with the first, you just assume that someone else constructed them in a suitable way</p>



<a name="229025685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229025685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229025685">(Mar 05 2021 at 21:12)</a>:</h4>
<p>Ok, to me, this seems a different convention than what happens with ℕ and ℤ.  However, I can see that maybe ℕ gets treated differently than ℝ.  Is this the case?</p>



<a name="229026123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229026123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229026123">(Mar 05 2021 at 21:15)</a>:</h4>
<p>In any case, if you think that the instance below should go into mathlib, I can PR it (or feel free to do it yourself!), although I am going to bed now, so it will be at some other point!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">nnreal.to_real_hom.to_algebra</span>
</code></pre></div>



<a name="229026356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229026356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229026356">(Mar 05 2021 at 21:17)</a>:</h4>
<p>That instance definitely belongs in mathlib IMO</p>



<a name="229027240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229027240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229027240">(Mar 05 2021 at 21:24)</a>:</h4>
<p>I would put it in <code>data/real/nnreal</code>, but there is no <code>import algebra.algebra.basis</code>: it seems too much to import a file simply to use <code>algebra</code> for this instance, though...</p>



<a name="229028134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229028134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229028134">(Mar 05 2021 at 21:31)</a>:</h4>
<p>N, Z, and Q are special because there are typeclasses for which every instance has an associated algebra - semiring, ring, and division_ring</p>



<a name="229028957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229028957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229028957">(Mar 05 2021 at 21:37)</a>:</h4>
<p>I can see that, although in the case of division ring, you should also assume char_zero.  Anyway, being the initial object of a "natural" category seems like a good place to draw the line!</p>



<a name="229042360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229042360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229042360">(Mar 05 2021 at 23:33)</a>:</h4>
<p>But all three of those algebra (and semimodule) instances cause nasty non-defeq typeclass diamonds</p>



<a name="229042505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229042505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229042505">(Mar 05 2021 at 23:34)</a>:</h4>
<p>Eg, a <code>prod</code> of two add_comm_monoids is a nat-module in two ways; by distributing the smul to the components, and by repeated addition</p>



<a name="229042795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229042795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229042795">(Mar 05 2021 at 23:38)</a>:</h4>
<p>And it only gets worse, a product <code>(M x N) x (P x Q)</code> has 5 nat-module structures, all pairwise non-defeq</p>



<a name="229067285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229067285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229067285">(Mar 06 2021 at 05:16)</a>:</h4>
<p>Eric, thank you for taking the time to explain the arguments in favour and against these <code>instances</code>!</p>



<a name="229067780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229067780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229067780">(Mar 06 2021 at 05:24)</a>:</h4>
<p>PR <a href="https://github.com/leanprover-community/mathlib/issues/6560">#6560</a></p>



<a name="229078278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229078278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229078278">(Mar 06 2021 at 08:10)</a>:</h4>
<p>Now, I guess you'll want \C to inherit that structure too...</p>



<a name="229078792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229078792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229078792">(Mar 06 2021 at 08:19)</a>:</h4>
<p>Well, I have been working with <code>ordered</code> things, so I will let <code>\C</code> be for the moment... even though Scott was adding orders on <code>\C</code>!  <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="229079101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229079101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229079101">(Mar 06 2021 at 08:23)</a>:</h4>
<p>I think <a href="https://leanprover-community.github.io/mathlib_docs/find/complex.algebra_over_reals">docs#complex.algebra_over_reals</a> should be changed to copy across any algebra structure on R, not just R itself</p>



<a name="229087853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229087853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229087853">(Mar 06 2021 at 10:47)</a>:</h4>
<p>Attempted in <a href="https://github.com/leanprover-community/mathlib/issues/6562">#6562</a></p>



<a name="229091152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229091152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229091152">(Mar 06 2021 at 11:41)</a>:</h4>
<p>Oooh, I see that this PR is also spraling... I hope that it will be easier than the other <code>instance</code> explosion.</p>



<a name="229091227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229091227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229091227">(Mar 06 2021 at 11:42)</a>:</h4>
<p>But your observation that <code>ℕ</code> and <code>ℤ</code> are treated specially is salient, as that's where most of the pain in that PR is coming from</p>



<a name="229091379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229091379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229091379">(Mar 06 2021 at 11:45)</a>:</h4>
<p>Much to my surprise, CI passes already!</p>



<a name="229092340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229092340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229092340">(Mar 06 2021 at 12:00)</a>:</h4>
<p>I really find these conversations very useful!  Thank you for explaining the "Lean translation"  of "initial objects in a category".</p>
<p>And I am happy that this is also helpful for the development of the API that you are carrying forward!</p>
<p>Of course, in maths I am also used to making any ring R special/initial, by considering the category of all R-algebras.  I can accept that this may not have the status of a "global" instance in Lean.</p>



<a name="229093507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229093507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229093507">(Mar 06 2021 at 12:18)</a>:</h4>
<p>And thank you for teaching me some category theory words to describe the lean!</p>



<a name="229775887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rings%20from%20subtype/near/229775887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rings.20from.20subtype.html#229775887">(Mar 11 2021 at 01:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/rings.20from.20subtype/near/229078278">said</a>:</p>
<blockquote>
<p>Now, I guess you'll want \C to inherit that structure too...</p>
</blockquote>
<p>As of just now, you should find an <code>algebra ℝ≥0  ℂ</code> instance</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
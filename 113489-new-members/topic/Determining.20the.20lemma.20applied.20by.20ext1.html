---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html">Determining the lemma applied by ext1</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="200761487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200761487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200761487">(Jun 13 2020 at 11:16)</a>:</h4>
<p>I've a tactic-mode proof that uses <code>ext1</code>, and I'd like to know exactly which lemma was applied. Is there an easy way to find out?</p>



<a name="200761562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200761562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200761562">(Jun 13 2020 at 11:17)</a>:</h4>
<p>The specific transformation I'm trying to find is the one that simplifies the goal from<code>λ x, y = λ x, z</code> to <code>y = z</code></p>



<a name="200761678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200761678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200761678">(Jun 13 2020 at 11:20)</a>:</h4>
<p>you can <code>#print</code> a lemma to see the term</p>



<a name="200761684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200761684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200761684">(Jun 13 2020 at 11:20)</a>:</h4>
<p>to answer the question directly, i think you're looking for the name <code>funext</code></p>



<a name="200761688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200761688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200761688">(Jun 13 2020 at 11:20)</a>:</h4>
<p>But I don't know the lemma to print - <code>ext1</code> is picking a lemma for me, isn't it?</p>



<a name="200761694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200761694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200761694">(Jun 13 2020 at 11:21)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">z</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">show_term</span><span class="o">{</span> <span class="n">ext1</span> <span class="o">},</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>



<a name="200761706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200761706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200761706">(Jun 13 2020 at 11:21)</a>:</h4>
<p>Excellent, thanks!</p>



<a name="200761757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200761757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200761757">(Jun 13 2020 at 11:23)</a>:</h4>
<p>How do I go from that term-mode expression to a tactic-mode line I can replace ext1 with?</p>



<a name="200761799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200761799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200761799">(Jun 13 2020 at 11:24)</a>:</h4>
<p>are you asking the general question "how i do enter a term into a tactic mode proof?" I think the answer is <code>exact</code></p>



<a name="200761805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200761805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200761805">(Jun 13 2020 at 11:24)</a>:</h4>
<p>That only works as the terminal step of a proof though, right?</p>



<a name="200761810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200761810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200761810">(Jun 13 2020 at 11:25)</a>:</h4>
<p>For now, I'm looking for a way to replace the tactic <code>ext1</code> with something more precise.</p>



<a name="200761813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200761813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200761813">(Jun 13 2020 at 11:25)</a>:</h4>
<p><code>apply funext</code> doesn't quite seem to be the same.</p>



<a name="200761821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200761821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200761821">(Jun 13 2020 at 11:25)</a>:</h4>
<p>Well here is the full term mode proof</p>



<a name="200761823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200761823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200761823">(Jun 13 2020 at 11:25)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">mwe</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">:</span><span class="n">β</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">:</span><span class="n">β</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">ext</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">mwe</span>
</code></pre></div>



<a name="200761833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200761833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200761833">(Jun 13 2020 at 11:26)</a>:</h4>
<p>the output of the print is</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">mwe</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span> <span class="bp">→</span> <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span><span class="o">),</span> <span class="n">funext</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">h</span><span class="o">)</span>
</code></pre></div>



<a name="200761878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200761878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200761878">(Jun 13 2020 at 11:26)</a>:</h4>
<p>the heart of the proof is the term <code>funext (λ (x : β), h)</code></p>



<a name="200761931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200761931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200761931">(Jun 13 2020 at 11:28)</a>:</h4>
<p>I think in this particular case, I was looking for the answer</p>
<div class="codehilite"><pre><span></span><code><span class="n">apply</span> <span class="n">funext</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">x_1</span><span class="o">,</span>
</code></pre></div>


<p>as the equivalent of what <code>ext1</code> was doing</p>



<a name="200761937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200761937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200761937">(Jun 13 2020 at 11:29)</a>:</h4>
<p>yes, I think the <code>#print</code> statement tells you that</p>



<a name="200761989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200761989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200761989">(Jun 13 2020 at 11:30)</a>:</h4>
<p>Thanks for the help, anyway.</p>



<a name="200762020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200762020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200762020">(Jun 13 2020 at 11:30)</a>:</h4>
<p>there's no general algorithm for translating a term-mode proof into an "idiomatic" tactic proof</p>



<a name="200762087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200762087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200762087">(Jun 13 2020 at 11:32)</a>:</h4>
<p>i think most people here only care about proofs up to an equivalence relation "how fast does it run, how well can you understand what's happening by reading it, how robust is it to minor changes in the underlying libraries"<br>
(I might be missing something)</p>



<a name="200762140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200762140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200762140">(Jun 13 2020 at 11:34)</a>:</h4>
<p>(so we have good tooling to answer those kinds of questions, and may not have good tooling to answer other kinds of questions about proofs)</p>



<a name="200762746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200762746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200762746">(Jun 13 2020 at 11:52)</a>:</h4>
<p><code>show_term</code> will print terms with placeholders, so if it's it isn't the final step in a proof, you can use <code>refine ...</code>, replacing <code>...</code> with the output of <code>show_term</code>.</p>



<a name="200762747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200762747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200762747">(Jun 13 2020 at 11:52)</a>:</h4>
<p>Of course, many tactics will produce proof terms that you would not want to copy and paste.</p>



<a name="200762916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200762916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200762916">(Jun 13 2020 at 11:57)</a>:</h4>
<p>I'm finding some irritating behavior with <code>show_term</code>. I'd assumed that if I have a term like<br>
<code>(begin show_term{ some, tactics, } end)</code>, then I can replace the whole thing with the output of show_term. In my case though, doing so gives an error</p>



<a name="200762975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200762975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200762975">(Jun 13 2020 at 11:59)</a>:</h4>
<p>well you don't want to place a raw term inside of your tactic script. is the problem that you can't make it work even with refine?</p>



<a name="200762976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200762976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200762976">(Jun 13 2020 at 11:59)</a>:</h4>
<p>do you want to show an example?</p>



<a name="200763036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200763036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200763036">(Jun 13 2020 at 12:00)</a>:</h4>
<p>oh, i see, you got to the end of the proof and show_term isn't giving you a complete proof</p>



<a name="200763038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200763038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200763038">(Jun 13 2020 at 12:01)</a>:</h4>
<p>Yeah, was just constructing the MWE</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="n">def</span> <span class="n">comp</span> <span class="o">(</span><span class="n">τ</span> <span class="n">σ</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">τ</span> <span class="n">a</span> <span class="n">c</span> <span class="bp">∧</span> <span class="n">σ</span> <span class="n">c</span> <span class="n">b</span>
<span class="kn">notation</span> <span class="n">τ</span> <span class="err">∘</span> <span class="n">σ</span> <span class="o">:=</span> <span class="n">comp</span> <span class="n">τ</span> <span class="n">σ</span>

<span class="c">/-</span><span class="cm"> Prove that composition is associative -/</span>
<span class="kn">theorem</span> <span class="n">comp_assoc</span> <span class="o">:</span> <span class="bp">@</span><span class="n">associative</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="n">comp</span> <span class="o">:=</span>
    <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">funext</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a_1</span><span class="o">,</span> <span class="n">funext</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b_1</span><span class="o">,</span> <span class="o">(</span><span class="n">iff</span><span class="bp">.</span><span class="n">to_eq</span> <span class="err">$</span> <span class="n">iff</span><span class="bp">.</span><span class="n">intro</span>
        <span class="o">(</span><span class="k">begin</span>
            <span class="n">show_term</span><span class="o">{</span>
                <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">z</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">rxy</span><span class="o">,</span> <span class="n">syz</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">tzw</span><span class="bp">⟩</span><span class="o">,</span>
                <span class="n">exact</span> <span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">y</span> <span class="err">$</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">rxy</span> <span class="err">$</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">z</span> <span class="err">$</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">syz</span> <span class="n">tzw</span><span class="o">)</span>
            <span class="o">}</span>
        <span class="kn">end</span><span class="o">)</span>
        <span class="o">(</span><span class="k">begin</span>
            <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">rxy</span><span class="o">,</span> <span class="n">z</span><span class="o">,</span> <span class="n">syz</span><span class="o">,</span> <span class="n">tzw</span><span class="bp">⟩</span><span class="o">,</span>
            <span class="n">exact</span> <span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">z</span> <span class="err">$</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">y</span> <span class="err">$</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">rxy</span> <span class="n">syz</span><span class="o">)</span> <span class="n">tzw</span><span class="o">)</span>
        <span class="kn">end</span><span class="o">)</span>
    <span class="o">)))</span>
</code></pre></div>


<p>If I replace the first <code>(begin ...  end)</code> with the result of the <code>show_term</code> within it:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">λ</span> <span class="o">(</span><span class="n">a_2</span> <span class="o">:</span> <span class="o">((</span><span class="n">a</span> <span class="err">∘</span> <span class="n">b</span><span class="o">)</span> <span class="err">∘</span> <span class="n">c</span><span class="o">)</span> <span class="n">a_1</span> <span class="n">b_1</span><span class="o">),</span>
  <span class="n">Exists</span><span class="bp">.</span><span class="n">dcases_on</span> <span class="n">a_2</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a_2_h</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="err">∘</span> <span class="n">b</span><span class="o">)</span> <span class="n">a_1</span> <span class="n">z</span> <span class="bp">∧</span> <span class="n">c</span> <span class="n">z</span> <span class="n">b_1</span><span class="o">),</span>
       <span class="n">a_2_h</span><span class="bp">.</span><span class="n">dcases_on</span>
         <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a_2_h_left</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="err">∘</span> <span class="n">b</span><span class="o">)</span> <span class="n">a_1</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">tzw</span> <span class="o">:</span> <span class="n">c</span> <span class="n">z</span> <span class="n">b_1</span><span class="o">),</span>
            <span class="n">Exists</span><span class="bp">.</span><span class="n">dcases_on</span> <span class="n">a_2_h_left</span>
              <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a_2_h_left_h</span> <span class="o">:</span> <span class="n">a</span> <span class="n">a_1</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">b</span> <span class="n">y</span> <span class="n">z</span><span class="o">),</span>
                 <span class="n">a_2_h_left_h</span><span class="bp">.</span><span class="n">dcases_on</span>
                   <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">rxy</span> <span class="o">:</span> <span class="n">a</span> <span class="n">a_1</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">syz</span> <span class="o">:</span> <span class="n">b</span> <span class="n">y</span> <span class="n">z</span><span class="o">),</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">y</span> <span class="bp">⟨</span><span class="n">rxy</span><span class="o">,</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">z</span> <span class="bp">⟨</span><span class="n">syz</span><span class="o">,</span> <span class="n">tzw</span><span class="bp">⟩⟩</span><span class="o">))))</span>
</code></pre></div>


<p>I get the error</p>
<div class="codehilite"><pre><span></span><code>invalid &#39;Exists.dcases_on&#39; application, elaborator has special support for this kind of application (it is handled as an &quot;eliminator&quot;), but expected type must not contain metavariables
</code></pre></div>



<a name="200763093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200763093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200763093">(Jun 13 2020 at 12:02)</a>:</h4>
<p>(deleted)</p>



<a name="200763234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200763234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200763234">(Jun 13 2020 at 12:07)</a>:</h4>
<p>This is taken from <a href="https://www.codewars.com/kata/5ea9b14c9b7bf50001b88e55/train/lean">https://www.codewars.com/kata/5ea9b14c9b7bf50001b88e55/train/lean</a>, where I don't appear to have <code>rintros</code> available to me, so I was trying to work out the replacement.</p>



<a name="200763285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200763285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200763285">(Jun 13 2020 at 12:08)</a>:</h4>
<p><code>rintros</code> should work fine on codewars, as long as you have <code>import tactic</code></p>



<a name="200763287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200763287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200763287">(Jun 13 2020 at 12:08)</a>:</h4>
<p>disclaimer: I personally have spent no time trying to build long term proofs<br>
I think the way that people build long term proofs is with holes</p>



<a name="200763294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200763294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200763294">(Jun 13 2020 at 12:09)</a>:</h4>
<p>codewars is running... lean community 3.11? with the last mathlib that was published before 3.12?</p>



<a name="200763298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200763298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200763298">(Jun 13 2020 at 12:09)</a>:</h4>
<p><code>rintros</code> is a lot older than that I think</p>



<a name="200763342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200763342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200763342">(Jun 13 2020 at 12:10)</a>:</h4>
<p>Whoops, typo as <code>import tactics</code>.</p>
<p>Still, would like to understand what rintros is doing for me in that example</p>



<a name="200763348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200763348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200763348">(Jun 13 2020 at 12:10)</a>:</h4>
<p>But it's hard to do so when the supposed <code>show_term</code> replacement doesn't actually work</p>



<a name="200763349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200763349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200763349">(Jun 13 2020 at 12:10)</a>:</h4>
<p><code>rintros</code> is <code>intros, rcases</code><br>
(so you can make the terms a little shorter and get to the truth more quickly by focusing in on the <code>rcases</code> part)</p>



<a name="200763887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200763887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200763887">(Jun 13 2020 at 12:25)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> <code>rcases</code> is doing repeated <code>cases</code>. <code>cases</code> , even recursive <code>cases</code>, can be mimicked in term mode using <code>let &lt;x, y, z, ...&gt; = proof in proof</code></p>



<a name="200764277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200764277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200764277">(Jun 13 2020 at 12:35)</a>:</h4>
<p>Here's an even simpler reproduction of <code>show_term</code> failing:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="n">def</span> <span class="n">comp</span> <span class="o">(</span><span class="n">τ</span> <span class="n">σ</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">τ</span> <span class="n">a</span> <span class="n">c</span> <span class="bp">∧</span> <span class="n">σ</span> <span class="n">c</span> <span class="n">b</span>
<span class="kn">notation</span> <span class="n">τ</span> <span class="err">∘</span> <span class="n">σ</span> <span class="o">:=</span> <span class="n">comp</span> <span class="n">τ</span> <span class="n">σ</span>

<span class="kn">theorem</span> <span class="n">show_term_doesnt_work</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">a_1</span> <span class="n">b_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
<span class="o">((</span><span class="n">a</span> <span class="err">∘</span> <span class="n">b</span><span class="o">)</span> <span class="err">∘</span> <span class="n">c</span><span class="o">)</span> <span class="n">a_1</span> <span class="n">b_1</span> <span class="bp">→</span> <span class="o">(</span><span class="n">a</span> <span class="err">∘</span> <span class="n">b</span> <span class="err">∘</span> <span class="n">c</span><span class="o">)</span> <span class="n">a_1</span> <span class="n">b_1</span> <span class="o">:=</span>
    <span class="o">(</span><span class="k">begin</span>
        <span class="n">show_term</span><span class="o">{</span>
            <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">z</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">rxy</span><span class="o">,</span> <span class="n">syz</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">tzw</span><span class="bp">⟩</span><span class="o">,</span>
            <span class="n">exact</span> <span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">y</span> <span class="err">$</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">rxy</span> <span class="err">$</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">z</span> <span class="err">$</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">syz</span> <span class="n">tzw</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="kn">end</span><span class="o">)</span>
</code></pre></div>


<p>The result of <code>show_term</code>is the same as above, but when you actually use the suggested term as</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="n">def</span> <span class="n">comp</span> <span class="o">(</span><span class="n">τ</span> <span class="n">σ</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">τ</span> <span class="n">a</span> <span class="n">c</span> <span class="bp">∧</span> <span class="n">σ</span> <span class="n">c</span> <span class="n">b</span>
<span class="kn">notation</span> <span class="n">τ</span> <span class="err">∘</span> <span class="n">σ</span> <span class="o">:=</span> <span class="n">comp</span> <span class="n">τ</span> <span class="n">σ</span>

<span class="kn">theorem</span> <span class="n">show_term_doesnt_work</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">a_1</span> <span class="n">b_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
<span class="o">((</span><span class="n">a</span> <span class="err">∘</span> <span class="n">b</span><span class="o">)</span> <span class="err">∘</span> <span class="n">c</span><span class="o">)</span> <span class="n">a_1</span> <span class="n">b_1</span> <span class="bp">→</span> <span class="o">(</span><span class="n">a</span> <span class="err">∘</span> <span class="n">b</span> <span class="err">∘</span> <span class="n">c</span><span class="o">)</span> <span class="n">a_1</span> <span class="n">b_1</span> <span class="o">:=</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a_2</span> <span class="o">:</span> <span class="o">((</span><span class="n">a</span> <span class="err">∘</span> <span class="n">b</span><span class="o">)</span> <span class="err">∘</span> <span class="n">c</span><span class="o">)</span> <span class="n">a_1</span> <span class="n">b_1</span><span class="o">),</span>
      <span class="n">Exists</span><span class="bp">.</span><span class="n">dcases_on</span> <span class="n">a_2</span>
        <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a_2_h</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="err">∘</span> <span class="n">b</span><span class="o">)</span> <span class="n">a_1</span> <span class="n">z</span> <span class="bp">∧</span> <span class="n">c</span> <span class="n">z</span> <span class="n">b_1</span><span class="o">),</span>
           <span class="n">a_2_h</span><span class="bp">.</span><span class="n">dcases_on</span>
             <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a_2_h_left</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="err">∘</span> <span class="n">b</span><span class="o">)</span> <span class="n">a_1</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">tzw</span> <span class="o">:</span> <span class="n">c</span> <span class="n">z</span> <span class="n">b_1</span><span class="o">),</span>
                <span class="n">Exists</span><span class="bp">.</span><span class="n">dcases_on</span> <span class="n">a_2_h_left</span>
                  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a_2_h_left_h</span> <span class="o">:</span> <span class="n">a</span> <span class="n">a_1</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">b</span> <span class="n">y</span> <span class="n">z</span><span class="o">),</span>
                     <span class="n">a_2_h_left_h</span><span class="bp">.</span><span class="n">dcases_on</span>
                       <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">rxy</span> <span class="o">:</span> <span class="n">a</span> <span class="n">a_1</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">syz</span> <span class="o">:</span> <span class="n">b</span> <span class="n">y</span> <span class="n">z</span><span class="o">),</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">y</span> <span class="bp">⟨</span><span class="n">rxy</span><span class="o">,</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">z</span> <span class="bp">⟨</span><span class="n">syz</span><span class="o">,</span> <span class="n">tzw</span><span class="bp">⟩⟩</span><span class="o">)))))</span>
</code></pre></div>


<p>You get the same error as above,</p>
<div class="codehilite"><pre><span></span><code><span class="n">invalid</span> <span class="err">&#39;</span><span class="n">Exists</span><span class="bp">.</span><span class="n">dcases_on&#39;</span> <span class="n">application</span><span class="o">,</span> <span class="n">elaborator</span> <span class="n">has</span> <span class="n">special</span> <span class="n">support</span> <span class="n">for</span> <span class="n">this</span> <span class="n">kind</span> <span class="n">of</span> <span class="n">application</span> <span class="o">(</span><span class="n">it</span> <span class="n">is</span> <span class="n">handled</span> <span class="n">as</span> <span class="n">an</span> <span class="s2">&quot;eliminator&quot;</span><span class="o">),</span> <span class="n">but</span> <span class="n">expected</span> <span class="n">type</span> <span class="n">must</span> <span class="n">not</span> <span class="n">contain</span> <span class="n">metavariables</span>
</code></pre></div>



<a name="200764327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200764327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200764327">(Jun 13 2020 at 12:36)</a>:</h4>
<p>It's not that <code>show_term</code> is failing--it printed what I assume is the actual proof term; it's just that Lean can't actually re-elaborate it</p>



<a name="200764339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200764339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200764339">(Jun 13 2020 at 12:36)</a>:</h4>
<p>Can you explain why some terms can't be re-elaborated?</p>



<a name="200764341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200764341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200764341">(Jun 13 2020 at 12:36)</a>:</h4>
<p>Because the default is to hide implicit arguments like all the induction motives, but for whatever reason Lean can't re-infer them</p>



<a name="200764350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200764350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200764350">(Jun 13 2020 at 12:37)</a>:</h4>
<p>If you use <code>set_option pp.all true</code> then you would get a term more likely to round-trip</p>



<a name="200764396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200764396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200764396">(Jun 13 2020 at 12:38)</a>:</h4>
<p>Thanks, that did the trick. It would be nice if <code>show_term</code> could only put in the information that lean needs to round-trip</p>



<a name="200764407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200764407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200764407">(Jun 13 2020 at 12:38)</a>:</h4>
<p>It's hard enough to consistently render a string that Lean will be able to re-elaborate, but by default it's trying to produce somthing vaguely human-readable as well and then the problem is basically impossible.</p>



<a name="200764487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200764487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200764487">(Jun 13 2020 at 12:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1/near/200764396">said</a>:</p>
<blockquote>
<p>the information that lean needs to round-trip</p>
</blockquote>
<p>For this to be well-defined the elaboration has to have some kind of locality property which I'm not sure is true in practice.</p>



<a name="200764506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200764506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200764506">(Jun 13 2020 at 12:41)</a>:</h4>
<p>In other words: could adding more information in a deep sub-term affect the elaboration of some outer part of the structure? I suspect so, and then the search space for this kind of thing would be huge.</p>



<a name="200764941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200764941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200764941">(Jun 13 2020 at 12:52)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> I thought you just wanted to see the term to see which lemmas had been used? Making the pretty printer an inverse of the elaborator is a much harder problem</p>



<a name="200765008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200765008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200765008">(Jun 13 2020 at 12:54)</a>:</h4>
<p>Actually, I think the specific problem here is that lean is using projection notation for <code>elab_as_eliminator</code> functions</p>



<a name="200765015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200765015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200765015">(Jun 13 2020 at 12:55)</a>:</h4>
<p>which basically never works</p>



<a name="200765023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200765023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200765023">(Jun 13 2020 at 12:55)</a>:</h4>
<p>you can locally fix this by setting some option</p>



<a name="200765118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Determining%20the%20lemma%20applied%20by%20ext1/near/200765118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Determining.20the.20lemma.20applied.20by.20ext1.html#200765118">(Jun 13 2020 at 12:57)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="n">def</span> <span class="n">comp</span> <span class="o">(</span><span class="n">τ</span> <span class="n">σ</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">τ</span> <span class="n">a</span> <span class="n">c</span> <span class="bp">∧</span> <span class="n">σ</span> <span class="n">c</span> <span class="n">b</span>
<span class="kn">notation</span> <span class="n">τ</span> <span class="err">∘</span> <span class="n">σ</span> <span class="o">:=</span> <span class="n">comp</span> <span class="n">τ</span> <span class="n">σ</span>

<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">structure_projections</span> <span class="n">false</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">a_1</span> <span class="n">b_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
<span class="o">((</span><span class="n">a</span> <span class="err">∘</span> <span class="n">b</span><span class="o">)</span> <span class="err">∘</span> <span class="n">c</span><span class="o">)</span> <span class="n">a_1</span> <span class="n">b_1</span> <span class="bp">→</span> <span class="o">(</span><span class="n">a</span> <span class="err">∘</span> <span class="n">b</span> <span class="err">∘</span> <span class="n">c</span><span class="o">)</span> <span class="n">a_1</span> <span class="n">b_1</span> <span class="o">:=</span>
    <span class="o">(</span><span class="k">begin</span>
        <span class="n">show_term</span><span class="o">{</span>
            <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">z</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">rxy</span><span class="o">,</span> <span class="n">syz</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">tzw</span><span class="bp">⟩</span><span class="o">,</span>
            <span class="n">exact</span> <span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">y</span> <span class="err">$</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">rxy</span> <span class="err">$</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">z</span> <span class="err">$</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">syz</span> <span class="n">tzw</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="kn">end</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">a_1</span> <span class="n">b_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
<span class="o">((</span><span class="n">a</span> <span class="err">∘</span> <span class="n">b</span><span class="o">)</span> <span class="err">∘</span> <span class="n">c</span><span class="o">)</span> <span class="n">a_1</span> <span class="n">b_1</span> <span class="bp">→</span> <span class="o">(</span><span class="n">a</span> <span class="err">∘</span> <span class="n">b</span> <span class="err">∘</span> <span class="n">c</span><span class="o">)</span> <span class="n">a_1</span> <span class="n">b_1</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="n">a_2</span> <span class="o">:</span> <span class="o">((</span><span class="n">a</span> <span class="err">∘</span> <span class="n">b</span><span class="o">)</span> <span class="err">∘</span> <span class="n">c</span><span class="o">)</span> <span class="n">a_1</span> <span class="n">b_1</span><span class="o">),</span>
  <span class="n">Exists</span><span class="bp">.</span><span class="n">dcases_on</span> <span class="n">a_2</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a_2_h</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="err">∘</span> <span class="n">b</span><span class="o">)</span> <span class="n">a_1</span> <span class="n">z</span> <span class="bp">∧</span> <span class="n">c</span> <span class="n">z</span> <span class="n">b_1</span><span class="o">),</span>
       <span class="n">and</span><span class="bp">.</span><span class="n">dcases_on</span> <span class="n">a_2_h</span>
         <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a_2_h_left</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="err">∘</span> <span class="n">b</span><span class="o">)</span> <span class="n">a_1</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">tzw</span> <span class="o">:</span> <span class="n">c</span> <span class="n">z</span> <span class="n">b_1</span><span class="o">),</span>
            <span class="n">Exists</span><span class="bp">.</span><span class="n">dcases_on</span> <span class="n">a_2_h_left</span>
              <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a_2_h_left_h</span> <span class="o">:</span> <span class="n">a</span> <span class="n">a_1</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">b</span> <span class="n">y</span> <span class="n">z</span><span class="o">),</span>
                 <span class="n">and</span><span class="bp">.</span><span class="n">dcases_on</span> <span class="n">a_2_h_left_h</span>
                   <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">rxy</span> <span class="o">:</span> <span class="n">a</span> <span class="n">a_1</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">syz</span> <span class="o">:</span> <span class="n">b</span> <span class="n">y</span> <span class="n">z</span><span class="o">),</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">y</span> <span class="bp">⟨</span><span class="n">rxy</span><span class="o">,</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">z</span> <span class="bp">⟨</span><span class="n">syz</span><span class="o">,</span> <span class="n">tzw</span><span class="bp">⟩⟩</span><span class="o">))))</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
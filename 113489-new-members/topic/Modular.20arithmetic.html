---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Modular.20arithmetic.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html">Modular arithmetic</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="221454183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221454183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nerya <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221454183">(Jan 03 2021 at 14:52)</a>:</h4>
<p>hello,<br>
in the last few weeks i have learnd lean and now i want to start proving thing in Modular arithmetic up to Chinese remainder theorem, and hopefully to prove the whole rsa system, is there any libraries already written about that? <br>
thank you very much</p>



<a name="221454415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221454415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221454415">(Jan 03 2021 at 14:57)</a>:</h4>
<p>well we have the ring-theoretic version of the Chinese Remainder Theorem (written by yours truly!) if that helps</p>



<a name="221456885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221456885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221456885">(Jan 03 2021 at 15:51)</a>:</h4>
<p>Of course that doesn't stop you proving it again, especially if you want some practice :-) I would recommend working with integers rather than naturals.</p>



<a name="221457811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221457811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221457811">(Jan 03 2021 at 16:11)</a>:</h4>
<p>Since you mention RSA, you might be interested in <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.modeq.pow_totient">docs#nat.modeq.pow_totient</a></p>



<a name="221457911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221457911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221457911">(Jan 03 2021 at 16:13)</a>:</h4>
<p>I'm sure we also have the multiplicativity of the totient function, but I can't find it right now...</p>



<a name="221457915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221457915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221457915">(Jan 03 2021 at 16:13)</a>:</h4>
<p>Perhaps a place to start is that <code>totient</code> is multiplicative? Do we have that? I can't immediately spot it. How will one prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>p</mi><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>q</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi(pq)=(p-1)(q-1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϕ</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>?</p>



<a name="221457967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221457967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221457967">(Jan 03 2021 at 16:14)</a>:</h4>
<p>Ok maybe I'm not so sure <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="221457988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221457988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nerya <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221457988">(Jan 03 2021 at 16:15)</a>:</h4>
<p>wow i can see you done a lot of fine work already, lets see if i can find myself in there</p>



<a name="221457990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221457990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221457990">(Jan 03 2021 at 16:15)</a>:</h4>
<p>The maths proof would be to prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><mi>n</mi><mi mathvariant="double-struck">Z</mi><msup><mo stretchy="false">)</mo><mo>×</mo></msup><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\phi(n)=|(\mathbb{Z}/n\mathbb{Z})^\times|</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϕ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.021331em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mopen">(</span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span> and to use ring CRT</p>



<a name="221458562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221458562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221458562">(Jan 03 2021 at 16:27)</a>:</h4>
<p>Oh yeah this should be easy since we have CRT and <a href="https://leanprover-community.github.io/mathlib_docs/find/zmod.card_units_eq_totient">docs#zmod.card_units_eq_totient</a></p>



<a name="221459119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221459119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221459119">(Jan 03 2021 at 16:39)</a>:</h4>
<p>Is <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.modeq.chinese_remainder">docs#nat.modeq.chinese_remainder</a> the nat version of CRT? Looks like it to me.</p>



<a name="221459286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221459286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221459286">(Jan 03 2021 at 16:42)</a>:</h4>
<p>This is the actual theorem<br>
<a href="https://leanprover-community.github.io/mathlib_docs/find/nat.modeq.modeq_and_modeq_iff_modeq_mul">docs#nat.modeq.modeq_and_modeq_iff_modeq_mul</a></p>



<a name="221459393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221459393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221459393">(Jan 03 2021 at 16:45)</a>:</h4>
<p>But you need the statements about the cardinality of units for the multiplicativity of totient, and I think it would be annoying to use this version to prove that</p>



<a name="221518432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221518432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arcayn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221518432">(Jan 04 2021 at 12:39)</a>:</h4>
<p>This is really spooky as I haven't seen this but just proved RSA over the weekend</p>



<a name="221518567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221518567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arcayn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221518567">(Jan 04 2021 at 12:40)</a>:</h4>
<p>I needed to prove multiplicativity for it plus values on prime inputs, I will potentially PR it although the naive number-theoretic approach is possibly less valuable than using the ring theortic version of the CRT</p>



<a name="221518903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221518903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221518903">(Jan 04 2021 at 12:45)</a>:</h4>
<p>What exactly did you prove? PS I assume you're the person who told me they'd done this on the Discord earlier ;-)</p>



<a name="221519819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221519819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arcayn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221519819">(Jan 04 2021 at 12:56)</a>:</h4>
<p>Yes I am ! let me just post the theorem statement here - I imagine you could make a more powerful version which doesn't require the private key d to be provided but I didn't really want to mess around with switching between nat and zmod to find modular inverses etc. at the moment as I'm still fairly new :) </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">rsa_is_correct</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="n">m</span> <span class="n">e</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h_e</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span>  <span class="o">(</span><span class="n">h_p</span> <span class="o">:</span> <span class="n">p.prime</span><span class="o">)</span> <span class="o">(</span><span class="n">h_q</span> <span class="o">:</span> <span class="n">q.prime</span><span class="o">)</span> <span class="o">(</span><span class="n">p_neq_q</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≠</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h_1</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">*</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">totient.modeq</span> <span class="o">(</span><span class="n">e</span> <span class="bp">*</span> <span class="n">d</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">p</span> <span class="bp">*</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">modeq</span> <span class="o">((</span><span class="n">m</span> <span class="bp">^</span> <span class="n">e</span><span class="o">)</span> <span class="bp">^</span> <span class="n">d</span><span class="o">)</span> <span class="n">m</span>
</code></pre></div>



<a name="221520107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221520107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arcayn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221520107">(Jan 04 2021 at 12:59)</a>:</h4>
<p>And just for the sake of completeness</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mul_totient</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a.coprime</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">totient</span> <span class="bp">=</span> <span class="n">a.totient</span> <span class="bp">*</span> <span class="n">b.totient</span>
</code></pre></div>



<a name="221520623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221520623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221520623">(Jan 04 2021 at 13:04)</a>:</h4>
<p>Nice! These, and also evaluation of totient function on prime powers, would surely be welcome additions to mathlib.</p>



<a name="221520685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221520685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arcayn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221520685">(Jan 04 2021 at 13:05)</a>:</h4>
<p>(note that this is the version of the proof that does not require m to be coprime to n and doesn't invoke <code>nat.modeq.pow_totient</code> but instead <code>zmod.units_pow_card_sub_one_eq_one</code>. If we base this proof on Euler's theorem, afaik we would not need multiplicativity of phi)</p>



<a name="221520860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221520860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arcayn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221520860">(Jan 04 2021 at 13:06)</a>:</h4>
<p>Yes, I also proved</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">prime_totient</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a.prime</span><span class="o">)</span> <span class="o">:</span> <span class="n">a.totient</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">-</span> <span class="mi">1</span>
</code></pre></div>
<p>Which is trivially extensible to prime powers i think</p>



<a name="221521346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/221521346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#221521346">(Jan 04 2021 at 13:12)</a>:</h4>
<p>It sounds like you should be able to redefine <code>totient</code> as an <code>arithmetic_function</code>, and provide <code>totient_is_multiplicative : totient.is_multiplicative</code></p>



<a name="289297593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/289297593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mark Gerads <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#289297593">(Jul 12 2022 at 09:22)</a>:</h4>
<p>I am having trouble with modular arithmetic. How can this be proved, and can someone add this (with a better name and proof) to mathlib?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">modCongruent1</span> <span class="o">(</span><span class="n">n1</span> <span class="n">n3</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">):</span> <span class="n">n1</span> <span class="bp">%</span> <span class="n">n3</span> <span class="bp">=</span> <span class="o">(</span><span class="n">n1</span> <span class="bp">+</span> <span class="n">k</span> <span class="bp">*</span> <span class="n">n3</span><span class="o">)</span> <span class="bp">%</span> <span class="n">n3</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="289297986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/289297986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#289297986">(Jul 12 2022 at 09:26)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/int.add_mul_mod_self">docs#int.add_mul_mod_self</a></p>



<a name="289298004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/289298004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#289298004">(Jul 12 2022 at 09:27)</a>:</h4>
<p><span class="user-mention" data-user-id="385848">@Mark Gerads</span>, did you try <code>library_search</code>?</p>



<a name="289298041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/289298041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#289298041">(Jul 12 2022 at 09:27)</a>:</h4>
<p>Too late, <code>yael_search</code> was triggered <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="289298503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/289298503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mark Gerads <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#289298503">(Jul 12 2022 at 09:32)</a>:</h4>
<p>I tried library_search with 'import all'. I don't know why it wasn't found; maybe because the equation was backward?</p>



<a name="289337089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Modular%20arithmetic/near/289337089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Modular.20arithmetic.html#289337089">(Jul 12 2022 at 15:00)</a>:</h4>
<p>My instinct is to write it the other way from the way you wrote it; simplification lemmas <code>h : A = B</code> are often used with <code>rw h</code> so to make it easier to use it's nicer to have A the more complicated thing and B the simpler thing.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/induction.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html">induction</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="207225846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/207225846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#207225846">(Aug 18 2020 at 05:54)</a>:</h4>
<p>How to say this kind of induction?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span>  <span class="o">(</span><span class="n">p</span><span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">m</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">n</span> <span class="n">m</span> <span class="n">h</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">m</span> <span class="bp">-</span> <span class="n">n</span><span class="o">,</span> <span class="c1">-- it doesnt like this</span>

<span class="kn">end</span>
</code></pre></div>



<a name="207227067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/207227067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#207227067">(Aug 18 2020 at 06:24)</a>:</h4>
<p>One thing you can do is prove a related statement first, where <code>m - n</code> is replaced by a variable:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span>  <span class="o">(</span><span class="n">p</span><span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">m</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="n">key</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">k</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">n</span> <span class="n">k</span> <span class="n">h&#39;</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">k</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">id</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">k_ih</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">zero_le</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">a</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">m</span> <span class="n">h&#39;</span> <span class="n">hp</span><span class="o">,</span>
  <span class="n">convert_to</span> <span class="n">p</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="o">(</span><span class="n">m</span> <span class="bp">-</span> <span class="n">n</span><span class="o">)),</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">add_sub_of_le</span> <span class="n">h&#39;</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">key</span><span class="o">,</span>
  <span class="n">linarith</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hp</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>There's also a direct proof:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span>  <span class="o">(</span><span class="n">p</span><span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">m</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">m</span> <span class="n">h&#39;</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">m</span> <span class="n">generalizing</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">le_zero_iff_eq</span><span class="bp">.</span><span class="n">mp</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="n">exact</span> <span class="n">id</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">by_cases</span> <span class="n">h&#39;&#39;</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m_n</span><span class="bp">.</span><span class="n">succ</span><span class="o">,</span> <span class="n">rwa</span> <span class="n">h&#39;&#39;</span> <span class="n">at</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">h</span><span class="o">,</span> <span class="n">apply</span> <span class="n">m_ih</span> <span class="n">n</span> <span class="bp">_</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_eq_add_one</span> <span class="n">at</span> <span class="n">h&#39;</span> <span class="n">h&#39;&#39;</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">eq_or_lt_of_le</span> <span class="n">h&#39;</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h&#39;&#39;</span> <span class="n">h_1</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">linarith</span> <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="207227258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/207227258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#207227258">(Aug 18 2020 at 06:29)</a>:</h4>
<p>I see, thanks.</p>



<a name="207227427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/207227427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#207227427">(Aug 18 2020 at 06:32)</a>:</h4>
<p><code>induction h</code></p>



<a name="207227905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/207227905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#207227905">(Aug 18 2020 at 06:43)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">(</span><span class="n">p</span><span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">p_succ_of_p</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>

<span class="kn">example</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">m</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">n</span> <span class="n">m</span> <span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>How I can declare <code>p_succ_of_p</code> as a top-level variable and still refer to it inside the <code>example</code> proof?</p>



<a name="207228051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/207228051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#207228051">(Aug 18 2020 at 06:46)</a>:</h4>
<p>Assuming this is actually what you want to do, you can use <code>include</code></p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">(</span><span class="n">p</span><span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">p_succ_of_p</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>
<span class="n">include</span> <span class="n">p_succ_of_p</span>

<span class="kn">example</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">m</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">n</span> <span class="n">m</span> <span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="207228172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/207228172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#207228172">(Aug 18 2020 at 06:48)</a>:</h4>
<p>What is happening is that <code>variables</code> declares variables that will be auto-included if they are referred to in the statement of the lemma, definition, or example, and <code>include</code> overrides this to always include it.  You can use <code>omit</code> later to cause it to go back to the default behavior if I remember correctly.</p>



<a name="207228247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/207228247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#207228247">(Aug 18 2020 at 06:49)</a>:</h4>
<p>ah that's what I was looking for</p>



<a name="211025373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211025373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Claus-Peter Becke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211025373">(Sep 23 2020 at 16:09)</a>:</h4>
<p>What would be suitable to represent a formula of a sum as the following one:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">sum</span> <span class="n">k</span> <span class="n">between</span> <span class="n">k</span><span class="bp">=</span><span class="mi">1</span> <span class="n">and</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span> <span class="o">:=</span>
</code></pre></div>

<p>I don't find a way, if it is possible at all to try it this way, to represent the equation's left hand side of the formula.</p>



<a name="211026053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211026053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211026053">(Sep 23 2020 at 16:13)</a>:</h4>
<p>have you seen <code>algebra.big_operators</code>?</p>



<a name="211026450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211026450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Claus-Peter Becke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211026450">(Sep 23 2020 at 16:16)</a>:</h4>
<p>No, I didn't. Thank you for that hint.</p>



<a name="211093498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211093498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Claus-Peter Becke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211093498">(Sep 24 2020 at 06:19)</a>:</h4>
<p>As far as I have seen the operator sum works on finite sets. I would like to prove by induction the assertion's validity on the infinite set of natural numbers.</p>



<a name="211099232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211099232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211099232">(Sep 24 2020 at 07:55)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.big_operators</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kn">open</span> <span class="n">finset</span>

<span class="c1">-- finset.range n is the set {0,1,2, ..., n-1}</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">range</span> <span class="mi">5</span> <span class="bp">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">}</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c1">-- So finset.range n.succ is the set {0,1,2,...,n}</span>
<span class="c1">-- In this case, the extra `0` term being summed makes no difference, since</span>
<span class="c1">--  n     n</span>
<span class="c1">--  ∑ i = ∑ i</span>
<span class="c1">--  i=0   i=1</span>

<span class="c1">-- Then, we can represent</span>
<span class="c1">--  n</span>
<span class="c1">--  ∑ i</span>
<span class="c1">--  i=0</span>
<span class="c1">--</span>
<span class="c1">-- as ∑ i in (range n.succ), i</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="o">(</span><span class="n">range</span> <span class="n">n.succ</span><span class="o">),</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="211103752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211103752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211103752">(Sep 24 2020 at 08:48)</a>:</h4>
<p>Why not cast the i in the sum to a rational, in order to get that division to be mathematical division rather than some weird rounding one?</p>



<a name="211119394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211119394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Claus-Peter Becke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211119394">(Sep 24 2020 at 11:47)</a>:</h4>
<p>@Shing Tag Lam: Thank you very much for your solution which is really helpful. This is a great model for me to be studied closely to become more familiar with the techniques which are needed to deal with induction.<br>
@Kevin Buzzard: As far as I remember type-casting is used in Java writing the target type in brackets in front of the variable to be casted. Does it  work similar in Lean?</p>



<a name="211119864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211119864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Claus-Peter Becke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211119864">(Sep 24 2020 at 11:52)</a>:</h4>
<p>@Shing Tak Lam: I'm sorry for the misspelling of your name</p>



<a name="211120170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211120170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211120170">(Sep 24 2020 at 11:54)</a>:</h4>
<p><span class="user-mention" data-user-id="329867">@Claus-Peter Becke</span> If you write <code>@Shi</code> then Zulip should suggest autocompletions of the name (unless you use a nonstandard zulip client).<br>
The benefit of those auto-completed names is that the person in question gets a notification somewhere in their interface.</p>



<a name="211121711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211121711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211121711">(Sep 24 2020 at 12:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="329867">Claus-Peter Becke</span> <a href="#narrow/stream/113489-new-members/topic/induction/near/211119394">said</a>:</p>
<blockquote>
<p>@Shing Tag Lam: Thank you very much for your solution which is really helpful. This is a great model for me to be studied closely to become more familiar with the techniques which are needed to deal with induction.<br>
@Kevin Buzzard: As far as I remember type-casting is used in Java writing the target type in brackets in front of the variable to be casted. Does it  work similar in Lean?</p>
</blockquote>
<p>You can use <code>(term : type)</code> to coerce the <code>i</code> to a rational number like so:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="o">(</span><span class="n">range</span> <span class="n">n.succ</span><span class="o">),</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span> <span class="o">:=</span>
</code></pre></div>

<p>And you'll see <code>↑</code> next to the <code>n</code> in the tactic state, which is Lean coercing <code>n</code> from a <code>nat</code> to a <code>rat</code>.</p>
<p>In this specific example, natural number division isn't an issue, since <code>n * (n + 1) / 2 = (n * (n + 1)) / 2</code> and <code>n * (n + 1)</code> is always even, but in general, flooring division may not be what you want, hence Kevin is suggesting you cast it to a rational number.</p>



<a name="211127390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211127390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211127390">(Sep 24 2020 at 13:02)</a>:</h4>
<p>It is an issue in the <em>proof</em>, because you want to prove this by induction, and it will be much more horrible to work in the integers with its broken division than to work in the rationals with a division that obeys much nicer properties.</p>



<a name="211127736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211127736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211127736">(Sep 24 2020 at 13:05)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.big_operators</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kn">open</span> <span class="n">finset</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="o">(</span><span class="n">range</span> <span class="n">n.succ</span><span class="o">),</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- base case true by definition</span>
    <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- inductive step</span>
    <span class="n">rw</span> <span class="n">sum_range_succ</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hd</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">nat.succ_eq_add_one</span><span class="o">],</span>
    <span class="n">ring</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>

<p>Proof when they're rationals goes through without thinking really.</p>



<a name="211127857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211127857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211127857">(Sep 24 2020 at 13:06)</a>:</h4>
<p>Proof when they're integers will be much more of a pain, you'll have to look up specific lemmas like <code>a/b+c=(a+c*b)/b</code> etc.</p>



<a name="211129063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211129063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211129063">(Sep 24 2020 at 13:16)</a>:</h4>
<p>Fair enough, I used <code>nat.div_eq_of_eq_mul_right</code> in my nat proof, but I already knew that lemma (which transforms the problem from nat division to one in nat multiplication), but I can see how dealing with division can be a pain.</p>



<a name="211129410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211129410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211129410">(Sep 24 2020 at 13:19)</a>:</h4>
<p>I just think that this sort of argument (fighting integer division) looks bad to mathematicians (especially those who have never used computer algebra software and are totally confused by the fact that 5/2 could ever be thought of as being equal to 2 -- this never happens on a calculator).</p>



<a name="211160857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211160857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Claus-Peter Becke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211160857">(Sep 24 2020 at 17:05)</a>:</h4>
<p>Thank you both very much for these awesome explanations which will supply me with a lot of stuff to think about and to learn from.</p>



<a name="211345914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211345914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Claus-Peter Becke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211345914">(Sep 26 2020 at 06:44)</a>:</h4>
<p>Up to now I stick to the following stage of development of the proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">algebra.big_operators</span>

<span class="kn">open</span> <span class="n">nat</span>
<span class="kn">open</span> <span class="n">algebra</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">),</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">zero_mul</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">succ_mul</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">succ_add</span><span class="o">,</span>
    <span class="n">repeat</span> <span class="o">{</span><span class="n">rw</span> <span class="n">succ_eq_add_one</span><span class="o">},</span>
    <span class="n">rw</span> <span class="n">mul_succ</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">nat.left_distrib</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">nat.div_eq_of_eq_mul_right</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>

<p>The application of these tactics generates the following result:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">there</span> <span class="n">are</span> <span class="n">unsolved</span> <span class="n">goals</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">ih</span> <span class="o">:</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">range</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span>
<span class="bp">⊢</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">range</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">I</span>
</code></pre></div>

<p>The left hand side of the goal expresses the term which I would have liked to produce: (n+1)*(n+2) which shows the sum for n+1. But I fail in finding tactics to generate a solution which produces a suitable progress. The main problem I observed is that I don't have an focussed overview about the theorems which are stored in the library and which are applicable in the different contexts. Are there any exercises which help me to become more familiar with the nat-library after having finished the Natural Number Game?</p>



<a name="211346118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211346118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211346118">(Sep 26 2020 at 06:51)</a>:</h4>
<p>One strategy is to hope that the library is thorough, and use <code>library_search</code> to obtain the names of relevant lemmas. e.g. your first task to relate a sum over <code>range (n+1)</code> to a sum over <code>range n</code> and an extra term, and surely there must be a lemma doing this.</p>



<a name="211346189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211346189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211346189">(Sep 26 2020 at 06:53)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.big_operators.basic</span>

<span class="kn">open</span> <span class="n">finset</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">range</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">+</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">range</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">library_search</span>
</code></pre></div>



<a name="211346228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211346228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211346228">(Sep 26 2020 at 06:54)</a>:</h4>
<p>This finds <code>sum_range_succ</code> for you.</p>



<a name="211346241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211346241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211346241">(Sep 26 2020 at 06:54)</a>:</h4>
<p>Another strategy is to realise that all statements in mathlib are named using an excruciatingly boring scheme, which is so boring that often you can predict the name if you know what you're looking for!</p>



<a name="211346257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211346257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211346257">(Sep 26 2020 at 06:55)</a>:</h4>
<p>Since this is a lemma about the <code>sum</code> over a <code>range</code> involving a <code>succ</code>, it's not crazy (and feels much less crazy as you get used to it) to just guess <code>sum_range_succ</code> might exist. (Use #print to verify, or just <code>rw</code> by it if you're bold.)</p>



<a name="211346307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211346307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211346307">(Sep 26 2020 at 06:56)</a>:</h4>
<p>(Note also that your example wasn't quite a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> --- without an <code>open_locale</code> statement it shouldn't work.)</p>



<a name="211346636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211346636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Claus-Peter Becke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211346636">(Sep 26 2020 at 07:06)</a>:</h4>
<p>@Scott Morrison:<br>
Thank you very much for your very helpful explanations. Yes, I forgot to add the open_locale big_operators statement. I tried the library_search-tactic, too. But it didn't produce any results. That's weird. But anyway. The sum_range_succ-tactic is very helpful because it allows to rewrite the right hand side of the goal via application of the induction-hypothesis which finally will help to close the goal, I hope at least.</p>



<a name="211347294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211347294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211347294">(Sep 26 2020 at 07:25)</a>:</h4>
<p>Note that <code>sum_range_succ</code> is a <em>lemma</em>, not a <em>tactic</em>. It's worth making the distinction.</p>



<a name="211347337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211347337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211347337">(Sep 26 2020 at 07:26)</a>:</h4>
<p><code>library_search</code> only solves the exact goal it's presented with. That's why I wrote it out as an <code>example</code> rather than using it inline in your proof.</p>



<a name="211347342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211347342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211347342">(Sep 26 2020 at 07:26)</a>:</h4>
<p>(You can also use the <code>have</code> tactic to setup a temporary goal mid-proof to try <code>library_search</code> on.)</p>



<a name="211347453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211347453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Claus-Peter Becke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211347453">(Sep 26 2020 at 07:30)</a>:</h4>
<p>Yes, I know. That was a moment of thoughtlessness in the face of the nerve-wracking trials to solve the problems concerning the simplification of the applied induction hypothesis.</p>



<a name="211347693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211347693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211347693">(Sep 26 2020 at 07:37)</a>:</h4>
<p>You should cast everything to rationals so that the division becomes easier to work with</p>



<a name="211347745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211347745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Claus-Peter Becke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211347745">(Sep 26 2020 at 07:38)</a>:</h4>
<p>I tried a new example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="kd">end</span>
</code></pre></div>

<p>and the application of the have-tactic:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">have</span> <span class="n">h1</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">),</span>
</code></pre></div>

<p>In both cases Lean gave the message that 'library_search' failed after having used <code>by library_search</code></p>



<a name="211347802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211347802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211347802">(Sep 26 2020 at 07:40)</a>:</h4>
<p>well, it's very unlikely that <code>library_search</code> will help with that goal --- it's only suitable when there is a lemma in the library that gives you exactly your goal (possibly after substituting arguments from local hypotheses).</p>



<a name="211347811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211347811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211347811">(Sep 26 2020 at 07:41)</a>:</h4>
<p>And you're still using a broken division</p>



<a name="211347816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211347816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211347816">(Sep 26 2020 at 07:41)</a>:</h4>
<p>This stuff would probably be doable with a tactic if you switch to rationals</p>



<a name="211347858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211347858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211347858">(Sep 26 2020 at 07:42)</a>:</h4>
<p>In fact, you can see that this example is actually <em>false</em>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.slim_check</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">slim_check</span>
<span class="kd">end</span>
</code></pre></div>



<a name="211347862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211347862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211347862">(Sep 26 2020 at 07:42)</a>:</h4>
<p>which prints</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">===================</span>
<span class="n">Found</span> <span class="n">problems</span><span class="bp">!</span>

<span class="n">n</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="mi">2</span> <span class="bp">≠</span> <span class="mi">0</span>
<span class="c1">-------------------</span>
</code></pre></div>



<a name="211347873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211347873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211347873">(Sep 26 2020 at 07:43)</a>:</h4>
<p>(<code>slim_check</code> is very new to mathlib)</p>



<a name="211348191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211348191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Claus-Peter Becke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211348191">(Sep 26 2020 at 07:53)</a>:</h4>
<p>I observed that, too, and I wondered that Lean produces and accepts such an equation after having applied rw ih.</p>



<a name="211348237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211348237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211348237">(Sep 26 2020 at 07:54)</a>:</h4>
<p>Another problem with your variant is that <code>range n</code> is the n numbers from 0 to n-1 so what you're trying to prove is false</p>



<a name="211348248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211348248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211348248">(Sep 26 2020 at 07:55)</a>:</h4>
<p>You're also going to run into the issue that <code>x/2*2=x</code> is not true for naturals because the division is not mathematical division</p>



<a name="211348920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211348920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Claus-Peter Becke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211348920">(Sep 26 2020 at 08:15)</a>:</h4>
<p>@Kevin Buzzard: Thank you very much for your hints. I will study your solution closely and try to apply it.</p>



<a name="211349676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211349676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211349676">(Sep 26 2020 at 08:36)</a>:</h4>
<p>Another approach would be to stick with naturals but clear denominators, and prove that twice the sum is n(n+1). Remember to use range (n+1) though -- if you stay with range n then you'll have to use natural subtraction which is broken in the same way</p>



<a name="211407715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211407715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Claus-Peter Becke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211407715">(Sep 27 2020 at 09:37)</a>:</h4>
<p>The next days I will try to prove some induction-tasks, first with pen and paper, afterwards in Lean. It's very helpful to have the models which you and Shing Tak Lam posted the last days. Now I have a guide which serves as an instructor that can be varied to fit in respective contexts. To know of how to deal with sums on infinite sets and to have a collection of lemmata and tactics concerning these problems is a very good point to start from.</p>



<a name="211513409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211513409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Claus-Peter Becke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211513409">(Sep 28 2020 at 16:10)</a>:</h4>
<p>Is there any possibility to solve the following goal?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⊢</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">4</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
</code></pre></div>



<a name="211513981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211513981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211513981">(Sep 28 2020 at 16:15)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">4</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">hn</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hn</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="k">suffices</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">4</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">this</span> <span class="o">},</span>
    <span class="n">omega</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="211514297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211514297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211514297">(Sep 28 2020 at 16:18)</a>:</h4>
<p>But in general, nat subtraction is not very nice to deal with, Since <code>2 * n - 1 + 4</code> is not always equal to <code>2 * n + 3</code> (if <code>n = 0</code> LHS is <code>4</code> and RHS is <code>3</code>). In this specific example, if <code>n = 0</code>, you're multiplying by <code>0</code> so both sides do end up being equal.</p>



<a name="211514844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211514844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Claus-Peter Becke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211514844">(Sep 28 2020 at 16:23)</a>:</h4>
<p>Thank you very much. I still have some trouble with the omega expression. I'll get the message:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">eval_expr</span><span class="o">,</span> <span class="n">expression</span> <span class="n">must</span> <span class="n">be</span> <span class="n">closed</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span>
<span class="bp">⊢</span> <span class="bp">¬∑</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">range</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">k</span> <span class="bp">*</span> <span class="mi">4</span> <span class="bp">-</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">∨</span> <span class="bp">¬¬</span><span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">4</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">+</span> <span class="mi">3</span>
</code></pre></div>



<a name="211514994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211514994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211514994">(Sep 28 2020 at 16:24)</a>:</h4>
<p>Can you post what you have so far? From my experience, <code>omega</code> can be a bit fragile and additional hypotheses can stop it from working, and <code>clear</code>ing sometimes helps</p>



<a name="211515230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211515230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Claus-Peter Becke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211515230">(Sep 28 2020 at 16:26)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">algebra.big_operators</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">algebra.ring</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kn">open</span> <span class="n">finset</span>
<span class="kn">open</span> <span class="n">nat</span>
<span class="kn">open</span> <span class="n">algebra</span>

<span class="kd">variables</span> <span class="n">k</span> <span class="n">n</span> <span class="n">m</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∑</span> <span class="n">k</span> <span class="k">in</span> <span class="o">(</span><span class="n">range</span> <span class="n">n.succ</span><span class="o">),</span> <span class="o">(</span><span class="mi">4</span> <span class="bp">*</span> <span class="n">k</span> <span class="bp">-</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sum_range_succ</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">ih</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">nat.succ_eq_add_one</span><span class="o">],</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">rw</span> <span class="n">mul_add</span><span class="o">},</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">add_comm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_comm</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">add_mul</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_add</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">ring</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_comm</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">)</span> <span class="n">n</span><span class="o">,</span>
</code></pre></div>



<a name="211515765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211515765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211515765">(Sep 28 2020 at 16:30)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">algebra.big_operators</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">algebra.ring</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kn">open</span> <span class="n">finset</span>
<span class="kn">open</span> <span class="n">nat</span>
<span class="kn">open</span> <span class="n">algebra</span>

<span class="kd">variables</span> <span class="n">k</span> <span class="n">n</span> <span class="n">m</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∑</span> <span class="n">k</span> <span class="k">in</span> <span class="o">(</span><span class="n">range</span> <span class="n">n.succ</span><span class="o">),</span> <span class="o">(</span><span class="mi">4</span> <span class="bp">*</span> <span class="n">k</span> <span class="bp">-</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sum_range_succ</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">ih</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">nat.succ_eq_add_one</span><span class="o">],</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">rw</span> <span class="n">mul_add</span><span class="o">},</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">add_comm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_comm</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">add_mul</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_add</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">ring</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_comm</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">)</span> <span class="n">n</span><span class="o">,</span>
  <span class="c1">---- My part below</span>
  <span class="n">cases</span> <span class="n">n</span><span class="o">,</span> <span class="c1">-- turns out we don't need `by_cases`, just `cases` is enough</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="k">suffices</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n.succ</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">4</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n.succ</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">this</span> <span class="o">},</span>
    <span class="n">clear</span> <span class="n">ih</span><span class="o">,</span> <span class="c1">-- We don't need ih here, and omega doesn't seem to like it</span>
    <span class="n">omega</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="211516380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211516380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Claus-Peter Becke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211516380">(Sep 28 2020 at 16:34)</a>:</h4>
<p>Thank you very much. That's great. I tried a longer time to close this goal. I will look at the API to get more informations about the tactics you used which are new for me.</p>



<a name="211721947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211721947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Claus-Peter Becke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211721947">(Sep 30 2020 at 06:56)</a>:</h4>
<p><span class="user-mention" data-user-id="266440">@Shing Tak Lam</span> : In your very helpful explanations concerning the sum-formula in Lean you gave a description of the sums between limits i=0 or i=1 as the lower bound and i=n as the upper bound of the computation. If I understood you correctly that means that Lean doesn't distinguish with respect to the induction's base case between i=0 and i=1 but looks for a solution which contains i=0 or i=1. If the formula is satisfiable for one of these values the refl-tactic will close the base-case-goal. Is this correct?<br>
What can be done to change especially the lower bound if there shall be computed inequalities which hold for example only presupposing a lower bound as 3 as in the following example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∑</span> <span class="n">k</span> <span class="k">in</span> <span class="o">(</span><span class="n">range</span> <span class="n">n.succ</span><span class="o">),</span> <span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span> <span class="bp">≥</span> <span class="mi">2</span><span class="bp">*</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">3</span> <span class="o">:=</span>
</code></pre></div>



<a name="211722649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211722649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211722649">(Sep 30 2020 at 07:06)</a>:</h4>
<p>Your message is very obscure to me, but you may be looking for <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.two_step_induction">docs#nat.two_step_induction</a></p>



<a name="211722696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211722696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211722696">(Sep 30 2020 at 07:07)</a>:</h4>
<p><span class="user-mention" data-user-id="329867">@Claus-Peter Becke</span> </p>
<p>Apologies if I caused any confusion. The reason why I said it didn't matter in the previous example is that the sum of the natural numbers from 0 to n is the same as the sum of the natural numbers from 1 to n, since 0 + x = x. Therefore in that specific example, it didn't matter that the sum in question had an extra term.</p>
<p>If you wanted a sum from i=a to i=b, you would use <code>∑ k in (range (b - a))</code> and then replace any <code>k</code> with <code>k + a</code>. I'm not sure what that inequality is supposed to be, and I haven't got too much time at the moment, but do you mean that <code>k</code> should be at least <code>3</code>? Or do you mean that <code>n</code> should be at least <code>3</code>?</p>



<a name="211723170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction/near/211723170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Claus-Peter Becke <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.html#211723170">(Sep 30 2020 at 07:14)</a>:</h4>
<p><span class="user-mention" data-user-id="266440">@Shing Tak Lam</span> I meant k should be at least 3. Your proposal seems to be very helpful again. I will try it immediately. Your support is very worthwhile for me. So you don't have any reason to apologize. Because I'm a newbie in all these questions I'm dealing with in this context it happens that I misunderstand some informations which are given.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
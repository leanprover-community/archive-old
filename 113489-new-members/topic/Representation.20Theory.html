---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Representation.20Theory.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html">Representation Theory</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="178343253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178343253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jineon Baek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178343253">(Oct 17 2019 at 01:39)</a>:</h4>
<p>I was reading through a Representation Theory textbook and a question came to my mind: Have the theory been implemented in any LEAN library?</p>



<a name="178344006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178344006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178344006">(Oct 17 2019 at 01:59)</a>:</h4>
<p>No, there's essentially no representation theory at this point (although there is some commutative algebra).</p>



<a name="178345476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178345476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jineon Baek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178345476">(Oct 17 2019 at 02:36)</a>:</h4>
<p>Thank you for answering. If so, how much it will be worth (for this community) to implement the theory in a library? It's a classical theory, but the fact that it is not yet implemented seems to somewhat imply that there are more urgent needs for other theories now. I want to know the context if any exists.</p>



<a name="178345702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178345702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178345702">(Oct 17 2019 at 02:42)</a>:</h4>
<p><span class="user-mention" data-user-id="242240">@Jineon Baek</span> It only somewhat implies that we don't have enough people power. It's a relatively small group of contributors, and they just hack on whatever they think is fun.</p>



<a name="178345714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178345714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178345714">(Oct 17 2019 at 02:43)</a>:</h4>
<p>There are several people on this chat that think that representation theory is extremely important. But we just haven't got round to doing anything so far.</p>



<a name="178345726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178345726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178345726">(Oct 17 2019 at 02:43)</a>:</h4>
<p>At some point <span class="user-mention" data-user-id="220718">@Ben McDonnell</span> started working on some rep.theory. Maybe he can share what he's got so far somewhere.</p>



<a name="178346393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178346393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178346393">(Oct 17 2019 at 03:02)</a>:</h4>
<p>Yes, I'd love to see some! A lot depends on what generality you want to do things in, and often for mathlib the answer is "a lot of generality".</p>



<a name="178346406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178346406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178346406">(Oct 17 2019 at 03:03)</a>:</h4>
<p>The theory of abelian categories is on the horizon, and might be useful to have in place, so if someone wants to work on that I'd be happy to provide some pointers (and get around to doing some of the things I promised to do).</p>



<a name="178346410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178346410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178346410">(Oct 17 2019 at 03:04)</a>:</h4>
<p>But generally --- pick a (good) book, and have a go. :-)</p>



<a name="178346477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178346477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178346477">(Oct 17 2019 at 03:05)</a>:</h4>
<p>I'd love to see someone start on Etingof's Representation Theory: <a href="http://www-math.mit.edu/~etingof/repb.pdf" target="_blank" title="http://www-math.mit.edu/~etingof/repb.pdf">http://www-math.mit.edu/~etingof/repb.pdf</a></p>



<a name="178348965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178348965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jineon Baek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178348965">(Oct 17 2019 at 04:15)</a>:</h4>
<p>Thanks for the input everyone! I'm a newbie both in this lean game and representation theory, so I'm thinking of learning both by implementing theorems in a textbook as I learn them like the 'intro to proof' course project.</p>



<a name="178349170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178349170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jineon Baek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178349170">(Oct 17 2019 at 04:20)</a>:</h4>
<p>Full generality is definitely what standard library should aim for though. If my own little project works out well I'll share. Would happy to hear pointers for a starting point. I'm wondering if I should give it a try for finite group rep. with finite dimensional vector space first, or in a bit more generality.</p>



<a name="178349357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178349357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178349357">(Oct 17 2019 at 04:24)</a>:</h4>
<p>Why not try to prove the first interesting thing about finite group representations: averaging over the group is the projection onto the trivial isotypic component?</p>



<a name="178349402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178349402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178349402">(Oct 17 2019 at 04:25)</a>:</h4>
<ol>
<li>define the operator 1/|G| \Sigma_g g</li>
<li>prove that it is idempotent</li>
<li>prove that anything in its image is fixed by the group</li>
<li>prove that if you are fixed by every group element you are fixed by this operator</li>
</ol>



<a name="178349473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178349473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178349473">(Oct 17 2019 at 04:27)</a>:</h4>
<p>You'll need to see how to work with linear operators, and use <code>finset.sum</code> to handle the summations.</p>



<a name="178349554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178349554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jineon Baek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178349554">(Oct 17 2019 at 04:29)</a>:</h4>
<p><span class="user-mention" data-user-id="242241">@Seewoo Lee</span></p>



<a name="178352673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178352673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178352673">(Oct 17 2019 at 05:50)</a>:</h4>
<p><span class="user-mention" data-user-id="242240">@Jineon Baek</span> But certainly you will make your Lean life a lot easier by not putting those finiteness assumptions in your definition</p>



<a name="178352690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178352690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178352690">(Oct 17 2019 at 05:50)</a>:</h4>
<ol start="5">
<li>prove that the subset of elements fixed by the group is a sub-vectorspace.</li>
</ol>



<a name="178354918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178354918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178354918">(Oct 17 2019 at 06:46)</a>:</h4>
<p>Representation theory is one of the many things on my list of stuff we need to get done at some point. It's a beautiful theory, and essentially self-contained. The first part of Serre's book would be the kind of goal we'd need</p>



<a name="178359160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178359160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178359160">(Oct 17 2019 at 08:04)</a>:</h4>
<p>inb4 it's a special case of L^2(G) and Peter--Weyl theorem</p>



<a name="178416100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178416100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Daly <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178416100">(Oct 17 2019 at 19:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  When we developed Axiom at IBM Research there was an effort made to invite and actively support people who worked in areas where we needed implementations, for example, in finite fields. It might be interesting to "talent search" among mathematicians and actively recruit their participation. Perhaps Microsoft could be convinced to do a "Microsoft Summer of Code", providing a summer support program for mathematicians with proposals for lean development.</p>



<a name="178451453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178451453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#178451453">(Oct 18 2019 at 07:50)</a>:</h4>
<p>I don't think we need a "person who works in representation theory" -- all we need is an intelligent undergraduate who is trained in type theory and is interested, and I'm sure I'll find one in the end.</p>



<a name="190638253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190638253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190638253">(Mar 15 2020 at 09:22)</a>:</h4>
<p>I've collected together some of the bits and pieces of mathlib that I will require to define linear representations, but I'm still too new to be able to assemble them into a definition. I think the following is all the component parts, but it's just a heap of nonsense at the moment. Would some kind soul be able to align them into something I can start expressing lemmas about? (I'll probably only need a few of this kind of really basic question before I can answer such trivia myself.)</p>
<p>One particular question I don't know the answer to: should I be expressing "linear representation" as a typeclass or merely a record? </p>
<p>Alternatively, is there some kind of Lean walkthrough of how to assemble a definition like this?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">field</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">finite_dimensional</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">x</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">U</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">F</span> <span class="o">:</span> <span class="n">field</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">X</span> <span class="o">:</span> <span class="n">Set</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">V</span> <span class="o">:</span> <span class="n">vector_space</span> <span class="n">F</span> <span class="n">X</span><span class="o">]</span>

<span class="c1">-- Definition. Let V be a finite-dimensional vector space over F. A (linear) repre-</span>
<span class="c1">-- sentation of G on V is a homomorphism ρ = ρ_V : G → GL(V).</span>

<span class="c1">--def general_linear_group := units (M →ₗ[R] M)</span>
<span class="c1">--class is_group_hom [group α] [group β] (f : α → β) extends is_mul_hom f : Prop</span>
</pre></div>



<a name="190638449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190638449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190638449">(Mar 15 2020 at 09:28)</a>:</h4>
<p>The variables are quite right. The variables are the underlying types, and the structures are anonymous typeclass variables. Like so:</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V</span><span class="o">]</span>
</pre></div>



<a name="190638461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190638461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190638461">(Mar 15 2020 at 09:29)</a>:</h4>
<p>Similarly, <code>G</code> is a group means <code>variables {G : Type*} [group G]</code></p>



<a name="190638536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190638536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190638536">(Mar 15 2020 at 09:30)</a>:</h4>
<p>and then a linear representation would be an element of <code>G -&gt;* units (V -&gt;l[F] V)</code></p>



<a name="190639239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190639239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190639239">(Mar 15 2020 at 09:47)</a>:</h4>
<p>Thanks. The way I had previously expected this to look was something like <code>def linear_representation (p : G -&gt; general_linear_group F (n -&gt; F)) := is_monoid_hom p</code>, but I suspect my mental model is wrong in a way that I don't understand (that line certainly doesn't compile). Is it clear to you what I've misunderstood?</p>



<a name="190639427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190639427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190639427">(Mar 15 2020 at 09:50)</a>:</h4>
<p>to be clear, I currently have:</p>
<div class="codehilite"><pre><span></span>import algebra.field
import linear_algebra.finite_dimensional
import linear_algebra.basic
import algebra.module

open linear_map

universes u v
variables {F : Type u} {V : Type v}
variables [discrete_field F]
variables (n : Type u) [fintype n] [decidable_eq n]
variables [field F]
variables {G : Type*} [add_comm_group G]
variables [vector_space F G]

def linear_representation (p : G -&gt; general_linear_group F (n -&gt; F)) := is_monoid_hom p
</pre></div>



<a name="190640530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190640530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190640530">(Mar 15 2020 at 10:18)</a>:</h4>
<p>You have two instances on <code>F</code>, one a <code>field</code> and one a <code>discrete_field</code>, that's definitely wrong. That is saying that <code>F</code> has two independent field structures. (In the latest version of lean/mathlib <code>discrete_field</code> has been renamed to <code>field</code>, replacing the original <code>field</code>.)</p>



<a name="190640544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190640544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190640544">(Mar 15 2020 at 10:19)</a>:</h4>
<p>It's true that I didn't say anything about the finite dimensionality in the version I gave. That could be a predicate on <code>V</code>, something like <code>dim V &lt; omega</code>, although perhaps there's a typeclass for this now</p>



<a name="190640597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190640597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190640597">(Mar 15 2020 at 10:20)</a>:</h4>
<p>But in your version, <code>vector_space F G</code> means that <code>G</code> is the <code>F</code>-vector space</p>



<a name="190640604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190640604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190640604">(Mar 15 2020 at 10:21)</a>:</h4>
<p>which could be what you mean but doesn't match the math text in the comment</p>



<a name="190640656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190640656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190640656">(Mar 15 2020 at 10:23)</a>:</h4>
<p>The way you have set up <code>linear_representation p</code> is as a predicate on functions from G asserting that they are a linear representation, whereas the approach I gave takes linear representations to be the entire type <code>G -&gt;* units (V -&gt;l[F] V)</code>, which bundles together the function with the proof that it is a group hom</p>



<a name="190640695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190640695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190640695">(Mar 15 2020 at 10:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190640604" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190640604">said</a>:</p>
<blockquote>
<p>which could be what you mean but doesn't match the math text in the comment</p>
</blockquote>
<p>Ah, you're quite right - I don't know how I could have made that mistake :P</p>



<a name="190640704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190640704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190640704">(Mar 15 2020 at 10:24)</a>:</h4>
<p>mathlib is slowly moving away from unbundled homs like <code>is_monoid_hom</code> in favor of bundled homs like <code>G -&gt;+ H</code></p>



<a name="190640707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190640707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190640707">(Mar 15 2020 at 10:24)</a>:</h4>
<p>OK, that makes sense - thanks</p>



<a name="190641233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190641233">(Mar 15 2020 at 10:41)</a>:</h4>
<p>The flood of my questions should decay exponentially, but in the meantime: the following doesn't compile because "type expected at <code>linear_representation</code>" in the last line. How can I pass a linear representation into the function <code>dimension</code>?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">field</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">finite_dimensional</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">module</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span><span class="bp">.</span><span class="n">hom</span>

<span class="kn">open</span> <span class="n">linear_map</span>

<span class="n">universes</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">F</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">n</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">n</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V</span><span class="o">]</span>

<span class="n">def</span> <span class="n">linear_representation</span> <span class="o">:=</span> <span class="n">monoid_hom</span> <span class="n">G</span> <span class="o">(</span><span class="n">general_linear_group</span> <span class="n">F</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">F</span><span class="o">))</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">dimension</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">linear_representation</span><span class="o">)</span> <span class="o">:=</span> <span class="n">vector_space</span><span class="bp">.</span><span class="n">dim</span> <span class="n">V</span>
</pre></div>



<a name="190641409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190641409">(Mar 15 2020 at 10:45)</a>:</h4>
<p>Have a look at <code>#check linear_representation</code></p>



<a name="190641447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190641447">(Mar 15 2020 at 10:46)</a>:</h4>
<p>Maybe you don't quite understand how <code>variable</code> works yet.</p>



<a name="190641510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190641510">(Mar 15 2020 at 10:48)</a>:</h4>
<p>Also try <code>#check @linear_representation</code>, and try to think about what is <code>V</code> at the very end of your code, and how it relates to <code>p</code>.</p>



<a name="190641511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190641511">(Mar 15 2020 at 10:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190641447" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190641447">said</a>:</p>
<blockquote>
<p>Maybe you don't quite understand how <code>variable</code> works yet.</p>
</blockquote>
<p>Ah right - again, I've been misled by Agda, which tends to do this via parameterised modules</p>



<a name="190641522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190641522">(Mar 15 2020 at 10:49)</a>:</h4>
<p>There is also a problem which is completely independent of language differences.</p>



<a name="190641531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190641531">(Mar 15 2020 at 10:49)</a>:</h4>
<p>Your <code>V</code> in the body of the definition has no relation whatsoever with <code>p</code>.</p>



<a name="190641589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190641589">(Mar 15 2020 at 10:50)</a>:</h4>
<p>Your <code>p</code> obviously has dimension <code>n</code> by definition.</p>



<a name="190641647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190641647">(Mar 15 2020 at 10:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190641589" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190641589">said</a>:</p>
<blockquote>
<p>Your <code>p</code> obviously has dimension <code>n</code> by definition.</p>
</blockquote>
<p>You're right, I actually want the <code>n</code> from the body of <code>linear_representation</code> - but I am happy to leave questions like "have I got the definition correct" for the moment (I'll discover they're wrong as soon as I come to formulate any theorems) while I learn how to use Lean</p>



<a name="190641660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190641660">(Mar 15 2020 at 10:53)</a>:</h4>
<p>You have <code>V</code> and also <code>n -&gt; F</code> as vector spaces. Which do you want?</p>



<a name="190641666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190641666">(Mar 15 2020 at 10:53)</a>:</h4>
<p>In case this isn't clear: Mario's question is about the same topic as mine.</p>



<a name="190641667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190641667">(Mar 15 2020 at 10:53)</a>:</h4>
<p><code>linear_representation</code> has too many implicit variables</p>



<a name="190641671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190641671">(Mar 15 2020 at 10:54)</a>:</h4>
<p><code>n -&gt; F</code> - but I can almost certainly work out how to do that by myself, once I've correctly passed a linear representation into <code>dimension</code>. I'll rejig it so that the right variables are explicit and then it'll probably all just fall out</p>



<a name="190641673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190641673">(Mar 15 2020 at 10:54)</a>:</h4>
<p>Thanks</p>



<a name="190641711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190641711">(Mar 15 2020 at 10:54)</a>:</h4>
<p>you need to make the type variables explicit, and then write e.g. <code>p : linear_representation F G V</code></p>



<a name="190641720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190641720">(Mar 15 2020 at 10:54)</a>:</h4>
<p>or <code>linear_representation F G n</code> if you want that version</p>



<a name="190641729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190641729">(Mar 15 2020 at 10:55)</a>:</h4>
<p>That's why I wrote a bunch of <code>#check</code></p>



<a name="190641768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190641768">(Mar 15 2020 at 10:56)</a>:</h4>
<p>If the definition has the form <code>linear_representation F G n</code>, then the dimension is <code>n</code>, and there is no need for a definition <code>dimension</code>. This is what patrick is saying</p>



<a name="190641776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190641776">(Mar 15 2020 at 10:56)</a>:</h4>
<p>Because in this situation Lean will typically complain it cannot synthesize a term of type<code>Type u</code> without telling which implicit variable it wasn't able to synthesize and this is not easy to debug without <code>#check</code></p>



<a name="190643018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190643018">(Mar 15 2020 at 11:36)</a>:</h4>
<p><span class="user-mention" data-user-id="117987">@Patrick Stevens</span> <code>field</code> means different things in Lean 3.4.2 (the officially sanctioned version of Lean, which is frozen, as is mathlib support) and 3.6.1 (the community version, which current mathlib compiles with). I guess I'd recommend you use 3.6.1 but I just wanted to flag this now.</p>



<a name="190643511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190643511">(Mar 15 2020 at 11:53)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="c1">-- working with Lean 3.6.1 and current mathlib</span>
<span class="c1">-- don&#39;t need all of these imports for group_module</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">field</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">finite_dimensional</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">module</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span><span class="bp">.</span><span class="n">hom</span>

<span class="n">class</span> <span class="n">group_module</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span>
  <span class="kn">extends</span>  <span class="n">has_scalar</span> <span class="n">G</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">one_smul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span>
<span class="o">(</span><span class="n">smul_smul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">g</span> <span class="n">h</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">,</span> <span class="n">g</span> <span class="err">•</span> <span class="o">(</span><span class="n">h</span> <span class="err">•</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">g</span> <span class="bp">*</span> <span class="n">h</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span><span class="o">)</span>
<span class="o">(</span><span class="n">smul_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">M</span><span class="o">,</span> <span class="n">g</span> <span class="err">•</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">g</span> <span class="err">•</span> <span class="n">n</span><span class="o">)</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">one_smul</span> <span class="n">smul_smul</span> <span class="n">smul_add</span> <span class="c1">-- I think?</span>

<span class="kn">namespace</span> <span class="n">group_module</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">group_module</span> <span class="n">G</span> <span class="n">M</span><span class="o">]</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">smul_neg</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">g</span> <span class="err">•</span> <span class="o">(</span><span class="bp">-</span><span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="o">(</span><span class="n">g</span> <span class="err">•</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">smul_zero</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">g</span> <span class="err">•</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">smul_sub</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">g</span> <span class="err">•</span> <span class="o">(</span><span class="n">m</span> <span class="bp">-</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">-</span> <span class="n">g</span> <span class="err">•</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">group_module</span>

<span class="c1">-- new file with more imports</span>

<span class="n">class</span> <span class="n">group_representation</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span>
  <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">F</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">group_module</span> <span class="n">G</span> <span class="n">V</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">smul_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">g</span> <span class="err">•</span> <span class="o">(</span><span class="n">μ</span> <span class="err">•</span> <span class="n">v</span><span class="o">)</span> <span class="bp">=</span> <span class="n">μ</span> <span class="err">•</span> <span class="o">(</span><span class="n">g</span> <span class="err">•</span> <span class="n">v</span><span class="o">)</span> <span class="o">)</span>

<span class="kn">namespace</span> <span class="n">group_representation</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span>
  <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">F</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">group_module</span> <span class="n">G</span> <span class="n">V</span><span class="o">]</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">dim</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">group_representation</span> <span class="n">G</span> <span class="n">F</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">vector_space</span><span class="bp">.</span><span class="n">dim</span> <span class="n">V</span>

<span class="kn">end</span> <span class="n">group_representation</span>
</pre></div>


<p>There's my effort, but definitions are not my strong point.</p>



<a name="190643519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190643519">(Mar 15 2020 at 11:53)</a>:</h4>
<p>There should really be a bunch of lemmas about <code>group_module</code> first, because this is a simpler object (no field involved)</p>



<a name="190643565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190643565">(Mar 15 2020 at 11:54)</a>:</h4>
<p>furthermore the definitions should be in two different files really, because someone interested in group cohomology might not want to import the representation theory stuff.</p>



<a name="190643691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190643691">(Mar 15 2020 at 11:58)</a>:</h4>
<p>The following doesn't compile because "maximum class-instance resolution depth has been reached" on the last line for <code>monoid_hom</code>; presumably that means Lean can't figure out that I've specified a homomorphism, so I need to supply an instance of <code>is_monoid_hom</code> to go with the lambda-term. </p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">field</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">finite_dimensional</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">module</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span><span class="bp">.</span><span class="n">hom</span>

<span class="kn">open</span> <span class="n">linear_map</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">F</span><span class="o">]</span>

<span class="n">def</span> <span class="n">linear_representation</span>
  <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
  <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V</span><span class="o">]</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">n</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">n</span><span class="o">]</span>
  <span class="o">:=</span>
  <span class="n">monoid_hom</span> <span class="n">G</span> <span class="o">(</span><span class="n">general_linear_group</span> <span class="n">F</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">F</span><span class="o">))</span>

<span class="n">def</span> <span class="n">trivial_representation</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">linear_representation</span> <span class="n">F</span> <span class="n">G</span> <span class="n">F</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">monoid_hom</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="n">general_linear_group</span><span class="bp">.</span><span class="n">of_linear_equiv</span> <span class="o">(</span><span class="n">linear_equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span> <span class="bp">-&gt;</span> <span class="n">F</span><span class="o">)))</span>
</pre></div>


<p>But my best attempt at that instance is the following, which doesn't compile ("don't know how to synthesize placeholder" on <code>general_linear_group</code>):</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">identity_is_hom</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_monoid_hom</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">general_linear_group</span><span class="bp">.</span><span class="n">of_linear_equiv</span> <span class="o">(</span><span class="n">linear_equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span> <span class="bp">-&gt;</span> <span class="n">F</span><span class="o">))</span>
<span class="k">by</span> <span class="n">sorry</span>
</pre></div>


<p>This problem persists even if I supply <code>F</code> as well (i.e. prepend the arguments <code>(F : Type*) [discrete_field F]</code> to <code>identity_is_hom</code>). It's not clear to me that I can supply any more information to Lean here; what have I missed?</p>



<a name="190643708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190643708">(Mar 15 2020 at 11:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643519" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643519">said</a>:</p>
<blockquote>
<p>There should really be a bunch of lemmas about <code>group_module</code> first, because this is a simpler object (no field involved)</p>
</blockquote>
<p>Fair enough - I'm using this more as a "learn Lean" exercise than a "produce something to go into mathlib" at the moment, so am happy just playing around with the definitions at the moment</p>



<a name="190643758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190643758">(Mar 15 2020 at 12:00)</a>:</h4>
<p>OK I'll take a look at your version.</p>



<a name="190643826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190643826">(Mar 15 2020 at 12:02)</a>:</h4>
<p>Which version of Lean are you using?</p>



<a name="190643894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190643894">(Mar 15 2020 at 12:05)</a>:</h4>
<p>Your def of <code>linear_representation</code> has a V as an input which is never used</p>



<a name="190643899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190643899">(Mar 15 2020 at 12:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643826" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643826">said</a>:</p>
<blockquote>
<p>Which version of Lean are you using?</p>
</blockquote>
<p>leanprover-community/lean:3.5.1, according to my <code>leanpkg.toml</code></p>



<a name="190643945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190643945">(Mar 15 2020 at 12:06)</a>:</h4>
<p>You should probably upgrade because I just noticed that it's a pain to look at your code because of all this deprecated <code>discrete_field</code> stuff. There will be a painless way to do it with <code>leanproject</code> I suspect.</p>



<a name="190643949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190643949">(Mar 15 2020 at 12:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643945" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643945">said</a>:</p>
<blockquote>
<p>You should probably upgrade because I just noticed that it's a pain to look at your code because of all this deprecated <code>discrete_field</code> stuff. There will be a painless way to do it with <code>leanproject</code> I suspect.</p>
</blockquote>
<p>OK, thanks - I'll do that before anything else</p>



<a name="190643952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190643952">(Mar 15 2020 at 12:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> what do you think of my version by the way? Once we have the definitions right the lemmas should be fun, but the definitions are a minefield.</p>



<a name="190644083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644083">(Mar 15 2020 at 12:11)</a>:</h4>
<p>I think it should be a monoid rather than a group</p>



<a name="190644089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644089">(Mar 15 2020 at 12:11)</a>:</h4>
<p>it also looks suspiciously like a group action</p>



<a name="190644090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644090">(Mar 15 2020 at 12:11)</a>:</h4>
<p>It <em>is</em> a group action</p>



<a name="190644091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644091">(Mar 15 2020 at 12:11)</a>:</h4>
<p>A group module is a group action by module homs</p>



<a name="190644096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644096">(Mar 15 2020 at 12:11)</a>:</h4>
<p>Mario is pointing out that it could extend group actions</p>



<a name="190644135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644135">(Mar 15 2020 at 12:12)</a>:</h4>
<p>(then you get a bunch of theorems for free)</p>



<a name="190644157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644157">(Mar 15 2020 at 12:13)</a>:</h4>
<p>You also get a bunch of theorems for free if you don't define this at all and use the high level characterization instead</p>



<a name="190644259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644259">(Mar 15 2020 at 12:14)</a>:</h4>
<p>I'm not sure what you mean, but whatever you mean I suspect people will want this in practice.</p>



<a name="190644262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644262">(Mar 15 2020 at 12:14)</a>:</h4>
<p>Don't you get all this if you just say <code>linear_representation := G -&gt;* units (V -&gt;l[F] V)</code>?</p>



<a name="190644267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644267">(Mar 15 2020 at 12:14)</a>:</h4>
<p>Yes absolutely</p>



<a name="190644304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644304">(Mar 15 2020 at 12:15)</a>:</h4>
<p>it's not clear to me what the tradeoffs are here</p>



<a name="190644305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644305">(Mar 15 2020 at 12:15)</a>:</h4>
<p>Is that a high-level characterisation? There is another one -- there's a ring <code>G -&gt;_0 F</code> called the group ring, and a group representation is the same thing as a module over that ring</p>



<a name="190644342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644342">(Mar 15 2020 at 12:16)</a>:</h4>
<p>sure, any of those sound good to me</p>



<a name="190644344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644344">(Mar 15 2020 at 12:16)</a>:</h4>
<p>they are already very compact</p>



<a name="190644351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644351">(Mar 15 2020 at 12:16)</a>:</h4>
<p>You're a computer scientist so can see advantages in the compactness</p>



<a name="190644353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644353">(Mar 15 2020 at 12:16)</a>:</h4>
<p>It's less clear to me</p>



<a name="190644401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644401">(Mar 15 2020 at 12:16)</a>:</h4>
<p>Isn't this usually how the mathematicians do it?</p>



<a name="190644403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644403">(Mar 15 2020 at 12:16)</a>:</h4>
<p>I would prefer clarity</p>



<a name="190644418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644418">(Mar 15 2020 at 12:17)</a>:</h4>
<p>I feel like we've swapped sides of this argument</p>



<a name="190644421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644421">(Mar 15 2020 at 12:17)</a>:</h4>
<p>If you define it as a module over the group ring then all of a sudden you don't have <code>g \bub v</code> you have <code>\u g \bub v</code> etc</p>



<a name="190644424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644424">(Mar 15 2020 at 12:17)</a>:</h4>
<p>and these invisible functions can cause confusion, make rewriting harder etc</p>



<a name="190644466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644466">(Mar 15 2020 at 12:18)</a>:</h4>
<p>remind me who is playing the role of the CS guy again</p>



<a name="190644471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644471">(Mar 15 2020 at 12:18)</a>:</h4>
<p>With your approach there are coercions to fun etc, whereas sometimes <code>g \bub v</code> is just the thing you want.</p>



<a name="190644476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644476">(Mar 15 2020 at 12:19)</a>:</h4>
<p>My understanding here is that there is no perfect solution.</p>



<a name="190644478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644478">(Mar 15 2020 at 12:19)</a>:</h4>
<p>That's certainly going to be the case</p>



<a name="190644480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644480">(Mar 15 2020 at 12:19)</a>:</h4>
<p>how about you CS guys make the system we want then ;-)</p>



<a name="190644484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644484">(Mar 15 2020 at 12:19)</a>:</h4>
<p>Like I said, there is a tradeoff here and I don't have a good grasp of it</p>



<a name="190644530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644530">(Mar 15 2020 at 12:20)</a>:</h4>
<p>because you don't know what mathematicians actually use group representations for. This is why we need the area to get bigger, we need people who are experts at everything at once.</p>



<a name="190644594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644594">(Mar 15 2020 at 12:21)</a>:</h4>
<p>Mathematicians just invoke the invisible function machine and pass seamlessly from one concept to the other</p>



<a name="190644595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644595">(Mar 15 2020 at 12:21)</a>:</h4>
<p>I have already argued that DTT is the problem but you're already bought in so ¯\_(ツ)_/¯</p>



<a name="190644596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644596">(Mar 15 2020 at 12:21)</a>:</h4>
<p>and we don't check the diagrams commute because this is trivial</p>



<a name="190644604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644604">(Mar 15 2020 at 12:21)</a>:</h4>
<p>in set theory it really is that easy to pass between representations</p>



<a name="190644653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644653">(Mar 15 2020 at 12:21)</a>:</h4>
<p>I'm not going back to assembly language now</p>



<a name="190644718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644718">(Mar 15 2020 at 12:22)</a>:</h4>
<p>to use a rust analogy, I don't want assembly language, I want <code>unsafe</code> blocks</p>



<a name="190644770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644770">(Mar 15 2020 at 12:24)</a>:</h4>
<p>You lost me :-/ but I'm happy to hear more.</p>



<a name="190644781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644781">(Mar 15 2020 at 12:24)</a>:</h4>
<p>I want the ability to get around the type system without it getting mad at me forever</p>



<a name="190644786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644786">(Mar 15 2020 at 12:24)</a>:</h4>
<p>In set theory if <code>x \in A</code> and <code>A = B</code> then <code>x \in B</code></p>



<a name="190644792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644792">(Mar 15 2020 at 12:25)</a>:</h4>
<p>in type theory this will cause the proof assistant to hate you forever</p>



<a name="190644805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644805">(Mar 15 2020 at 12:25)</a>:</h4>
<p><span class="user-mention" data-user-id="117987">@Patrick Stevens</span> the problem with your code, I guess, is that you've defined a function <code>j</code> from G to <code>general_linear_group F (fin 1 → F)</code> but Lean has no particular reason to know that this function has the property that <code>j(g*h)=j(g)*j(h)</code>.</p>



<a name="190644875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644875">(Mar 15 2020 at 12:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190644792" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190644792">said</a>:</p>
<blockquote>
<p>in type theory this will cause the proof assistant to hate you forever</p>
</blockquote>
<p>In type theory we have to insert an invisible coercion from A to B and then coerce x over.</p>



<a name="190644909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644909">(Mar 15 2020 at 12:26)</a>:</h4>
<p>it's not invisible</p>



<a name="190644912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644912">(Mar 15 2020 at 12:26)</a>:</h4>
<p>I wish it was</p>



<a name="190644918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644918">(Mar 15 2020 at 12:27)</a>:</h4>
<p>we try very hard to make it not too annoying with mixed success</p>



<a name="190644922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644922">(Mar 15 2020 at 12:27)</a>:</h4>
<p>Sure -- I just meant "invisible to mathematicians"</p>



<a name="190644973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190644973">(Mar 15 2020 at 12:27)</a>:</h4>
<p>and we have a rather liberal notion of <code>=</code></p>



<a name="190645022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645022">(Mar 15 2020 at 12:28)</a>:</h4>
<p>I think that lean is a great system, probably the best among all systems I know at the user experience. I also think that this property has almost nothing to do with the fact that it implements DTT</p>



<a name="190645030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645030">(Mar 15 2020 at 12:29)</a>:</h4>
<p>We understand the concept of an equivalence of categories, but all these structures on one vector space V (a linear action of a group, a group hom to the automorphisms, a module for the group ring) are all equal because they are simply different ways of packing up precisely the same information. They are a tedious implementation issue which we cunningly avoid by seamlessly changing our implementation decisions mid-proof.</p>



<a name="190645106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645106">(Mar 15 2020 at 12:30)</a>:</h4>
<p>in lean, we can do this with equivs of various kinds, and maybe this will eventually be packed into some category machinery</p>



<a name="190645116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645116">(Mar 15 2020 at 12:31)</a>:</h4>
<p>but I do think it is essential to be able to do concrete work in any of those representations</p>



<a name="190645117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645117">(Mar 15 2020 at 12:31)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">monoid_hom</span><span class="bp">.</span><span class="n">of</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">monoid_hom.of :</span>
<span class="cm">  Π {M : Type u_3} {N : Type u_4} [mM : monoid M] [mN : monoid N] (f : M → N) [h : is_monoid_hom f], M →* N</span>
<span class="cm">-/</span>
</pre></div>


<p>Patrick -- this definition of <code>monoid_hom.of</code> says "you give me a map <code>f</code> and I will then use type class inference to find a term <code>h</code> of type <code>is_monoid_hom f</code>. Once I've found it I'll give you back a monoid homomorphism (which is essentially the pair consisting of f and h).</p>



<a name="190645122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645122">(Mar 15 2020 at 12:31)</a>:</h4>
<p>Yep, I'd got that far - I'm struggling to construct that term though</p>



<a name="190645123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645123">(Mar 15 2020 at 12:31)</a>:</h4>
<p>The type class inference system is a bunch of lemmas of the form "a ring homomorphism is a monoid homomorphism" etc.</p>



<a name="190645216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645216">(Mar 15 2020 at 12:32)</a>:</h4>
<p>The following doesn't compile, for example, because "don't know how to synthesize placeholder" at <code>general_linear_group</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">identity_is_hom</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">F</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_monoid_hom</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">general_linear_group</span><span class="bp">.</span><span class="n">of_linear_equiv</span> <span class="o">(</span><span class="n">linear_equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span> <span class="bp">-&gt;</span> <span class="n">F</span><span class="o">)))</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">sorry</span>
</pre></div>



<a name="190645267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645267">(Mar 15 2020 at 12:34)</a>:</h4>
<p>It will probably know that <code>general_linear_group X Y</code> is a group and hence a monoid but it won't know that your map is a monoid hom.</p>



<a name="190645273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645273">(Mar 15 2020 at 12:34)</a>:</h4>
<p>The issue with the synthesizing placeholder will be that Lean can't figure out which ring you're working over.</p>



<a name="190645276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645276">(Mar 15 2020 at 12:34)</a>:</h4>
<p>I was hoping to tell it this was a hom, in the bit where I currently have <code>sorry</code></p>



<a name="190645288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645288">(Mar 15 2020 at 12:35)</a>:</h4>
<p>Before the sorry Lean is failing to elaborate the term.</p>



<a name="190645290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645290">(Mar 15 2020 at 12:35)</a>:</h4>
<p>It can't figure out the type of <code>linear_equiv.refl (fin 1 -&gt; F)</code></p>



<a name="190645334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645334">(Mar 15 2020 at 12:36)</a>:</h4>
<p>The type is that <code>(fin 1 -&gt; F)</code> is isomorphic to itself as a module over...some metavariable.</p>



<a name="190645345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645345">(Mar 15 2020 at 12:37)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">identity_is_hom</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">F</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">is_monoid_hom</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="bp">@</span><span class="n">general_linear_group</span><span class="bp">.</span><span class="n">of_linear_equiv</span> <span class="n">F</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">linear_equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span> <span class="bp">-&gt;</span> <span class="n">F</span><span class="o">)))</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">sorry</span>
</pre></div>



<a name="190645454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645454">(Mar 15 2020 at 12:39)</a>:</h4>
<p>The variable inputs in <code>{}</code> brackets are ones which are supposed to be inferred by unification, but we're claiming that the identity map <code>fin 1 -&gt; F</code> is R-linear where R is a ring acting on <code>fin 1 -&gt; F</code> and we give no indication as to what this ring is. Whatever R is, this theorem is still true. My gut feeling is that your problem has come from a possibly questionable design decision to make the R input implicit.</p>



<a name="190645461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645461">(Mar 15 2020 at 12:39)</a>:</h4>
<p>Ooh, yuck - thanks; in Agda you can supply any particular implicit variable, like <code>f {A = B} arg1 {C = C} arg2</code> where <code>A</code> and <code>C</code> were implicit args. It looks like in Lean you can only "make all args explicit"?</p>



<a name="190645464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645464">(Mar 15 2020 at 12:39)</a>:</h4>
<p>PS I am now talking to you as if you were an expert. Let me know if I'm going over your head.</p>



<a name="190645496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645496">(Mar 15 2020 at 12:40)</a>:</h4>
<p>Yes, you can make all args explicit or none of them! That is a really cool agda thing, I wish we had that in Lean.</p>



<a name="190645512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645512">(Mar 15 2020 at 12:40)</a>:</h4>
<p>Yep, I see what you mean</p>



<a name="190645513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645513">(Mar 15 2020 at 12:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> can you just pop that into 3.7.2 for us?</p>



<a name="190645533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645533">(Mar 15 2020 at 12:41)</a>:</h4>
<p>there is a concrete syntax for this in lean 4 but I forget what it is</p>



<a name="190645582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645582">(Mar 15 2020 at 12:42)</a>:</h4>
<p>if we used that notation it would get confused with passing a singleton of an equality to <code>f</code></p>



<a name="190645587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645587">(Mar 15 2020 at 12:43)</a>:</h4>
<p>MS should employ an intern who gets an email whenever an issue like this comes up, and solves it manually</p>



<a name="190645593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645593">(Mar 15 2020 at 12:43)</a>:</h4>
<p>Oh here's a better idea -- just use a new kind of bracket.</p>



<a name="190645602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645602">(Mar 15 2020 at 12:43)</a>:</h4>
<p>Even if it did exist, the name of the argument could only possibly be the name of the binder, and typeclass args always have ugly names like <code>_inst_1</code></p>



<a name="190645603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645603">(Mar 15 2020 at 12:43)</a>:</h4>
<p>Why are we using <code>{}</code> for both implicit variable and set notation anyway?</p>



<a name="190645697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645697">(Mar 15 2020 at 12:44)</a>:</h4>
<p>Here we were missing <code>R</code> not some typeclass thing. The issue here was with unification failing, not type class inference.</p>



<a name="190645699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645699">(Mar 15 2020 at 12:44)</a>:</h4>
<p>Binders are always distinguishable because they come after binding notation tokens</p>



<a name="190645707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645707">(Mar 15 2020 at 12:44)</a>:</h4>
<p>but implicit function args are just in regular expression position</p>



<a name="190645731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645731">(Mar 15 2020 at 12:45)</a>:</h4>
<p>Mathematicians got <code>{}</code> first for sets, you just need some wacky unicode for your implicit instances and then we're all set.</p>



<a name="190645782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645782">(Mar 15 2020 at 12:46)</a>:</h4>
<p>there is no problem with binders because they only come after <code>\lam</code> and stuff</p>



<a name="190645785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645785">(Mar 15 2020 at 12:46)</a>:</h4>
<p><code>\lam {x | x &gt; 0}</code> doesn't make any sense</p>



<a name="190645788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645788">(Mar 15 2020 at 12:46)</a>:</h4>
<p>I don't know what a binder is. I thought that was forall etc.</p>



<a name="190645790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645790">(Mar 15 2020 at 12:46)</a>:</h4>
<p>yes</p>



<a name="190645795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645795">(Mar 15 2020 at 12:46)</a>:</h4>
<p><code>\Pi</code>, <code>\forall</code>, <code>\lam</code>, <code>\sum</code>, etc</p>



<a name="190645796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645796">(Mar 15 2020 at 12:46)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">linear_equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_3</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_4</span><span class="o">)</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_5</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">],</span> <span class="n">M</span> <span class="err">≃ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span>
</pre></div>


<p>Should R be explicit here?</p>



<a name="190645801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645801">(Mar 15 2020 at 12:47)</a>:</h4>
<p>I think so</p>



<a name="190645802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645802">(Mar 15 2020 at 12:47)</a>:</h4>
<p>I am confused about what binders have to do with the fact that I just had to write <code>@foo F _ _ _ _</code></p>



<a name="190645807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645807">(Mar 15 2020 at 12:47)</a>:</h4>
<p>There are no binders involved in the expression <code>@foo F _ _ _ _</code></p>



<a name="190645809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645809">(Mar 15 2020 at 12:47)</a>:</h4>
<p>whereas I wanted to write <code>foo {R = F}</code></p>



<a name="190645855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645855">(Mar 15 2020 at 12:48)</a>:</h4>
<p>but <code>{R = F}</code> is actually a valid expression, of type <code>set Prop</code></p>



<a name="190645860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645860">(Mar 15 2020 at 12:48)</a>:</h4>
<p>and that's why I'm saying you should keep your grubby implicit variable hands off our set notation and come up with some different bracket system.</p>



<a name="190645861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645861">(Mar 15 2020 at 12:48)</a>:</h4>
<p>which is kind of nonsense, but <code>foo</code> might nevertheless have type <code>set Prop -&gt; T</code> and then <code>foo {R = F}</code> is valid</p>



<a name="190645869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645869">(Mar 15 2020 at 12:49)</a>:</h4>
<p>Oh, if the notation is something other than <code>@foo {R = F}</code> then we're fine probably</p>



<a name="190645870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645870">(Mar 15 2020 at 12:49)</a>:</h4>
<p>or treat us like dirt, like you usually do, and make us use different weird brackets so as to confuse the regular mathematicians</p>



<a name="190645876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645876">(Mar 15 2020 at 12:49)</a>:</h4>
<p>I mean we already have those funny unicode brackets that are a pain to type for semi implicit</p>



<a name="190645881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645881">(Mar 15 2020 at 12:49)</a>:</h4>
<p>You wouldn't believe how many times I've been asked why <code>2 | 4</code> throw up wacky errors</p>



<a name="190645966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645966">(Mar 15 2020 at 12:50)</a>:</h4>
<p>when it works in LaTeX</p>



<a name="190645971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645971">(Mar 15 2020 at 12:50)</a>:</h4>
<p><code>2 \mid 4</code> is the way to do it in latex</p>



<a name="190645973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190645973">(Mar 15 2020 at 12:50)</a>:</h4>
<p>(actually it doesn't even work in LaTeX, the glue is incorrect and the user should use <code>\mid</code> ;-) )</p>



<a name="190646000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190646000">(Mar 15 2020 at 12:51)</a>:</h4>
<p>Because of the possibility of conflict, it seems pretty sensitive what notation is used for passing implicit arguments like this. I should see what lean 4 picked</p>



<a name="190646045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190646045">(Mar 15 2020 at 12:52)</a>:</h4>
<p>but yes, if it's some <code>foo {&lt;&lt;R = F&gt;&gt;}</code> thing then we're fine</p>



<a name="190646053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190646053">(Mar 15 2020 at 12:52)</a>:</h4>
<p>then again, typing that may become annoying</p>



<a name="190646056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190646056">(Mar 15 2020 at 12:53)</a>:</h4>
<p>syntax is hard</p>



<a name="190646061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190646061">(Mar 15 2020 at 12:53)</a>:</h4>
<p>You all seem to be happy with all that &gt;=-+ monad stuff</p>



<a name="190646062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190646062">(Mar 15 2020 at 12:53)</a>:</h4>
<p>This is a feature that isn't meant to be used very often</p>



<a name="190646108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190646108">(Mar 15 2020 at 12:54)</a>:</h4>
<p>So what you're saying is that instead of all this bracket banter I should just be making a PR changing {R} to (R)? :-)</p>



<a name="190646110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190646110">(Mar 15 2020 at 12:54)</a>:</h4>
<p>unfortuately it won't work for 3.4.2 ;-)</p>



<a name="190646177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190646177">(Mar 15 2020 at 12:56)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">identity_is_hom</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">F</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">is_monoid_hom</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="bp">@</span><span class="n">general_linear_group</span><span class="bp">.</span><span class="n">of_linear_equiv</span> <span class="n">F</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">linear_equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span> <span class="bp">-&gt;</span> <span class="n">F</span><span class="o">)))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_mul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">map_one</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">}</span>
</pre></div>


<p>is how to make the instance, in case you didn't know Lean syntax</p>



<a name="190646191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190646191">(Mar 15 2020 at 12:57)</a>:</h4>
<p>I got this in VS Code by writing <code>... := {! !}</code> and then clicking on the little lightbulb which appeared and selecting "create a skeleton"</p>



<a name="190661151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190661151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190661151">(Mar 15 2020 at 18:44)</a>:</h4>
<p>It's really hard to Google for the <code>example</code> keyword :P is it possible for me to name an example, or do I have to make it a <code>def</code> if I want to refer to it? Currently I have a definition which works, and now I want to run it through <code>#check</code> but I can't work out how to refer to it.</p>
<div class="codehilite"><pre><span></span><span class="c1">-- Trivial representation</span>
<span class="kn">example</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">linear_representation</span> <span class="n">F</span> <span class="n">G</span> <span class="n">F</span> <span class="o">:=</span>
  <span class="o">{</span>
    <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="n">general_linear_group</span><span class="bp">.</span><span class="n">of_linear_equiv</span> <span class="o">(</span><span class="n">linear_equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="bp">_</span><span class="o">),</span>
    <span class="n">map_one&#39;</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="k">by</span>
    <span class="k">begin</span>
      <span class="n">intros</span> <span class="n">g</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="kn">end</span>
  <span class="o">}</span>
</pre></div>



<a name="190661478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190661478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Keys <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190661478">(Mar 15 2020 at 18:51)</a>:</h4>
<p>You can try giving it a name, like so: <code>def even (n : ℤ) := 2 ∣ n</code></p>



<a name="190661482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190661482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190661482">(Mar 15 2020 at 18:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="259186">Daniel Keys</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190661478" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190661478">said</a>:</p>
<blockquote>
<p>You can try giving it a name, like so: <code>def even (n : ℤ) := 2 ∣ n</code></p>
</blockquote>
<p>Sure, I was just wondering if I could use the <code>example</code> syntax to name an example, or whether I was forced to use <code>def</code></p>



<a name="190661543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190661543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Keys <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#190661543">(Mar 15 2020 at 18:52)</a>:</h4>
<p>I think you need to make it a lemma or theorem in order to give it a name.</p>



<a name="191337769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191337769">(Mar 21 2020 at 09:52)</a>:</h4>
<p>Here's a stupid question: I've defined some stuff, and I want to #eval it to see whether it looks right (before I start going to the effort of proving things about it). For example, I've defined the dimension of a representation, and I want to check that the dimension of a certain representation is in fact 2 when I expect it to be. But for the life of me I can't find any actual examples of groups in mathlib (and so I have nothing to pass into #eval): the cyclic groups seem not to have been defined, Q and R appear not to have been endowed with group structures, etc. Are there actually any groups anywhere? And how should I be trying to find them in mathlib?</p>



<a name="191337883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191337883">(Mar 21 2020 at 09:54)</a>:</h4>
<p>Hmm... such examples are certain there.</p>



<a name="191337890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191337890">(Mar 21 2020 at 09:54)</a>:</h4>
<p>Q and R are both endowed with the structure of a linearly ordered field, so in particular they are additive groups</p>



<a name="191337898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191337898">(Mar 21 2020 at 09:55)</a>:</h4>
<p>But <code>#eval</code> cannot compute a dimension for you</p>



<a name="191337915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191337915">(Mar 21 2020 at 09:55)</a>:</h4>
<p>(It would have to cook up a basis, etc...)</p>



<a name="191337917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191337917">(Mar 21 2020 at 09:55)</a>:</h4>
<p>My current problem is simply an inability to synthesise a typeclass instance for <code>group R</code>, for example</p>



<a name="191337919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191337919">(Mar 21 2020 at 09:55)</a>:</h4>
<p>On the other hand, there is certainly a theorem in mathlib saying that <code>K^n</code> has dimension <code>n</code> over <code>K</code>.</p>



<a name="191337958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191337958">(Mar 21 2020 at 09:56)</a>:</h4>
<p>Because it's not a group. It's an <code>add_group</code>.</p>



<a name="191337962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191337962">(Mar 21 2020 at 09:56)</a>:</h4>
<p>This is very unfortunate.</p>



<a name="191337971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191337971">(Mar 21 2020 at 09:56)</a>:</h4>
<p>Oh, that's very upsetting</p>



<a name="191337973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191337973">(Mar 21 2020 at 09:56)</a>:</h4>
<p>But in the current setup, we need to duplicate groups to distinguish between multiplicative and additive groups</p>



<a name="191337976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191337976">(Mar 21 2020 at 09:56)</a>:</h4>
<p>If we don't do that, we cannot have nice notation.</p>



<a name="191337985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191337985">(Mar 21 2020 at 09:57)</a>:</h4>
<p>On the other hand, this is mostly done completely automatically. You prove things for multiplicative groups, and you are done.</p>



<a name="191337988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191337988">(Mar 21 2020 at 09:57)</a>:</h4>
<p>So you get <code>monoid R</code> and <code>add_group R</code> in your case.</p>



<a name="191337994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191337994">(Mar 21 2020 at 09:57)</a>:</h4>
<p>So it's just a matter of taste whether you want to use <code>add_group</code> or <code>group</code> in a particular theory?</p>



<a name="191338048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191338048">(Mar 21 2020 at 09:59)</a>:</h4>
<p>Well, mostly yes.</p>



<a name="191338057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191338057">(Mar 21 2020 at 10:00)</a>:</h4>
<p>But the machinery can turn generate an additive version of a multiplicative definition/theorem, but not the other way round.</p>



<a name="191338100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191338100">(Mar 21 2020 at 10:00)</a>:</h4>
<p>So all the generalities are developed using multiplicative notation.</p>



<a name="191338110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191338110">(Mar 21 2020 at 10:00)</a>:</h4>
<p>But stuff like modules and representations assumes additive groups</p>



<a name="191338131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191338131">(Mar 21 2020 at 10:01)</a>:</h4>
<p>Was that a mistake? Should they not use the phrasing that affords more generality, i.e. multiplicative?</p>



<a name="191338362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191338362">(Mar 21 2020 at 10:07)</a>:</h4>
<p>No, because of the notation.</p>



<a name="191338371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191338371">(Mar 21 2020 at 10:07)</a>:</h4>
<p>If M is an R-module, you want to me able to write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>⋅</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r \cdot (x + y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> for <code>r : R</code> and <code>x y : M</code></p>



<a name="191338411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191338411">(Mar 21 2020 at 10:08)</a>:</h4>
<p>I agree that it's confusing. (The mathematician in me is still unhappy about it.) But in practice it works quite well.</p>



<a name="191338424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191338424">(Mar 21 2020 at 10:09)</a>:</h4>
<p>So, the magic command to make a multiplicative theorem additive is</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">to_additive</span><span class="o">]</span>
<span class="kn">theorem</span> <span class="n">my_multiplicative_thm</span> <span class="bp">...</span>
</pre></div>



<a name="191338432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191338432">(Mar 21 2020 at 10:09)</a>:</h4>
<p>Besides that, if <code>G</code> is a <code>group</code>, then <code>additive G</code> is an <code>add_group</code>. (The only thing this does is switch notation.)<br>
Analogously <code>multiplicative A</code> turns an additive group into a multiplicative one.</p>



<a name="191338476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191338476">(Mar 21 2020 at 10:10)</a>:</h4>
<p>Together, this gives a system that's quite flexible, and has nice notation.</p>



<a name="191340607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191340607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191340607">(Mar 21 2020 at 11:09)</a>:</h4>
<p>The following code doesn't compile because I haven't defined a relation: the type is not X -&gt; X -&gt; Prop because the type of <code>is_isomorphic</code> here is <code>linear_representation _ _ V1 -&gt; linear_representation _ _ V2 -&gt; Prop</code>. I could solve this by splitting the definition into two: <code>linear_representation_over_a_specific_vector_space</code> (name TBD), and convert <code>linear_representation</code> to being instead a dependent pair of (vector space, representation on that vector space), but this seems a little sad. Can anyone see anything nicer I could do?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">field</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">finite_dimensional</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">module</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span><span class="bp">.</span><span class="n">hom</span>

<span class="kn">open</span> <span class="n">linear_map</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span>

<span class="n">def</span> <span class="n">linear_representation</span>
  <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
  <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V</span><span class="o">]</span>
  <span class="o">:=</span>
  <span class="n">monoid_hom</span> <span class="n">G</span> <span class="o">(</span><span class="n">general_linear_group</span> <span class="n">F</span> <span class="n">V</span><span class="o">)</span>

<span class="c1">-- is_intertwining_map is the same as &quot;being a G-homomorphism&quot;</span>
<span class="n">def</span> <span class="n">is_intertwining_map</span>
  <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
  <span class="o">{</span><span class="n">V1</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V1</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V1</span><span class="o">]</span>
  <span class="o">{</span><span class="n">V2</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V2</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V2</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">linear_representation</span> <span class="n">F</span> <span class="n">G</span> <span class="n">V1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">linear_representation</span> <span class="n">F</span> <span class="n">G</span> <span class="n">V2</span><span class="o">)</span>
  <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">linear_map</span> <span class="n">F</span> <span class="n">V1</span> <span class="n">V2</span><span class="o">)</span>
  <span class="o">:=</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V1</span><span class="o">),</span>
    <span class="n">linear_map</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">φ</span> <span class="o">(</span><span class="n">units</span><span class="bp">.</span><span class="n">val</span> <span class="o">(</span><span class="n">monoid_hom</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">p1</span> <span class="n">g</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">units</span><span class="bp">.</span><span class="n">val</span> <span class="o">(</span><span class="n">monoid_hom</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">p2</span> <span class="n">g</span><span class="o">))</span> <span class="o">(</span><span class="n">linear_map</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">φ</span> <span class="n">x</span><span class="o">)</span>

<span class="n">def</span> <span class="n">is_isomorphism</span>
  <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
  <span class="o">{</span><span class="n">V1</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V1</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V1</span><span class="o">]</span>
  <span class="o">{</span><span class="n">V2</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V2</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V2</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">linear_representation</span> <span class="n">F</span> <span class="n">G</span> <span class="n">V1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">linear_representation</span> <span class="n">F</span> <span class="n">G</span> <span class="n">V2</span><span class="o">)</span>
  <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">linear_map</span> <span class="n">F</span> <span class="n">V1</span> <span class="n">V2</span><span class="o">)</span>
  <span class="o">:=</span>
  <span class="n">is_intertwining_map</span> <span class="n">F</span> <span class="n">p1</span> <span class="n">p2</span> <span class="n">φ</span> <span class="bp">∧</span> <span class="n">function</span><span class="bp">.</span><span class="n">bijective</span> <span class="o">(</span><span class="n">linear_map</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">φ</span><span class="o">)</span>

<span class="n">def</span> <span class="n">is_isomorphic</span>
  <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
  <span class="o">{</span><span class="n">V1</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V1</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V1</span><span class="o">]</span>
  <span class="o">{</span><span class="n">V2</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V2</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V2</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">linear_representation</span> <span class="n">F</span> <span class="n">G</span> <span class="n">V1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">linear_representation</span> <span class="n">F</span> <span class="n">G</span> <span class="n">V2</span><span class="o">)</span>
  <span class="o">:=</span>
  <span class="bp">∃</span> <span class="n">φ</span><span class="o">,</span> <span class="n">is_isomorphism</span> <span class="n">F</span> <span class="n">p1</span> <span class="n">p2</span> <span class="n">φ</span>

<span class="kn">lemma</span> <span class="n">isomorphism_rel_is_reflexive</span>
  <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
  <span class="o">{</span><span class="n">V1</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V1</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V1</span><span class="o">]</span>
  <span class="o">{</span><span class="n">V2</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V2</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V2</span><span class="o">]</span>
  <span class="o">:</span> <span class="n">reflexive</span> <span class="o">(</span><span class="bp">@</span><span class="n">is_isomorphic</span> <span class="n">F</span> <span class="bp">_</span> <span class="n">G</span> <span class="bp">_</span> <span class="n">V1</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">V2</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="c1">-- doesn&#39;t compile</span>
  <span class="o">:=</span>
<span class="k">by</span> <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>



<a name="191342638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191342638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191342638">(Mar 21 2020 at 12:06)</a>:</h4>
<p>I restructured in that way and it does work, of course, although it's a bit gross</p>



<a name="191345620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191345620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191345620">(Mar 21 2020 at 13:26)</a>:</h4>
<p>An example of an actual <code>group</code> in mathlib would be <code>units</code>. For example <code>units (zmod 42)</code> is an interesting, nontrivial and computable finite multiplicative group</p>



<a name="191345780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191345780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191345780">(Mar 21 2020 at 13:31)</a>:</h4>
<p>The way this would be usually done in mathlib is that first you define a bunded <code>intertwining_map</code>, and then you would define the identity intertwining map, and a composition of intertwining maps, and you would define an isomorphism to be an intertwining map with an inverse. I don't think I understand your question about reflexive. Surely the assertion that the relation is reflexive is that V1 is isomorphic to V1, I don't see the role of V2.</p>



<a name="191345843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191345843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191345843">(Mar 21 2020 at 13:33)</a>:</h4>
<p>But here you don't really want to use equivalence relations anyway, because they lose track of data. A mathematician would say "if V1 is isomorphic to V2 then V2 is isomorphic to V1" but this is less than what they mean. They <em>mean</em> "if you have an isomorphism V1 -&gt; V2 then I can give you an isomorphism V2 -&gt; V1, namely its inverse", and you would to well to capture this stronger statement.</p>



<a name="191346036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191346036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191346036">(Mar 21 2020 at 13:38)</a>:</h4>
<p>You should look at how it is set up for modules. Because a group representation is just a module for the group ring, you are just re-doing that theory anyway. <a href="https://github.com/leanprover-community/mathlib/blob/dd85db0cc7b5d0849f6f75535e109fa3d6f7ac56/src/algebra/module.lean#L165" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/dd85db0cc7b5d0849f6f75535e109fa3d6f7ac56/src/algebra/module.lean#L165">Here are module homomorphisms in mathlib</a>. Instead of making the predicate on a homomorphism of additive abelian groups, they bundle everything up in a structure and then define <code>id</code> and <code>comp</code> -- these are the fundamental things you need to make everything into a category.</p>



<a name="191346259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191346259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191346259">(Mar 21 2020 at 13:44)</a>:</h4>
<p>The reason that you don't see statements such as isomorphism being reflexive, symmetric etc is that everything like that is already done in some huge generality in <a href="https://github.com/leanprover-community/mathlib/blob/dd85db0cc7b5d0849f6f75535e109fa3d6f7ac56/src/data/equiv/mul_add.lean#L73" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/dd85db0cc7b5d0849f6f75535e109fa3d6f7ac56/src/data/equiv/mul_add.lean#L73">files like this</a>. This is a definition, not a theorem, it's the construction of the identity map and the proof that it preserves multiplication on any type with a multiplication. This is some abstract theory of "mul-equiv"s, which means bijections between two sets X and Y with multiplication, such that the bijection preserves the multiplication. Things like that get set up in huge generality and then the idea is that it will apply to your situation if you need it.</p>



<a name="191346602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191346602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191346602">(Mar 21 2020 at 13:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191345843" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191345843">said</a>:</p>
<blockquote>
<p>But here you don't really want to use equivalence relations anyway, because they lose track of data. A mathematician would say "if V1 is isomorphic to V2 then V2 is isomorphic to V1" but this is less than what they mean. They <em>mean</em> "if you have an isomorphism V1 -&gt; V2 then I can give you an isomorphism V2 -&gt; V1, namely its inverse", and you would to well to capture this stronger statement.</p>
</blockquote>
<p>Ah, again this is a habit imported from Agda, where to say that A is iso to B is to exhibit an isomorphism</p>



<a name="191346649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191346649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191346649">(Mar 21 2020 at 13:52)</a>:</h4>
<p>There is an <em>awful</em> lot to unlearn here :P</p>



<a name="191346687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191346687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191346687">(Mar 21 2020 at 13:53)</a>:</h4>
<p>In Lean, you say that A and B are <code>equiv</code>, which is also an explicit iso.</p>



<a name="191347345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191347345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191347345">(Mar 21 2020 at 14:08)</a>:</h4>
<p><span class="user-mention" data-user-id="117987">@Patrick Stevens</span> your definition of <code>is_isomorphism</code> is a <code>Prop</code>, so when you prove  the isomorphism you'll have to exhibit the map, but the moment the proof has compiled the map will be forgotten, because Lean's Prop is...umm..I think it's called impredicative.</p>



<a name="191347512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191347512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191347512">(Mar 21 2020 at 14:12)</a>:</h4>
<p>Fair enough - I just need to get much more clear about what is constructive and what isn't</p>



<a name="191348417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191348417">(Mar 21 2020 at 14:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191347345" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191347345">said</a>:</p>
<blockquote>
<p>because Lean's Prop is...umm..I think it's called impredicative.</p>
</blockquote>
<p>No, that's not what impredicative means. <a href="https://en.wikipedia.org/wiki/Impredicativity" target="_blank" title="https://en.wikipedia.org/wiki/Impredicativity">https://en.wikipedia.org/wiki/Impredicativity</a></p>



<a name="191348469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191348469">(Mar 21 2020 at 14:34)</a>:</h4>
<p>well, Lean's prop is forgetful</p>



<a name="191348483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191348483">(Mar 21 2020 at 14:34)</a>:</h4>
<p>that would be proof irrelevance</p>



<a name="191348486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191348486">(Mar 21 2020 at 14:34)</a>:</h4>
<blockquote>
<p>There is no generally accepted precise definition of what it means to be predicative or impredicative</p>
</blockquote>



<a name="191348489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191348489">(Mar 21 2020 at 14:34)</a>:</h4>
<p>that's the last time I'm using that word. It's as bad as canonical.</p>



<a name="191348491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191348491">(Mar 21 2020 at 14:34)</a>:</h4>
<p>we can say that Prop is a proof irrelevant universe</p>



<a name="191348559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191348559">(Mar 21 2020 at 14:36)</a>:</h4>
<p>I don't think I agree with the wikipedia statement. The meaning of impredicativity is context dependent but precise in most places where it appears</p>



<a name="191348594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191348594">(Mar 21 2020 at 14:37)</a>:</h4>
<p>Almost all the uses you are likely to have seen are using the same meaning. Alternate meanings are mostly historical and philosophical uses like avoiding self reference in the liar's paradox</p>



<a name="191348668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191348668">(Mar 21 2020 at 14:39)</a>:</h4>
<p>And this meaning is somehow orthogonal to proof irrelevance, right?</p>



<a name="191348749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191348749">(Mar 21 2020 at 14:40)</a>:</h4>
<p>they are related by a paradox that makes one of the possible permutations inconsistent</p>



<a name="191361408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191361408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191361408">(Mar 21 2020 at 19:10)</a>:</h4>
<p><span class="user-mention" data-user-id="117987">@Patrick Stevens</span> , could you have a look at <a href="https://github.com/leanprover-community/mathlib/issues/2121" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/2121">#2121</a>, as a "rather bundled" suggestion for the basics of representation theory?</p>



<a name="191375384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191375384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#191375384">(Mar 22 2020 at 02:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191345620" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191345620">said</a>:</p>
<blockquote>
<p>An example of an actual <code>group</code> in mathlib would be <code>units</code>. For example <code>units (zmod 42)</code> is an interesting, nontrivial and computable finite multiplicative group</p>
</blockquote>
<p>You can also do <code>units</code> of a general linear group to get some fun non-abelian computable groups.</p>



<a name="193803142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/193803142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#193803142">(Apr 13 2020 at 18:22)</a>:</h4>
<p>I'm planning to do some representation theory with <span class="user-mention" data-user-id="201575">@Michael R Douglas</span>. Do you think that is helpful, or are we then stepping on someone's toes? (<span class="user-mention" data-user-id="110087">@Scott Morrison</span> and <span class="user-mention" data-user-id="117987">@Patrick Stevens</span> might be working on the same or similar stuff)?</p>



<a name="193803299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/193803299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#193803299">(Apr 13 2020 at 18:24)</a>:</h4>
<p>The basic definitions will be the same as for group cohomology. <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> and some of his students have done a bunch there.</p>



<a name="193806239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/193806239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#193806239">(Apr 13 2020 at 18:51)</a>:</h4>
<p>The reason this never gets done is the usual (see graphs, or Cauchy's integral formula, or ...): people haven't yet decided on what the definition should be.</p>



<a name="193806389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/193806389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#193806389">(Apr 13 2020 at 18:52)</a>:</h4>
<p>Should one just define a representation of a group to be, by definition, a module over the group ring? Or should one make a new class of a vector space (or more generally module -- please set it up over modules over a commutative ring rather than vector spaces over a field) equipped with an action of G?</p>



<a name="193806654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/193806654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#193806654">(Apr 13 2020 at 18:54)</a>:</h4>
<p><a href="https://github.com/Shenyang1995/M4R/blob/66f1450f206dc05c3093bc4eaa1361309bf8633b/src/G_module/basic.lean#L10-L14" title="https://github.com/Shenyang1995/M4R/blob/66f1450f206dc05c3093bc4eaa1361309bf8633b/src/G_module/basic.lean#L10-L14">https://github.com/Shenyang1995/M4R/blob/66f1450f206dc05c3093bc4eaa1361309bf8633b/src/G_module/basic.lean#L10-L14</a> I need advice about whether this is the best idea. I don't have enough experience to know. Mario and I talked about this a week or two ago, I'll find the link. I'm not sure we came to any conclusions though, just like when we talk about what generality to define a contour integral in...</p>



<a name="193807039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/193807039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#193807039">(Apr 13 2020 at 18:57)</a>:</h4>
<p>(oh, it's just earlier in this thread)</p>



<a name="193840291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/193840291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#193840291">(Apr 14 2020 at 00:50)</a>:</h4>
<p>I did do a little, but got distracted trying to fix up <code>monoid_algebra</code> and its associated theorems. There's a lot still missing there.</p>



<a name="193840322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/193840322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#193840322">(Apr 14 2020 at 00:51)</a>:</h4>
<p>I think it's best to have separate notions for a group acting on something, and for a module for the group ring.</p>



<a name="193840328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/193840328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#193840328">(Apr 14 2020 at 00:51)</a>:</h4>
<p>You really need both points of view, and the ability to move between them.</p>



<a name="193843542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/193843542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#193843542">(Apr 14 2020 at 01:57)</a>:</h4>
<p>I started proving this equivalence in my <code>GroupModule_2</code> (rather experimental!) branch: <a href="https://github.com/leanprover-community/mathlib/blob/519a49d74154cee3d23dc45978a4a0e9e5274f37/src/group_theory/Rep.lean#L118" title="https://github.com/leanprover-community/mathlib/blob/519a49d74154cee3d23dc45978a4a0e9e5274f37/src/group_theory/Rep.lean#L118">https://github.com/leanprover-community/mathlib/blob/519a49d74154cee3d23dc45978a4a0e9e5274f37/src/group_theory/Rep.lean#L118</a></p>



<a name="193854919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/193854919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#193854919">(Apr 14 2020 at 06:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="111080">Floris van Doorn</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/193803142" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/193803142">said</a>:</p>
<blockquote>
<p>I'm planning to do some representation theory with <span class="user-mention silent" data-user-id="201575">Michael R Douglas</span>. Do you think that is helpful, or are we then stepping on someone's toes? (<span class="user-mention silent" data-user-id="110087">Scott Morrison</span> and <span class="user-mention silent" data-user-id="117987">Patrick Stevens</span> might be working on the same or similar stuff)?</p>
</blockquote>
<p>I am certainly not devoting that much effort to it - I'm a complete Lean noob and can't really spare the time to become good at the moment!</p>



<a name="193906443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/193906443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#193906443">(Apr 14 2020 at 14:33)</a>:</h4>
<p><span class="user-mention" data-user-id="111080">@Floris van Doorn</span> I think this would be a good time to experiment with the <a href="https://github.com/leanprover-community/mathlib/projects" title="https://github.com/leanprover-community/mathlib/projects">github projects feature</a>. There is a clear path with the basic theory: (1) definition of a representation of a group on an R-module (2) Maschke's theorem (G finite, order invertible in R) (3) Uniqueness of decomposition into irreducible factors (R a field, V fin dim), Schur's Lemma etc (4) [from now on G is finite of order invertible in the alg closed field k and V is fin dim] character of a representation (5) orthonormality of irred chars, and the fact that a rep is determined by its character (6) characters are a basis for the class functions (7) induction and restriction, Frobenius reciprocity. </p>
<p>I think we should use projects more. People come along and say "I am an undergrad mathematician, this all looks interesting, what can I do?" and if we can show them 5 undergraduate-level projects they might find a place to drop in.</p>



<a name="193906697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/193906697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#193906697">(Apr 14 2020 at 14:35)</a>:</h4>
<p>Representation theory is one of these areas where every few months someone pops up and asks if it's done, and with a project we can indicate its current state.</p>



<a name="193913534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/193913534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> orlando <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#193913534">(Apr 14 2020 at 15:20)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  :   a little maths question :  perhaps we can take  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mtext>Card</mtext><mo stretchy="false">(</mo><mi>G</mi><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mi mathvariant="normal">/</mi><mo stretchy="false">⟨</mo><msub><mi mathvariant="normal">Φ</mi><mrow><mtext>Card</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex"> R[\text{Card}(G)^{-1}] [X ] / \langle \Phi_{\text{Card}(G)} (X) \rangle  </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.1693079999999998em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord text"><span class="mord">Card</span></span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mord">/</span><span class="mopen">⟨</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Card</span></span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">G</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mclose">⟩</span></span></span></span> as  " algebraic closed field " , with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex"> \Phi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Φ</span></span></span></span> the cyclotomic polynomial,    <span aria-label="innocent" class="emoji emoji-1f607" role="img" title="innocent">:innocent:</span></p>



<a name="193913570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/193913570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#193913570">(Apr 14 2020 at 15:20)</a>:</h4>
<p>Maybe :-)</p>



<a name="193913618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/193913618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#193913618">(Apr 14 2020 at 15:20)</a>:</h4>
<p>But maybe you can only prove that after you have set up the theory? :-/</p>



<a name="193970006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/193970006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#193970006">(Apr 14 2020 at 23:46)</a>:</h4>
<p>That is a nice overview Kevin. It has been too long since I studied representation theory myself to remember the order to build up the theory, but I made a project by putting everything you said on a card.</p>



<a name="194247617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194247617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194247617">(Apr 16 2020 at 01:08)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="111080">@Floris van Doorn</span> ! I'd like to contribute to this if it's convenient: it seems like someone's already started defining a representation but happy to do Maschke's theorem, or character theory/class functions etc, so should I wait until the file with the definition has been uploaded to start writing code?</p>



<a name="194247936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194247936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194247936">(Apr 16 2020 at 01:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="235423">Ashwin Iyengar</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/194247617" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/194247617">said</a>:</p>
<blockquote>
<p>Hi <span class="user-mention silent" data-user-id="111080">Floris van Doorn</span> ! I'd like to contribute to this if it's convenient: it seems like someone's already started defining a representation but happy to do Maschke's theorem, or character theory/class functions etc, so should I wait until the file with the definition has been uploaded to start writing code?</p>
</blockquote>
<p>On the other hand, if I'm treading on your toes let me know and I'll find something else to work on!</p>



<a name="194248020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194248020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194248020">(Apr 16 2020 at 01:16)</a>:</h4>
<p>Ashvni wants to start working on local fields :-)</p>



<a name="194261377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194261377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194261377">(Apr 16 2020 at 06:19)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="235423">@Ashwin Iyengar</span>: yes, you can join. I made a very small start here: <a href="https://github.com/fpvandoorn/group-representations" title="https://github.com/fpvandoorn/group-representations">https://github.com/fpvandoorn/group-representations</a><br>
What is your Github username, then I can give you write access.</p>



<a name="194265099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194265099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194265099">(Apr 16 2020 at 07:21)</a>:</h4>
<p>It seems that there are 4 interesting definitions:</p>
<ol>
<li><code>G →* general_linear_group R M</code></li>
<li><code>group_module (G : Type*) [group G] (M : Type*) [add_comm_group M] extends has_scalar G M :=</code></li>
<li><code>linear_group_module</code> like above, but with modules over <code>R</code></li>
<li><code>module (monoid_algebra R G) M</code></li>
</ol>
<p>Approaches (1), (3), and (4) lead to equivalent categories, and (2) is the specialization <code>R = int</code>.<br>
The benefit of (3) is that it gives nice notation. It is so to speak the least bundled version.</p>



<a name="194268608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194268608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194268608">(Apr 16 2020 at 08:01)</a>:</h4>
<p>Shouldn't (4) give the same notation  as (3) if you define something like this?</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="o">[</span><span class="n">module</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">R</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M</span>
<span class="kn">instance</span> <span class="o">[</span><span class="n">module</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">R</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_scalar</span> <span class="n">G</span> <span class="n">M</span>
</pre></div>



<a name="194269017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194269017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194269017">(Apr 16 2020 at 08:05)</a>:</h4>
<p>Yes, I think that could work.</p>



<a name="194269117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194269117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194269117">(Apr 16 2020 at 08:06)</a>:</h4>
<p>Ooh, maybe not... because <code>R</code> does not occur in <code>has_scalar G M</code>. So it will apply "too often".</p>



<a name="194273758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194273758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194273758">(Apr 16 2020 at 08:51)</a>:</h4>
<p>Great <span class="user-mention" data-user-id="111080">@Floris van Doorn</span> my github name is ashwiniyengar</p>



<a name="194281257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194281257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194281257">(Apr 16 2020 at 10:04)</a>:</h4>
<p>Oh, I've also got something. I just made a PR as <a href="https://github.com/leanprover-community/mathlib/issues/2431" title="https://github.com/leanprover-community/mathlib/issues/2431">#2431</a> to make it public.</p>



<a name="194281323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194281323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194281323">(Apr 16 2020 at 10:04)</a>:</h4>
<p>I went the route of extending <code>distrib_mul_action</code>, so it gives the <code>•</code> notation (but may suffer from the problem Johan mentions; so far I haven't seen it).</p>



<a name="194281363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194281363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194281363">(Apr 16 2020 at 10:05)</a>:</h4>
<p>My PR proves the equivalence between</p>
<ol>
<li><code>representation k G M</code></li>
<li><code>G →* (M →ₗ[k] M)</code></li>
<li><code>module (monoid_algebra k G) M</code></li>
</ol>



<a name="194281405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194281405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194281405">(Apr 16 2020 at 10:05)</a>:</h4>
<p>but is stacked on top of <a href="https://github.com/leanprover-community/mathlib/issues/2366" title="https://github.com/leanprover-community/mathlib/issues/2366">#2366</a> and <a href="https://github.com/leanprover-community/mathlib/issues/2417" title="https://github.com/leanprover-community/mathlib/issues/2417">#2417</a>, neither of which compile at the moment ... :-)</p>



<a name="194281418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194281418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194281418">(Apr 16 2020 at 10:05)</a>:</h4>
<p>(I think it's minor for both.)</p>



<a name="194281983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194281983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194281983">(Apr 16 2020 at 10:11)</a>:</h4>
<p>(hopefully all three compile now)</p>



<a name="194282780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194282780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194282780">(Apr 16 2020 at 10:20)</a>:</h4>
<p>Yes, I'm afraid we tried enabling the <code>\bu</code> notation before with little representation theory projects, but ran into trouble...</p>



<a name="194338624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194338624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194338624">(Apr 16 2020 at 17:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/194268608" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/194268608">said</a>:</p>
<blockquote>
<p>Shouldn't (4) give the same notation  as (3) if you define something like this?</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="o">[</span><span class="n">module</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">R</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M</span>
<span class="kn">instance</span> <span class="o">[</span><span class="n">module</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">R</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_scalar</span> <span class="n">G</span> <span class="n">M</span>
</pre></div>


</blockquote>
<p>These two instances are likely causing looping behavior. For the second one, whenever Lean needs to find <em>any</em> <code>has_scalar A B</code> instance, is now has to look for instances <code>module (monoid_algebra ?M A) B</code>, which might cause looping because of the metavariable.</p>
<p>Option (1) and (3) both seem good. The question is really which notation we want to use: <code>ρ g x</code> or <code>g • x</code>. <br>
The latter notation is nicer, but also more ambiguous. I think it makes it hard to state results about two representations of the same group in the same vector space. I think those results occur quite frequently in representation theory (right?). Or maybe that's the wrong way of stating it in Lean; maybe the Lean way is to have the representations on different (but isomorphic?) vector spaces.</p>



<a name="194340580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194340580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194340580">(Apr 16 2020 at 17:37)</a>:</h4>
<p>I guess that for any continuous group homomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>→</mo><msup><mi mathvariant="double-struck">C</mi><mo>×</mo></msup></mrow><annotation encoding="application/x-tex">G\to\mathbb{C}^\times</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">C</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span></span></span></span> one gets a character which traditionally would commonly be realised as a action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> on the vector space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">C</span></span></span></span></span>.</p>



<a name="194340907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194340907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194340907">(Apr 16 2020 at 17:39)</a>:</h4>
<p>This whole business is going to be pretty interesting to formalise actually. One would ideally get as far as the characters of a finite group (over an alg closed field of char 0, say) as being a basis for the class functions, but I always felt like I was treating a character as "the same as" a representation, whereas given a character one is going to have to make some kind of choice for the representation when actually proving things about it, and perhaps if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\chi(1)=n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">χ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> the natural choice for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>k</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">k^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>? Although then there's no natural choice for the action <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>…</mo></mrow><annotation encoding="application/x-tex">\ldots</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.12em;vertical-align:0em;"></span><span class="minner">…</span></span></span></span></p>



<a name="194348267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194348267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194348267">(Apr 16 2020 at 18:33)</a>:</h4>
<p>Characters are the decategorification of representations!</p>



<a name="194353664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194353664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194353664">(Apr 16 2020 at 19:13)</a>:</h4>
<p>My standard contribution: Feit-Thompson uses representation theory so, if you are serious about formalizing it, you should at least have a look at mathcomp. Or ask <span class="user-mention" data-user-id="110172">@Assia Mahboubi</span> and <span class="user-mention" data-user-id="110193">@Cyril Cohen</span></p>



<a name="194520334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194520334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> orlando <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194520334">(Apr 18 2020 at 01:56)</a>:</h4>
<p>Hello, i do i little exercice with the file of <a href="https://github.com/fpvandoorn/group-representations/blob/master/src/group_theory/representation/basic.lean" title="https://github.com/fpvandoorn/group-representations/blob/master/src/group_theory/representation/basic.lean">here</a> of <span class="user-mention" data-user-id="111080">@Floris van Doorn</span>  !  I just try to define a sub representation when a subspace is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ρ</span></span></span></span>-stable !  <a href="https://github.com/Or7ando/lean/blob/master/.github/workflows/group_representation.lean" title="https://github.com/Or7ando/lean/blob/master/.github/workflows/group_representation.lean">here</a></p>



<a name="194522941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194522941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194522941">(Apr 18 2020 at 03:09)</a>:</h4>
<p>Hi @orlando, it's a bit hard to comment on the whole thing at once, as many things are going on in your file.</p>



<a name="194522998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194522998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194522998">(Apr 18 2020 at 03:10)</a>:</h4>
<p>I've also been thinking about a different approach to defining representations (and in a branch I have the outline of a proof of Maschke's theorem).</p>



<a name="194523013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194523013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194523013">(Apr 18 2020 at 03:10)</a>:</h4>
<p>It's in the PR <a href="https://github.com/leanprover-community/mathlib/issues/2431" title="https://github.com/leanprover-community/mathlib/issues/2431">#2431</a>, under the branch name <code>representation</code>.</p>



<a name="194523034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194523034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194523034">(Apr 18 2020 at 03:11)</a>:</h4>
<p>Your file has a lot of preparatory lemmas, whose purpose I'm pretty unclear on.</p>



<a name="194534442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/194534442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> orlando <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#194534442">(Apr 18 2020 at 09:03)</a>:</h4>
<p>Hi Scott. </p>
<p>I try to explain at the outset the definition refers to groups of units. And I would  do things by looking at linear endomophisms.  If i understand, you take endomorphism  definition ! </p>
<p>I use the notation \ oo for composition (and I realized that there is a notion * so <code>\ oo</code>  is not useful I think). The preparatory lemma a just some formula to simplify a little. (and for fun <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span>). </p>
<p>ohh ,it's cool if you have outline of Maschke Theorem !</p>
<p>Ps : I just make : </p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">new_groupe_representation</span> <span class="o">:</span>
<span class="o">(</span> <span class="n">group_representation</span> <span class="n">G</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span>  <span class="bp">→</span>  <span class="n">G</span> <span class="bp">→*</span> <span class="o">(</span><span class="n">M</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ρ</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">has_coe_to</span> <span class="n">ρ</span><span class="o">,</span> <span class="n">rmap_one</span> <span class="n">ρ</span><span class="o">,</span><span class="n">rmap_mul</span> <span class="n">ρ</span><span class="bp">⟩</span>
</pre></div>


<p>So i thinck that glue the two definitions. But perhaps there is a quicker way to do., using <code> general_linear_equiv :  general_linear_group R M ≃* (M ≃ₗ[R] M) </code> in the  file linear algebra basic <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span></p>



<a name="195032307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/195032307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> orlando <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#195032307">(Apr 23 2020 at 08:43)</a>:</h4>
<p>Hello <span class="user-mention" data-user-id="110087">@Scott Morrison</span>  I redo all my stuff. </p>
<p>I have problem with conversion <code>↑ ⇑  erw  </code> etc  i think it's more clear but not perfect and it's a good project for me to learn !  I have show just the Schur lemma from Serre book and construct some stuff.  Next step use character hum hum ! </p>
<p>If you are some comment for a better programming ? <br>
<a href="https://github.com/Or7ando/group_representation" title="https://github.com/Or7ando/group_representation">here</a></p>



<a name="195041768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/195041768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#195041768">(Apr 23 2020 at 10:23)</a>:</h4>
<p>The computer scientists will tell you to change <code>[group G]</code> to <code>[monoid G]</code> in the <em>definition</em>, because you do not use inverses :-)</p>



<a name="195042867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/195042867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#195042867">(Apr 23 2020 at 10:35)</a>:</h4>
<p><span class="user-mention" data-user-id="270476">@orlando</span> did you see <a href="https://github.com/leanprover-community/mathlib/projects/4" title="https://github.com/leanprover-community/mathlib/projects/4">the representation theory project</a>?</p>



<a name="195044142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/195044142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> orlando <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#195044142">(Apr 23 2020 at 10:52)</a>:</h4>
<p>Yes Kevin, i start with the first file of <span class="user-mention" data-user-id="111080">@Floris van Doorn</span>  but i change the definition because (conversion big problem) ! </p>
<p>I'm happy cause i understand i little more <code>rfl </code> <span aria-label="innocent" class="emoji emoji-1f607" role="img" title="innocent">:innocent:</span></p>



<a name="195044240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/195044240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#195044240">(Apr 23 2020 at 10:54)</a>:</h4>
<p>With this project, I feel like the hardest part is choosing the correct initial definition.</p>



<a name="195044503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/195044503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#195044503">(Apr 23 2020 at 10:57)</a>:</h4>
<p>ooh, I didn't know we have a kanban board (or whatever the kids call it these days)</p>



<a name="197530309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197530309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> orlando <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197530309">(May 14 2020 at 09:43)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span>  <span class="user-mention" data-user-id="111080">@Floris van Doorn</span>   </p>
<p>I don't know if you continue about representation. But a question :  do you have a version of the decomposition of representation in irreducible representation ? I have the  orthogonality of character (i have just a little problem with a formula  <code> trace rho g \-1 = complex.conj trace rho g </code> i don't know if it's decisive for the moment). </p>
<p>I think just a little about the decomposition for the moment ! So if you have a version tell me <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span></p>



<a name="197544673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197544673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197544673">(May 14 2020 at 12:25)</a>:</h4>
<p>Wow the proof I know of that trace fact uses a lot</p>



<a name="197544757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197544757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197544757">(May 14 2020 at 12:26)</a>:</h4>
<p>g is in a finite group so the order is finite (else it's false)</p>



<a name="197544797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197544797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197544797">(May 14 2020 at 12:26)</a>:</h4>
<p>There is something called eigenvalues of a matrix</p>



<a name="197544813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197544813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197544813">(May 14 2020 at 12:26)</a>:</h4>
<p>Each eigenvalue is a root of the min poly</p>



<a name="197544851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197544851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197544851">(May 14 2020 at 12:27)</a>:</h4>
<p>Each eigenvalue is a root of unity</p>



<a name="197544869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197544869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197544869">(May 14 2020 at 12:27)</a>:</h4>
<p>Wait</p>



<a name="197544888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197544888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197544888">(May 14 2020 at 12:27)</a>:</h4>
<p>Perhaps what I'm missing is the theory of unitary matrices</p>



<a name="197544993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197544993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197544993">(May 14 2020 at 12:28)</a>:</h4>
<p>Trace of inverse = trace of conjugate = conjugate of trace by <code>transport</code></p>



<a name="197545065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197545065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197545065">(May 14 2020 at 12:29)</a>:</h4>
<p>So maybe prove that the image is in the unitary matrices wrt some R-structure made using the averaged inner form trick?</p>



<a name="197545968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197545968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> orlando <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197545968">(May 14 2020 at 12:38)</a>:</h4>
<p>hum the problem is what is easy to make in <code>lean </code> for the moment ! Perhaps the root of unity it's difficult for the moment, ???  Perhaps with unitary representation !  </p>
<p>Yes it's the average trick !  All the basic theory is the average trick  <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p>



<a name="197563533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197563533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197563533">(May 14 2020 at 14:32)</a>:</h4>
<p><span class="user-mention" data-user-id="270476">@orlando</span> You really need to start writing PRs <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span></p>



<a name="197583321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197583321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> orlando <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197583321">(May 14 2020 at 16:42)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>  I'm really noob with git hub, i just understand <code> git add , git commit, git push </code> <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span>  so  first i finish with <code> math / lean </code> and next i try too understand   <code> PR's story </code> <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="197584761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197584761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197584761">(May 14 2020 at 16:53)</a>:</h4>
<p>Those three commands are enough (-;</p>



<a name="197584883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197584883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197584883">(May 14 2020 at 16:54)</a>:</h4>
<p>Ooh, maybe add <code>git checkout</code> for switching branches.</p>



<a name="197584976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197584976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197584976">(May 14 2020 at 16:54)</a>:</h4>
<p>I really fear that otherwise you'll end up with 5000 lines of code, and it will just sit in some repo, and never get PR'd</p>



<a name="197607720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197607720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197607720">(May 14 2020 at 19:43)</a>:</h4>
<p><span class="user-mention" data-user-id="270476">@orlando</span> We're definitely not there yet. We're still working on Maschke's Theorem, but we're making good progress.</p>



<a name="197608701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197608701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197608701">(May 14 2020 at 19:51)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Can you elaborate a bit on what you mean by Maschke's theorem for an R-module (instead of a vector space)? Given a submodule of a module, there doesn't necessarily even have to exist a complementary submodule, so if Maschke's theorem guarantees an invariant complementary submodule, then it is false. I think we can prove that <em>if</em> a submodule has a complementary submodule, it also has an invariant one.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">maschke2</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">ρ</span> <span class="o">:</span> <span class="n">group_representation</span> <span class="n">G</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="n">N&#39;</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">complementary</span> <span class="n">N</span> <span class="n">N&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">hN</span> <span class="o">:</span> <span class="n">invariant_subspace</span> <span class="n">ρ</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">hG</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="o">(</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">G</span> <span class="o">:</span> <span class="n">R</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">N&#39;</span><span class="o">,</span> <span class="n">invariant_subspace</span> <span class="n">ρ</span> <span class="n">N&#39;</span> <span class="bp">∧</span> <span class="n">complementary</span> <span class="n">N</span> <span class="n">N&#39;</span>
</code></pre></div>


<p><a href="https://github.com/fpvandoorn/group-representations/blob/da8dfe6c436ec15abeefb73040e31f19d197e11b/src/group_theory/representation/basic.lean#L501">https://github.com/fpvandoorn/group-representations/blob/da8dfe6c436ec15abeefb73040e31f19d197e11b/src/group_theory/representation/basic.lean#L501</a><br>
Is this the statement you had in mind?</p>
<p>Also, is there any source that does representation theory in modules (not in vector spaces)? We're kind of trying to figure out what holds for R-modules as we go, and sometimes have to reformulate results to only hold for vector spaces in the middle of a proof.</p>



<a name="197610423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197610423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197610423">(May 14 2020 at 20:05)</a>:</h4>
<p>Yes, it seems to me that you're right, I think the theorems are the following:<br>
1) If G is finite and 1/|G| is in R, and if there exists a complementary submodule (possibly not G-invariant) to your G-invariant one, then there exists a G-invariant complementary submodule.<br>
2) If R is a field then there always exists a complementary submodule</p>



<a name="197610582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197610582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197610582">(May 14 2020 at 20:06)</a>:</h4>
<p>The FLT proof contains a whole bunch of representation theory to arbitrary rings, but it doesn't need anything like Maschke, it needs representability theorems. Here is an example of a theorem that it uses (and I'm sure <span class="user-mention" data-user-id="112680">@Johan Commelin</span> knows about this stuff too):</p>



<a name="197610684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197610684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197610684">(May 14 2020 at 20:07)</a>:</h4>
<p>(oh, dinner time)</p>



<a name="197610709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197610709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197610709">(May 14 2020 at 20:07)</a>:</h4>
<p>(universal deformation rings)</p>



<a name="197610781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197610781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197610781">(May 14 2020 at 20:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/197610684">said</a>:</p>
<blockquote>
<p>(oh, dinner time)</p>
</blockquote>
<p>Yup, I know that one.</p>



<a name="197611126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197611126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> orlando <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197611126">(May 14 2020 at 20:10)</a>:</h4>
<p><span class="user-mention" data-user-id="111080">@Floris van Doorn</span>  :</p>
<p>I'm ok with you're theorem you have to put the hypothesis <code> h </code> for module. But perhaps in a first time we have to use field, for ring i think there is very complicated thing !</p>



<a name="197620046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197620046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197620046">(May 14 2020 at 21:23)</a>:</h4>
<p>Ah good, we have already proven (2), using Zorn's Lemma. <br>
Then we're going to finish this version of Maschke's Theorem.</p>



<a name="197621747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197621747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197621747">(May 14 2020 at 21:38)</a>:</h4>
<p>Hmm, I'm surprised that I couldn't find any kind of representation theory in Bourbaki with my google searches.</p>



<a name="197623440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197623440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> orlando <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197623440">(May 14 2020 at 21:55)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>  i think it's in this volume :<a href="http://www.bourbaki.ens.fr/algebre8-tdm.pdf">here</a></p>



<a name="197623550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197623550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197623550">(May 14 2020 at 21:57)</a>:</h4>
<p>oh, yes! I only found Algebra I (chapters 1-3) and Algebra II (chapters 4-7)</p>



<a name="197623552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197623552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> orlando <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197623552">(May 14 2020 at 21:57)</a>:</h4>
<p>i don't have the book <span aria-label="frown" class="emoji emoji-1f641" role="img" title="frown">:frown:</span></p>



<a name="197623689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197623689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> orlando <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197623689">(May 14 2020 at 21:58)</a>:</h4>
<p>But there is 400 page before : <code> representation lineaire sur les nombres complexes </code>  i have to learn and read i little <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p>



<a name="197624191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197624191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197624191">(May 14 2020 at 22:04)</a>:</h4>
<p>I see, so this entire book of nearly 500 pages is "chapter 8"</p>



<a name="197625144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197625144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197625144">(May 14 2020 at 22:14)</a>:</h4>
<p>I found the page on Maschke's theorem on Google Books but I don't know what the standing assumptions on "<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>" are.</p>



<a name="197625313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197625313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197625313">(May 14 2020 at 22:16)</a>:</h4>
<p>I found one place that says "if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> is a field [division algebra]" and others "a commutative field" though, so I assume the standing assumption is that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> is just a ring...</p>



<a name="197626432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197626432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> orlando <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197626432">(May 14 2020 at 22:29)</a>:</h4>
<p>Oh thx i don't use google book, it's good !</p>



<a name="197639091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197639091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197639091">(May 15 2020 at 01:28)</a>:</h4>
<p>I will try to get back to this soon, but I have a proof of Maschke's theorem in <code>Maschke</code>.</p>



<a name="197644444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/197644444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#197644444">(May 15 2020 at 03:20)</a>:</h4>
<p><span class="user-mention" data-user-id="111080">@Floris van Doorn</span> <span aria-label="up" class="emoji emoji-2b06" role="img" title="up">:up:</span></p>



<a name="198212467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/198212467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#198212467">(May 20 2020 at 15:11)</a>:</h4>
<p>I made <a href="https://github.com/leanprover-community/mathlib/issues/2762">#2762</a>, with my proof of Maschke's theorem. It's still a bit messy, but all the sorries are gone!</p>



<a name="198212743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/198212743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#198212743">(May 20 2020 at 15:13)</a>:</h4>
<p>The thing that it is missing still is the fact that any <code>k</code>-linear inclusion has a retraction, but this is hopefully done somewhere in the existing linear algebra library, and I can plug it in. For now the final statement includes an extra hypothesis for this fact.</p>



<a name="198220677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/198220677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#198220677">(May 20 2020 at 16:07)</a>:</h4>
<p>I think that fact isn't done yet, but it should be trivial once Yury's PRs on complementary submodules are merged.</p>



<a name="198220716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/198220716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#198220716">(May 20 2020 at 16:07)</a>:</h4>
<p>Great work with Maschke's theorem. It's one of those things that every self-respecting library ought to have (-;</p>



<a name="198220817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/198220817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#198220817">(May 20 2020 at 16:08)</a>:</h4>
<p>Scott doesn't need continuous version, and <code>projection</code> PR is already merged.</p>



<a name="198220911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/198220911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#198220911">(May 20 2020 at 16:09)</a>:</h4>
<p>What exactly do you need?</p>



<a name="198220974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/198220974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#198220974">(May 20 2020 at 16:10)</a>:</h4>
<p>E.g., we have <code>exists_left_inverse_of_injective</code> and <code>exists_right_inverse_of_surjective</code> in <code>linear_algebra/basis.lean</code>.</p>



<a name="198297535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/198297535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> orlando <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#198297535">(May 21 2020 at 08:31)</a>:</h4>
<p>Hello, That good <span class="user-mention" data-user-id="110087">@Scott Morrison</span> , i  have also a version of Maschke theorem.  </p>
<p>But for me the big step is really to make the application over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">C</span></span></span></span></span> ! </p>
<p>For example, the decomposition of a representation in irreducible representation.</p>
<p>I think the decomposition in irrducible part is ok for field (not algebraically closed).</p>



<a name="198307212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/198307212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#198307212">(May 21 2020 at 10:42)</a>:</h4>
<p>Could we move this thread to the math stream?</p>



<a name="198341356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/198341356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Representation.20Theory.html#198341356">(May 21 2020 at 16:18)</a>:</h4>
<p>This topic was moved by <span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> to <a class="stream-topic" data-stream-id="116395" href="/#narrow/stream/116395-maths/topic/Representation.20Theory">#maths &gt; Representation Theory</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
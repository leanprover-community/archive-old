---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/functions.20with.20finite.20support.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html">functions with finite support</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="195907483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195907483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195907483">(Apr 30 2020 at 21:58)</a>:</h4>
<p>I want to talk about an object which in my head has either type <code>f : M →. N </code> with <code>A : finset M</code> and <code>support f = a</code> (I don't actually know what I mean by <code>support</code>) or else has type <code>f : A → N</code> the latter doesn't work because A is not a type. I thought about trying to make <code>A</code> a subtype of <code>M</code> with an insteance <code>fintype A</code>, but I want to have <code>m : M</code> and reason about <code>m ∈ A : Prop</code>. Any advice? "Go read all of this particular file and you'll figure it out" would be fine.</p>



<a name="195907927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195907927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195907927">(Apr 30 2020 at 22:03)</a>:</h4>
<p>Maybe the answer is "read fintype.basic", since fintype.of_finset looks like a good place for me to start.</p>



<a name="195909022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195909022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195909022">(Apr 30 2020 at 22:14)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/data/finsupp.html" title="https://leanprover-community.github.io/mathlib_docs/data/finsupp.html"><code>data.finsupp</code></a></p>



<a name="195909285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195909285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195909285">(Apr 30 2020 at 22:17)</a>:</h4>
<p>I don't think <code>finsupp</code> is really the right thing. <code>finsupp</code> is basically just free module, or direct sum, and requires <code>M</code> to have a zero.</p>



<a name="195909439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195909439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195909439">(Apr 30 2020 at 22:19)</a>:</h4>
<p>I also don't think there are any examples of this really in mathlib, other than by making <code>A</code> the domain of the function. There is <code>data.pfun</code> for partial functions, but the best approach probably depends on what you want to do with it.</p>



<a name="195909831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195909831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195909831">(Apr 30 2020 at 22:23)</a>:</h4>
<p>the big goal is to prove categoricity of dense linear orders without endpoints. (this was the nuke that came to mind for one of Kenny's kata, and it seemed like a good exercise regardless of whether it was appropriate)<br>
the small goal is to talk about extending a finitely supported function by one point</p>



<a name="195909996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195909996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195909996">(Apr 30 2020 at 22:25)</a>:</h4>
<p>is pfun supposed to be finsupp but replacing 0 with none?</p>



<a name="195910087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195910087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195910087">(Apr 30 2020 at 22:26)</a>:</h4>
<p>that seems like a step in the right direction, I was about to enrich my target type with a "zero" by wrapping it in option and setting <code>0 = none</code></p>



<a name="195910274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195910274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195910274">(Apr 30 2020 at 22:28)</a>:</h4>
<p>Are you doing it only for countable orders then?</p>



<a name="195910350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195910350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195910350">(Apr 30 2020 at 22:29)</a>:</h4>
<p>"Finite" is not really the condition you need, right?</p>



<a name="195910415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195910415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195910415">(Apr 30 2020 at 22:30)</a>:</h4>
<p>Like, it's automatically finite because you've only picked finitely many things so far. So you don't also need to remember it's a <code>finset</code>.</p>



<a name="195910798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195910798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195910798">(Apr 30 2020 at 22:35)</a>:</h4>
<p>yeah i just want to do it for countable orders (which should be like 80% of the work of doing it for orders in bijection with an arbitrary ordinal)</p>



<a name="195910837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195910837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195910837">(Apr 30 2020 at 22:35)</a>:</h4>
<p>my plan was to do a mutual induction on two maps <code>forth : M \to N</code> and <code>back : N \to M</code></p>



<a name="195910955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195910955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195910955">(Apr 30 2020 at 22:37)</a>:</h4>
<p>I think you will find this tricky, and I'm curious to see what you come up with</p>



<a name="195910964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195910964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195910964">(Apr 30 2020 at 22:37)</a>:</h4>
<p>yeah I agree</p>



<a name="195910999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195910999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195910999">(Apr 30 2020 at 22:37)</a>:</h4>
<p>(my hope is that it ends up being a decent kata)</p>



<a name="195911766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195911766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195911766">(Apr 30 2020 at 22:46)</a>:</h4>
<p>i guess it's time to see if I know how the option monad works...</p>



<a name="195913459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195913459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195913459">(Apr 30 2020 at 23:07)</a>:</h4>
<p>okay, I think this is the API that I want into roption (as in, I think after I know this I don't have to think about the guts of roption)</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">pfun</span>
<span class="kn">open</span> <span class="n">pfun</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
<span class="kn">structure</span> <span class="n">safely_applied</span>
<span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">dom</span> <span class="n">f</span><span class="o">)</span>
<span class="o">:=</span> <span class="n">mk</span> <span class="bp">::</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">h_val</span> <span class="o">:</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">roption</span><span class="bp">.</span><span class="n">some</span> <span class="n">val</span><span class="o">)</span>

<span class="n">def</span> <span class="n">safely_apply</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">M</span><span class="o">}(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">dom</span> <span class="n">f</span><span class="o">)</span>
<span class="o">:</span> <span class="n">safely_applied</span> <span class="n">ha</span>
 <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>


<p>edit: now it's an MWE instead of an ME</p>



<a name="195921075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195921075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195921075">(May 01 2020 at 00:56)</a>:</h4>
<p>I don't get this api at all. The structure <code>safely_applied</code> is useless, you may as well have <code>{val // f a = roption.some val}</code>  as the target type of <code>safely_apply</code>, which is more conventionally written <code>{val // val \in f a}</code>, and the proof is <code>&lt;(f a).get ha, (f a).get_mem ha&gt;</code></p>



<a name="195921114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195921114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195921114">(May 01 2020 at 00:57)</a>:</h4>
<p>that is, the <code>safely_apply</code> function is called <code>get</code></p>



<a name="195925134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195925134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195925134">(May 01 2020 at 02:12)</a>:</h4>
<p>hmm now I realize I don't know how to do what I want with either <code>safely_apply</code> or get. How would you fix this?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
<span class="n">def</span> <span class="n">partial_embedding</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">dom</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">dom</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="o">:=</span> <span class="o">(</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">f</span> <span class="n">b</span> <span class="o">)</span>
</code></pre></div>



<a name="195925169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195925169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195925169">(May 01 2020 at 02:13)</a>:</h4>
<p>where the problem is that i've asked about the order between two terms of type <code>roption N</code> instead of <code>N</code></p>



<a name="195925236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195925236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195925236">(May 01 2020 at 02:15)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
<span class="n">def</span> <span class="n">partial_embedding</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">dom</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">dom</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="o">:=</span> <span class="o">(</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">get</span> <span class="n">ha</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">get</span> <span class="n">hb</span> <span class="o">)</span>
</code></pre></div>



<a name="195925240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195925240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195925240">(May 01 2020 at 02:15)</a>:</h4>
<p>I wanted to replace <code>f a</code> with something like <code>get (f a) ha</code> or <code>(safely_apply f a).val</code>, but I didn't seem to understand the error messages when I tried using each of those</p>



<a name="195925253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195925253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195925253">(May 01 2020 at 02:15)</a>:</h4>
<p>Thank you!</p>



<a name="195925308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195925308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195925308">(May 01 2020 at 02:16)</a>:</h4>
<p>If you don't use dot notation you have to write <code>roption.get (f a) ha</code> or open <code>roption</code></p>



<a name="195925317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195925317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195925317">(May 01 2020 at 02:16)</a>:</h4>
<p>dot notation is great</p>



<a name="195925410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/195925410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#195925410">(May 01 2020 at 02:19)</a>:</h4>
<p>I'll have to study the definition of roption.get to figure out why my attempt to call <code>.val</code> on my structure failed</p>



<a name="196028887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196028887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196028887">(May 02 2020 at 02:43)</a>:</h4>
<p>Okay I think I'm still missing something fundamental. I want to define a term <code>def partial_embedding (f : M →. N) : Prop </code> which morally means "whenever <code>f a</code> and <code>f b</code> are defined, we have <code>a \le b \iff f a \le f b</code>"</p>



<a name="196028888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196028888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196028888">(May 02 2020 at 02:43)</a>:</h4>
<p>This is what I came up with, and I think it is bad in a way that means I'm missing something fundamental</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">pfun</span>
<span class="kn">open</span> <span class="n">pfun</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">DLO</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">DLO</span> <span class="n">N</span><span class="o">]</span>

<span class="n">def</span> <span class="n">partial_embedding_at_points</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">dom</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">dom</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="o">:=</span> <span class="o">(</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">get</span> <span class="n">ha</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">get</span> <span class="n">hb</span> <span class="o">)</span>

<span class="n">def</span> <span class="n">partial_embedding_aux</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">by_cases</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">dom</span> <span class="n">f</span><span class="o">,</span>
    <span class="n">swap</span><span class="o">,</span> <span class="n">exact</span> <span class="n">true</span><span class="o">,</span> <span class="n">rename</span> <span class="n">h</span> <span class="n">ha</span><span class="o">,</span>
<span class="n">by_cases</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">dom</span> <span class="n">f</span><span class="o">,</span>
    <span class="n">swap</span><span class="o">,</span> <span class="n">exact</span> <span class="n">true</span><span class="o">,</span> <span class="n">rename</span> <span class="n">h</span> <span class="n">hb</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">partial_embedding_at_points</span> <span class="n">f</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">partial_embedding</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">M</span><span class="o">,</span> <span class="n">partial_embedding_aux</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span>
</code></pre></div>



<a name="196028894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196028894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196028894">(May 02 2020 at 02:43)</a>:</h4>
<p>(oof I did not mean to have "press enter to send" checked)</p>



<a name="196029019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196029019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196029019">(May 02 2020 at 02:46)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">partial_embedding</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span> <span class="bp">@</span><span class="n">partial_embedding_at_points</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span>
</code></pre></div>



<a name="196029028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196029028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196029028">(May 02 2020 at 02:47)</a>:</h4>
<p>oh i didn't know you could leave the type unspecified in a quantifier. that's great!</p>



<a name="196029066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196029066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196029066">(May 02 2020 at 02:48)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">pfun</span>
<span class="kn">open</span> <span class="n">pfun</span>

<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">N</span><span class="o">]</span>

<span class="n">def</span> <span class="n">partial_embedding</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">get</span> <span class="n">ha</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">get</span> <span class="n">hb</span>
</code></pre></div>



<a name="196029289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196029289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196029289">(May 02 2020 at 02:54)</a>:</h4>
<p>The next broken bit is this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">embedding_extension</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">partial_embedding</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mk</span> <span class="bp">::</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">embedding</span> <span class="o">:</span> <span class="n">partial_embedding</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">extension</span> <span class="o">:</span> <span class="n">dom</span> <span class="n">f</span> <span class="bp">≤</span> <span class="n">dom</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">supports_x</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">dom</span> <span class="n">F</span><span class="o">)</span>

<span class="n">def</span> <span class="n">finite_embedding_extension</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">partial_embedding</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">finite</span> <span class="n">dom</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">embedding_extension</span> <span class="n">f</span> <span class="n">hf</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>


<p>The problem is that the type signature of the second term doesn't compile. The error message looks to me like it says it doesn't know <code>partial_embedding f = partial_embedding f</code></p>
<div class="codehilite"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">embedding_extension</span> <span class="n">f</span> <span class="n">hf</span>
<span class="n">term</span>
  <span class="n">hf</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">partial_embedding</span> <span class="n">M</span> <span class="n">N</span> <span class="bp">_</span><span class="n">inst_1</span> <span class="bp">_</span><span class="n">inst_2</span> <span class="n">f</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">partial_embedding</span> <span class="err">?</span><span class="n">m_1</span> <span class="err">?</span><span class="n">m_2</span> <span class="err">?</span><span class="n">m_3</span> <span class="err">?</span><span class="n">m_4</span> <span class="n">f</span>
</code></pre></div>


<p>or maybe like it's upset that it got concrete variables when it expected metavariables?</p>



<a name="196029652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196029652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196029652">(May 02 2020 at 03:05)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/wiki/Minimum-Working-Example-&#40;MWE&#41;" title="https://github.com/leanprover-community/mathlib/wiki/Minimum-Working-Example-&#40;MWE&#41;">#mwe</a></p>



<a name="196029751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196029751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196029751">(May 02 2020 at 03:08)</a>:</h4>
<p>fixed, thanks</p>



<a name="196029761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196029761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196029761">(May 02 2020 at 03:08)</a>:</h4>
<p>what is <code>(set.finite dom f)</code> doing?</p>



<a name="196029764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196029764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196029764">(May 02 2020 at 03:09)</a>:</h4>
<p>That looks like a malformed binder</p>



<a name="196029768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196029768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196029768">(May 02 2020 at 03:09)</a>:</h4>
<p>in any case <code>set.finite</code> isn't imported</p>



<a name="196029771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196029771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196029771">(May 02 2020 at 03:09)</a>:</h4>
<p>and <code>dom</code> doesn't exist either</p>



<a name="196029884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196029884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196029884">(May 02 2020 at 03:13)</a>:</h4>
<p>added an import for <code>set</code>. </p>
<p><code>#check dom</code> works for me? it's <code>pfun.dom</code> which comes from <code>import data.pfun</code></p>



<a name="196029937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196029937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196029937">(May 02 2020 at 03:14)</a>:</h4>
<p>I think more newlines might help.</p>



<a name="196029958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196029958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196029958">(May 02 2020 at 03:14)</a>:</h4>
<p>ah, the malformed binder is why I couldn't tell that <code>set.finite</code> was missing</p>



<a name="196030043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196030043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196030043">(May 02 2020 at 03:16)</a>:</h4>
<p>Okay, this works now. I guess I will try to recognize malformed binders in the future.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">pfun</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span>
<span class="kn">open</span> <span class="n">pfun</span>

<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">N</span><span class="o">]</span>

<span class="n">def</span> <span class="n">partial_embedding</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">get</span> <span class="n">ha</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">get</span> <span class="n">hb</span>

<span class="kn">structure</span> <span class="n">embedding_extension</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">partial_embedding</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mk</span> <span class="bp">::</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">embedding</span> <span class="o">:</span> <span class="n">partial_embedding</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">extension</span> <span class="o">:</span> <span class="n">dom</span> <span class="n">f</span> <span class="bp">≤</span> <span class="n">dom</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">supports_x</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">dom</span> <span class="n">F</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">dom</span>

<span class="n">def</span> <span class="n">finite_embedding_extension</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">partial_embedding</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite</span> <span class="o">(</span><span class="n">dom</span> <span class="n">f</span><span class="o">)</span> <span class="o">)</span> <span class="o">:</span> <span class="n">embedding_extension</span> <span class="n">f</span> <span class="n">hf</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="196030105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196030105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196030105">(May 02 2020 at 03:18)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">embedding_extension</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">partial_embedding</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">embedding</span> <span class="o">:</span> <span class="n">partial_embedding</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">extension</span> <span class="o">:</span> <span class="n">dom</span> <span class="n">f</span> <span class="bp">≤</span> <span class="n">dom</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">supports_x</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">dom</span> <span class="n">F</span><span class="o">)</span>
</code></pre></div>



<a name="196030106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196030106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196030106">(May 02 2020 at 03:18)</a>:</h4>
<p>put fields one per line, and skip <code>mk ::</code></p>



<a name="196030113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196030113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196030113">(May 02 2020 at 03:19)</a>:</h4>
<p>okay, thanks. Is there a style guide somewhere?</p>



<a name="196030138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196030138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196030138">(May 02 2020 at 03:20)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/master/docs/contribute/style.md" title="https://github.com/leanprover-community/mathlib/blob/master/docs/contribute/style.md">https://github.com/leanprover-community/mathlib/blob/master/docs/contribute/style.md</a> but I wouldn't be surprised if it's missing something</p>



<a name="196030173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196030173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196030173">(May 02 2020 at 03:20)</a>:</h4>
<p><code>mk ::</code> is unnecessary since <code>mk</code> is the default</p>



<a name="196030182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196030182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196030182">(May 02 2020 at 03:20)</a>:</h4>
<p>Mostly, look at mathlib sources to get a feel for the style</p>



<a name="196030199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196030199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196030199">(May 02 2020 at 03:21)</a>:</h4>
<p>also be kind to people who have 80-100 character wide screens</p>



<a name="196030202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196030202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196030202">(May 02 2020 at 03:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/functions.20with.20finite.20support/near/196030173" title="#narrow/stream/113489-new-members/topic/functions.20with.20finite.20support/near/196030173">said</a>:</p>
<blockquote>
<p><code>mk ::</code> is unnecessary since <code>mk</code> is the default</p>
</blockquote>
<p>I have no idea what that means, I just copied <code>structure </code> blocks from other places enough times for me to memorize that <code>mk ::</code> is a thing to type</p>



<a name="196030237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196030237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196030237">(May 02 2020 at 03:22)</a>:</h4>
<p>the <code>name ::</code> at the beginning of a structure is a (rarely used) feature to allow you to change the name of the single constructor for the structure</p>



<a name="196030263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196030263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196030263">(May 02 2020 at 03:22)</a>:</h4>
<p>hmm okay</p>



<a name="196030267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196030267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196030267">(May 02 2020 at 03:22)</a>:</h4>
<p>the default is <code>mk</code> and most structures go with that, but sometimes you might want a custom constructor with that name so you will see <code>mk' ::</code> sometimes</p>



<a name="196030286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196030286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196030286">(May 02 2020 at 03:23)</a>:</h4>
<p>it's because a structure is sugar for an inductive type like this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">embedding_extension</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">partial_embedding</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="bp">∀</span>
  <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→.</span> <span class="n">N</span><span class="o">)</span>
  <span class="o">(</span><span class="n">embedding</span> <span class="o">:</span> <span class="n">partial_embedding</span> <span class="n">F</span><span class="o">)</span>
  <span class="o">(</span><span class="n">extension</span> <span class="o">:</span> <span class="n">dom</span> <span class="n">f</span> <span class="bp">≤</span> <span class="n">dom</span> <span class="n">F</span><span class="o">)</span>
  <span class="o">(</span><span class="n">supports_x</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">dom</span> <span class="n">F</span><span class="o">),</span>
  <span class="n">embedding_extension</span>
</code></pre></div>



<a name="196030348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196030348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196030348">(May 02 2020 at 03:24)</a>:</h4>
<p>anyway, I missed what the question is</p>



<a name="196030350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196030350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196030350">(May 02 2020 at 03:25)</a>:</h4>
<p>the code you sent seems to work</p>



<a name="196030426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196030426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196030426">(May 02 2020 at 03:27)</a>:</h4>
<p>Yeah, I agree, I was just trying to express that I incorporated the solution. I prefaced it with "this works now". Sorry for causing extra copy-paste-compiles.</p>



<a name="196039494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196039494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196039494">(May 02 2020 at 07:59)</a>:</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">κ</span></span></span></span>-categoricity is false for uncountable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">κ</span></span></span></span>, right?  Consider something like "rationals union negative reals" vs "rationals union positive reals". The interesting thing is that you get completeness from just <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span>-categoricity.</p>
<p>Anyway, this is definitely a nice exercise! :-)</p>



<a name="196046647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/functions%20with%20finite%20support/near/196046647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/functions.20with.20finite.20support.html#196046647">(May 02 2020 at 11:06)</a>:</h4>
<p>Oh, nice example, thanks. I must have been mixing up this with something else then.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
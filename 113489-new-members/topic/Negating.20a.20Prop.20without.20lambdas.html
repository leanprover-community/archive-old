---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html">Negating a Prop without lambdas</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="215669038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215669038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215669038">(Nov 05 2020 at 03:55)</a>:</h4>
<p>Is there a short notation for the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span>
</code></pre></div>



<a name="215669411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215669411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215669411">(Nov 05 2020 at 04:04)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∘</span><span class="o">)</span> <span class="n">not</span>
</code></pre></div>



<a name="215672086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215672086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215672086">(Nov 05 2020 at 05:12)</a>:</h4>
<p>Cool. But <code>not ∘ p</code> when <code>p</code> is <code>decidable_pred</code> is not <code>decidable_pred</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">decidable_pred</span> <span class="n">p</span><span class="o">,</span>
<span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">hn</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="bp">¬</span><span class="n">p</span> <span class="o">(</span><span class="n">v.nth</span> <span class="n">i</span><span class="o">))</span> <span class="bp">→</span> <span class="n">v.filter_count</span> <span class="o">(</span><span class="n">not</span> <span class="bp">∘</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
<span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n.succ</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">),</span> <span class="bp">¬</span><span class="n">p</span> <span class="o">(</span><span class="n">v.nth</span> <span class="n">i</span><span class="o">),</span>
<span class="n">this</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">v.head</span>
<span class="bp">⊢</span> <span class="n">decidable_pred</span> <span class="n">not</span>
</code></pre></div>



<a name="215760400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215760400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215760400">(Nov 05 2020 at 19:14)</a>:</h4>
<p>I think there's just a missing instance in mathlib maybe? Something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">decidable_not_of_decidable_pred</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">inst1</span><span class="o">:</span> <span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">not</span> <span class="o">(</span><span class="n">p</span> <span class="n">x</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="n">x</span> <span class="k">then</span> <span class="n">is_false</span> <span class="o">(</span><span class="n">absurd</span> <span class="n">h1</span><span class="o">)</span> <span class="k">else</span> <span class="n">is_true</span> <span class="n">h1</span>
</code></pre></div>



<a name="215761132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215761132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215761132">(Nov 05 2020 at 19:21)</a>:</h4>
<p>Actually the composition one is a little nicer to look at.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">decidable_not_of_decidable_pred</span>
  <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">inst1</span><span class="o">:</span> <span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="n">not</span> <span class="bp">∘</span> <span class="n">p</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="n">x</span> <span class="k">then</span> <span class="n">is_false</span> <span class="o">(</span><span class="n">absurd</span> <span class="n">h1</span><span class="o">)</span> <span class="k">else</span> <span class="n">is_true</span> <span class="n">h1</span>
</code></pre></div>



<a name="215761473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215761473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215761473">(Nov 05 2020 at 19:23)</a>:</h4>
<p>I think my not finding it was due to a <code>congr</code> that went too deep. Because this is in core:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="kd">instance</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="k">then</span> <span class="n">is_false</span> <span class="o">(</span><span class="n">absurd</span> <span class="n">hp</span><span class="o">)</span> <span class="k">else</span> <span class="n">is_true</span> <span class="n">hp</span>
</code></pre></div>



<a name="215761483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215761483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215761483">(Nov 05 2020 at 19:23)</a>:</h4>
<p>Judging from <a href="https://leanprover-community.github.io/mathlib_docs/find/list.partition_eq_filter_filter">docs#list.partition_eq_filter_filter</a> it seems like such an instance must already exist, no?</p>



<a name="215762160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215762160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215762160">(Nov 05 2020 at 19:28)</a>:</h4>
<p>But that's not exactly the same thing.</p>



<a name="215762171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215762171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215762171">(Nov 05 2020 at 19:28)</a>:</h4>
<p>This fails:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="o">(</span><span class="k">show</span> <span class="n">decidable_pred</span> <span class="n">not</span><span class="o">,</span> <span class="kd">by</span> <span class="n">apply_instance</span><span class="o">)</span>
</code></pre></div>



<a name="215763211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215763211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215763211">(Nov 05 2020 at 19:36)</a>:</h4>
<p>And there can't be such an instance</p>



<a name="215763377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215763377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215763377">(Nov 05 2020 at 19:37)</a>:</h4>
<p>Right. So again, <code>congr</code>'d too deep. This is all in the context of trying to define <code>partition</code> like things on vectors. Thanks for the pointer to that list partition lemma!</p>



<a name="215763512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215763512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215763512">(Nov 05 2020 at 19:38)</a>:</h4>
<p>Lean tends to not really like you writing <code>not ∘ p</code> for <code>λ x, ¬ p x</code> because of reasons like this</p>



<a name="215763576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215763576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215763576">(Nov 05 2020 at 19:39)</a>:</h4>
<p>You'd want a reducible version of <code>∘</code>.</p>



<a name="215763672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215763672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215763672">(Nov 05 2020 at 19:40)</a>:</h4>
<p>Relatedly, is there a partition-like sum type that splits a type into a sum of two subtypes, each predicated on the two cases of a proposition?</p>



<a name="215763868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215763868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215763868">(Nov 05 2020 at 19:41)</a>:</h4>
<p>Yeah, the friction of Lean with some pointfree style gets in the way sometimes</p>



<a name="215764578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215764578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215764578">(Nov 05 2020 at 19:46)</a>:</h4>
<p>It's better to not stir up trouble and stick to the simple <code>λ x, ¬ p x</code>, IMO</p>



<a name="215764664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215764664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215764664">(Nov 05 2020 at 19:47)</a>:</h4>
<p>Yeah, sorry for misleading with the first response. I don't recommend using pointfree style in lean because it doesn't work well with higher order type classes</p>



<a name="215765817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215765817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215765817">(Nov 05 2020 at 19:56)</a>:</h4>
<p>Does that mean things like this should also be avoided?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">prod.map</span> <span class="o">((</span><span class="bp">+</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span> <span class="n">id</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">prod.map</span> <span class="n">prod.fst</span> <span class="n">id</span><span class="o">)</span>
</code></pre></div>



<a name="215765878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215765878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215765878">(Nov 05 2020 at 19:56)</a>:</h4>
<p>In the context of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">prod.map</span> <span class="n">prod.fst</span> <span class="o">(</span><span class="bp">@</span><span class="n">id</span> <span class="n">α</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">prod.map</span> <span class="o">((</span><span class="bp">+</span><span class="o">)</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">))</span> <span class="n">id</span><span class="o">)</span> <span class="bp">=</span> <span class="n">prod.map</span> <span class="o">((</span><span class="bp">+</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span> <span class="n">id</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">prod.map</span> <span class="n">prod.fst</span> <span class="n">id</span><span class="o">)</span>
</code></pre></div>



<a name="215765983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215765983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215765983">(Nov 05 2020 at 19:57)</a>:</h4>
<p>This is <code>\lam p, (1 + p.1.1, p.2)</code>?</p>



<a name="215766121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215766121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215766121">(Nov 05 2020 at 19:58)</a>:</h4>
<p>I'd say there is certainly no advantage to the pointfree version... even ignoring it being unnecessarily higher-order</p>



<a name="215766249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215766249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215766249">(Nov 05 2020 at 19:59)</a>:</h4>
<p>Hopefully, it took me just three tries to understand what it meant</p>



<a name="215766449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215766449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215766449">(Nov 05 2020 at 20:01)</a>:</h4>
<p>I'm trying to show that one can rearrange these operations on a vector of pairs -- I guess I should probably simplify my definitions</p>



<a name="215767327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215767327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215767327">(Nov 05 2020 at 20:08)</a>:</h4>
<p>what's the context of the goal?</p>



<a name="215767601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215767601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215767601">(Nov 05 2020 at 20:10)</a>:</h4>
<p>I was assuming you wrote that expression... if it arose in a proof then it's not necessarily bad, but these <code>prod.map</code> and <code>∘</code> must have come from somewhere</p>



<a name="215767613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215767613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215767613">(Nov 05 2020 at 20:10)</a>:</h4>
<p>At this point, I've probably fixed the code enough that I don't remember where this was coming up. But I am proving (not putting in all of the auxiliary definitions):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">map_filter_enum_prop_eq_enum_from_filter'</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">v.filter_count</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="n">v.enum_prop'</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">xpair</span><span class="o">,</span> <span class="n">p</span> <span class="n">xpair.snd</span><span class="o">)</span>
    <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">filter_count_of_map_snd_enum_prop'</span><span class="o">,</span> <span class="n">h</span><span class="o">]))</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">prod.map</span> <span class="n">prod.fst</span> <span class="n">id</span><span class="o">)</span> <span class="bp">=</span>
  <span class="o">(</span><span class="n">v.filter</span> <span class="n">p</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">enum_from'</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="215767863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215767863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215767863">(Nov 05 2020 at 20:12)</a>:</h4>
<p>The broader goal is to provide an <code>enumerate</code> definition for vectors, which enumerates the <code>p x</code> and <code>not (p x)</code> separately.</p>



<a name="215767952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215767952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215767952">(Nov 05 2020 at 20:13)</a>:</h4>
<p>And at the end of the day, indexes them not by <code>nat</code> but by <code>fin m</code> where <code>m</code> is the total number of <code>p x</code> in the vector (of size <code>n</code>).</p>



<a name="215768029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215768029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215768029">(Nov 05 2020 at 20:14)</a>:</h4>
<p>Sorry for confusion -- the explanations about pointfree or not was helpful! I think I'm good to go.</p>



<a name="215769415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215769415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215769415">(Nov 05 2020 at 20:26)</a>:</h4>
<p>what is the type of <code>v</code>?</p>



<a name="215769496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215769496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215769496">(Nov 05 2020 at 20:27)</a>:</h4>
<p>that <code>rw</code> in the middle of the statement doesn't look great</p>



<a name="215769741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215769741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215769741">(Nov 05 2020 at 20:29)</a>:</h4>
<p>It sounds like what you are doing could be most easily accomplished by converting the vector to a list and then using <code>list.filter</code> or perhaps <code>list.partition</code></p>



<a name="215770009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215770009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215770009">(Nov 05 2020 at 20:32)</a>:</h4>
<p>to get that final indexing, you can use <code>list.nth_le</code> on the resulting list, after a propositional proof that the length of the list is whatever your target value is</p>



<a name="215771232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215771232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215771232">(Nov 05 2020 at 20:42)</a>:</h4>
<p>So perform all the manipulations on the list level, while carrying around proofs that the length isn't changed? Isn't that exactly what the vector type represents? I think you're saying that, yes, that is what vector represents, but it is not worth it to "avoid the underlying list". While I have been trying to try to remain in the vector API (as I build it up). Did I understand correctly?</p>



<a name="215772779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215772779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215772779">(Nov 05 2020 at 20:56)</a>:</h4>
<p>I don't even understand how that statement is valid Lean code... you can use a <code>by rw</code> inside the statement of a lemma that you're trying to prove?</p>



<a name="215775043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215775043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215775043">(Nov 05 2020 at 21:14)</a>:</h4>
<p>Why not? <code>by</code> is a way to enter tactic mode when in term mode. It creates a weird <code>eq.rec</code> term, but that shouldn't matter, because proof irrelevance means a proof that has <code>eq.rec</code> on it is still equal to one that doesn't. I had to use <code>by rw</code> in that instance because my current definitions have implicit variables where I probably should not have them. So, a simple <code>filter_count_of_map_snd_enum_prop'  ▸  h</code> or whatever it would be doesn't work because of uninferred metavariables. But <code>rw</code> is able to discharge them.</p>



<a name="215775400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215775400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215775400">(Nov 05 2020 at 21:17)</a>:</h4>
<p>The reason I have that propositional term here anyway is that my definition of <code>vector.filter</code> requires a hypothesis that proves that the number of items that match the condition that you're filtering on is <code>m</code>: <code>(h : v.filter_count p = m)</code>. This makes it easier to make proofs by operations on that <code>m</code>. I guess I could encode it implicitly, then have to do something like a</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">set</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">\</span><span class="n">N</span> <span class="o">:=</span> <span class="n">v.filter_count</span> <span class="n">p</span> <span class="k">with</span> <span class="n">h</span><span class="o">,</span>
<span class="bp">...</span>
</code></pre></div>
<p>inside all my proofs.</p>



<a name="215777903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215777903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215777903">(Nov 05 2020 at 21:40)</a>:</h4>
<blockquote>
<p>while carrying around proofs that the length isn't changed?</p>
</blockquote>
<p>Not carrying around the proof, inserting the proof once at the end</p>



<a name="215777973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215777973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215777973">(Nov 05 2020 at 21:41)</a>:</h4>
<p>Still a bit hard to give pointed advice without a mwe</p>



<a name="215778156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215778156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215778156">(Nov 05 2020 at 21:43)</a>:</h4>
<p>I think that <code>vector.filter</code>, if it is to exist at all, is forced to have essentially the type you have said, but I would want to <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> the problem a bit more and look at the reason you want this function</p>



<a name="215778402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215778402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215778402">(Nov 05 2020 at 21:46)</a>:</h4>
<p>However, the fact that you need a special function just to describe the length of the resulting filter, and assert equality to <code>m</code>, suggests that you aren't really gaining anything over a plain <code>list.filter</code> (which you can always force into a <code>vector A m</code> using the constructor, which takes a hypothesis <code>(list.filter v p).length = m</code>)</p>



<a name="215781477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215781477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215781477">(Nov 05 2020 at 22:16)</a>:</h4>
<p>The goal is to make this sorry free and legible:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">collect_pieces</span>
       <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="bp">♞</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♞</span><span class="o">],</span>
         <span class="bp">!</span><span class="o">[</span><span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">],</span>
         <span class="bp">!</span><span class="o">[</span><span class="bp">♘</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♘</span><span class="o">]]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">sorry</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">!</span><span class="o">[</span><span class="bp">♞</span><span class="o">,</span> <span class="bp">♞</span><span class="o">,</span> <span class="bp">♘</span><span class="o">,</span> <span class="bp">♘</span><span class="o">]</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">@</span><span class="n">number_pieces</span> <span class="mi">3</span> <span class="mi">3</span> <span class="mi">4</span>
       <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="bp">♞</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♞</span><span class="o">],</span>
         <span class="bp">!</span><span class="o">[</span><span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">],</span>
         <span class="bp">!</span><span class="o">[</span><span class="bp">♘</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♘</span><span class="o">]]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">sorry</span><span class="o">)</span> <span class="bp">=</span>
       <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="mi">1</span><span class="o">],</span>
         <span class="bp">!</span><span class="o">[</span><span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">],</span>
         <span class="bp">!</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="mi">3</span><span class="o">]]</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">option</span> <span class="n">colored_pieces</span><span class="o">))</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b.count_some</span> <span class="bp">=</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">number_pieces</span> <span class="n">b</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">option.map</span> <span class="o">(</span><span class="n">collect_pieces</span> <span class="n">b</span> <span class="n">h</span><span class="o">))</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="215781489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215781489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215781489">(Nov 05 2020 at 22:16)</a>:</h4>
<p>Here's a stub file with a lot of missing definitions and lemmas:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.matrix.notation</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">color</span>
<span class="bp">|</span> <span class="n">white</span>
<span class="bp">|</span> <span class="n">black</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">pieces</span>
<span class="bp">|</span> <span class="n">knight</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">structure</span> <span class="n">colored_pieces</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">piece</span> <span class="o">:</span> <span class="n">pieces</span><span class="o">)</span>
<span class="o">(</span><span class="n">color</span> <span class="o">:</span> <span class="n">color</span><span class="o">)</span>

<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">white_knight</span> <span class="o">:</span> <span class="n">colored_pieces</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">pieces.knight</span><span class="o">,</span> <span class="n">color.white</span><span class="o">⟩</span>
<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">black_knight</span> <span class="o">:</span> <span class="n">colored_pieces</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">pieces.knight</span><span class="o">,</span> <span class="n">color.black</span><span class="o">⟩</span>

<span class="kd">notation</span> <span class="bp">`</span> <span class="bp">♘</span> <span class="bp">`</span> <span class="o">:=</span> <span class="n">white_knight</span>
<span class="kd">notation</span> <span class="bp">`</span> <span class="bp">♞</span> <span class="bp">`</span> <span class="o">:=</span> <span class="n">black_knight</span>
<span class="kd">notation</span> <span class="bp">`</span><span class="n">__</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">none</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">matrix.ravel</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">*</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">vector.filter_count</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">v.to_list.filter</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span>

<span class="kd">def</span> <span class="n">vector.filter</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">v.filter_count</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">m</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">v.to_list.filter</span> <span class="n">p</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">vector.count_some</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="o">(</span><span class="n">option</span> <span class="n">α</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">v.filter_count</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">option.is_some</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">vector.filter_some</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="o">(</span><span class="n">option</span> <span class="n">α</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">v.count_some</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">vector</span> <span class="o">(</span><span class="n">option</span> <span class="n">α</span><span class="o">)</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">v.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">option.is_some</span> <span class="n">x</span><span class="o">)</span> <span class="n">hm</span>

<span class="kd">lemma</span> <span class="n">vector.filter_valid</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">v.filter_count</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">p</span> <span class="o">((</span><span class="n">v.filter</span> <span class="n">p</span> <span class="n">hm</span><span class="o">)</span><span class="bp">.</span><span class="n">nth</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">lemma</span> <span class="n">vector.filter_some_pred</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="o">(</span><span class="n">option</span> <span class="n">α</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">v.count_some</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="o">((</span><span class="n">v.filter_some</span> <span class="n">hm</span><span class="o">)</span><span class="bp">.</span><span class="n">nth</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">is_some</span> <span class="o">:=</span>
<span class="n">vector.filter_valid</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hm</span>

<span class="kd">def</span> <span class="n">vector.reduce_some</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="o">(</span><span class="n">option</span> <span class="n">α</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">v.count_some</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">vector.of_fn</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">option.get</span> <span class="o">((</span><span class="n">v.filter_some_pred</span> <span class="n">hm</span><span class="o">)</span> <span class="n">i</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">matrix.count_some</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">option</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">vector.count_some</span> <span class="o">(</span><span class="n">vector.of_fn</span> <span class="n">M.ravel</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">collect_pieces</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">option</span> <span class="n">colored_pieces</span><span class="o">))</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b.count_some</span> <span class="bp">=</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">colored_pieces</span> <span class="o">:=</span>
<span class="n">vector.nth</span> <span class="o">(</span><span class="n">vector.reduce_some</span> <span class="o">(</span><span class="n">vector.of_fn</span> <span class="n">b.ravel</span><span class="o">)</span> <span class="n">h</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">number_pieces</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">option</span> <span class="n">colored_pieces</span><span class="o">))</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b.count_some</span> <span class="bp">=</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">option</span> <span class="o">(</span><span class="n">fin</span> <span class="n">k</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="o">(</span><span class="n">option</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">some</span> <span class="mi">0</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="o">(</span><span class="n">option</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)))</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">some</span> <span class="mi">1</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">option</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="bp">+</span><span class="o">)</span> <span class="bp">&lt;$&gt;</span> <span class="n">x</span> <span class="bp">&lt;*&gt;</span> <span class="n">y</span><span class="o">⟩</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">collect_pieces</span>
       <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="bp">♞</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♞</span><span class="o">],</span>
         <span class="bp">!</span><span class="o">[</span><span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">],</span>
         <span class="bp">!</span><span class="o">[</span><span class="bp">♘</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♘</span><span class="o">]]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">sorry</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">!</span><span class="o">[</span><span class="bp">♞</span><span class="o">,</span> <span class="bp">♞</span><span class="o">,</span> <span class="bp">♘</span><span class="o">,</span> <span class="bp">♘</span><span class="o">]</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">@</span><span class="n">number_pieces</span> <span class="mi">3</span> <span class="mi">3</span> <span class="mi">4</span>
       <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="bp">♞</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♞</span><span class="o">],</span>
         <span class="bp">!</span><span class="o">[</span><span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">],</span>
         <span class="bp">!</span><span class="o">[</span><span class="bp">♘</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♘</span><span class="o">]]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">sorry</span><span class="o">)</span> <span class="bp">=</span>
       <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="mi">1</span><span class="o">],</span>
         <span class="bp">!</span><span class="o">[</span><span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">],</span>
         <span class="bp">!</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="mi">3</span><span class="o">]]</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">option</span> <span class="n">colored_pieces</span><span class="o">))</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b.count_some</span> <span class="bp">=</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">number_pieces</span> <span class="n">b</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">option.map</span> <span class="o">(</span><span class="n">collect_pieces</span> <span class="n">b</span> <span class="n">h</span><span class="o">))</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="215781663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215781663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215781663">(Nov 05 2020 at 22:18)</a>:</h4>
<p>For this exact problem, I could have just written all the <code>filter</code> stuff specialized to <code>option</code>, like <code>list.reduce_option</code> already is. But at some point, I'll need to filter on other predicates, like what piece it is, so that I can number pieces of different types.</p>



<a name="215781754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215781754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215781754">(Nov 05 2020 at 22:19)</a>:</h4>
<p>Happy to hear any suggestions and to be set on a right path.</p>



<a name="215782806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215782806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215782806">(Nov 05 2020 at 22:32)</a>:</h4>
<p>can you describe what is the overall problem you are trying to solve, like why do you want to number pieces?</p>



<a name="215782928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215782928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215782928">(Nov 05 2020 at 22:33)</a>:</h4>
<p>for this specific problem it seems like having a matrix is pretty inconvenient, maybe you could just turn it into a list and prove things there</p>



<a name="215782943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215782943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215782943">(Nov 05 2020 at 22:33)</a>:</h4>
<p>The general context is the following project: <a href="https://github.com/Julian/lean-across-the-board">https://github.com/Julian/lean-across-the-board</a></p>



<a name="215783038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215783038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215783038">(Nov 05 2020 at 22:34)</a>:</h4>
<p>The pieces have to be numbered because one moves around pieces based on the piece identity, but tracks their positions based on index.</p>



<a name="215783126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215783126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215783126">(Nov 05 2020 at 22:35)</a>:</h4>
<p>does one do that? typically in chess you specify moves like <code>Ng1-f3</code>, you dont store an identity for a single knight across the whole game</p>



<a name="215783131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215783131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215783131">(Nov 05 2020 at 22:35)</a>:</h4>
<p>For example, if you wanted to model castling, would you assign the two different rooks different piece types? How would you keep track of which was the king's-side and which was the queen's-side rook to keep track of whether it has moved before castling?</p>



<a name="215783215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215783215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215783215">(Nov 05 2020 at 22:36)</a>:</h4>
<p>you just keep track of two boolean values, is k-side castling and q-side castling still allowed</p>



<a name="215783472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215783472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215783472">(Nov 05 2020 at 22:39)</a>:</h4>
<p>I think it's a matter of notation. If I started from a board with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">!</span><span class="o">[</span><span class="bp">♞</span><span class="o">,</span> <span class="bp">♞</span><span class="o">,</span> <span class="bp">♘</span><span class="o">,</span> <span class="bp">♘</span><span class="o">]</span> <span class="bp">@</span>
<span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="mi">0</span> <span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="mi">1</span> <span class="o">],</span>
  <span class="bp">!</span><span class="o">[</span><span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">],</span>
  <span class="bp">!</span><span class="o">[</span><span class="mi">2</span> <span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="mi">3</span> <span class="o">]]</span>
</code></pre></div>
<p>and said that I made a move to end at </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">!</span><span class="o">[</span><span class="bp">♞</span><span class="o">,</span> <span class="bp">♞</span><span class="o">,</span> <span class="bp">♘</span><span class="o">,</span> <span class="bp">♘</span><span class="o">]</span> <span class="bp">@</span>
<span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="mi">1</span> <span class="o">],</span>
  <span class="bp">!</span><span class="o">[</span><span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">],</span>
  <span class="bp">!</span><span class="o">[</span><span class="mi">3</span> <span class="o">,</span> <span class="mi">0</span> <span class="o">,</span> <span class="mi">2</span> <span class="o">]]</span>
</code></pre></div>
<p>should that be counted at legal?</p>



<a name="215783581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215783581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215783581">(Nov 05 2020 at 22:40)</a>:</h4>
<p>basically I recommend having some <code>meta structure chess_board</code> sort of class, and sticking a bunch of variables in there whenever it helps you. you probably want to keep the whole game history around in the data structure. then you can implement lots of lemmas on top of it.</p>



<a name="215783632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215783632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215783632">(Nov 05 2020 at 22:40)</a>:</h4>
<p>you don't really want to have to do things like extend the <code>vector</code> class to do different sorts of filtering</p>



<a name="215783637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215783637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215783637">(Nov 05 2020 at 22:40)</a>:</h4>
<p>Which we've done so far, without <code>meta</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">starting_position</span> <span class="o">:</span> <span class="n">chess.board</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">pieces</span> <span class="o">:=</span> <span class="bp">!</span><span class="o">[</span><span class="bp">♞</span><span class="o">,</span> <span class="bp">♞</span><span class="o">,</span> <span class="bp">♘</span><span class="o">,</span> <span class="bp">♘</span><span class="o">],</span>
  <span class="n">contents</span> <span class="o">:=</span> <span class="n">PF</span> <span class="bp">!</span><span class="o">[</span>
    <span class="bp">!</span><span class="o">[(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">4</span><span class="o">),</span> <span class="n">__</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">4</span><span class="o">)],</span>
    <span class="bp">!</span><span class="o">[</span>    <span class="n">__</span><span class="o">,</span>      <span class="n">__</span><span class="o">,</span>       <span class="n">__</span>   <span class="o">],</span>
    <span class="bp">!</span><span class="o">[(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">4</span><span class="o">),</span> <span class="n">__</span><span class="o">,</span> <span class="o">(</span><span class="mi">3</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">4</span><span class="o">)]</span>
  <span class="o">],</span>
<span class="o">}</span>


<span class="kd">def</span> <span class="n">ending_position</span> <span class="o">:</span> <span class="n">chess.board</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">starting_position</span> <span class="k">with</span>
  <span class="n">pieces</span> <span class="o">:=</span> <span class="bp">!</span><span class="o">[</span><span class="bp">♘</span><span class="o">,</span> <span class="bp">♘</span><span class="o">,</span> <span class="bp">♞</span><span class="o">,</span> <span class="bp">♞</span><span class="o">],</span>
<span class="o">}</span>

<span class="c1">-- Direct solution</span>

<span class="kd">def</span> <span class="n">guarini_seq</span> <span class="o">:</span> <span class="n">chess.move.sequence.legal</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">start_board</span> <span class="o">:=</span> <span class="n">starting_position</span><span class="o">,</span>
  <span class="n">elements</span> <span class="o">:=</span> <span class="bp">!</span><span class="o">[</span>
  <span class="o">((</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">))]</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">first_move</span> <span class="o">:</span> <span class="n">chess.move</span> <span class="n">starting_position</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">pair</span> <span class="o">:=</span> <span class="n">guarini_seq.elements</span> <span class="mi">0</span> <span class="k">in</span> <span class="o">⟨</span><span class="n">pair.fst</span><span class="o">,</span> <span class="n">pair.snd</span><span class="o">,</span> <span class="n">dec_trivial</span><span class="o">,</span> <span class="n">dec_trivial</span><span class="o">⟩</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">guarini_seq.to_sequence.boards</span> <span class="mi">0</span> <span class="bp">≈</span> <span class="n">guarini_seq.start_board</span> <span class="o">:=</span> <span class="n">dec_trivial</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">guarini_seq.to_sequence.boards</span> <span class="mi">1</span> <span class="bp">≈</span> <span class="n">first_move.perform_move</span> <span class="o">:=</span> <span class="n">dec_trivial</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">ix</span><span class="o">,</span> <span class="o">(</span><span class="n">guarini_seq.elements</span> <span class="n">ix</span><span class="o">)</span><span class="bp">.</span><span class="n">fst</span> <span class="bp">≠</span> <span class="o">(</span><span class="n">guarini_seq.elements</span> <span class="n">ix</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span> <span class="o">:=</span> <span class="n">dec_trivial</span>

<span class="kd">lemma</span> <span class="n">guarini</span> <span class="o">:</span> <span class="n">starting_position.has_sequence_to</span> <span class="n">ending_position</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">guarini_seq.to_sequence</span><span class="o">,</span> <span class="n">dec_trivial</span><span class="o">⟩</span>
</code></pre></div>



<a name="215783761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215783761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215783761">(Nov 05 2020 at 22:42)</a>:</h4>
<p>so dont try to make a bunch of lemmas like <code>vector.filter_some_pred</code></p>



<a name="215783768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215783768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215783768">(Nov 05 2020 at 22:42)</a>:</h4>
<p>And that compiles currently without sorries. However, it's annoying to have to say:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">starting_position</span> <span class="o">:</span> <span class="n">chess.board</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">pieces</span> <span class="o">:=</span> <span class="bp">!</span><span class="o">[</span><span class="bp">♞</span><span class="o">,</span> <span class="bp">♞</span><span class="o">,</span> <span class="bp">♘</span><span class="o">,</span> <span class="bp">♘</span><span class="o">],</span>
  <span class="n">contents</span> <span class="o">:=</span> <span class="n">PF</span> <span class="bp">!</span><span class="o">[</span>
    <span class="bp">!</span><span class="o">[(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">4</span><span class="o">),</span> <span class="n">__</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">4</span><span class="o">)],</span>
    <span class="bp">!</span><span class="o">[</span>    <span class="n">__</span><span class="o">,</span>      <span class="n">__</span><span class="o">,</span>       <span class="n">__</span>   <span class="o">],</span>
    <span class="bp">!</span><span class="o">[(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">4</span><span class="o">),</span> <span class="n">__</span><span class="o">,</span> <span class="o">(</span><span class="mi">3</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">4</span><span class="o">)]</span>
  <span class="o">],</span>
<span class="o">}</span>
</code></pre></div>



<a name="215783769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215783769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215783769">(Nov 05 2020 at 22:42)</a>:</h4>
<p>make lemmas about chess boards</p>



<a name="215783788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215783788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215783788">(Nov 05 2020 at 22:42)</a>:</h4>
<p>yeah if you read like PGN or ASCII format it'll be much nicer</p>



<a name="215783861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215783861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215783861">(Nov 05 2020 at 22:43)</a>:</h4>
<p>And it's be nice to just say:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">starting_position</span> <span class="o">:</span> <span class="n">chess.board</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">convert</span> <span class="bp">!</span><span class="o">[</span>
    <span class="bp">!</span><span class="o">[</span><span class="bp">♞</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♞</span><span class="o">],</span>
    <span class="bp">!</span><span class="o">[</span><span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">],</span>
    <span class="bp">!</span><span class="o">[</span><span class="bp">♘</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♘</span><span class="o">]</span>
  <span class="o">]</span>
</code></pre></div>
<p>and have the <code>pieces</code> and <code>contents</code> correct.</p>



<a name="215783988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215783988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215783988">(Nov 05 2020 at 22:45)</a>:</h4>
<p>But then there'll need to be lemmas making sure that <code>convert</code> always generates a <code>pieces</code> and <code>contents</code> that matches the defition of the board structure:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">board</span> <span class="o">:=</span>
<span class="c1">-- The pieces the board holds, provided as an indexed vector</span>
<span class="o">(</span><span class="n">pieces</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">K</span><span class="o">)</span>
<span class="c1">-- The playfield on which the pieces are placed</span>
<span class="o">(</span><span class="n">contents</span> <span class="o">:</span> <span class="n">playfield</span> <span class="n">m</span> <span class="n">n</span> <span class="n">ι</span><span class="o">)</span>
<span class="c1">-- All the pieces in `pieces` are on the `contents`</span>
<span class="c1">-- See "Implementation details" for info about `dec_trivial`</span>
<span class="o">(</span><span class="n">contains</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="n">contents.index_at</span> <span class="bp">.</span> <span class="n">tactic.exact_dec_trivial</span><span class="o">)</span>
<span class="c1">-- Different positions hold different indices</span>
<span class="o">(</span><span class="n">injects</span> <span class="o">:</span> <span class="n">contents.some_injective</span> <span class="bp">.</span> <span class="n">tactic.exact_dec_trivial</span><span class="o">)</span>
</code></pre></div>



<a name="215784019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215784019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215784019">(Nov 05 2020 at 22:45)</a>:</h4>
<p>Specifically, that <code>convert</code> respects and satisfies the <code>contains</code> and <code>injects</code> constraints.</p>



<a name="215784041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215784041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215784041">(Nov 05 2020 at 22:45)</a>:</h4>
<p>And so I ended up (over?)generalizing the vector filtering operations, instead of just working on the specific case of the chess board.</p>



<a name="215784111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215784111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215784111">(Nov 05 2020 at 22:46)</a>:</h4>
<p>ok. I guess overall I would just try using lists instead of vectors. you might want to make the size of the chess board part of the top level structure - it seems pretty important</p>



<a name="215784146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215784146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215784146">(Nov 05 2020 at 22:46)</a>:</h4>
<p>Sorry, I didn't include:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- The dimensions of the board, finite and decidably equal</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">n</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">n</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">m</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">m</span><span class="o">]</span>
<span class="c1">-- The index associated to pieces on a playfield</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span>
<span class="c1">-- The piece type</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
</code></pre></div>



<a name="215784161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215784161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215784161">(Nov 05 2020 at 22:47)</a>:</h4>
<p>i just mean lists for helper functions like "list all the knights on the board". if you don't know the length of the output, just make it a list rather than a vector. then i think you will avoid a lot of this painful typing.</p>



<a name="215788157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215788157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215788157">(Nov 05 2020 at 23:37)</a>:</h4>
<p>I think we're a step before that really. Like Yakov said, we're trying to make <em>constructing</em> boards simpler</p>



<a name="215788223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215788223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215788223">(Nov 05 2020 at 23:38)</a>:</h4>
<p>Parsing ASCII boards was my original idea, but I think that'd be fairly painful in Lean, from what I saw there's not very many implemented string manipulation methods</p>



<a name="215788266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215788266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215788266">(Nov 05 2020 at 23:39)</a>:</h4>
<p>i mean, this sample code is building 10 or so helper functions over vectors in order to construct a chessboard</p>



<a name="215788282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215788282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215788282">(Nov 05 2020 at 23:39)</a>:</h4>
<p>i'm saying, at least, it would be smoother to use lists there</p>



<a name="215788455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215788455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215788455">(Nov 05 2020 at 23:41)</a>:</h4>
<p>how I would represent chess positions for input is as a string like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rnbqkbnr</span>
<span class="n">pppppppp</span>
<span class="bp">........</span>
<span class="bp">........</span>
<span class="bp">........</span>
<span class="bp">........</span>
<span class="n">PPPPPPPP</span>
<span class="n">RNBQKBNR</span>
</code></pre></div>
<p>you should be able to do that without any string functions except converting to a list of chars.</p>



<a name="215788600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215788600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215788600">(Nov 05 2020 at 23:43)</a>:</h4>
<p>I have to think more personally. But it's not obvious to me that that makes the "collect the knights" problem easier, it sounds like you're saying it is (and I admit I'm not fully following the conversation about vectors other than "there's a bunch more stuff implemented on list that isn't implemented on vectors", so it could just be I don't understand enough to have an opinion)</p>



<a name="215788650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215788650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215788650">(Nov 05 2020 at 23:44)</a>:</h4>
<p>But unlike normal chess we <em>do</em> I think want/need to track "identity" of pieces globally</p>



<a name="215788676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215788676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215788676">(Nov 05 2020 at 23:44)</a>:</h4>
<p>Because if I want to prove like 2 knights making simultaneous knights tours on a board it seems likely it's easier to do that if you remember which knight it was the whole time?</p>



<a name="215788699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215788699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215788699">(Nov 05 2020 at 23:45)</a>:</h4>
<p>But maybe my intuition is wrong there too and you'll say you can do it just as easy with just the sequences of moving numbers I don't know too hard to think before dinner</p>



<a name="215788865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215788865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215788865">(Nov 05 2020 at 23:47)</a>:</h4>
<p>what are you proving about two simultaneous knights tours on a board? you're giving it a tour and you want to prove that it's a tour? or you want it to automatically find one?</p>



<a name="215788895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215788895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215788895">(Nov 05 2020 at 23:48)</a>:</h4>
<p>sorry I left out words, but I meant "given a board and two knights on it, the existence (or non-existence) of a tour of both knights on it"</p>



<a name="215788949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215788949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215788949">(Nov 05 2020 at 23:48)</a>:</h4>
<p>i.e. both of them need to cover every square once (and cannot capture each other)</p>



<a name="215788978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215788978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215788978">(Nov 05 2020 at 23:49)</a>:</h4>
<p>is the existence just supposed to follow from the existence of a single tour</p>



<a name="215789013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215789013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215789013">(Nov 05 2020 at 23:49)</a>:</h4>
<p>no because in the general case (some number of pieces, some configuration) you can fill up squares you need to make progress</p>



<a name="215789094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215789094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215789094">(Nov 05 2020 at 23:50)</a>:</h4>
<p>do you want lean to like, analyze a specific position to see if there's a tour, via some search algorithm</p>



<a name="215789113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215789113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215789113">(Nov 05 2020 at 23:51)</a>:</h4>
<p>or is there some mathy principle for how you'd prove the existence</p>



<a name="215789117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215789117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215789117">(Nov 05 2020 at 23:51)</a>:</h4>
<p>so firstly all of this is purely for fun :) so I don't know what I personally want to do other  than "prove stuff that's fun"</p>



<a name="215789125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215789125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215789125">(Nov 05 2020 at 23:51)</a>:</h4>
<p>but yeah there are mathy principles for proving existence</p>



<a name="215789153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215789153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215789153">(Nov 05 2020 at 23:51)</a>:</h4>
<p>you do coloring proofs (parity proofs) in simple cases where you show nonexistence because squares of various colors would be visited an impossible number of times</p>



<a name="215789214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215789214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215789214">(Nov 05 2020 at 23:52)</a>:</h4>
<p>ok. well, i dont really understand what sort of thing you're trying to do, but I am fairly sure that you don't want to be implementing <code>vector.filter_some</code> as part of a plan to read in chess boards from an ascii representation as part of it</p>



<a name="215789253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215789253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215789253">(Nov 05 2020 at 23:53)</a>:</h4>
<p>use a list when a function is returning things that might be of different lengths, it'll be easier</p>



<a name="215789291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215789291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215789291">(Nov 05 2020 at 23:53)</a>:</h4>
<p><em>nod</em></p>



<a name="215790110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215790110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215790110">(Nov 06 2020 at 00:05)</a>:</h4>
<p>What if you just had</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">starting_position</span> <span class="o">:</span> <span class="n">chess.board</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="bp">!</span><span class="o">[</span>
    <span class="bp">!</span><span class="o">[</span><span class="bp">♞</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♞</span><span class="o">],</span>
    <span class="bp">!</span><span class="o">[</span><span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">],</span>
    <span class="bp">!</span><span class="o">[</span><span class="bp">♘</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♘</span><span class="o">]</span>
  <span class="o">]</span>
</code></pre></div>
<p>?</p>



<a name="215790185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215790185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215790185">(Nov 06 2020 at 00:06)</a>:</h4>
<p>Which is to say, why bother with the <code>pieces</code> if you are already storing all the info in the <code>contents</code></p>



<a name="215790613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215790613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215790613">(Nov 06 2020 at 00:11)</a>:</h4>
<p>Because in a chess game, the piece behind an index can change (pawn upgrades).</p>



<a name="215790697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215790697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215790697">(Nov 06 2020 at 00:12)</a>:</h4>
<p>if the pieces are on the board, you just change what is stored at that position</p>



<a name="215790710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215790710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215790710">(Nov 06 2020 at 00:13)</a>:</h4>
<p>evidence that this is easier with lists:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">collect_pieces</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="o">(</span><span class="n">option</span> <span class="n">colored_pieces</span><span class="o">)))</span> <span class="o">:</span>
  <span class="n">list</span> <span class="n">colored_pieces</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">l</span> <span class="bp">←</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">←</span> <span class="n">l</span><span class="o">,</span> <span class="n">a.to_list</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">collect_pieces</span>
        <span class="o">[[</span><span class="bp">♞</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♞</span><span class="o">],</span>
         <span class="o">[</span><span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">],</span>
         <span class="o">[</span><span class="bp">♘</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♘</span><span class="o">]]</span> <span class="bp">=</span> <span class="o">[</span><span class="bp">♞</span><span class="o">,</span> <span class="bp">♞</span><span class="o">,</span> <span class="bp">♘</span><span class="o">,</span> <span class="bp">♘</span><span class="o">]</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="215791108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215791108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215791108">(Nov 06 2020 at 00:18)</a>:</h4>
<p>Yeah, I have a working <code>collect_pieces</code> that I didn't upload above. I think I started down this path because I foresaw proving (or even expressing) that accessing by number into the collected pieces is the same as what you started with.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">option</span> <span class="n">colored_pieces</span><span class="o">))</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b.count_some</span> <span class="bp">=</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">number_pieces</span> <span class="n">b</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">option.map</span> <span class="o">(</span><span class="n">collect_pieces</span> <span class="n">b</span> <span class="n">h</span><span class="o">))</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="215791123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215791123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215791123">(Nov 06 2020 at 00:18)</a>:</h4>
<p>Of course, that's not relevant if one throws indexing out of the window.</p>



<a name="215791139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215791139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215791139">(Nov 06 2020 at 00:18)</a>:</h4>
<p>algebraic chess notation doesn't index pieces by number</p>



<a name="215792128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215792128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215792128">(Nov 06 2020 at 00:33)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">move</span>
<span class="bp">|</span> <span class="n">knight</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">position</span> <span class="o">:=</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="o">(</span><span class="n">option</span> <span class="n">colored_pieces</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">position.get</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">position</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">colored_pieces</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="n">p</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">l</span> <span class="bp">←</span> <span class="n">p.nth</span> <span class="n">y</span><span class="o">,</span> <span class="n">b</span> <span class="bp">←</span> <span class="n">l.nth</span> <span class="n">x</span><span class="o">,</span> <span class="n">b</span>
<span class="kd">def</span> <span class="n">position.set</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">colored_pieces</span> <span class="bp">→</span> <span class="n">position</span> <span class="bp">→</span> <span class="n">position</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="n">c</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">p.modify_nth</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">l.update_nth</span> <span class="n">x</span> <span class="n">c</span><span class="o">)</span> <span class="n">y</span>

<span class="kd">def</span> <span class="n">move.eval</span> <span class="o">:</span> <span class="n">color</span> <span class="bp">→</span> <span class="n">move</span> <span class="bp">→</span> <span class="n">position</span> <span class="bp">→</span> <span class="n">position</span>
<span class="bp">|</span> <span class="n">c</span> <span class="o">(</span><span class="n">move.knight</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">p</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">p.set</span> <span class="n">a</span> <span class="n">none</span><span class="o">)</span><span class="bp">.</span><span class="n">set</span> <span class="n">b</span> <span class="o">(</span><span class="n">some</span> <span class="o">⟨</span><span class="n">pieces.knight</span><span class="o">,</span> <span class="n">c</span><span class="o">⟩)</span>

<span class="kd">def</span> <span class="n">move.valid</span> <span class="o">:</span> <span class="n">color</span> <span class="bp">→</span> <span class="n">move</span> <span class="bp">→</span> <span class="n">position</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">c</span> <span class="o">(</span><span class="n">move.knight</span> <span class="o">(</span><span class="n">x₁</span><span class="o">,</span> <span class="n">y₁</span><span class="o">)</span> <span class="o">(</span><span class="n">x₂</span><span class="o">,</span> <span class="n">y₂</span><span class="o">))</span> <span class="n">p</span> <span class="o">:=</span>
  <span class="o">(</span><span class="k">let</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">x₁.dist</span> <span class="n">x₂</span><span class="o">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">y₁.dist</span> <span class="n">y₂</span> <span class="k">in</span>
   <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">∧</span>
  <span class="n">p.get</span> <span class="o">(</span><span class="n">x₁</span><span class="o">,</span> <span class="n">y₁</span><span class="o">)</span> <span class="bp">=</span> <span class="n">some</span> <span class="o">⟨</span><span class="n">pieces.knight</span><span class="o">,</span> <span class="n">c</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">move.apply</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">color</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">move</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">position</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="n">position</span> <span class="o">:=</span>
<span class="n">guardb</span> <span class="o">(</span><span class="n">m.valid</span> <span class="n">c</span> <span class="n">p</span><span class="o">)</span> <span class="bp">&gt;&gt;</span> <span class="n">some</span> <span class="o">(</span><span class="n">m.eval</span> <span class="n">c</span> <span class="n">p</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">move.knight</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">))</span><span class="bp">.</span><span class="n">apply</span> <span class="n">color.black</span>
        <span class="o">[[</span><span class="bp">♞</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♞</span><span class="o">],</span>
         <span class="o">[</span><span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">],</span>
         <span class="o">[</span><span class="bp">♘</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♘</span><span class="o">]]</span> <span class="bp">=</span>
   <span class="n">some</span> <span class="o">[[</span><span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♞</span><span class="o">],</span>
         <span class="o">[</span><span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">],</span>
         <span class="o">[</span><span class="bp">♘</span><span class="o">,</span> <span class="bp">♞</span><span class="o">,</span> <span class="bp">♘</span><span class="o">]]</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="215795163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215795163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215795163">(Nov 06 2020 at 01:13)</a>:</h4>
<p>Here's an implementation of the guarini knight exchange problem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.dist</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">color</span>
<span class="bp">|</span> <span class="n">white</span>
<span class="bp">|</span> <span class="n">black</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">pieces</span>
<span class="bp">|</span> <span class="n">knight</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">structure</span> <span class="n">colored_pieces</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">piece</span> <span class="o">:</span> <span class="n">pieces</span><span class="o">)</span>
<span class="o">(</span><span class="n">color</span> <span class="o">:</span> <span class="n">color</span><span class="o">)</span>

<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">white_knight</span> <span class="o">:</span> <span class="n">colored_pieces</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">pieces.knight</span><span class="o">,</span> <span class="n">color.white</span><span class="o">⟩</span>
<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">black_knight</span> <span class="o">:</span> <span class="n">colored_pieces</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">pieces.knight</span><span class="o">,</span> <span class="n">color.black</span><span class="o">⟩</span>

<span class="kd">notation</span> <span class="bp">`</span> <span class="bp">♘</span> <span class="bp">`</span> <span class="o">:=</span> <span class="n">white_knight</span>
<span class="kd">notation</span> <span class="bp">`</span> <span class="bp">♞</span> <span class="bp">`</span> <span class="o">:=</span> <span class="n">black_knight</span>
<span class="kd">notation</span> <span class="bp">`</span><span class="n">__</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">none</span>

<span class="kd">def</span> <span class="n">colored_pieces.to_string</span> <span class="o">:</span> <span class="n">colored_pieces</span> <span class="bp">→</span> <span class="n">string</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">pieces.knight</span><span class="o">,</span> <span class="n">color.white</span><span class="o">⟩</span> <span class="o">:=</span> <span class="s2">"♘"</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">pieces.knight</span><span class="o">,</span> <span class="n">color.black</span><span class="o">⟩</span> <span class="o">:=</span> <span class="s2">"♞"</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_to_string</span> <span class="n">colored_pieces</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">colored_pieces.to_string</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">position</span> <span class="o">:=</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="o">(</span><span class="n">option</span> <span class="n">colored_pieces</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">position.get</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">position</span> <span class="bp">→</span> <span class="n">option</span> <span class="o">(</span><span class="n">option</span> <span class="n">colored_pieces</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="n">p</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">l</span> <span class="bp">←</span> <span class="n">p.nth</span> <span class="n">y</span><span class="o">,</span> <span class="n">l.nth</span> <span class="n">x</span>
<span class="kd">def</span> <span class="n">position.set</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">colored_pieces</span> <span class="bp">→</span> <span class="n">position</span> <span class="bp">→</span> <span class="n">position</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="n">c</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">p.modify_nth</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">l.update_nth</span> <span class="n">x</span> <span class="n">c</span><span class="o">)</span> <span class="n">y</span>

<span class="kd">def</span> <span class="n">is_knight_move</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x₁</span><span class="o">,</span> <span class="n">y₁</span><span class="o">)</span> <span class="o">(</span><span class="n">x₂</span><span class="o">,</span> <span class="n">y₂</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">x₁.dist</span> <span class="n">x₂</span><span class="o">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">y₁.dist</span> <span class="n">y₂</span> <span class="k">in</span>
  <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_repr</span> <span class="n">position</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">c</span><span class="o">,</span> <span class="n">c.to_string</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">position.apply</span> <span class="o">:</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">×</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">position</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">position</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="n">p</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">guardb</span> <span class="o">(</span><span class="n">is_knight_move</span> <span class="n">a</span> <span class="n">b</span><span class="o">),</span>
  <span class="o">⟨</span><span class="n">pieces.knight</span><span class="o">,</span> <span class="n">c</span><span class="o">⟩</span> <span class="bp">←</span> <span class="n">mjoin</span> <span class="o">(</span><span class="n">p.get</span> <span class="n">a</span><span class="o">),</span>
  <span class="n">guard</span> <span class="o">(</span><span class="n">p.get</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">none</span><span class="o">),</span>
  <span class="n">some</span> <span class="o">((</span><span class="n">p.set</span> <span class="n">a</span> <span class="n">none</span><span class="o">)</span><span class="bp">.</span><span class="n">set</span> <span class="n">b</span> <span class="o">(</span><span class="n">some</span> <span class="o">⟨</span><span class="n">pieces.knight</span><span class="o">,</span> <span class="n">c</span><span class="o">⟩))</span>

<span class="kd">def</span> <span class="n">position.apply_seq</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="o">((</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">×</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">)))</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">position</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="n">position</span> <span class="o">:=</span> <span class="n">l.mfoldl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">l</span><span class="o">,</span> <span class="n">p.apply</span> <span class="n">l</span><span class="o">)</span> <span class="n">p</span>

<span class="kd">def</span> <span class="n">starting_position</span> <span class="o">:</span> <span class="n">position</span> <span class="o">:=</span>
<span class="o">[[</span><span class="bp">♞</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♞</span><span class="o">],</span>
 <span class="o">[</span><span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">],</span>
 <span class="o">[</span><span class="bp">♘</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♘</span><span class="o">]]</span>

<span class="kd">def</span> <span class="n">ending_position</span> <span class="o">:</span> <span class="n">position</span> <span class="o">:=</span>
<span class="o">[[</span><span class="bp">♘</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♘</span><span class="o">],</span>
 <span class="o">[</span><span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">],</span>
 <span class="o">[</span><span class="bp">♞</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♞</span><span class="o">]]</span>

<span class="c1">-- Direct solution</span>

<span class="kd">def</span> <span class="n">guarini_seq</span> <span class="o">:=</span> <span class="o">[</span>
  <span class="o">((</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)),</span>
  <span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">))]</span>

<span class="kd">lemma</span> <span class="n">guarini</span> <span class="o">:</span>
  <span class="n">position.apply_seq</span> <span class="n">guarini_seq</span> <span class="n">starting_position</span> <span class="bp">=</span>
  <span class="n">some</span> <span class="n">ending_position</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="215800867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215800867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215800867">(Nov 06 2020 at 02:48)</a>:</h4>
<p>Wow, thanks, that looks way way simpler than what I ended up with. I don't know what dist or the guards do but will do some reading and then see if I can poke a bit more. Thanks this is great</p>



<a name="215808480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215808480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215808480">(Nov 06 2020 at 05:44)</a>:</h4>
<p><code>nat.dist</code> is <code>abs (x - y)</code> defined on nats</p>



<a name="215808487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215808487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215808487">(Nov 06 2020 at 05:44)</a>:</h4>
<p>it makes it easy to define the knights move requirement</p>



<a name="215808501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215808501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215808501">(Nov 06 2020 at 05:45)</a>:</h4>
<p><code>guard</code> is a function defined on option by <code>guard p = if p then some () else none</code>, which is useful to assert predicates inside the option monad</p>



<a name="215808507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215808507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215808507">(Nov 06 2020 at 05:45)</a>:</h4>
<p><code>guardb</code> is the same thing but for bools</p>



<a name="215808559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215808559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215808559">(Nov 06 2020 at 05:46)</a>:</h4>
<p>By writing the function this way it is easy for lean to compute with, and you can still prove properties about the function if you want a more abstract representation</p>



<a name="215808626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215808626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215808626">(Nov 06 2020 at 05:48)</a>:</h4>
<p>for instance, you could prove that <code>position.apply</code> always returns a <code>n × n</code> board if the input is <code>n × n</code>, and similarly for other structural properties like the number of knights of each color on the board</p>



<a name="215808736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215808736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215808736">(Nov 06 2020 at 05:51)</a>:</h4>
<p>(By the way, when I implemented this at first I had a turn counter, that would track the current color to play, and enforced that you only move a piece of your color. I dropped this because the guarini sequence does not respect turn order, and I don't know if it's part of the original problem statement.)</p>



<a name="215813260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215813260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215813260">(Nov 06 2020 at 07:33)</a>:</h4>
<p>starting to get off topic, but this code confused me:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">collect_pieces</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="o">(</span><span class="n">option</span> <span class="n">colored_pieces</span><span class="o">)))</span> <span class="o">:</span>
  <span class="n">list</span> <span class="n">colored_pieces</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">l</span> <span class="bp">←</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">←</span> <span class="n">l</span><span class="o">,</span> <span class="n">a.to_list</span>
</code></pre></div>
<p>So those left-arrows are de-monadizing the list and option monads? or both list monads? I don't get how that works. like what type are <code>a</code> and <code>l</code></p>



<a name="215814390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215814390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215814390">(Nov 06 2020 at 07:53)</a>:</h4>
<p><code>l : list (option colored_pieces)</code> and <code>a : option colored_pieces</code>.</p>



<a name="215814750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215814750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215814750">(Nov 06 2020 at 07:58)</a>:</h4>
<p>and then <code>a.to_list</code> converts an <code>option colored_pieces</code> to a <code>list colored_pieces</code>? is there some implicit monadic cast sort of thing going on here</p>



<a name="215815076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215815076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215815076">(Nov 06 2020 at 08:03)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">to_list</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">none</span>     <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>
</code></pre></div>
<p>from mathlib</p>



<a name="215815763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215815763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215815763">(Nov 06 2020 at 08:12)</a>:</h4>
<p>Compare to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">collect_pieces'</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="o">(</span><span class="n">option</span> <span class="n">colored_pieces</span><span class="o">)))</span> <span class="o">:</span>
  <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">colored_pieces</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">b.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="k">do</span> <span class="n">a</span> <span class="bp">←</span> <span class="n">l</span><span class="o">,</span> <span class="n">a.to_list</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">collect_pieces'</span>
        <span class="o">[[</span><span class="bp">♞</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♞</span><span class="o">],</span>
         <span class="o">[</span><span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">],</span>
         <span class="o">[</span><span class="bp">♘</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♘</span><span class="o">]]</span> <span class="bp">=</span>
        <span class="o">[[</span><span class="bp">♞</span><span class="o">,</span> <span class="bp">♞</span><span class="o">],</span>
         <span class="o">[],</span>
         <span class="o">[</span><span class="bp">♘</span><span class="o">,</span> <span class="bp">♘</span><span class="o">]]</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="215815785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215815785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215815785">(Nov 06 2020 at 08:13)</a>:</h4>
<p>The <code>do</code> notation desugars to the following, (recalling that <code>bind l f</code> in the <code>list</code> monad is <code>list.join (l.map f)</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">collect_pieces_desugared</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="o">(</span><span class="n">option</span> <span class="n">colored_pieces</span><span class="o">)))</span> <span class="o">:</span>
  <span class="n">list</span> <span class="n">colored_pieces</span> <span class="o">:=</span>
<span class="n">list.join</span> <span class="o">(</span><span class="n">b.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">list.join</span> <span class="o">(</span><span class="n">l.map</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a.to_list</span><span class="o">)))</span>
</code></pre></div>



<a name="215815892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215815892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215815892">(Nov 06 2020 at 08:14)</a>:</h4>
<p>Right, that's why my example looks like that, it's the map but without the join.</p>



<a name="215815926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215815926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215815926">(Nov 06 2020 at 08:15)</a>:</h4>
<p>Are there portions of mathlib that make definitions and state/prove lemmas using do notation on the term level?</p>



<a name="215816000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215816000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215816000">(Nov 06 2020 at 08:16)</a>:</h4>
<p>I understand that the tactic sequence is operating in the tactic "monad", but I mean some mathematical statements phrased in <code>do</code> or other monadic bind chains?</p>



<a name="215816292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215816292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215816292">(Nov 06 2020 at 08:20)</a>:</h4>
<p>The only thing that comes to mind at the moment is some <code>list</code> definitions stated with <code>do</code> notation in <a href="https://github.com/leanprover-community/mathlib/blob/fd3212c39d39dab1174fada57c7de6bf32b98bc8/src/data/list/defs.lean"><code>data.list.defs</code></a>.</p>



<a name="215816495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215816495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215816495">(Nov 06 2020 at 08:22)</a>:</h4>
<p>Oh, there's also presumably a bunch of stuff in <a href="https://github.com/leanprover-community/mathlib/blob/2ab31f911c04a45ae4c155e0a4172424665f4a50/src/control/basic.lean"><code>control</code></a>, but just like <code>list</code>, I don't know whether these count as "mathematical".</p>



<a name="215816508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215816508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215816508">(Nov 06 2020 at 08:22)</a>:</h4>
<p>Even those list defs seem to be the lemmas about other monads</p>



<a name="215816568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215816568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215816568">(Nov 06 2020 at 08:23)</a>:</h4>
<p>Yeah, that's true.</p>



<a name="215820771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215820771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215820771">(Nov 06 2020 at 09:16)</a>:</h4>
<p>My guess is that lemmas aren't stated that way because a proof about <code>list.bind</code> is easier to apply than a proof about <code>@has_bind.bind list</code></p>



<a name="215861058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Negating%20a%20Prop%20without%20lambdas/near/215861058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Negating.20a.20Prop.20without.20lambdas.html#215861058">(Nov 06 2020 at 15:27)</a>:</h4>
<p>The turing machine stuff has a lot of proofs about things in the roption monad written in do notation</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
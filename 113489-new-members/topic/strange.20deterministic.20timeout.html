---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/strange.20deterministic.20timeout.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html">strange deterministic timeout</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="217829396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217829396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Amelia Livingston <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217829396">(Nov 24 2020 at 23:52)</a>:</h4>
<p>Hello. I am confused: if you uncomment both commented out proofs at once, you get deterministic timeout, but uncommenting either one on its own is fine. I've tried increasing the timeout and it didn't help. I tried factoring out the lemmas, and it  didn't help, though I got different errors. Thanks in advance.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.tensor_product</span> <span class="n">linear_algebra.multilinear</span>

<span class="kd">def</span> <span class="n">tpow_aux</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">ℕ</span> <span class="bp">→</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">add_comm_monoid</span> <span class="n">N</span><span class="o">),</span> <span class="bp">@</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">N</span> <span class="n">_</span> <span class="n">h</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">R</span><span class="o">,</span> <span class="o">⟨</span><span class="kd">by</span> <span class="n">apply_instance</span><span class="o">,</span> <span class="kd">by</span> <span class="n">apply_instance</span><span class="o">⟩⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">@</span><span class="n">tensor_product</span> <span class="n">R</span> <span class="n">_</span> <span class="n">M</span> <span class="o">(</span><span class="n">tpow_aux</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">_</span> <span class="o">(</span><span class="n">tpow_aux</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span>
  <span class="n">_</span> <span class="o">(</span><span class="n">tpow_aux</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="o">⟨</span><span class="kd">by</span> <span class="n">apply_instance</span><span class="o">,</span> <span class="kd">by</span> <span class="n">apply_instance</span><span class="o">⟩⟩</span>

<span class="kd">instance</span> <span class="n">tpow_acm</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
<span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">tpow_aux</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">:=</span> <span class="o">(</span><span class="n">tpow_aux</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span>

<span class="kd">instance</span> <span class="n">tpow_semimodule</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
<span class="n">semimodule</span> <span class="n">R</span> <span class="o">(</span><span class="n">tpow_aux</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">:=</span> <span class="o">(</span><span class="n">tpow_aux</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span>

<span class="kd">@[reducible]</span> <span class="kd">def</span> <span class="n">tpow</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">tpow_aux</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>

<span class="kd">def</span> <span class="n">tpow_lift</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">{</span><span class="n">h1</span> <span class="o">:</span> <span class="n">add_comm_monoid</span> <span class="n">P</span><span class="o">},</span> <span class="kd">by</span> <span class="n">exactI</span> <span class="bp">Π</span>
  <span class="o">{</span><span class="n">h2</span> <span class="o">:</span> <span class="n">semimodule</span> <span class="n">R</span> <span class="n">P</span><span class="o">},</span> <span class="kd">by</span> <span class="n">exactI</span>
   <span class="bp">@</span><span class="n">multilinear_map</span> <span class="n">R</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">M</span><span class="o">)</span> <span class="n">P</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span>
  <span class="n">tpow</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">P</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">P</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="bp">@</span><span class="n">linear_map.to_span_singleton</span> <span class="n">R</span> <span class="n">P</span> <span class="n">_</span> <span class="n">h1</span> <span class="n">h2</span> <span class="bp">$</span> <span class="n">g</span> <span class="o">(</span><span class="n">default</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)),</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">P</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="bp">@</span><span class="n">tensor_product.lift</span> <span class="n">R</span> <span class="n">_</span> <span class="n">M</span> <span class="o">(</span><span class="n">tpow</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">)</span> <span class="n">P</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h1</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h2</span> <span class="bp">$</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">tpow_lift</span> <span class="n">n</span> <span class="n">P</span> <span class="o">(</span><span class="bp">@</span><span class="n">multilinear_map.curry_left</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h1</span> <span class="n">_</span> <span class="n">h2</span> <span class="n">g</span> <span class="n">m</span><span class="o">),</span>
    <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span> <span class="c1">-- λ x y, by {rw linear_map.map_add, exact (tpow_lift n P).map_add (@multilinear_map.curry_left _ _ _ _ _ _ h1 _ h2 g x) (@multilinear_map.curry_left _ _ _ _ _ _ h1 _ h2 g y) },</span>
    <span class="n">map_smul'</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span> <span class="c1">-- λ r x, by {rw linear_map.map_smul, exact linear_map.map_smul _ _ _ }</span>
      <span class="o">},</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span> <span class="o">}</span>
</code></pre></div>



<a name="217845370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217845370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217845370">(Nov 25 2020 at 05:15)</a>:</h4>
<p>this is scary and annoying. I'm sorry that I can't be more helpful</p>



<a name="217845698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217845698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217845698">(Nov 25 2020 at 05:22)</a>:</h4>
<p>which branch is this from? I get this error:</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>type mismatch at application
  multilinear_map.curry_left
term
  h1
has type
  add_comm_monoid P : Type ?
but is expected to have type
  add_comm_group ?m_1 : Type ?
</code></pre></div>



<a name="217901773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217901773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Amelia Livingston <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217901773">(Nov 25 2020 at 15:51)</a>:</h4>
<p>oh whoops - I tried to test that it works on normal mathlib but I must have messed up. I'll make a new mwe</p>



<a name="217904027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217904027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Amelia Livingston <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217904027">(Nov 25 2020 at 16:07)</a>:</h4>
<p>okay, this should work </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.tensor_product</span> <span class="n">linear_algebra.multilinear</span>

<span class="kd">def</span> <span class="n">tpow_aux</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">ℕ</span> <span class="bp">→</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">add_comm_monoid</span> <span class="n">N</span><span class="o">),</span> <span class="bp">@</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">N</span> <span class="n">_</span> <span class="n">h</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">R</span><span class="o">,</span> <span class="o">⟨</span><span class="kd">by</span> <span class="n">apply_instance</span><span class="o">,</span> <span class="kd">by</span> <span class="n">apply_instance</span><span class="o">⟩⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">@</span><span class="n">tensor_product</span> <span class="n">R</span> <span class="n">_</span> <span class="n">M</span> <span class="o">(</span><span class="n">tpow_aux</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">_</span> <span class="o">(</span><span class="n">tpow_aux</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span>
  <span class="n">_</span> <span class="o">(</span><span class="n">tpow_aux</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="o">⟨</span><span class="kd">by</span> <span class="n">apply_instance</span><span class="o">,</span> <span class="kd">by</span> <span class="n">apply_instance</span><span class="o">⟩⟩</span>

<span class="kd">instance</span> <span class="n">tpow_acm</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
<span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">tpow_aux</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">:=</span> <span class="o">(</span><span class="n">tpow_aux</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span>

<span class="kd">instance</span> <span class="n">tpow_semimodule</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
<span class="n">semimodule</span> <span class="n">R</span> <span class="o">(</span><span class="n">tpow_aux</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">:=</span> <span class="o">(</span><span class="n">tpow_aux</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span>

<span class="kd">@[reducible]</span> <span class="kd">def</span> <span class="n">tpow</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">tpow_aux</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>

<span class="kd">def</span> <span class="n">tpow_lift</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">{</span><span class="n">h1</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">P</span><span class="o">},</span> <span class="kd">by</span> <span class="n">exactI</span> <span class="bp">Π</span>
  <span class="o">{</span><span class="n">h2</span> <span class="o">:</span> <span class="n">semimodule</span> <span class="n">R</span> <span class="n">P</span><span class="o">},</span> <span class="kd">by</span> <span class="n">exactI</span>
   <span class="bp">@</span><span class="n">multilinear_map</span> <span class="n">R</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">M</span><span class="o">)</span> <span class="n">P</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">tpow</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">P</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">P</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="bp">@</span><span class="n">linear_map.to_span_singleton</span> <span class="n">R</span> <span class="n">P</span> <span class="n">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">add_comm_group.to_add_comm_monoid</span> <span class="n">P</span> <span class="n">h1</span><span class="o">)</span> <span class="n">h2</span> <span class="bp">$</span> <span class="n">g</span> <span class="o">(</span><span class="n">default</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)),</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">P</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="bp">@</span><span class="n">tensor_product.lift</span> <span class="n">R</span> <span class="n">_</span> <span class="n">M</span> <span class="o">(</span><span class="n">tpow</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">)</span> <span class="n">P</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">add_comm_group.to_add_comm_monoid</span> <span class="n">P</span> <span class="n">h1</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h2</span> <span class="bp">$</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">tpow_lift</span> <span class="n">n</span> <span class="n">P</span> <span class="o">(</span><span class="bp">@</span><span class="n">multilinear_map.curry_left</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h1</span> <span class="n">_</span> <span class="n">h2</span> <span class="n">g</span> <span class="n">m</span><span class="o">),</span>
    <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span> <span class="c1">-- λ x y, by {rw linear_map.map_add, exact (tpow_lift n P).map_add (@multilinear_map.curry_left _ _ _ _ _ _ h1 _ h2 g x) (@multilinear_map.curry_left _ _ _ _ _ _ h1 _ h2 g y) },</span>
    <span class="n">map_smul'</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span> <span class="c1">-- λ r x, by {rw linear_map.map_smul, exact linear_map.map_smul _ _ _ }</span>
      <span class="o">},</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span> <span class="o">}</span>
</code></pre></div>



<a name="217918022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217918022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217918022">(Nov 25 2020 at 17:51)</a>:</h4>
<p>In the last example I get an deterministic timeout if I uncomment <code>map_add'</code>, even when not uncommenting <code>map_smul'</code>.</p>
<p>Would tactic mode work for you? I think that is a little more robust for complicated elaboration problems. This works for me:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">tpow_lift</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">{</span><span class="n">h1</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">P</span><span class="o">}</span> <span class="o">{</span><span class="n">h2</span> <span class="o">:</span> <span class="n">semimodule</span> <span class="n">R</span> <span class="n">P</span><span class="o">}</span> <span class="o">:</span>
   <span class="bp">@</span><span class="n">multilinear_map</span> <span class="n">R</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">M</span><span class="o">)</span> <span class="n">P</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">tpow</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">P</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfreezingI</span> <span class="o">{</span> <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span> <span class="n">generalizing</span> <span class="n">P</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="bp">@</span><span class="n">linear_map.to_span_singleton</span> <span class="n">R</span> <span class="n">P</span> <span class="n">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">add_comm_group.to_add_comm_monoid</span> <span class="n">P</span> <span class="n">h1</span><span class="o">)</span> <span class="n">h2</span> <span class="bp">$</span> <span class="n">g</span> <span class="o">(</span><span class="n">default</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)),</span>
      <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
      <span class="n">map_smul'</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="bp">@</span><span class="n">tensor_product.lift</span> <span class="n">R</span> <span class="n">_</span> <span class="n">M</span> <span class="o">(</span><span class="n">tpow</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">)</span> <span class="n">P</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">add_comm_group.to_add_comm_monoid</span> <span class="n">P</span> <span class="n">h1</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h2</span> <span class="bp">$</span>
    <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">ih</span> <span class="n">P</span> <span class="o">(</span><span class="bp">@</span><span class="n">multilinear_map.curry_left</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h1</span> <span class="n">_</span> <span class="n">h2</span> <span class="n">g</span> <span class="n">m</span><span class="o">),</span>
      <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span><span class="n">rw</span> <span class="n">linear_map.map_add</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">ih</span> <span class="n">P</span><span class="o">)</span><span class="bp">.</span><span class="n">map_add</span> <span class="o">(</span><span class="bp">@</span><span class="n">multilinear_map.curry_left</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h1</span> <span class="n">_</span> <span class="n">h2</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">multilinear_map.curry_left</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h1</span> <span class="n">_</span> <span class="n">h2</span> <span class="n">g</span> <span class="n">y</span><span class="o">)</span> <span class="o">},</span>
      <span class="n">map_smul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span><span class="n">rw</span> <span class="n">linear_map.map_smul</span><span class="o">,</span> <span class="n">exact</span> <span class="n">linear_map.map_smul</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">}</span>
        <span class="o">},</span>
    <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
    <span class="n">map_smul'</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="217939352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217939352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Amelia Livingston <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217939352">(Nov 25 2020 at 21:05)</a>:</h4>
<p>thank you so much! Tactic mode works for me too, I'll keep that in mind.</p>



<a name="217943317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217943317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217943317">(Nov 25 2020 at 21:47)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.tensor_product</span> <span class="n">linear_algebra.multilinear</span>

<span class="n">open_locale</span> <span class="n">tensor_product</span>

<span class="kd">def</span> <span class="n">tpow_aux</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">ℕ</span> <span class="bp">→</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">add_comm_monoid</span> <span class="n">N</span><span class="o">),</span> <span class="bp">@</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">N</span> <span class="n">_</span> <span class="n">h</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">R</span><span class="o">,</span> <span class="o">⟨</span><span class="kd">by</span> <span class="n">apply_instance</span><span class="o">,</span> <span class="kd">by</span> <span class="n">apply_instance</span><span class="o">⟩⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">@</span><span class="n">tensor_product</span> <span class="n">R</span> <span class="n">_</span> <span class="n">M</span> <span class="o">(</span><span class="n">tpow_aux</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">_</span> <span class="o">(</span><span class="n">tpow_aux</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span>
  <span class="n">_</span> <span class="o">(</span><span class="n">tpow_aux</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="o">⟨</span><span class="kd">by</span> <span class="n">apply_instance</span><span class="o">,</span> <span class="kd">by</span> <span class="n">apply_instance</span><span class="o">⟩⟩</span>

<span class="kd">def</span> <span class="n">tpow</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">tpow_aux</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>

<span class="kd">instance</span> <span class="n">tpow_acm</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
<span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">tpow</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">tpow_aux</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span>

<span class="kd">instance</span> <span class="n">tpow_semimodule</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
<span class="n">semimodule</span> <span class="n">R</span> <span class="o">(</span><span class="n">tpow</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">tpow_aux</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span>

<span class="kd">def</span> <span class="n">tpow_zero</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">tpow</span> <span class="n">R</span> <span class="n">M</span> <span class="mi">0</span> <span class="bp">≃ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">tpow_succ</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">tpow</span> <span class="n">R</span> <span class="n">M</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">≃ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">tpow</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">}</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="n">irreducible</span><span class="o">]</span> <span class="n">tpow</span>

<span class="kn">open</span> <span class="n">multilinear_map</span>

<span class="kd">def</span> <span class="n">tpow_lift</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">P</span><span class="o">]</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">multilinear_map</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">M</span><span class="o">)</span> <span class="n">P</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">tpow</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">P</span> <span class="o">:=</span>
<span class="n">nat.rec_on</span> <span class="n">n</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="n">linear_map.comp</span>
        <span class="o">(</span><span class="n">linear_map.to_span_singleton</span> <span class="n">R</span> <span class="n">P</span> <span class="bp">$</span> <span class="n">g</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
        <span class="o">(</span><span class="n">tpow_zero</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="n">tpow</span> <span class="n">R</span> <span class="n">M</span> <span class="mi">0</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">R</span><span class="o">),</span>
      <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g₁</span> <span class="n">g₂</span><span class="o">,</span> <span class="n">linear_map.ext</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">smul_add</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">map_smul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">g</span><span class="o">,</span> <span class="n">linear_map.ext</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">r'</span><span class="o">,</span> <span class="n">smul_comm</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">}</span> <span class="bp">$</span>
<span class="bp">λ</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span> <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="n">linear_map.comp</span>
      <span class="o">(</span><span class="n">tensor_product.lift.equiv</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">$</span> <span class="n">ih.comp</span> <span class="bp">$</span>
        <span class="o">(</span><span class="n">multilinear_curry_left_equiv</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="n">g</span><span class="o">)</span>
      <span class="o">(</span><span class="n">tpow_succ</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span> <span class="o">:</span> <span class="n">tpow</span> <span class="n">R</span> <span class="n">M</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">tpow</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">),</span>
    <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g₁</span> <span class="n">g₂</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">linear_map.map_add</span><span class="o">,</span> <span class="n">linear_equiv.map_add</span><span class="o">,</span>
        <span class="n">linear_map.comp_add</span><span class="o">,</span> <span class="n">linear_map.add_comp</span><span class="o">],</span>
    <span class="n">map_smul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">g₁</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">linear_map.map_smul</span><span class="o">,</span> <span class="n">linear_equiv.map_smul</span><span class="o">,</span>
        <span class="n">linear_map.comp_smul</span><span class="o">,</span> <span class="n">linear_map.smul_comp</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div>



<a name="217943327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217943327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217943327">(Nov 25 2020 at 21:47)</a>:</h4>
<p>it also helps to make things <code>irreducible</code> and use <code>nat.rec_on</code> instead of the equation compiler I think</p>



<a name="217943378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217943378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217943378">(Nov 25 2020 at 21:48)</a>:</h4>
<p>(using <code>by exact</code> at the beginning would also speed up the code a lot, but I did not use it here as a proof of concept)</p>



<a name="217943451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217943451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217943451">(Nov 25 2020 at 21:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/113489-new-members/topic/strange.20deterministic.20timeout/near/217943378">said</a>:</p>
<blockquote>
<p>(using <code>by exact</code> at the beginning would also speed up the code a lot</p>
</blockquote>
<p>Why?</p>



<a name="217945549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217945549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217945549">(Nov 25 2020 at 22:13)</a>:</h4>
<p>I have no idea</p>



<a name="217945612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217945612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217945612">(Nov 25 2020 at 22:14)</a>:</h4>
<p>to me it feels like (completely unverified claim) that tactics can store intermediate terms so that you don't produce a large term at once</p>



<a name="217946036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217946036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Amelia Livingston <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217946036">(Nov 25 2020 at 22:19)</a>:</h4>
<p>thank you very much Kenny!</p>



<a name="217949600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217949600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217949600">(Nov 25 2020 at 23:08)</a>:</h4>
<p>The sigma type in tpow_aux is a clever way to avoid the difficulty I had when trying to define the tensor power and its typeclass instances at the same time with <code>mutual def</code> - thanks for the inspiration!</p>



<a name="217952129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217952129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217952129">(Nov 25 2020 at 23:47)</a>:</h4>
<p><span class="user-mention" data-user-id="118107">@Amelia Livingston</span> <span class="user-mention" data-user-id="310045">@Eric Wieser</span> Are either of you planning to PR material on tensor powers? I'm also interested in this, in fact I was planning to write code for the tensor product of a set of states indexed by a type <code>ι </code>, so basically what would be denoted by <code>⨂ i : ι, f i</code> with <code>f : ι → Type*</code>. This would be a bit more general than tensor powers, which we could recover by choosing <code>fin n</code> as <code>ι</code> and <code>f</code> a constant function.</p>



<a name="217952232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217952232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217952232">(Nov 25 2020 at 23:49)</a>:</h4>
<p>What is the type of <code>⨂ i : ι, f i</code>?</p>



<a name="217952334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217952334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217952334">(Nov 25 2020 at 23:50)</a>:</h4>
<p>Amelia is working on another model for the free R-algebra on an R-module because she found the current one hard to work with, even with the universal property.</p>



<a name="217952335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217952335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217952335">(Nov 25 2020 at 23:50)</a>:</h4>
<p>I was planning to just copy the approach in <code>tensor_product</code>, so <code>free_add_monoid (Π i, f i)</code> quotiented by the appropriate equivalence relation.</p>



<a name="217952412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217952412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217952412">(Nov 25 2020 at 23:52)</a>:</h4>
<p>I don't know how to do infinite tensor products. What is the appropriate equivalence relation? I have only ever seen restricted infinite tensor products which have some finiteness assumptions on them.</p>



<a name="217952436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217952436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217952436">(Nov 25 2020 at 23:52)</a>:</h4>
<p>I would be OK with a finiteness assumption.</p>



<a name="217952447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217952447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217952447">(Nov 25 2020 at 23:53)</a>:</h4>
<p>You mean you're assuming iota is a fintype?</p>



<a name="217952452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217952452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217952452">(Nov 25 2020 at 23:53)</a>:</h4>
<p>In that case I'm happy.</p>



<a name="217952454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217952454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217952454">(Nov 25 2020 at 23:53)</a>:</h4>
<p>Yes.</p>



<a name="217952512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217952512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217952512">(Nov 25 2020 at 23:54)</a>:</h4>
<p>Does the tensor power only approach not have this restriction?</p>



<a name="217952523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217952523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217952523">(Nov 25 2020 at 23:54)</a>:</h4>
<p>Amelia is taking finite tensor powers of a fixed R-module M</p>



<a name="217952564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217952564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217952564">(Nov 25 2020 at 23:55)</a>:</h4>
<p>but indexed by <code>fin n</code> and so now she's in <code>fin</code> hell, dealing with bijections <code>fin a \coprod fin b -&gt; fin (a + b)</code></p>



<a name="217952594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217952594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217952594">(Nov 25 2020 at 23:56)</a>:</h4>
<p>although she has actually made a lot of progress recently -- I'm meeting her tomorrow and will get an update.</p>



<a name="217952643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217952643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217952643">(Nov 25 2020 at 23:56)</a>:</h4>
<p>Oh dear.</p>



<a name="217952779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217952779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217952779">(Nov 25 2020 at 23:58)</a>:</h4>
<p>In any case, it would be nice to coordinate on this.</p>



<a name="217953075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/strange%20deterministic%20timeout/near/217953075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/strange.20deterministic.20timeout.html#217953075">(Nov 26 2020 at 00:02)</a>:</h4>
<p>While I'm here, the way I have seen infinite tensor products done is that you have a bunch of modules <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">M_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and fixed vectors <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub><mo>∈</mo><msub><mi>M</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i\in M_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> for all but finitely many <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> and then the restricted infinite tensor product of the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">M_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is generated by terms <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>⊗</mo><mi>i</mi></msub><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\otimes_i n_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> subject to the condition that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub><mo>=</mo><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_i=m_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> for all but finitely many <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>. It's how you make a representation of the adelic group <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><msub><mi mathvariant="double-struck">A</mi><mi>F</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(\mathbb{A}_F)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathbb">A</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> from representations of the local groups <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><msub><mi>F</mi><mi>v</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(F_v)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> running the though the places of the global field <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>. The <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are unramified vectors.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Predicativity.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Predicativity.html">Predicativity</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="239251081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Predicativity/near/239251081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Predicativity.html#239251081">(May 18 2021 at 13:14)</a>:</h4>
<p>Probably a very basic type theory question, but what is the purpose of the predicativity of <code>Type</code>? What would break if<br>
<code>Π α : Type, α</code>were of type <code>Type</code> instead of <code>Type 1</code>? And what among the features distinguishing <code>Prop</code> from <code>Type</code> make <code>Prop</code> admissible as an impredicative sort?</p>



<a name="239251823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Predicativity/near/239251823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Predicativity.html#239251823">(May 18 2021 at 13:19)</a>:</h4>
<p>If Pi a : Type, a were of type Type then you will get the same kind of contradiction as Russell's paradox, where you allow the collection of all sets to be a set. I think it's called Girard's paradox in type theory. Prop is impredicative because Leo designed it that way, I'm not sure I really understand the second question.</p>



<a name="239252082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Predicativity/near/239252082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Predicativity.html#239252082">(May 18 2021 at 13:21)</a>:</h4>
<p>Oh I see -- you're asking "how come forall a : Prop, a is allowed to be a Prop"?</p>



<a name="239252141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Predicativity/near/239252141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Predicativity.html#239252141">(May 18 2021 at 13:21)</a>:</h4>
<p>Yes, that's right</p>



<a name="239252308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Predicativity/near/239252308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Predicativity.html#239252308">(May 18 2021 at 13:22)</a>:</h4>
<p>You could look at <a href="https://leanprover-community.github.io/mathlib_docs/logic/girard.html">https://leanprover-community.github.io/mathlib_docs/logic/girard.html</a> and then change all the <code>Type u</code> to Prop and see what breaks.</p>



<a name="239252312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Predicativity/near/239252312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Predicativity.html#239252312">(May 18 2021 at 13:22)</a>:</h4>
<p>And why is it not contradictory if with <code>Type</code> it is. It seems like the same situation</p>



<a name="239253518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Predicativity/near/239253518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Predicativity.html#239253518">(May 18 2021 at 13:29)</a>:</h4>
<p>OK so with the set theoretic version you construct a problematic set -- the set of all sets which don't contain themselves -- and then you make a contradiction from that. The key thing is that the contradiction involves constructing data, which doesn't live in the Prop universe.</p>
<p>If you just stick to <code>Type</code> then the Girard contradiction involves</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">F</span><span class="o">:</span> <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">),</span> <span class="o">(</span><span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span>
<span class="n">U</span><span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">pi</span> <span class="n">F</span>
</code></pre></div>
<p>If you try this with <code>X : Prop</code> then Lean chokes at <code>set X</code>.</p>



<a name="239253582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Predicativity/near/239253582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Predicativity.html#239253582">(May 18 2021 at 13:30)</a>:</h4>
<p>As I understand it, <code>Type : Type</code>is contradictory because <code>Type</code> is too big, e.g. it should have strictly more elements than any <code>A : Type</code>. Similarly whenever you construct some type by referring to all <code>A : Type</code>, there is a risk that the result is too big, so can't be in <code>Type</code>. (Actually <code>Π α : Type, α</code> is not too big, since it's empty.) This is <em>not</em> true when you construct a <code>Prop</code> by referring to all <code>A : Type</code>: the resulting prop can only have one element, so classically it's <code>true</code> or <code>false</code>. So you shouldn't expect an impredicative <code>Prop</code> to be contradictory.</p>



<a name="239254168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Predicativity/near/239254168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Predicativity.html#239254168">(May 18 2021 at 13:33)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="o">(((</span><span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span> <span class="o">((</span><span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="c1">-- Prop → Type</span>
<span class="k">#check</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">),</span> <span class="o">(((</span><span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span> <span class="o">((</span><span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="c1">-- Type → Type</span>
<span class="k">#check</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">),</span> <span class="o">(((</span><span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span> <span class="o">((</span><span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="c1">-- Type u → Type u</span>
</code></pre></div>
<p>So here explicitly is where the Girard proof breaks. I've replaced <code>set X</code> with <code>X -&gt; Prop</code>. The trick doesn't work with Prop as the target is data.</p>



<a name="239254323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Predicativity/near/239254323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Predicativity.html#239254323">(May 18 2021 at 13:34)</a>:</h4>
<p>Of course the _proof_ that an impredicative Prop isn't contradictory is that Lean's type theory is equiconsistent with ZFC + universes!</p>



<a name="239257822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Predicativity/near/239257822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Predicativity.html#239257822">(May 18 2021 at 13:57)</a>:</h4>
<p>Thank you both for the great clarifications!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html">How to unfold `rat.mul` in goal</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="223078786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20unfold%20%60rat.mul%60%20in%20goal/near/223078786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html#223078786">(Jan 18 2021 at 03:54)</a>:</h4>
<p>In this proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.rat.basic</span>
<span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">lemma</span> <span class="n">mul_injective</span>
        <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">}</span>
        <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
        <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a.denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span>
        <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b.denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">):</span>
        <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">ha</span> <span class="n">at</span> <span class="n">a_cop</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hb</span> <span class="n">at</span> <span class="n">b_cop</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">ha</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">hb</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hmn</span><span class="o">:</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">n</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>at the first <code>sorry</code>, the tactic state is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">nm</span><span class="o">:</span> <span class="n">ℕ</span>
<span class="n">a_num</span><span class="o">:</span> <span class="n">ℤ</span>
<span class="n">a_denom</span><span class="o">:</span> <span class="n">ℕ</span>
<span class="n">a_pos</span><span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a_denom</span>
<span class="n">a_cop</span><span class="o">:</span> <span class="n">a_num.nat_abs.coprime</span> <span class="n">a_denom</span>
<span class="n">b_num</span><span class="o">:</span> <span class="n">ℤ</span>
<span class="n">b_denom</span><span class="o">:</span> <span class="n">ℕ</span>
<span class="n">b_pos</span><span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">b_denom</span>
<span class="n">b_cop</span><span class="o">:</span> <span class="n">b_num.nat_abs.coprime</span> <span class="n">b_denom</span>
<span class="n">ha</span><span class="o">:</span> <span class="n">a_denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span>
<span class="n">hb</span><span class="o">:</span> <span class="n">b_denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span>
<span class="n">a_cop</span><span class="o">:</span> <span class="n">a_num.nat_abs.coprime</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span>
<span class="n">b_cop</span><span class="o">:</span> <span class="n">b_num.nat_abs.coprime</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">)</span>
<span class="n">hmn</span><span class="o">:</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span>
<span class="bp">⊢</span> <span class="o">({</span><span class="n">num</span> <span class="o">:=</span> <span class="n">a_num</span><span class="o">,</span> <span class="n">denom</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">,</span> <span class="n">pos</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">cop</span> <span class="o">:=</span> <span class="n">_</span><span class="o">}</span> <span class="bp">*</span> <span class="o">{</span><span class="n">num</span> <span class="o">:=</span> <span class="n">b_num</span><span class="o">,</span> <span class="n">denom</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">,</span> <span class="n">pos</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">cop</span> <span class="o">:=</span> <span class="n">_</span><span class="o">})</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span>
</code></pre></div>
<p>Is there a way to unfold the <code>rat.mul</code> operation <code>*</code> inside the <code>.denom</code> on the left?  The ideal is if each field like <code>num</code>, <code>pos</code>, <code>denom</code> and <code>cop</code> get rewritten into single expressions.</p>



<a name="223079140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20unfold%20%60rat.mul%60%20in%20goal/near/223079140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html#223079140">(Jan 18 2021 at 04:04)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">simp</span> <span class="n">only</span> <span class="o">[(</span><span class="bp">*</span><span class="o">)],</span>
  <span class="n">rw</span> <span class="n">rat.mul</span><span class="o">,</span>
</code></pre></div>



<a name="223082197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20unfold%20%60rat.mul%60%20in%20goal/near/223082197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html#223082197">(Jan 18 2021 at 05:25)</a>:</h4>
<p>Thanks Alex that did the trick!</p>



<a name="223127146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20unfold%20%60rat.mul%60%20in%20goal/near/223127146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html#223127146">(Jan 18 2021 at 14:36)</a>:</h4>
<p>Also it is a great revelation that I can use <code>rw</code> on any definition to expand a structure.  For example, in this lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.rat.basic</span>
<span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">lemma</span> <span class="n">work</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
           <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span>
       <span class="o">(</span><span class="n">a_cop</span><span class="o">:</span> <span class="n">a.nat_abs.coprime</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">))</span>
       <span class="o">(</span><span class="n">b_cop</span><span class="o">:</span> <span class="n">b.nat_abs.coprime</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">))</span>
       <span class="o">(</span><span class="n">a_pos</span><span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span>
       <span class="o">(</span><span class="n">b_pos</span><span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">)</span>
     <span class="o">(</span><span class="n">ab_pos</span><span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">)</span>
       <span class="o">(</span><span class="n">hmn</span><span class="o">:</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">):</span>
       <span class="o">(</span><span class="n">rat.mk_pnat</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="o">⟨</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">,</span> <span class="n">ab_pos</span><span class="o">⟩)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="n">rat.mk_pnat</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>The <code>simp_rw rat.mk_pnat</code> takes an inscrutable goal:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⊢</span> <span class="o">(</span><span class="n">rat.mk_pnat</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="o">⟨</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">,</span> <span class="n">ab_pos</span><span class="o">⟩)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span>
</code></pre></div>
<p>and turns it into a very scrutable one:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⊢</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span> <span class="bp">/</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">nat_abs.gcd</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span>
</code></pre></div>



<a name="223136538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20unfold%20%60rat.mul%60%20in%20goal/near/223136538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html#223136538">(Jan 18 2021 at 15:50)</a>:</h4>
<p>There is also a lemma <a href="https://leanprover-community.github.io/mathlib_docs/find/rat.mk_pnat_denom">docs#rat.mk_pnat_denom</a> you can rewrite directly</p>



<a name="223143678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20unfold%20%60rat.mul%60%20in%20goal/near/223143678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html#223143678">(Jan 18 2021 at 16:55)</a>:</h4>
<p>Unfortunately these expansions reduce the problem to something which has a counterexample for the something which is reduced to, even though it is not a counterexample for the overall problem.  The counterexample is <code>a = 3/2</code>, <code>b=7/2</code>.  In this case <code>a*b=21/4</code> which is injective (has denominator <code>2^k</code>). But it leads to a <code>2=1</code> assertion in <code>trouble</code>: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.rat.basic</span>
<span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">tactic.slim_check</span>

<span class="kd">lemma</span> <span class="n">trouble</span>
<span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span>
<span class="o">(</span><span class="n">a_cop</span> <span class="o">:</span> <span class="n">a.nat_abs.coprime</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">))</span>
<span class="o">(</span><span class="n">b_cop</span> <span class="o">:</span> <span class="n">b.nat_abs.coprime</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">))</span>
<span class="o">(</span><span class="n">hmn</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">):</span>
<span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">nat_abs.gcd</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">slim_check</span>

<span class="c">/-</span><span class="cm"> counterexample</span>
<span class="cm">n := 1</span>
<span class="cm">m := 1</span>
<span class="cm">a := -3</span>
<span class="cm">b := -1</span>
<span class="cm">-/</span>

<span class="c">/-</span><span class="cm"> lemma mul_to_right_div (a b c : ℕ ) (c0: c &gt; 0) (h: a * b = a * c): a * b / c = a :=</span>
<span class="cm">  nat.div_eq_of_eq_mul_left c0 h -/</span>

<span class="kd">lemma</span> <span class="n">cancel_right_mul</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span>  <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span><span class="o">):</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:=</span>
  <span class="n">congr_arg</span> <span class="o">(</span><span class="n">has_mul.mul</span> <span class="n">a</span><span class="o">)</span> <span class="n">h</span>

<span class="kd">lemma</span> <span class="n">move_div_right</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span><span class="o">:</span> <span class="n">b</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">:=</span>
  <span class="n">nat.div_eq_of_eq_mul_left</span> <span class="n">hb</span> <span class="n">h</span>

<span class="kd">lemma</span> <span class="n">mul_injective</span>
        <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">}</span>
        <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
        <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a.denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span>
        <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b.denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">):</span>
        <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">ha</span> <span class="n">at</span> <span class="n">a_cop</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hb</span> <span class="n">at</span> <span class="n">b_cop</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">ha</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">hb</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">ha</span> <span class="n">at</span> <span class="n">a_pos</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hb</span> <span class="n">at</span> <span class="n">b_pos</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hmn</span><span class="o">:</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">,{</span>
    <span class="n">use</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[(</span><span class="bp">*</span><span class="o">)],</span>
    <span class="n">rw</span> <span class="n">rat.mul</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">ab_pos</span> <span class="o">:=</span> <span class="n">mul_pos</span> <span class="n">a_pos</span> <span class="n">b_pos</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="n">rat.mk_pnat_denom</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">move_div_right</span><span class="o">,</span>
    <span class="n">rotate</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="n">left</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">trouble</span> <span class="n">n</span> <span class="n">m</span> <span class="n">a_num</span> <span class="n">b_num</span> <span class="n">a_cop</span> <span class="n">b_cop</span> <span class="n">hmn</span><span class="o">),</span> <span class="c1">-- Not good</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="223145504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20unfold%20%60rat.mul%60%20in%20goal/near/223145504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html#223145504">(Jan 18 2021 at 17:13)</a>:</h4>
<p>This looks like a case where you want to be a little more sure of the maths proof before writing it in lean. At a guess, you started down the dead end when you did <code>use n</code>.</p>



<a name="223145627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20unfold%20%60rat.mul%60%20in%20goal/near/223145627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html#223145627">(Jan 18 2021 at 17:14)</a>:</h4>
<p>As a tip, you can clean up your 6 <code>rw</code> / <code>simp_rw</code> lines to a single <code>substs ha hb</code>.</p>



<a name="223150055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20unfold%20%60rat.mul%60%20in%20goal/near/223150055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html#223150055">(Jan 18 2021 at 18:03)</a>:</h4>
<p>With <code>substs</code> I can get to the problem faster.   I  reach false goal <code>⊢ 4 = 21.nat_abs.gcd 4</code> with this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.rat.basic</span>
<span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">tactic.slim_check</span>

<span class="kd">lemma</span> <span class="n">move_div_right</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span><span class="o">:</span> <span class="n">b</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">:=</span>
  <span class="n">nat.div_eq_of_eq_mul_left</span> <span class="n">hb</span> <span class="n">h</span>

<span class="kd">lemma</span> <span class="n">mul_injective</span>
        <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">}</span>
        <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
        <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a.denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span>
        <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b.denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">):</span>
        <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">substs</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[(</span><span class="bp">*</span><span class="o">)],</span>
  <span class="n">rw</span> <span class="n">rat.mul</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">rat.mk_pnat_denom</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h</span><span class="o">:</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">m</span><span class="o">),</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">move_div_right</span><span class="o">,</span>
  <span class="n">rotate</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h1</span><span class="o">:</span> <span class="n">m</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h2</span><span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h3</span><span class="o">:</span> <span class="n">a_num</span><span class="bp">=</span><span class="mi">3</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h4</span><span class="o">:</span> <span class="n">b_num</span><span class="bp">=</span><span class="mi">7</span><span class="o">,</span>
  <span class="n">substs</span> <span class="n">h1</span> <span class="n">h2</span> <span class="n">h3</span> <span class="n">h4</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">ring</span><span class="o">,</span>

<span class="kd">end</span>
</code></pre></div>
<p>However, the case which falsifies the subgoal doesn't falsify the main theorem.  It is <code>3/2 * 7/2 = 21/4</code>.  This is injective.  I would expect that my subgoal would produce something that falsifies the main goal.  I'm still confused, just confused in a more compact way.</p>



<a name="223150574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20unfold%20%60rat.mul%60%20in%20goal/near/223150574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html#223150574">(Jan 18 2021 at 18:10)</a>:</h4>
<p>Right, and its showing you that your math proof is wrong - <code>21/4 = 21/(2^2)</code>, yet you did <code>use [n - m]</code>despite the fact that <code>1 - 1 = 0 != 2</code>. My guess would be that you ought to be using <code>n + m</code>, but I haven't thought about it much</p>



<a name="223151854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20unfold%20%60rat.mul%60%20in%20goal/near/223151854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html#223151854">(Jan 18 2021 at 18:29)</a>:</h4>
<p>My reasoning is, just after the <code>by_cases h: m ≤ n</code>, we have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⊢</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="bp">↑</span><span class="o">⟨</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="bp">/</span> <span class="o">(</span><span class="n">a_num</span> <span class="bp">*</span> <span class="n">b_num</span><span class="o">)</span><span class="bp">.</span><span class="n">nat_abs.gcd</span> <span class="bp">↑</span><span class="o">⟨</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">k</span>
</code></pre></div>
<p>so find a <code>k</code> such that </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">k</span><span class="bp">*</span> <span class="o">(</span><span class="n">a_num</span> <span class="bp">*</span> <span class="n">b_num</span><span class="o">)</span><span class="bp">.</span><span class="n">nat_abs.gcd</span> <span class="bp">↑</span><span class="o">⟨</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span>
</code></pre></div>
<p>So...ah, good point.  <code>k=n+m</code> would do nicely.</p>



<a name="223152929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20unfold%20%60rat.mul%60%20in%20goal/near/223152929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html#223152929">(Jan 18 2021 at 18:44)</a>:</h4>
<p>You might still need to case-split later</p>



<a name="223173510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20unfold%20%60rat.mul%60%20in%20goal/near/223173510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html#223173510">(Jan 18 2021 at 23:40)</a>:</h4>
<p>The unfolding of <code>rat.mk_pnat_denom</code> doesn't seem to be reflecting the normalization of rationals which takes place.  I am multiplying <code>p=a/2^n</code> and <code>q=b/2^m</code>.  If <code>p=2/1</code> and <code>q=3/2</code>, then the normalized result is <code>p*q=3/1</code>.  But <code>a*b=6</code> and <code>2^n*2^m=2</code>.  My goal state reduces to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⊢</span> <span class="o">(</span><span class="n">a_num.nat_abs</span> <span class="bp">*</span> <span class="n">b_num.nat_abs</span><span class="o">)</span><span class="bp">.</span><span class="n">gcd</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span>
</code></pre></div>
<p>This is the pre-normalized form <code>6/2</code> and <code>gcd(6,2) = 2</code>.  So that's false, but only because normalization hasn't occurred.   I will keep staring at it, maybe I can avoid this.   Here is the proof with this problem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.rat.basic</span>
<span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">data.nat.prime</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">tactic.slim_check</span>

<span class="kd">lemma</span> <span class="n">coprime_from_gcd_eq_one</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">m.coprime</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">m.gcd</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="o">(</span><span class="n">rfl.congr</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span>

<span class="kd">lemma</span> <span class="n">gcd_eq_one_coprime</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">m.gcd</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">m.coprime</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">nat.coprime.coprime_dvd_right</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">dvd_refl</span> <span class="n">n</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">pow_add2</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">):</span> <span class="mi">2</span><span class="bp">^</span><span class="n">n</span> <span class="bp">*</span> <span class="mi">2</span><span class="bp">^</span><span class="n">m</span> <span class="bp">=</span> <span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="n">tactic.ring.pow_add_rev</span> <span class="mi">2</span> <span class="n">n</span> <span class="n">m</span>

<span class="kd">lemma</span> <span class="n">coprime_power_N</span> <span class="o">(</span><span class="n">a</span> <span class="n">p</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
                      <span class="o">(</span><span class="n">hp</span><span class="o">:</span> <span class="n">nat.prime</span> <span class="n">p</span><span class="o">)</span>
                      <span class="o">(</span><span class="n">hac</span><span class="o">:</span> <span class="n">a.coprime</span> <span class="o">(</span><span class="n">p</span> <span class="bp">^</span> <span class="n">n</span><span class="o">))</span>
                      <span class="o">(</span><span class="n">hn</span><span class="o">:</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">):</span>
                      <span class="n">a.coprime</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
  <span class="n">exfalso</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">nat.lt_asymm</span> <span class="n">hn</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">(</span><span class="n">nat.succ_eq_add_one</span> <span class="n">d</span><span class="o">)</span> <span class="n">at</span> <span class="n">hac</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">(</span><span class="n">pow_succ'</span> <span class="n">p</span> <span class="n">d</span><span class="o">)</span> <span class="n">at</span> <span class="n">hac</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">nat.coprime.coprime_mul_left_right</span> <span class="n">hac</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">power_N_coprime</span> <span class="o">(</span><span class="n">a</span> <span class="n">p</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>  <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">a.coprime</span> <span class="n">p</span><span class="o">):</span> <span class="n">a.coprime</span> <span class="o">(</span><span class="n">p</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">nat.coprime.pow_right</span> <span class="n">n</span> <span class="n">h</span>

<span class="kd">lemma</span> <span class="n">not_gt_zero_eq_zero</span> <span class="o">{</span><span class="n">m</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">¬</span><span class="n">m</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">finish</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">move_div_right</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span><span class="o">:</span> <span class="n">b</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">:=</span>
  <span class="n">nat.div_eq_of_eq_mul_left</span> <span class="n">hb</span> <span class="n">h</span>

<span class="kd">lemma</span> <span class="n">cancel_left_mul</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span><span class="o">:</span> <span class="n">a</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">):</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:=</span> <span class="o">(</span><span class="n">nat.mul_right_eq_self_iff</span> <span class="n">ha</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">finish</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">succ_def</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">m.succ</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">pow_two_ne_zero</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">):</span> <span class="mi">2</span><span class="bp">^</span><span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">(</span><span class="n">succ_def</span> <span class="n">d</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">(</span><span class="n">pow_succ</span> <span class="mi">2</span> <span class="n">d</span><span class="o">),</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">finish</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">pow_two_gt_zero</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">):</span> <span class="mi">2</span><span class="bp">^</span><span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:=</span> <span class="n">pow_two_ne_zero</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">finish</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">nat_gcd_gt_0</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hn</span><span class="o">:</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">):</span> <span class="n">m.gcd</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="o">:=</span>
  <span class="n">nat.gcd_pos_of_pos_right</span> <span class="n">m</span> <span class="n">hn</span>

<span class="kd">lemma</span> <span class="n">mul_injective</span>
        <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">}</span>
        <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
        <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a.denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span>
        <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b.denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">):</span>
        <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">substs</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[(</span><span class="bp">*</span><span class="o">)],</span>
  <span class="n">rw</span> <span class="n">rat.mul</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">rat.mk_pnat_denom</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="n">m</span><span class="o">),</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">move_div_right</span><span class="o">,</span>
  <span class="n">rotate</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">pow_add2</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">cancel_left_mul</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">pow_two_gt_zero</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="n">m</span><span class="o">),</span>
  <span class="n">rotate</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">nat_gcd_gt_0</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">pow_add2</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">pow_two_gt_zero</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">pow_add2</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">(</span><span class="n">int.nat_abs_mul</span> <span class="n">a_num</span> <span class="n">b_num</span><span class="o">),</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>and my tactic state is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">a_num</span> <span class="n">b_num</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span>
<span class="n">a_pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">,</span>
<span class="n">a_cop</span> <span class="o">:</span> <span class="n">a_num.nat_abs.coprime</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">),</span>
<span class="n">b_pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">,</span>
<span class="n">b_cop</span> <span class="o">:</span> <span class="n">b_num.nat_abs.coprime</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">)</span>
<span class="bp">⊢</span> <span class="o">(</span><span class="n">a_num.nat_abs</span> <span class="bp">*</span> <span class="n">b_num.nat_abs</span><span class="o">)</span><span class="bp">.</span><span class="n">gcd</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span>
</code></pre></div>



<a name="223173772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20unfold%20%60rat.mul%60%20in%20goal/near/223173772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html#223173772">(Jan 18 2021 at 23:45)</a>:</h4>
<p>I think you need to case-split on n=0 and m=0, and <code>use</code> a different value in those cases - since for those, a_num _can_ have 2 in its prime factorization</p>



<a name="223174266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20unfold%20%60rat.mul%60%20in%20goal/near/223174266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html#223174266">(Jan 18 2021 at 23:54)</a>:</h4>
<p>Hi Lars, did you see the proof approach <a href="#narrow/stream/113489-new-members/topic/If.20natural.20number.20n.20.E2.89.A0.200.20then.20it.20is.20not.200.20as.20a.20.E2.84.9A/near/222961714">here</a>? You shouldn't need any rat internals or to work with <code>gcd</code>, all the necessary theorems are there already</p>



<a name="223174380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20unfold%20%60rat.mul%60%20in%20goal/near/223174380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html#223174380">(Jan 18 2021 at 23:56)</a>:</h4>
<p>Note that the exact same proof from addition also works for multiplication, because the expression for the denominator is the same</p>



<a name="223179831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20unfold%20%60rat.mul%60%20in%20goal/near/223179831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html#223179831">(Jan 19 2021 at 01:51)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, yes I finished that for plus <a href="#narrow/stream/113489-new-members/topic/If.20natural.20number.20n.20.E2.89.A0.200.20then.20it.20is.20not.200.20as.20a.20.E2.84.9A/near/223057206">here</a>.</p>
<p>I will study it for adaptation to <code>mul</code> now.</p>



<a name="223180929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20unfold%20%60rat.mul%60%20in%20goal/near/223180929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html#223180929">(Jan 19 2021 at 02:15)</a>:</h4>
<p>Indeed that does the trick</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.rat.basic</span>
<span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">data.nat.prime</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">tactic.slim_check</span>

<span class="c1">-- Mario Carneiro, Hanting Zhang</span>
<span class="kd">lemma</span> <span class="n">eq_two_pow_of_dvd_two_pow</span> <span class="o">{</span><span class="n">a</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∣</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">@</span><span class="n">nat.dvd_prime_pow</span> <span class="mi">2</span> <span class="n">nat.prime_two</span> <span class="n">n</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h2</span> <span class="k">with</span> <span class="n">m</span> <span class="n">hm</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">hm</span> <span class="k">with</span> <span class="n">H</span> <span class="n">hH</span><span class="o">,</span>
  <span class="n">finish</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- Mario Carneiro</span>
<span class="kd">lemma</span> <span class="n">mul_injective</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a.denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b.denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="bp">@</span><span class="n">eq_two_pow_of_dvd_two_pow</span> <span class="n">_</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">rat.mul_num_denom</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="bp">←</span> <span class="n">pow_add</span><span class="o">,</span> <span class="bp">←</span> <span class="n">int.coe_nat_dvd</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">rat.denom_dvd</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="223181466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20unfold%20%60rat.mul%60%20in%20goal/near/223181466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20unfold.20.60rat.2Emul.60.20in.20goal.html#223181466">(Jan 19 2021 at 02:27)</a>:</h4>
<p>So finally here is Exercise 6F put to rest:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.rat.basic</span>
<span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">data.nat.prime</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">tactic.slim_check</span>
<span class="kn">import</span> <span class="n">ring_theory.subring</span>

<span class="kn">open</span> <span class="n">nat</span>

<span class="c1">-- Mario Carneiro, Hanting Zhang</span>
<span class="kd">lemma</span> <span class="n">eq_two_pow_of_dvd_two_pow</span> <span class="o">{</span><span class="n">a</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∣</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">@</span><span class="n">dvd_prime_pow</span> <span class="mi">2</span> <span class="n">nat.prime_two</span> <span class="n">n</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h2</span> <span class="k">with</span> <span class="n">m</span> <span class="n">hm</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">hm</span> <span class="k">with</span> <span class="n">H</span> <span class="n">hH</span><span class="o">,</span>
  <span class="n">finish</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">succ_def</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">m.succ</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">pow_two_ne_zero</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">):</span> <span class="mi">2</span><span class="bp">^</span><span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">(</span><span class="n">succ_def</span> <span class="n">d</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">(</span><span class="n">pow_succ</span> <span class="mi">2</span> <span class="n">d</span><span class="o">),</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">finish</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- Mario Carneiro</span>
<span class="kd">lemma</span> <span class="n">plus_injective</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a.denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b.denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="bp">@</span><span class="n">eq_two_pow_of_dvd_two_pow</span> <span class="n">_</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">rat.add_num_denom</span><span class="o">,</span> <span class="bp">←</span> <span class="n">int.coe_nat_mul</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="bp">←</span> <span class="n">pow_add</span><span class="o">,</span> <span class="bp">←</span> <span class="n">int.coe_nat_dvd</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">rat.denom_dvd</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- Mario Carneiro</span>
<span class="kd">lemma</span> <span class="n">mul_injective</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a.denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b.denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="bp">@</span><span class="n">eq_two_pow_of_dvd_two_pow</span> <span class="n">_</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">rat.mul_num_denom</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="bp">←</span> <span class="n">pow_add</span><span class="o">,</span> <span class="bp">←</span> <span class="n">int.coe_nat_dvd</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">rat.denom_dvd</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">B</span> <span class="o">:</span> <span class="n">subring</span> <span class="n">ℚ</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">x.denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span> <span class="o">},</span>
  <span class="n">one_mem'</span> <span class="c">/-</span><span class="cm"> (1 : M) ∈ carrier) -/</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">rw</span> <span class="n">set.mem_set_of_eq</span><span class="o">,</span>
    <span class="n">use</span> <span class="mi">0</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">mul_mem'</span> <span class="c">/-</span><span class="cm"> {a b} : a ∈ carrier → b ∈ carrier → a * b ∈ carrier) -/</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">set.mem_set_of_eq</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">set.mem_set_of_eq</span> <span class="n">at</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h2</span> <span class="k">with</span> <span class="n">m</span> <span class="n">hm</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">set.mem_set_of_eq</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">mul_injective</span> <span class="n">hn</span> <span class="n">hm</span><span class="o">),</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">zero_mem'</span> <span class="c">/-</span><span class="cm"> (0 : M) ∈ carrier -/</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">rw</span> <span class="n">set.mem_set_of_eq</span><span class="o">,</span>
    <span class="n">use</span> <span class="mi">0</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">add_mem'</span> <span class="c">/-</span><span class="cm"> {a b} : a ∈ carrier → b ∈ carrier → a + b ∈ carrier -/</span><span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">set.mem_set_of_eq</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">set.mem_set_of_eq</span> <span class="n">at</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h2</span> <span class="k">with</span> <span class="n">m</span> <span class="n">hm</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">set.mem_set_of_eq</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">plus_injective</span> <span class="n">hn</span> <span class="n">hm</span><span class="o">),</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">neg_mem'</span> <span class="c">/-</span><span class="cm"> {x} : x ∈ carrier →d -x ∈ carrier -/</span><span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">set.mem_set_of_eq</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">set.mem_set_of_eq</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hn</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
 <span class="o">}</span>

<span class="c1">-- Eric Wieser</span>
<span class="kd">abbreviation</span> <span class="n">is_an_integral_domain</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">sr</span> <span class="o">:</span> <span class="n">subring</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">sr</span><span class="o">],</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">sr</span>

<span class="kd">theorem</span> <span class="n">ex6f</span> <span class="o">:</span> <span class="n">is_an_integral_domain</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">x.denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span> <span class="o">}</span>  <span class="o">:=</span>
<span class="o">⟨</span><span class="n">B</span><span class="o">,</span> <span class="n">infer_instance</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Monoid.20Morphism.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html">Monoid Morphism</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="240749126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240749126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ken Lee <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240749126">(May 30 2021 at 10:22)</a>:</h4>
<p>Say I have <code>(M N : Type u) [monoid M] [monoid N](f : M -&gt; N)</code>, how do I say "<code>f</code> is a monoid morphism" in Lean?</p>



<a name="240750032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240750032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240750032">(May 30 2021 at 10:49)</a>:</h4>
<p>Just write <code>f : M →* N</code>.</p>



<a name="240750079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240750079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240750079">(May 30 2021 at 10:50)</a>:</h4>
<p>We use bundled morphisms (i.e. not just a bare function), and these have a coercion to functions so you can mostly use them just as if it was an honest function.</p>



<a name="240750087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240750087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240750087">(May 30 2021 at 10:51)</a>:</h4>
<p>There is probably a <code>is_monoid_hom</code> predicate as well, but don't use it unless you're really sure you should be: the bundled hom is usually better.</p>



<a name="240750132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240750132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ken Lee <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240750132">(May 30 2021 at 10:52)</a>:</h4>
<p>my issue though is that I'm given the bare function <code>f</code> and I want to say "this <code>f</code> is a monoid morphism"</p>



<a name="240750157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240750157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ken Lee <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240750157">(May 30 2021 at 10:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/Monoid.20Morphism/near/240750087">said</a>:</p>
<blockquote>
<p>There is probably a <code>is_monoid_hom</code> predicate as well, but don't use it unless you're really sure you should be: the bundled hom is usually better.</p>
</blockquote>
<p>because using bundled hom is morally "working in the category of monoids"?</p>



<a name="240750290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240750290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240750290">(May 30 2021 at 10:57)</a>:</h4>
<p>This is often an <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> problem. Usually the correct fix is to find the person giving you the bare function and make them give you the bundled function instead. :-)</p>



<a name="240750345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240750345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240750345">(May 30 2021 at 10:58)</a>:</h4>
<p>There is <code>is_monoid_hom</code> for exactly this purpose, but if you observe how infrequently it is used in mathlib, you'll see why I suggest you tell us here what you're doing, and we'll see if the bundled hom suits your purpose!</p>



<a name="240750495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240750495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ken Lee <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240750495">(May 30 2021 at 11:03)</a>:</h4>
<p>I'm trying out an alternative definition of "monoids internal to a category" based on Yoneda </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.category.Mon.basic</span>
<span class="kn">import</span> <span class="n">category_theory.category</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">structure</span> <span class="n">MON</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span>
<span class="o">(</span><span class="n">el_mon</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">δ</span> <span class="o">:</span> <span class="n">C</span><span class="o">),</span> <span class="n">monoid</span><span class="o">(</span><span class="n">δ</span> <span class="bp">⟶</span> <span class="n">carrier</span><span class="o">)</span> <span class="bp">.</span> <span class="n">tactic.apply_instance</span><span class="o">)</span>
<span class="o">(</span><span class="n">funk_mon</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">δ</span> <span class="n">δ₁</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">δ₁</span> <span class="bp">⟶</span> <span class="n">δ</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="n">d₁</span> <span class="o">:</span> <span class="n">δ</span> <span class="bp">⟶</span> <span class="n">carrier</span><span class="o">),</span>
  <span class="n">f</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">d</span> <span class="bp">*</span> <span class="n">d₁</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">≫</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">f</span> <span class="bp">≫</span> <span class="n">d₁</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">MON</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">δ</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span>
<span class="n">monoid</span> <span class="o">(</span><span class="n">δ</span> <span class="bp">⟶</span> <span class="n">M.carrier</span><span class="o">)</span> <span class="o">:=</span> <span class="n">M.el_mon</span> <span class="n">δ</span>

<span class="kd">structure</span> <span class="n">hom</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">MON</span> <span class="n">C</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mor</span> <span class="o">:</span> <span class="n">M.carrier</span> <span class="bp">⟶</span> <span class="n">N.carrier</span><span class="o">)</span>
<span class="o">(</span><span class="n">el_map_one</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">δ</span> <span class="o">:</span> <span class="n">C</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">δ</span> <span class="bp">⟶</span> <span class="n">M.carrier</span><span class="o">)</span><span class="bp">≫</span> <span class="n">mor</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">(</span><span class="n">el_map_mul</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">δ</span> <span class="o">:</span> <span class="n">C</span><span class="o">),</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">δ</span> <span class="bp">⟶</span> <span class="n">M.carrier</span><span class="o">),</span>
  <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">≫</span> <span class="n">mor</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">≫</span> <span class="n">mor</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">≫</span> <span class="n">mor</span><span class="o">)</span>
</code></pre></div>



<a name="240750565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240750565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ken Lee <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240750565">(May 30 2021 at 11:05)</a>:</h4>
<p>it would be nice for <code>funk_mon</code> to say "the (contravariant) induced map on homs is a monoid morphism" and similarly for definition of <code>hom</code> to be "a map such that induced map on homs is a monoid morphism", hence my post.</p>



<a name="240750687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240750687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240750687">(May 30 2021 at 11:09)</a>:</h4>
<p>Interesting!</p>



<a name="240750731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240750731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ken Lee <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240750731">(May 30 2021 at 11:10)</a>:</h4>
<p>maybe I shld phrase everything as upgrading the Yoneda embedding "<code>yoneda M : C^op =&gt; Type v</code>" to "<code>yoneda M : C^op =&gt; Mon Type v</code>"?</p>



<a name="240750740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240750740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240750740">(May 30 2021 at 11:11)</a>:</h4>
<p>I'm not quite sure what that would mean.</p>



<a name="240750758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240750758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240750758">(May 30 2021 at 11:11)</a>:</h4>
<p>We do have <code>Mon_ (C ⥤ D) ≌ C ⥤ Mon_ D</code>in <code>category_theory.monoidal.internal.functor_category</code>.</p>



<a name="240750803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240750803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240750803">(May 30 2021 at 11:12)</a>:</h4>
<p>So it would suffice to say <code>yoneda M</code> is an internal monoid. But we don't have unbundled internal monoids! :-)</p>



<a name="240750864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240750864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240750864">(May 30 2021 at 11:14)</a>:</h4>
<p>I guess you could not worry about representability, and just write <code>Mon_ (Cᵒᵖ ⥤ Type)</code> as the entirety of the definition... (pro- internal- monoids? I don't know what these would be called)</p>



<a name="240750881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240750881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240750881">(May 30 2021 at 11:15)</a>:</h4>
<p>Or take the subcategory which under <code>Mon_ (Cᵒᵖ ⥤ Type) ≌ Cᵒᵖ ⥤ Mon_ Type</code> become representable...</p>



<a name="240750889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240750889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240750889">(May 30 2021 at 11:15)</a>:</h4>
<p>But I think my answer for now is that you should use <code>is_monoid_hom</code>. :-)</p>



<a name="240750948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240750948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ken Lee <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240750948">(May 30 2021 at 11:16)</a>:</h4>
<p>I will play around with both <code>is_monoid_hom</code> and <code>Mon_ (Cᵒᵖ ⥤ Type)</code>. Thanks so much!</p>



<a name="240751009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monoid%20Morphism/near/240751009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ken Lee <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monoid.20Morphism.html#240751009">(May 30 2021 at 11:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/Monoid.20Morphism/near/240750864">said</a>:</p>
<blockquote>
<p>I guess you could not worry about representability, and just write <code>Mon_ (Cᵒᵖ ⥤ Type)</code> as the entirety of the definition... (pro- internal- monoids? I don't know what these would be called)</p>
</blockquote>
<p>monoid presheaves on <code>C</code> maybe?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html">synthesized not defeq inferred</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="199892250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199892250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199892250">(Jun 05 2020 at 15:23)</a>:</h4>
<p>Hi, I have encountered the following error and I can't figure out why, any help would be greatly appreciated:</p>
<div class="codehilite"><pre><span></span><code><span class="n">synthesized</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span> <span class="n">is</span> <span class="n">not</span> <span class="n">definitionally</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">expression</span> <span class="n">inferred</span> <span class="k">by</span> <span class="n">typing</span> <span class="n">rules</span><span class="o">,</span> <span class="n">synthesized</span>
  <span class="n">ring</span><span class="bp">.</span><span class="n">to_semiring</span>
<span class="n">inferred</span>
  <span class="n">comm_semiring</span><span class="bp">.</span><span class="n">to_semiring</span> <span class="err">↥</span><span class="n">K</span>
</code></pre></div>


<p><a href="https://leanprover-community.github.io/mwe.html">#mwe</a> is</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">ring_exp</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">opposites</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">commute</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">ring</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">quadratic_form</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">complex</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">class</span> <span class="n">geometric_algebra</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span>
<span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span>
<span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">K</span> <span class="n">V</span><span class="o">]</span> <span class="c1">-- [Q : quadratic_form K V]</span>
<span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">is_subring</span> <span class="n">K</span><span class="o">]</span>
<span class="o">[</span><span class="n">is_subring</span> <span class="n">V</span><span class="o">]</span>
<span class="kn">extends</span> <span class="n">algebra</span> <span class="n">K</span> <span class="n">G</span>
 <span class="o">:=</span>
<span class="o">(</span><span class="n">inner_product</span> <span class="o">:</span> <span class="n">quadratic_form</span> <span class="n">K</span> <span class="n">V</span><span class="o">)</span>
</code></pre></div>


<p>The background is that I need K ⊆ G and V ⊆ G and they need to share the same +, * and follow the same basic arithmetic rules.</p>
<p>Reference: <a href="https://en.wikipedia.org/wiki/Geometric_algebra">https://en.wikipedia.org/wiki/Geometric_algebra</a></p>



<a name="199902829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199902829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199902829">(Jun 05 2020 at 16:36)</a>:</h4>
<p>I get a different error message, but the problem seems to be the <code>[is_subring K]</code>. Lean can infer that <code>K</code> is a ring from <code>[field K]</code>. Below, when I ask Lean to print everything and I give it the instance explicitly, it complains that it is trying to match the two different ring instance for <code>K</code> and failing. Why do you need <code>[is_subring K]</code>? If I comment it out, the definition works for me.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">ring_exp</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">opposites</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">commute</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">ring</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">quadratic_form</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">complex</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">all</span> <span class="n">true</span>

<span class="n">class</span> <span class="n">geometric_algebra</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span>
<span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span>
<span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">vector_space</span> <span class="n">K</span> <span class="n">V</span><span class="o">]</span> <span class="c1">-- [Q : quadratic_form K V]</span>
<span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">is_subring</span> <span class="n">K</span><span class="o">]</span>
<span class="o">[</span><span class="n">is_subring</span> <span class="n">V</span><span class="o">]</span>
<span class="kn">extends</span> <span class="n">algebra</span> <span class="n">K</span> <span class="n">G</span>
 <span class="o">:=</span>
<span class="o">(</span><span class="n">inner_product</span> <span class="o">:</span> <span class="n">quadratic_form</span> <span class="n">K</span> <span class="n">V</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h</span><span class="o">)</span>
</code></pre></div>



<a name="199903683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199903683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199903683">(Jun 05 2020 at 16:43)</a>:</h4>
<p>I need it because there's another property I need that is <code>\forall v : V, v*v \in K</code></p>



<a name="199903951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199903951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199903951">(Jun 05 2020 at 16:45)</a>:</h4>
<p>I can tell the direct cause from the error massage but don't know if it's a limitation of Lean or I'm puting the assumption at the wrong location</p>



<a name="199904090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199904090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199904090">(Jun 05 2020 at 16:46)</a>:</h4>
<p>Three places to choose from: [] before extends, after extends, after :=</p>



<a name="199904701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199904701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199904701">(Jun 05 2020 at 16:51)</a>:</h4>
<p>By limitation I mean whether one type can be sub-something and something++ and Lean knows the duplication of specifying something is acceptable</p>



<a name="199904863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199904863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199904863">(Jun 05 2020 at 16:52)</a>:</h4>
<p>If I understand correctly, what is happening is that you are giving <code>K</code> two different (and possibly entirely unrelated) ring structures. I don't think the type classes are set up to do exactly what you want. Hmm.....</p>



<a name="199905162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199905162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199905162">(Jun 05 2020 at 16:54)</a>:</h4>
<p>Yes, I guess that's the root cause and I need to try doing it in another way.</p>



<a name="199905264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199905264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199905264">(Jun 05 2020 at 16:55)</a>:</h4>
<p>I think you need to define a special structure for <code>is_subfield K</code>, write down the axioms that describe that, and then show <code>is_subring K</code> and <code>field K</code> both follow.</p>



<a name="199905371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199905371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199905371">(Jun 05 2020 at 16:56)</a>:</h4>
<p>but G is not a field...</p>



<a name="199905427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199905427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199905427">(Jun 05 2020 at 16:56)</a>:</h4>
<p>(Where <code>is_subfield K</code> says, roughly, that <code>K</code> is equipped with a division that makes it both a field and a subring of the bigger ring. Maybe there is a better name for that, like <code>is_field_as_subring K</code>.)</p>



<a name="199905517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199905517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199905517">(Jun 05 2020 at 16:57)</a>:</h4>
<p>I see, that seems ok</p>



<a name="199905619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199905619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199905619">(Jun 05 2020 at 16:58)</a>:</h4>
<p>I'll try that, thanks!</p>



<a name="199905673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199905673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199905673">(Jun 05 2020 at 16:59)</a>:</h4>
<p><span class="user-mention" data-user-id="296911">@Utensil Song</span> In practice it seems to be better in the long run to work with injective structure preserving functions rather than <code>set G</code></p>



<a name="199905747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199905747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199905747">(Jun 05 2020 at 16:59)</a>:</h4>
<p>(In the perfectoid project we had the definition of a Huber pair, which is a ring <code>A</code> and a subring <code>A^+</code>...</p>



<a name="199905833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199905833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199905833">(Jun 05 2020 at 17:00)</a>:</h4>
<p>And after a while we realised that we couldn't prove that <code>Z_p, Q_p</code> was an example.</p>



<a name="199905878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199905878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199905878">(Jun 05 2020 at 17:00)</a>:</h4>
<p>Because in lean, <code>Z_p</code> is not a subring of <code>Q_p</code>, even though there is a injective ring homomorphism.</p>



<a name="199905944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199905944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199905944">(Jun 05 2020 at 17:01)</a>:</h4>
<p>So then we changed the definition, to use an injective ring hom (or algebra), and most proofs stayed the same, some became shorter.</p>



<a name="199905966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199905966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199905966">(Jun 05 2020 at 17:01)</a>:</h4>
<p>In general it was just a lot more pleasant to work with.</p>



<a name="199905971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199905971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199905971">(Jun 05 2020 at 17:01)</a>:</h4>
<p>That's because I just found out how to write <code>is_subring A B</code> (not Lean) from Zulip chat history</p>



<a name="199906245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199906245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199906245">(Jun 05 2020 at 17:03)</a>:</h4>
<p>broken into <code>A : set B</code> and <code>is_subring A</code>...</p>



<a name="199906562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199906562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199906562">(Jun 05 2020 at 17:06)</a>:</h4>
<p>strictly speaking, in my case, K is indeed not a subring of G</p>



<a name="199906614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/199906614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#199906614">(Jun 05 2020 at 17:06)</a>:</h4>
<p>the hom approach is more accurate</p>



<a name="200026861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200026861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200026861">(Jun 07 2020 at 14:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/199905944">said</a>:</p>
<blockquote>
<p>So then we changed the definition, to use an injective ring hom (or algebra), and most proofs stayed the same, some became shorter.</p>
</blockquote>
<p>The PR seems to be <a href="https://github.com/leanprover-community/lean-perfectoid-spaces/pull/56">https://github.com/leanprover-community/lean-perfectoid-spaces/pull/56</a> and particular <a href="https://github.com/leanprover-community/lean-perfectoid-spaces/pull/56/commits/2b6a01f707f667f0c761250d7784bc38b4ff6062">this commit</a>.</p>
<p>The related code are:</p>
<ol>
<li>in <a href="https://leanprover-community.github.io/mathlib_docs/find/ring_theory.algebra">docs#ring_theory.algebra</a></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">algebra</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span>
  <span class="kn">extends</span> <span class="n">has_scalar</span> <span class="n">R</span> <span class="n">A</span><span class="o">,</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">commutes&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="n">x</span><span class="o">,</span> <span class="n">to_fun</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">to_fun</span> <span class="n">r</span><span class="o">)</span>
<span class="o">(</span><span class="n">smul_def&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">to_fun</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span>

<span class="c">/-</span><span class="cm">- Embedding `R →+* A` given by `algebra` structure. -/</span>
<span class="n">def</span> <span class="n">algebra_map</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">A</span> <span class="o">:=</span>
<span class="n">algebra</span><span class="bp">.</span><span class="n">to_ring_hom</span>
</code></pre></div>


<ol start="2">
<li>in <a href="https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/Huber_pair.lean">https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/Huber_pair.lean</a></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">Huber_pair</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">plus</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">[</span><span class="n">ring</span> <span class="o">:</span> <span class="n">comm_ring</span> <span class="n">plus</span><span class="o">]</span>
<span class="o">[</span><span class="n">top</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">plus</span><span class="o">]</span>
<span class="o">[</span><span class="n">Huber</span> <span class="o">:</span> <span class="n">Huber_ring</span> <span class="n">carrier</span><span class="o">]</span>
<span class="o">[</span><span class="n">alg</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">plus</span> <span class="n">carrier</span><span class="o">]</span>
<span class="o">(</span><span class="n">intel</span> <span class="o">:</span> <span class="n">is_ring_of_integral_elements</span> <span class="n">plus</span> <span class="n">carrier</span><span class="o">)</span>

<span class="n">local</span> <span class="kn">postfix</span> <span class="bp">`</span><span class="err">⁺</span><span class="bp">`</span> <span class="o">:</span> <span class="mi">66</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="o">:</span> <span class="n">Huber_pair</span><span class="o">,</span> <span class="n">A</span><span class="bp">.</span><span class="n">plus</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">comm_ring</span> <span class="o">(</span><span class="n">A</span><span class="err">⁺</span><span class="o">)</span> <span class="o">:=</span> <span class="n">A</span><span class="bp">.</span><span class="n">ring</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">A</span><span class="err">⁺</span><span class="o">)</span> <span class="o">:=</span> <span class="n">A</span><span class="bp">.</span><span class="n">top</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">Huber_ring</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">A</span><span class="bp">.</span><span class="n">Huber</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">algebra</span> <span class="o">(</span><span class="n">A</span><span class="err">⁺</span><span class="o">)</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">A</span><span class="bp">.</span><span class="n">alg</span>
</code></pre></div>



<a name="200027157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200027157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200027157">(Jun 07 2020 at 14:44)</a>:</h4>
<p>From this example now I can see clearly why <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> said that <code>B : subring C</code> and  <code>algebra B C</code> are kind of the same in  <a href="#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/191348229">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/191348229</a> (found during searching for a proper solution for my issue here) .</p>



<a name="200027294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200027294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200027294">(Jun 07 2020 at 14:49)</a>:</h4>
<p>BTW, I don't know we can do <code>[]</code> after <code>:=</code>  too(I always wondered how we can reference the algebraic structure), only that it can be used before <code>extends</code>, and we can do it between <code>extends</code> and <code>:=</code> without the <code>[]</code>.</p>



<a name="200027595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200027595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200027595">(Jun 07 2020 at 14:56)</a>:</h4>
<p>And how do we decide where to put <code>[]</code>(the type class arguments)? I'm very confused now. All three places seem to be legal, this seems to be just a mathematical design principle issue.</p>



<a name="200027688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200027688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200027688">(Jun 07 2020 at 14:59)</a>:</h4>
<p>If you're talking about defining structures and classes, then <code>[]</code> after <code>:=</code> means that you tell it the instance at the same time as you're making the structure. Before the <code>:=</code> Lean will try to make the instance before you have even started making the structure</p>



<a name="200028349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200028349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200028349">(Jun 07 2020 at 15:17)</a>:</h4>
<p>Thanks, but what it means for the definition, mathematically?</p>



<a name="200028361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200028361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200028361">(Jun 07 2020 at 15:17)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">ring_exp</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">opposites</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">commute</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">ring</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">quadratic_form</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">complex</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">class</span> <span class="n">test</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">[</span><span class="n">field</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">]</span>
<span class="o">[</span><span class="n">group</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span>
<span class="o">[</span><span class="n">space</span> <span class="o">:</span> <span class="n">vector_space</span> <span class="n">K</span> <span class="n">V</span><span class="o">]</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">test</span><span class="bp">.</span><span class="n">mk</span> <span class="n">ℝ</span> <span class="n">ℝ</span> <span class="c1">-- test.mk ℝ ℝ : test</span>

<span class="n">noncomputable</span> <span class="kn">instance</span> <span class="n">test_rr</span> <span class="o">:</span> <span class="n">test</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">K</span> <span class="o">:=</span> <span class="n">ℝ</span><span class="o">,</span>
  <span class="n">V</span> <span class="o">:=</span> <span class="n">ℝ</span>
<span class="o">}</span>

<span class="n">class</span> <span class="n">test&#39;</span>
<span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">[</span><span class="n">field</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">]</span>
<span class="o">[</span><span class="n">group</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span>
<span class="o">[</span><span class="n">space</span> <span class="o">:</span> <span class="n">vector_space</span> <span class="n">K</span> <span class="n">V</span><span class="o">]</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">test&#39;</span> <span class="n">ℝ</span> <span class="n">ℝ</span> <span class="c1">-- test&#39; ℝ ℝ : Type</span>

<span class="kn">instance</span> <span class="n">test&#39;_rr</span> <span class="o">:</span> <span class="n">test&#39;</span> <span class="n">ℝ</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">sorry</span> <span class="c1">-- by apply_instance -- tactic.mk_instance failed to generate instance for</span>

<span class="n">class</span> <span class="n">test&#39;&#39;</span>
<span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">[</span><span class="n">field</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">]</span>
<span class="o">[</span><span class="n">group</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span>
<span class="kn">extends</span> <span class="n">vector_space</span> <span class="n">K</span> <span class="n">V</span> <span class="c1">-- invalid &#39;structure&#39; extends, &#39;vector_space&#39; is not a structure</span>
</code></pre></div>



<a name="200032447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200032447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200032447">(Jun 07 2020 at 16:59)</a>:</h4>
<p>Finally I got to my x of the <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> , here's a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>  that's actually working :</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">ring_exp</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">opposites</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">commute</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">ring</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">quadratic_form</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">complex</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">class</span> <span class="n">geometric_algebra</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lift</span> <span class="n">K</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">K</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lift</span> <span class="n">V</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span>
 <span class="o">:=</span>
<span class="o">[</span><span class="n">assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)]</span>
<span class="o">[</span><span class="n">left_distrib</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)]</span>
<span class="o">[</span><span class="n">right_distrib</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)]</span>
<span class="o">(</span><span class="n">v_sq_in_k</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">K</span><span class="o">,</span> <span class="o">(</span><span class="err">↑</span><span class="n">v</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="err">↑</span><span class="n">v</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="err">↑</span><span class="n">k</span> <span class="o">:</span> <span class="n">G</span><span class="o">))</span>

<span class="kn">namespace</span> <span class="n">geometric_algebra</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lift</span> <span class="n">K</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">K</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lift</span> <span class="n">V</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">GA</span> <span class="o">:</span> <span class="n">geometric_algebra</span> <span class="n">G</span> <span class="n">K</span> <span class="n">V</span><span class="o">]</span>

<span class="c1">-- the trivial case: prove ℝ is a GA</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_lift</span> <span class="n">ℝ</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">lift</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="o">}</span>

<span class="n">noncomputable</span> <span class="kn">instance</span> <span class="o">:</span> <span class="n">geometric_algebra</span> <span class="n">ℝ</span> <span class="n">ℝ</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="n">assoc</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">semigroup</span><span class="bp">.</span><span class="n">mul_assoc</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">),</span>
    <span class="n">left_distrib</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">distrib</span><span class="bp">.</span><span class="n">left_distrib</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">),</span>
    <span class="n">right_distrib</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">distrib</span><span class="bp">.</span><span class="n">right_distrib</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">),</span>
    <span class="n">v_sq_in_k</span> <span class="o">:=</span> <span class="k">begin</span>
        <span class="n">intro</span> <span class="n">v</span><span class="o">,</span>
        <span class="n">use</span> <span class="o">(</span><span class="err">↑</span><span class="n">v</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="err">↑</span><span class="n">v</span><span class="o">),</span>
        <span class="n">refl</span>
    <span class="kn">end</span>
<span class="o">}</span>

<span class="kn">end</span> <span class="n">geometric_algebra</span>
</code></pre></div>


<p>But I have 3 new questions:</p>
<p>Q1: How can I express that there should exist only one k? (by changing \in to \exist, I avoided the <code>has_mem</code> issues but it seems not completely safe)</p>
<p>Q2: Why do I have to write an instance for <code>has_lift ℝ ℝ</code>? Shouldn't it be automatically inferred?</p>
<p>Q3: Why can't <code>assoc</code>, <code>left_distrib</code>, <code>right_distrib</code> be automatically inferred?</p>



<a name="200033570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200033570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200033570">(Jun 07 2020 at 17:25)</a>:</h4>
<p><span class="user-mention" data-user-id="296911">@Utensil Song</span> You are requiring <code>[ring G]</code> and afterwards you have axioms <code>assoc</code>, <code>left_distrib</code>, and <code>right_distrib</code>. But those are already part of <code>ring G</code>...<br>
Did you mean something else?</p>



<a name="200033626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200033626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200033626">(Jun 07 2020 at 17:26)</a>:</h4>
<p>Also, you are not asking for any compatibility of the field structure on <code>K</code> and the ring structure on <code>G</code>. Should the <code>has_lift</code> respect multiplication and addition?</p>



<a name="200033816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200033816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200033816">(Jun 07 2020 at 17:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/200033570">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="296911">Utensil Song</span> You are requiring <code>[ring G]</code> and afterwards you have axioms <code>assoc</code>, <code>left_distrib</code>, and <code>right_distrib</code>. But those are already part of <code>ring G</code>...<br>
Did you mean something else?</p>
</blockquote>
<p>I think that I might have done something redundant here, but what I was thinking is that G is a ring but geometric_algebra G K V isn't so I added these trivial properties and name them under geometric_algebra. This seems to be exactly why it can't be inferred.</p>
<p>Ignore Q3 then.</p>



<a name="200034006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200034006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200034006">(Jun 07 2020 at 17:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/200033626">said</a>:</p>
<blockquote>
<p>Also, you are not asking for any compatibility of the field structure on <code>K</code> and the ring structure on <code>G</code>. Should the <code>has_lift</code> respect multiplication and addition?</p>
</blockquote>
<p>Yes, you're right, it should, I can add <code>[algebra K G]</code> back, and everything still works.</p>
<p>I removed it for K since I can't do the same for V. <code>[algebra V G]</code> requires <code>V</code> to be <code>[comm_semiring V]</code> but <code>*</code> (geometric product) does not commute for vectors and it's not even a group since the multiplication is not closed, a vector times a vector becomes a bivector, it's in G, but not in V. But actually for K, <code>[algebra V G]</code> is fine and so is the <code>*</code> for K.</p>



<a name="200034421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200034421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200034421">(Jun 07 2020 at 17:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/200027688">said</a>:</p>
<blockquote>
<p>If you're talking about defining structures and classes, then <code>[]</code> after <code>:=</code> means that you tell it the instance at the same time as you're making the structure. Before the <code>:=</code> Lean will try to make the instance before you have even started making the structure</p>
</blockquote>
<p>Either I don't understand this or Kevin is wrong here.</p>



<a name="200034608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200034608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200034608">(Jun 07 2020 at 17:49)</a>:</h4>
<p>I can quite believe I'm wrong. I think Utensil Song knows exactly what they are talking about at this point though.</p>



<a name="200034950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200034950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200034950">(Jun 07 2020 at 17:57)</a>:</h4>
<p>~To answer Q1, it seems that I should take a closer look at~</p>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm">-An R-algebra A is integrally closed if every element of A that is integral over R is contained in</span>
<span class="cm">the image of the canonical map R → A. This algebra_map is required to be injective.-/</span>
<span class="kn">structure</span> <span class="n">is_integrally_closed</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">inj</span> <span class="o">:</span> <span class="n">injective</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">A</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">A</span><span class="o">))</span>
<span class="o">(</span><span class="n">closed</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">is_integral</span> <span class="n">R</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">A</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">A</span><span class="o">))</span>
</code></pre></div>


<p>~from the Huber_pair PR.~</p>
<p>EDIT: doesn't help. The injection of the lift seems to be covered in <code>[algebra K G]</code> , the uniqueness of k is another question.</p>



<a name="200035091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200035091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200035091">(Jun 07 2020 at 18:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/200034608">said</a>:</p>
<blockquote>
<p>I can quite believe I'm wrong. I think Utensil Song knows exactly what they are talking about at this point though.</p>
</blockquote>
<p>From the tests in <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/200028361">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/200028361</a> , I do know that they're very different, but still, the applicability of each choice is still an unsolved puzzle.</p>



<a name="200035102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200035102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200035102">(Jun 07 2020 at 18:01)</a>:</h4>
<p>Lean is just letting you write what you mean.</p>



<a name="200035407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200035407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200035407">(Jun 07 2020 at 18:09)</a>:</h4>
<p>Indeed.</p>



<a name="200036387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200036387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200036387">(Jun 07 2020 at 18:34)</a>:</h4>
<p>However sometimes there is more than one way to write what you mean...</p>



<a name="200636600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200636600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200636600">(Jun 12 2020 at 05:42)</a>:</h4>
<p>After updating Lean to 3.16.0 and mathlib to  <code>mathlib = {git = "https://github.com/leanprover-community/mathlib", rev = "593f731dd200fe74c218ff9886eb663d4a860dcd"}</code> using <code>leanproject up</code>, Lean dies frequently for the following <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> :</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span><span class="bp">.</span><span class="n">hom</span>
<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">complex</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">u₀</span> <span class="n">u₁</span>

<span class="n">class</span> <span class="n">geometric_algebra</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="c1">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>
<span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">G₀</span><span class="o">]</span> <span class="o">[</span><span class="n">char_zero</span> <span class="n">G₀</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">G₀</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">G₀</span><span class="o">]</span>
<span class="c1">-- Axiom 3: G contains a subset G1 closed under addition, and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>
<span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">G₀</span> <span class="n">G₁</span><span class="o">]</span>
<span class="c1">-- Axiom 1: G is a ring with unit.</span>
<span class="c1">-- The additive identity is called 0 and the multiplicative identity is called 1.</span>
<span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">G</span><span class="o">]</span>
<span class="c1">-- TODO: find better ways to map G₀ and G₁ to G</span>
<span class="o">[</span><span class="n">has_coe</span> <span class="n">G₀</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">has_coe</span> <span class="n">G₁</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">G₀</span> <span class="bp">→+*</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">algebra</span> <span class="n">G₀</span> <span class="n">G</span><span class="o">]</span>
<span class="o">:=</span>
<span class="c1">-- Axiom 4: The square of every vector is a scalar.</span>
<span class="o">(</span><span class="n">vec_sq_scalar</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">G₀</span><span class="o">,</span> <span class="o">(</span><span class="n">v</span> <span class="bp">*</span> <span class="n">v</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">G</span><span class="o">))</span>

<span class="kn">namespace</span> <span class="n">geometric_algebra</span>

<span class="kn">section</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="c1">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>
<span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">G₀</span><span class="o">]</span> <span class="o">[</span><span class="n">char_zero</span> <span class="n">G₀</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">G₀</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">G₀</span><span class="o">]</span>
<span class="c1">-- Axiom 3: G contains a subset G1 closed under addition, and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>
<span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">G₀</span> <span class="n">G₁</span><span class="o">]</span>
<span class="c1">-- Axiom 1: G is a ring with unit.</span>
<span class="c1">-- The additive identity is called 0 and the multiplicative identity is called 1.</span>
<span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">G</span><span class="o">]</span>
<span class="c1">-- TODO: find better ways to map G₀ and G₁ to G</span>
<span class="o">[</span><span class="n">has_coe</span> <span class="n">G₀</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">has_coe</span> <span class="n">G₁</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">G₀</span> <span class="bp">→+*</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">algebra</span> <span class="n">G₀</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">GA</span> <span class="o">:</span> <span class="n">geometric_algebra</span> <span class="n">G</span> <span class="n">G₀</span> <span class="n">G₁</span><span class="o">]</span>

<span class="kn">end</span>
<span class="kn">end</span> <span class="n">geometric_algebra</span>
</code></pre></div>



<a name="200636656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200636656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200636656">(Jun 12 2020 at 05:44)</a>:</h4>
<p>After every restart of Lean, and opening only this <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> in the editor, the orange bar shows up and does not disappear and then<br>
<a href="/user_uploads/3121/2gmr5a6mM8-C0xylIGr3VTTx/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/2gmr5a6mM8-C0xylIGr3VTTx/image.png" title="image.png"><img src="/user_uploads/3121/2gmr5a6mM8-C0xylIGr3VTTx/image.png"></a></div>



<a name="200636672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200636672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200636672">(Jun 12 2020 at 05:45)</a>:</h4>
<p>How can I get more trace log to debug this?</p>



<a name="200636724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200636724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200636724">(Jun 12 2020 at 05:46)</a>:</h4>
<p>I don't have any issues running this, although I get an error on the last line because <code>[G₀ →+* G] [G₁ →+ G]</code> are not classes</p>



<a name="200636743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200636743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200636743">(Jun 12 2020 at 05:47)</a>:</h4>
<p>Usually, if you get something that kills lean straight away, it requires some C++ debugging</p>



<a name="200636746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200636746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200636746">(Jun 12 2020 at 05:47)</a>:</h4>
<p>because you don't have the opportunity to ask more info</p>



<a name="200636902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200636902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200636902">(Jun 12 2020 at 05:52)</a>:</h4>
<blockquote>
<p>[G₀ →+* G] [G₁ →+ G] are not classes</p>
</blockquote>
<p>Oh I see, type class <code>algebra</code> extends them but it doesn't mean I can use them as type classes. But I can't extend them either since there would be duplicated <code>to_fun</code> etc.</p>



<a name="200636948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200636948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200636948">(Jun 12 2020 at 05:54)</a>:</h4>
<p>you don't need to extend them</p>



<a name="200636949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200636949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200636949">(Jun 12 2020 at 05:54)</a>:</h4>
<blockquote>
<p>I don't have any issues running this</p>
</blockquote>
<p>I don't always have issues running this, but when I comment out some type classes and add some back, somehow it triggers Lean to be killed and it stays that way even after restart</p>



<a name="200636950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200636950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200636950">(Jun 12 2020 at 05:54)</a>:</h4>
<p>just have a field</p>



<a name="200636954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200636954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200636954">(Jun 12 2020 at 05:54)</a>:</h4>
<p>G1 is not a field by itself</p>



<a name="200636960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200636960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200636960">(Jun 12 2020 at 05:55)</a>:</h4>
<p>no, the function</p>



<a name="200636962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200636962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200636962">(Jun 12 2020 at 05:55)</a>:</h4>
<p>the two functions should be fields of the structure</p>



<a name="200636972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200636972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200636972">(Jun 12 2020 at 05:55)</a>:</h4>
<p>well probably not <code>[G₀ →+* G] </code> since that one duplicates the function embedded in the algebra</p>



<a name="200637015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637015">(Jun 12 2020 at 05:56)</a>:</h4>
<p>you should not ask for <code>has_coe</code> instances either</p>



<a name="200637022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637022">(Jun 12 2020 at 05:57)</a>:</h4>
<p>the intention was to comment out the <code>has_coe</code>, <code>algebra</code> lines</p>



<a name="200637031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637031">(Jun 12 2020 at 05:57)</a>:</h4>
<blockquote>
<p>Mario Carneiro: the two functions should be fields of the structure</p>
</blockquote>
<p>I'll try that</p>



<a name="200637137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637137">(Jun 12 2020 at 06:00)</a>:</h4>
<p>I think you want something like this:</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">geometric_algebra</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="c1">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>
<span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">G₀</span><span class="o">]</span> <span class="o">[</span><span class="n">char_zero</span> <span class="n">G₀</span><span class="o">]</span>
<span class="c1">-- Axiom 3: G contains a subset G1 closed under addition, and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>
<span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">G₀</span> <span class="n">G₁</span><span class="o">]</span>
<span class="c1">-- Axiom 1: G is a ring with unit.</span>
<span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">algebra</span> <span class="n">G₀</span> <span class="n">G</span><span class="o">]</span>
<span class="o">:=</span>
<span class="o">(</span><span class="n">f₁</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span><span class="o">)</span>
<span class="c1">-- Axiom 4: The square of every vector is a scalar.</span>
<span class="o">(</span><span class="n">vec_sq_scalar</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">G₀</span><span class="o">,</span> <span class="n">f₁</span> <span class="n">v</span> <span class="bp">*</span> <span class="n">f₁</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">algebra_map</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">k</span><span class="o">)</span>
</code></pre></div>



<a name="200637160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637160">(Jun 12 2020 at 06:01)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span><span class="bp">.</span><span class="n">hom</span>
<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">complex</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">u₀</span> <span class="n">u₁</span>

<span class="n">class</span> <span class="n">geometric_algebra</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="c1">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>
<span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">G₀</span><span class="o">]</span> <span class="o">[</span><span class="n">char_zero</span> <span class="n">G₀</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">G₀</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">G₀</span><span class="o">]</span>
<span class="c1">-- Axiom 3: G contains a subset G1 closed under addition, and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>
<span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">G₀</span> <span class="n">G₁</span><span class="o">]</span>
<span class="c1">-- Axiom 1: G is a ring with unit.</span>
<span class="c1">-- The additive identity is called 0 and the multiplicative identity is called 1.</span>
<span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">G</span><span class="o">]</span>
<span class="c1">-- TODO: find better ways to map G₀ and G₁ to G</span>
<span class="c1">-- [has_coe G₀ G] [has_coe G₁ G]</span>
<span class="c1">-- [G₀ →+* G]</span>
<span class="c1">-- [algebra G₀ G]</span>
<span class="o">:=</span>
<span class="o">(</span><span class="n">scalar_hom</span> <span class="o">:</span> <span class="n">G₀</span> <span class="bp">→+*</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">vec_hom</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span><span class="o">)</span>
<span class="c1">-- Axiom 4: The square of every vector is a scalar.</span>
<span class="o">(</span><span class="n">vec_sq_scalar</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">G₀</span><span class="o">,</span> <span class="n">vec_hom</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="bp">*</span> <span class="n">vec_hom</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="bp">=</span> <span class="n">scalar_hom</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="o">)</span>
</code></pre></div>


<p>Here's what I came up with</p>



<a name="200637172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637172">(Jun 12 2020 at 06:01)</a>:</h4>
<p>you have a lot of duplicate data in the parameters</p>



<a name="200637214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637214">(Jun 12 2020 at 06:02)</a>:</h4>
<p>Oh, <code>algebra_map _ _ k</code> is the <code>scalar_hom</code> equivalent</p>



<a name="200637225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637225">(Jun 12 2020 at 06:03)</a>:</h4>
<p>those <code>has_zero</code> and <code>has_one</code> instances are also duplicate</p>



<a name="200637227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637227">(Jun 12 2020 at 06:03)</a>:</h4>
<blockquote>
<p>Mario Carneiro: you have a lot of duplicate data in the parameters</p>
</blockquote>
<p>Yes, I'm trying to see the effect of doing so. Was expecting to get warnings about them.</p>



<a name="200637231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637231">(Jun 12 2020 at 06:03)</a>:</h4>
<p>no, you will just get stuck in proofs</p>



<a name="200637238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637238">(Jun 12 2020 at 06:03)</a>:</h4>
<p>I don't think lean knows what a warning is</p>



<a name="200637315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637315">(Jun 12 2020 at 06:05)</a>:</h4>
<p>If you have any duplicate data, you are constructing something like "a field with two independent multiplications" or similar. Any theorem using one operation will not be able to play well with definitions based on the other</p>



<a name="200637368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637368">(Jun 12 2020 at 06:06)</a>:</h4>
<blockquote>
<p>Mario Carneiro: no, you will just get stuck in proofs</p>
</blockquote>
<p>Oh, I got stuck somewhere else. Using <code>has_coe</code> made me to prove <code>↑kab - ↑ka - ↑kb = ↑(kab - ka - kb)</code> which can't be proved unless I have a <code>-&gt;+</code>.</p>



<a name="200637371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637371">(Jun 12 2020 at 06:06)</a>:</h4>
<p>for example, with <code>[field G₀] [has_one G₀]</code> you will not be able to prove <code>1 * x = x</code></p>



<a name="200637380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637380">(Jun 12 2020 at 06:06)</a>:</h4>
<p>because nothing says that <code>1</code> is a unit</p>



<a name="200637396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637396">(Jun 12 2020 at 06:07)</a>:</h4>
<p>Oh, I thought it's eliminated in the solution to the diamond problem.</p>



<a name="200637412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637412">(Jun 12 2020 at 06:07)</a>:</h4>
<p>if they were fields it would be a different matter, but you are passing everything as parameters</p>



<a name="200637453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637453">(Jun 12 2020 at 06:08)</a>:</h4>
<p>there is no way for lean to assert a relation on the inputs unless you provide such relation</p>



<a name="200637522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637522">(Jun 12 2020 at 06:10)</a>:</h4>
<p>I notice that <code>Axiom 2</code> and <code>Axiom 3</code> make additional claims about closure. These need to be axioms inside the structure</p>



<a name="200637541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637541">(Jun 12 2020 at 06:10)</a>:</h4>
<p>maybe they come for free given the homs</p>



<a name="200637647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200637647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200637647">(Jun 12 2020 at 06:13)</a>:</h4>
<blockquote>
<p>Mario Carneiro: maybe they come for free given the homs</p>
</blockquote>
<p>I believe so</p>



<a name="200679346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200679346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200679346">(Jun 12 2020 at 14:47)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  I can't refer to f1 later  though:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>

<span class="n">class</span> <span class="n">geometric_algebra</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="c1">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>
<span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">G₀</span><span class="o">]</span> <span class="o">[</span><span class="n">char_zero</span> <span class="n">G₀</span><span class="o">]</span>
<span class="c1">-- Axiom 3: G contains a subset G1 closed under addition, and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>
<span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">G₀</span> <span class="n">G₁</span><span class="o">]</span>
<span class="c1">-- Axiom 1: G is a ring with unit.</span>
<span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">algebra</span> <span class="n">G₀</span> <span class="n">G</span><span class="o">]</span>
<span class="o">:=</span>
<span class="o">(</span><span class="n">f₁</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span><span class="o">)</span>
<span class="c1">-- Axiom 4: The square of every vector is a scalar.</span>
<span class="o">(</span><span class="n">vec_sq_scalar</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">G₀</span><span class="o">,</span> <span class="n">f₁</span> <span class="n">v</span> <span class="bp">*</span> <span class="n">f₁</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">algebra_map</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">k</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">geometric_algebra</span>

<span class="kn">section</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="c1">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>
<span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">G₀</span><span class="o">]</span> <span class="o">[</span><span class="n">char_zero</span> <span class="n">G₀</span><span class="o">]</span>
<span class="c1">-- Axiom 3: G contains a subset G1 closed under addition, and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>
<span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">G₀</span> <span class="n">G₁</span><span class="o">]</span>
<span class="c1">-- Axiom 1: G is a ring with unit.</span>
<span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">algebra</span> <span class="n">G₀</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">GA</span> <span class="o">:</span> <span class="n">geometric_algebra</span> <span class="n">G</span> <span class="n">G₀</span> <span class="n">G₁</span><span class="o">]</span>

<span class="n">def</span> <span class="n">square</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span>

<span class="n">def</span> <span class="n">sym_prod</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`*</span><span class="err">₊</span><span class="bp">`</span><span class="o">:</span><span class="mi">75</span> <span class="o">:=</span> <span class="n">sym_prod</span>

<span class="n">local</span> <span class="kn">postfix</span> <span class="bp">`</span><span class="err">²</span><span class="bp">`</span><span class="o">:</span><span class="mi">80</span> <span class="o">:=</span> <span class="n">square</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">f₁</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">  Symmetrised product of two vectors must be a scalar</span>
<span class="cm">-/</span>
<span class="kn">lemma</span> <span class="n">vec_sym_prod_scalar_failed</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">G₀</span><span class="o">,</span>
  <span class="n">f₁</span> <span class="n">a</span> <span class="bp">*</span><span class="err">₊</span> <span class="n">f₁</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">algebra_map</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">k</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">sorry</span>

<span class="c1">-- type mismatch at application</span>
<span class="c1">--   f₁ a</span>
<span class="c1">-- term</span>
<span class="c1">--   a</span>
<span class="c1">-- has type</span>
<span class="c1">--   G₁ : Type u_3</span>
<span class="c1">-- but is expected to have type</span>
<span class="c1">--   Type ? : Type (?+1)</span>
<span class="c1">-- Additional information:</span>
<span class="c1">-- minimal.lean:43:2: context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message</span>
<span class="c1">--   type mismatch, term</span>
<span class="c1">--     f₁ ?m_2</span>
<span class="c1">--   has type</span>
<span class="c1">--     ?m_1 →+ ?m_2 : Type (max ? ?)</span>
<span class="c1">--   but is expected to have type</span>
<span class="c1">--     Type ? : Type (?+1)</span>

<span class="kn">lemma</span> <span class="n">vec_sym_prod_scalar_still_failed</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">G₀</span><span class="o">,</span>
  <span class="o">(</span><span class="n">f₁</span> <span class="n">G₀</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span><span class="err">₊</span> <span class="o">(</span><span class="n">f₁</span> <span class="n">G₀</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">algebra_map</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">k</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">sorry</span>
<span class="c1">-- failed to synthesize type class instance for</span>
<span class="c1">-- G₀ : Type u_2,</span>
<span class="c1">-- _inst_1 : field G₀,</span>
<span class="c1">-- _inst_2 : char_zero G₀,</span>
<span class="c1">-- G₁ : Type u_3,</span>
<span class="c1">-- _inst_3 : add_comm_group G₁,</span>
<span class="c1">-- _inst_4 : vector_space G₀ G₁,</span>
<span class="c1">-- a b : G₁,</span>
<span class="c1">-- k : G₀</span>
<span class="c1">-- ⊢ ring (Type ?)</span>

<span class="kn">end</span>

<span class="kn">end</span> <span class="n">geometric_algebra</span>
</code></pre></div>


<p>And Lean dies randomly again...</p>



<a name="200703068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200703068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200703068">(Jun 12 2020 at 17:58)</a>:</h4>
<p>I'm not able to reproduce this random dying thing. If you hover over the first error, namely <code>f₁</code>, you see that it has this type:</p>
<div class="codehilite"><pre><span></span><code><span class="n">geometric_algebra</span><span class="bp">.</span><span class="n">f₁</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">)</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">field</span> <span class="n">G₀</span><span class="o">]</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">char_zero</span> <span class="n">G₀</span><span class="o">]</span> <span class="o">{</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_3</span><span class="o">}</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_3</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_4</span> <span class="o">:</span> <span class="n">vector_space</span> <span class="n">G₀</span> <span class="n">G₁</span><span class="o">]</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_5</span> <span class="o">:</span> <span class="n">ring</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_6</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">G₀</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">geometric_algebra</span> <span class="n">G</span> <span class="n">G₀</span> <span class="n">G₁</span><span class="o">],</span> <span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span>
</code></pre></div>


<p>In particular <code>f₁ a</code> will not work because <code>a</code> is supposed to be <code>G₀</code>, the first <code>()</code> input to <code>f₁</code></p>



<a name="200703305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200703305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200703305">(Jun 12 2020 at 18:00)</a>:</h4>
<p>If you would like <code>G₀</code> to be inferred by unification, then change <code>(G₀ : Type*)</code> to <code>{G₀ : Type*}</code> when you're setting up your variables.</p>



<a name="200703710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200703710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200703710">(Jun 12 2020 at 18:03)</a>:</h4>
<p>Your second error is because when Lean sees <code>f₁ G₀ a</code> it has to now guess all of the <code>{}</code> variables for <code>f₁</code> by unification, and it doesn't know how to guess <code>G</code>, so it just uses a metavariable, and then it has to prove that this metavariable is a ring because of <code>[ring G]</code>, so it gets stuck.</p>



<a name="200704362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200704362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200704362">(Jun 12 2020 at 18:07)</a>:</h4>
<p>Next problem: <code>sym_prod</code> expects an explicit <code>G</code> (look at the type) so the <code>*₊</code> notation won't work. </p>
<div class="codehilite"><pre><span></span><code><span class="n">include</span> <span class="n">GA</span> <span class="c1">-- you named it, so it doesn&#39;t get included automatically</span>
<span class="c1">-- and Lean cannot solve the problem you have left it regarding implicit variables so I</span>
<span class="c1">-- told it the solution explicitly</span>
<span class="kn">lemma</span> <span class="n">vec_sym_prod_scalar_typechecks</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">G₀</span><span class="o">,</span>
  <span class="n">sym_prod</span> <span class="n">G</span> <span class="o">(</span><span class="bp">@</span><span class="n">f₁</span> <span class="n">G</span> <span class="n">G₀</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">G₁</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">f₁</span> <span class="n">G</span> <span class="n">G₀</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">G₁</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">algebra_map</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">k</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">sorry</span>
</code></pre></div>



<a name="200704577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200704577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200704577">(Jun 12 2020 at 18:09)</a>:</h4>
<p>The problem is that if you're just telling <code>f\_1</code> that it's going to eat <code>a</code>, then it can figure out <code>G\_1</code>, but it can't figure out <code>G</code> or <code>G\_0</code> because even though we have <code>geometric_algebra G G₀ G₁</code> Lean thinks that maybe there could be some other instances <code>geometric_algebra H H₀ G₁</code> so it will refuse to guess G and G_0 from what you told it.</p>



<a name="200704745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200704745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200704745">(Jun 12 2020 at 18:10)</a>:</h4>
<p>One easy fix is to let f_1 also eat G and G_0. This sort of thing happens with algebras in Lean -- if A is an R-algebra then Lean never quite knows if A is an algebra for any other ring too, so many definitions and lemmas about R-algebras ask for R explicitly.</p>



<a name="200705995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200705995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200705995">(Jun 12 2020 at 18:20)</a>:</h4>
<p>You probably want to make G implicit in <code>sym_prod</code> and to make G and G_0 explicit in f_1. Maybe this?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>

<span class="n">class</span> <span class="n">geometric_algebra</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="c1">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>
<span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">G₀</span><span class="o">]</span> <span class="o">[</span><span class="n">char_zero</span> <span class="n">G₀</span><span class="o">]</span>
<span class="c1">-- Axiom 3: G contains a subset G1 closed under addition, and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>
<span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">G₀</span> <span class="n">G₁</span><span class="o">]</span>
<span class="c1">-- Axiom 1: G is a ring with unit.</span>
<span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">algebra</span> <span class="n">G₀</span> <span class="n">G</span><span class="o">]</span>
<span class="o">:=</span>
<span class="o">(</span><span class="n">f₁&#39;</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span><span class="o">)</span> <span class="c1">-- I added a prime because the binders are wrong</span>
<span class="c1">-- Axiom 4: The square of every vector is a scalar.</span>
<span class="o">(</span><span class="n">vec_sq_scalar</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">G₀</span><span class="o">,</span> <span class="n">f₁&#39;</span> <span class="n">v</span> <span class="bp">*</span> <span class="n">f₁&#39;</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">algebra_map</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">k</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">geometric_algebra</span>

<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">f₁&#39;</span> <span class="c1">-- G is implicit</span>
<span class="c1">-- let&#39;s fix those binders</span>
<span class="n">def</span> <span class="n">f₁</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="c1">-- explicit G</span>
  <span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">G₀</span><span class="o">]</span> <span class="o">[</span><span class="n">char_zero</span> <span class="n">G₀</span><span class="o">]</span> <span class="o">{</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">G₀</span> <span class="n">G₁</span><span class="o">]</span> <span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">G₀</span> <span class="n">G</span><span class="o">]</span>
  <span class="o">[</span><span class="n">geometric_algebra</span> <span class="n">G</span> <span class="n">G₀</span> <span class="n">G₁</span><span class="o">]</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">f₁&#39;</span> <span class="n">G</span> <span class="n">G₀</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">G₁</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span>

<span class="kn">section</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="c1">-- make it implicit</span>
<span class="c1">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>
<span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">G₀</span><span class="o">]</span> <span class="o">[</span><span class="n">char_zero</span> <span class="n">G₀</span><span class="o">]</span>
<span class="c1">-- Axiom 3: G contains a subset G1 closed under addition, and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>
<span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">G₀</span> <span class="n">G₁</span><span class="o">]</span>
<span class="c1">-- Axiom 1: G is a ring with unit.</span>
<span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">algebra</span> <span class="n">G₀</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">geometric_algebra</span> <span class="n">G</span> <span class="n">G₀</span> <span class="n">G₁</span><span class="o">]</span> <span class="c1">-- removing the name</span>

<span class="n">def</span> <span class="n">square</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span>

<span class="c1">-- implicit G for sym_prod</span>
<span class="n">def</span> <span class="n">sym_prod</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`*</span><span class="err">₊</span><span class="bp">`</span><span class="o">:</span><span class="mi">75</span> <span class="o">:=</span> <span class="n">sym_prod</span>

<span class="n">local</span> <span class="kn">postfix</span> <span class="bp">`</span><span class="err">²</span><span class="bp">`</span><span class="o">:</span><span class="mi">80</span> <span class="o">:=</span> <span class="n">square</span>

<span class="c1">-- now back to explicit G</span>
<span class="kn">variable</span> <span class="o">(</span><span class="n">G</span><span class="o">)</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">  Symmetrised product of two vectors must be a scalar</span>
<span class="cm">-/</span>
<span class="kn">lemma</span> <span class="n">vec_sym_prod_scalar_typechecks</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">G₀</span><span class="o">,</span>
  <span class="o">(</span><span class="n">f₁</span> <span class="n">G</span> <span class="n">G₀</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span><span class="err">₊</span> <span class="o">(</span><span class="n">f₁</span> <span class="n">G</span> <span class="n">G₀</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">algebra_map</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">k</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">sorry</span>

<span class="kn">end</span>

<span class="kn">end</span> <span class="n">geometric_algebra</span>
</code></pre></div>



<a name="200747637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200747637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200747637">(Jun 13 2020 at 03:54)</a>:</h4>
<p>Thanks for your detailed explanations on how Lean works , here's the further <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> to demonstrate what I need partially following your hints with many comments describing my motivation and goal here:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span><span class="bp">.</span><span class="n">hom</span>
<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">complex</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">u₀</span> <span class="n">u₁</span>

<span class="n">class</span> <span class="n">geometric_algebra</span>
<span class="c1">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>
<span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">G₀</span><span class="o">]</span>
<span class="c1">-- Axiom 3: G contains a subset G1 closed under addition, and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>
<span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">G₀</span> <span class="n">G₁</span><span class="o">]</span>
<span class="c1">-- Axiom 1: G is a ring with unit.</span>
<span class="c1">-- The additive identity is called 0 and the multiplicative identity is called 1.</span>
<span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">G₀</span> <span class="n">G</span><span class="o">]</span>
<span class="o">:=</span>
<span class="o">(</span><span class="n">f₁</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span><span class="o">)</span>
<span class="c1">-- Axiom 4: The square of every vector is a scalar.</span>
<span class="o">(</span><span class="n">vec_sq_scalar</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">G₀</span><span class="o">,</span> <span class="n">f₁</span> <span class="n">v</span> <span class="bp">*</span> <span class="n">f₁</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">algebra_map</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">k</span> <span class="o">)</span>

<span class="kn">namespace</span> <span class="n">geometric_algebra</span>

<span class="kn">section</span>

<span class="kn">variables</span>
<span class="o">{</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">G₀</span><span class="o">]</span>
<span class="o">{</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">G₀</span> <span class="n">G₁</span><span class="o">]</span>
<span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">G₀</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">geometric_algebra</span> <span class="n">G₀</span> <span class="n">G₁</span> <span class="n">G</span><span class="o">]</span>

<span class="n">def</span> <span class="n">square</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span>

<span class="n">def</span> <span class="n">sym_prod</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`*</span><span class="err">₊</span><span class="bp">`</span><span class="o">:</span><span class="mi">75</span> <span class="o">:=</span> <span class="n">sym_prod</span>

<span class="n">local</span> <span class="kn">postfix</span> <span class="bp">`</span><span class="err">²</span><span class="bp">`</span><span class="o">:</span><span class="mi">80</span> <span class="o">:=</span> <span class="n">square</span>

<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">f₁</span>

<span class="c1">-- implicit G₀</span>
<span class="n">def</span> <span class="n">f₁&#39;</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">f₁</span> <span class="n">G₀</span>

<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">f₁&#39;</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">f₁&#39; :</span>
<span class="cm">  Π {G₀ : Type u_4} [_inst_1 : field G₀]</span>
<span class="cm">  {G₁ : Type u_5} [_inst_2 : add_comm_group G₁] [_inst_3 : vector_space G₀ G₁]</span>
<span class="cm">  {G : Type u_6} [_inst_4 : ring G] [_inst_5 : algebra G₀ G]</span>
<span class="cm">  [_inst_6 : geometric_algebra G₀ G₁ G],</span>
<span class="cm">  G₁ →+ G</span>
<span class="cm">-/</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">  Symmetrised product of two vectors must be a scalar</span>
<span class="cm">-/</span>
<span class="kn">lemma</span> <span class="n">vec_sym_prod_scalar_works_but_not_ideal</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">G₀</span><span class="o">,</span>
  <span class="n">f₁</span> <span class="n">G₀</span> <span class="n">a</span> <span class="bp">*</span><span class="err">₊</span> <span class="n">f₁</span> <span class="n">G₀</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">algebra_map</span> <span class="n">G₀</span> <span class="n">G</span> <span class="n">k</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">sorry</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">OK, it seems Lean knows G₁ from a and b,</span>
<span class="cm">but requires explicit G₀ to know to which G f₁ belongs</span>
<span class="cm">-/</span>

<span class="kn">lemma</span> <span class="n">vec_sym_prod_scalar_works_inferred_as_much_as_possible</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">G₀</span><span class="o">,</span>
  <span class="n">f₁</span> <span class="n">G₀</span> <span class="n">a</span> <span class="bp">*</span><span class="err">₊</span> <span class="n">f₁</span> <span class="n">G₀</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">algebra_map</span> <span class="bp">_</span> <span class="n">G</span> <span class="n">k</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">sorry</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">The only thing can be inferred is the type of k from k</span>
<span class="cm">-/</span>

<span class="kn">lemma</span> <span class="n">vec_sym_prod_scalar_better_but_failed</span><span class="o">:</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">G₀</span><span class="o">,</span>
  <span class="n">f₁&#39;</span> <span class="n">a</span> <span class="bp">*</span><span class="err">₊</span> <span class="n">f₁&#39;</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">algebra_map</span> <span class="n">G₀</span> <span class="n">G</span> <span class="n">k</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">sorry</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">Here&#39;s why I &quot;think&quot; this should work:</span>
<span class="cm">- rhs fixed G₀ and G, a and b fixed G₁, Lean should know everything about f₁&#39;</span>
<span class="cm">- plus *₊ fixed G too</span>

<span class="cm">Note that now I&#39;ve made all parameters in f₁&#39; implicit</span>
<span class="cm">-/</span>

<span class="kn">lemma</span> <span class="n">vec_sym_prod_scalar_ideal_but_seems_impossble_in_lean</span><span class="o">:</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">G₀</span><span class="o">,</span>
  <span class="n">a</span> <span class="bp">*</span><span class="err">₊</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">k</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">sorry</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">Here&#39;s why I further &quot;think&quot; this should work:</span>
<span class="cm">- a and b fixed G₁</span>
<span class="cm">- *₊ fixed G</span>
<span class="cm">- G₀ can be inferred from [geometric_algebra G₀ G₁ G]</span>

<span class="cm">Here&#39;s why I want it:</span>

<span class="cm">It&#39;s closer to how it&#39;s stated in literature, without the hassle of homs</span>
<span class="cm">and I have to state more complicated theoerem that involves more +-*/exp</span>
<span class="cm">as in https://github.com/pygae/GAlgebra.jl/blob/master/test/runtests.jl#L321</span>

<span class="cm">Here&#39;s how I&#39;m so close to it:</span>

<span class="cm">If I relax →+ and demand [has_coe G₀ G], then I get to state it like:</span>

<span class="cm">lemma vec_sym_prod_scalar [geometric_algebra G K V] :</span>
<span class="cm">∀ (a b : V), ∃ k : K, a *₊ b = (k : G) := by sorry</span>

<span class="cm">as in https://github.com/pygae/lean-ga/blob/master/src/geometric_algebra/nursery/basic.lean#L98</span>
<span class="cm">-/</span>

<span class="kn">end</span>

<span class="kn">end</span> <span class="n">geometric_algebra</span>
</code></pre></div>



<a name="200748255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200748255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200748255">(Jun 13 2020 at 04:14)</a>:</h4>
<p>The crucial thing here is "even though we have geometric_algebra G G₀ G₁ Lean thinks that maybe there could be some other instances geometric_algebra H H₀ G₁ so it will refuse to guess G and G_0 from what you told it."</p>



<a name="200748267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200748267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200748267">(Jun 13 2020 at 04:15)</a>:</h4>
<p>Is there a way to force so, just locally?</p>



<a name="200748324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200748324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200748324">(Jun 13 2020 at 04:16)</a>:</h4>
<p>(sorry I change the order of  G₀ G₁ G to make it in an ascendant order like in algebra)</p>



<a name="200749160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200749160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200749160">(Jun 13 2020 at 04:46)</a>:</h4>
<p>The @ character can be used to tell lean you want to explicitly fill some implicit types in</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">vec_sym_prod_scalar_better_but_failed</span><span class="o">:</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">G₀</span><span class="o">,</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">f₁&#39;</span> <span class="n">G₀</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="n">a</span> <span class="bp">*</span><span class="err">₊</span> <span class="o">(</span><span class="bp">@</span><span class="n">f₁&#39;</span> <span class="n">G₀</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">algebra_map</span> <span class="n">G₀</span> <span class="n">G</span> <span class="n">k</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">sorry</span>
</code></pre></div>


<p>I think your logic that the right hand side of this fixes <code>G₀</code>  doesn't really follow, the type of the RHS is <code>G</code> and just because you used a particular <code>G₀</code> doesn't mean the LHS has to use the same one.<br>
P.s. the extra brackets I added aren't needed really.</p>



<a name="200749166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200749166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200749166">(Jun 13 2020 at 04:47)</a>:</h4>
<p>It seems that to achieve what I want, I have to redesign the whole thing from ground up.</p>
<p>Starting by giving G₁ a (not has_mul) multiplication that always return G but it's actually just G₀ or G₂, which in turn needs a grade projection operator first, and make G₁ not special and not in the parameters but generated from a projection. But in this case I'll have to use <code>G -&gt; set G</code> as the type of the grade projection, which I have been trying to avoid, because I want G₀  and G₁ to be a real type and not a type to Prop. And then from there I'll need to redefine <code>eq</code> as well, because eventually I'll need all 0 in G₀,  G₁,  G₂, ..., G etc. to equal and a G with only G₁ or G₂ components to equal to G₁ or G₂. I'll also need to state that G can be written as the infinite sum of G₀,  G₁,  G₂, ..., which might involve some cardinality stuff......</p>
<p>(This formalism is used in GA to GC by Hestenes and Sobczyk, I thought I could try something simpler first, but the simpler formalism seems to be making it more difficult in Lean)</p>
<p>(To make the discussion above easier to interpret, think G as another formalism to spell out Clifford Algebra (it seems to be not ready to be defined generally in mathlib yet as I've read on the Zulip, as well as Grassmann Algebra i.e. exterior algebra ).)</p>



<a name="200749218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200749218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200749218">(Jun 13 2020 at 04:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/200749160">said</a>:</p>
<blockquote>
<p>I think your logic that the right hand side of this fixes <code>G₀</code>  doesn't really follow, the type of the RHS is <code>G</code> and just because you used a particular <code>G₀</code> doesn't mean the LHS has to use the same one.</p>
</blockquote>
<p>Yes, I can see that now, but I'm wondering whether it's possible to specify so somehow.</p>



<a name="200749331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200749331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200749331">(Jun 13 2020 at 04:53)</a>:</h4>
<p>I haven't used it myself, but perhaps using <code>parameters</code> instead of <code>variables</code> in this file does what you want</p>



<a name="200749675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200749675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200749675">(Jun 13 2020 at 05:05)</a>:</h4>
<p>Oh silly me, I've confused them before and doing this again...Changing <code>variables</code> to <code>parameters</code> makes <code>vec_sym_prod_scalar_better_but_failed</code> work as expected! Thanks!</p>



<a name="200774586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200774586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200774586">(Jun 13 2020 at 16:43)</a>:</h4>
<p>Is there anyway to simply use <code>cc</code>after <code>rw h1</code>, by making it somehow see through homs? It's painful to move terms around step by step...</p>
<div class="codehilite"><pre><span></span><code>      <span class="k">begin</span>
        <span class="n">intros</span> <span class="n">hb</span> <span class="n">ha</span> <span class="n">hab</span><span class="o">,</span>
        <span class="c">/-</span><span class="cm"></span>
<span class="cm">          G₀ : Type u_1,</span>
<span class="cm">          _inst_1 : field G₀,</span>
<span class="cm">          G₁ : Type u_2,</span>
<span class="cm">          _inst_2 : add_comm_group G₁,</span>
<span class="cm">          _inst_3 : vector_space G₀ G₁,</span>
<span class="cm">          G : Type u_3,</span>
<span class="cm">          _inst_4 : ring G,</span>
<span class="cm">          _inst_5 : algebra G₀ G,</span>
<span class="cm">          _inst_6 : geometric_algebra G₀ G₁ G,</span>
<span class="cm">          a b : G₁,</span>
<span class="cm">          h1 : (a + b)²ᵥ = a²ᵥ + b²ᵥ + a*₊ᵥ b,</span>
<span class="cm">          vec_sq_scalar : ∀ (v : G₁), ∃ (k : G₀), v²ᵥ = ⇑fₛ k,</span>
<span class="cm">          kab ka kb : G₀,</span>
<span class="cm">          hb : b²ᵥ = ⇑fₛ kb,</span>
<span class="cm">          ha : a²ᵥ = ⇑fₛ ka,</span>
<span class="cm">          hab : (a + b)²ᵥ = ⇑fₛ kab</span>
<span class="cm">          ⊢ ∃ (k : G₀), a*₊ᵥ b = ⇑fₛ k</span>
<span class="cm">        -/</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">hb</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hab</span><span class="o">]</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
        <span class="n">use</span> <span class="o">(</span><span class="bp">-</span><span class="n">ka</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="bp">-</span><span class="n">kb</span><span class="o">)</span> <span class="bp">+</span> <span class="n">kab</span><span class="o">,</span>
        <span class="c1">-- a*₊ᵥ b = ⇑fₛ (-ka - kb + kab)</span>
        <span class="n">rw</span> <span class="n">ring_hom</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">h1</span><span class="o">,</span>
        <span class="c1">-- a*₊ᵥ b = ⇑fₛ (-ka + -kb) + (⇑fₛ ka + ⇑fₛ kb + a*₊ᵥ b)</span>
        <span class="n">rw</span> <span class="err">←</span><span class="n">add_assoc</span><span class="o">,</span>
        <span class="c1">-- a*₊ᵥ b = ⇑fₛ (-ka + -kb) + (⇑fₛ ka + ⇑fₛ kb) + a*₊ᵥ b</span>
        <span class="n">rw</span> <span class="err">←</span><span class="n">add_assoc</span><span class="o">,</span>
        <span class="c1">-- a*₊ᵥ b = ⇑fₛ (-ka + -kb) + ⇑fₛ ka + ⇑fₛ kb + a*₊ᵥ b</span>
        <span class="n">rw</span> <span class="err">←</span><span class="n">ring_hom</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span>
        <span class="c1">-- a*₊ᵥ b = ⇑fₛ (-ka + -kb + ka) + ⇑fₛ kb + a*₊ᵥ b</span>
        <span class="n">rw</span> <span class="err">←</span><span class="n">ring_hom</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span>
        <span class="c1">-- a*₊ᵥ b = ⇑fₛ (-ka + -kb + ka + kb) + a*₊ᵥ b</span>
        <span class="n">rw</span> <span class="n">add_comm</span> <span class="o">(</span><span class="bp">-</span><span class="n">ka</span><span class="o">)</span> <span class="o">(</span><span class="bp">-</span><span class="n">kb</span><span class="o">),</span>
        <span class="c1">-- a*₊ᵥ b = ⇑fₛ (-kb + -ka + ka + kb) + a*₊ᵥ b</span>
        <span class="n">rw</span> <span class="n">add_assoc</span> <span class="o">(</span><span class="bp">-</span><span class="n">kb</span><span class="o">)</span> <span class="o">(</span><span class="bp">-</span><span class="n">ka</span><span class="o">)</span> <span class="n">ka</span><span class="o">,</span>
        <span class="c1">-- a*₊ᵥ b = ⇑fₛ (-kb + (-ka + ka) + kb) + a*₊ᵥ b</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">add_zero</span><span class="o">,</span> <span class="n">ring_hom</span><span class="bp">.</span><span class="n">map_zero</span><span class="o">,</span> <span class="n">add_left_neg</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">],</span>
      <span class="kn">end</span>
</code></pre></div>


<p>(Full working code is too long to paste in here, it's at <a href="https://github.com/pygae/lean-ga/blob/1d589406ffbed0e00bafff18bf1466689ea8b4b8/src/geometric_algebra/nursery/chisolm.lean#L97">https://github.com/pygae/lean-ga/blob/1d589406ffbed0e00bafff18bf1466689ea8b4b8/src/geometric_algebra/nursery/chisolm.lean#L97</a> )</p>



<a name="200777359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/200777359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#200777359">(Jun 13 2020 at 17:51)</a>:</h4>
<p>After <code>use (-ka) + (-kb) + kab,</code> you can do <code>simp [fₛ.map_add, h1]</code>, which immediately reduces your goal to</p>
<div class="codehilite"><pre><span></span><code><span class="err">⊢</span> <span class="n">a</span><span class="bp">*</span><span class="err">₊ᵥ</span> <span class="n">b</span> <span class="bp">=</span> <span class="bp">-</span><span class="err">⇑</span><span class="n">fₛ</span> <span class="n">ka</span> <span class="bp">+</span> <span class="bp">-</span><span class="err">⇑</span><span class="n">fₛ</span> <span class="n">kb</span> <span class="bp">+</span> <span class="o">(</span><span class="err">⇑</span><span class="n">fₛ</span> <span class="n">ka</span> <span class="bp">+</span> <span class="err">⇑</span><span class="n">fₛ</span> <span class="n">kb</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="err">₊ᵥ</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>


<p>and then the <code>abel</code> tactic finishes the job.</p>
<div class="codehilite"><pre><span></span><code>        <span class="n">rw</span> <span class="o">[</span><span class="n">hb</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hab</span><span class="o">]</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
        <span class="n">use</span> <span class="o">(</span><span class="bp">-</span><span class="n">ka</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="bp">-</span><span class="n">kb</span><span class="o">)</span> <span class="bp">+</span> <span class="n">kab</span><span class="o">,</span>
        <span class="c1">-- a*₊ᵥ b = ⇑fₛ (-ka - kb + kab)</span>
        <span class="n">simp</span> <span class="o">[</span><span class="n">fₛ</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span> <span class="n">h1</span><span class="o">],</span>
        <span class="n">abel</span><span class="o">,</span>
</code></pre></div>



<a name="202333834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202333834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202333834">(Jun 29 2020 at 16:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/200749331">said</a>:</p>
<blockquote>
<p>I haven't used it myself, but perhaps using <code>parameters</code> instead of <code>variables</code> in this file does what you want</p>
</blockquote>
<p>But <code>parameters</code> is being removed in lean 4, right? So what should we do here instead?</p>



<a name="202335163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202335163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202335163">(Jun 29 2020 at 16:31)</a>:</h4>
<p>Well if the problem you're trying to solve is, "I have a bunch of variables, and every def/lemma/theorem in the theory I'm writing takes all of them as input and I don't want to write them all the time (i.e. some ambient space / ring you are working in with some properties)" then I think the solution is to bundle everything you need into a structure that holds all these assumptions and use a single variable of type that structure and use that as input to every lemma etc.</p>



<a name="202335221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202335221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202335221">(Jun 29 2020 at 16:31)</a>:</h4>
<p>Or just don't worry about what Lean 4 may or may not do.</p>



<a name="202335718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202335718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202335718">(Jun 29 2020 at 16:35)</a>:</h4>
<p>Well in this case I run into the same problem using <code>variables</code> as I do trying to move my parameters to separate files</p>



<a name="202335885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202335885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202335885">(Jun 29 2020 at 16:36)</a>:</h4>
<p>Can you give an example of what you mean?</p>



<a name="202335900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202335900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202335900">(Jun 29 2020 at 16:36)</a>:</h4>
<p>I'm trying to</p>



<a name="202336406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202336406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202336406">(Jun 29 2020 at 16:40)</a>:</h4>
<p>Here's a fairly minimal example:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span><span class="bp">.</span><span class="n">hom</span>
<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>

<span class="n">class</span> <span class="n">geometric_algebra</span>
<span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">G₀</span><span class="o">]</span>
<span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span>
<span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span>
<span class="o">:=</span>
<span class="o">(</span><span class="n">f₁</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">geometric_algebra</span>
<span class="kn">section</span>

<span class="c">/-</span><span class="cm"> doesn&#39;t work if `variables` instead -/</span>
<span class="kn">parameters</span>
<span class="o">{</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">G₀</span><span class="o">]</span>
<span class="o">{</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span>
<span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">geometric_algebra</span> <span class="n">G₀</span> <span class="n">G₁</span> <span class="n">G</span><span class="o">]</span>

<span class="n">def</span> <span class="n">f</span><span class="err">ᵥ</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">f₁</span> <span class="n">G₀</span>
<span class="n">def</span> <span class="n">prod_vec</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">f</span><span class="err">ᵥ</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">f</span><span class="err">ᵥ</span> <span class="n">b</span>

<span class="kn">end</span>

<span class="kn">end</span> <span class="n">geometric_algebra</span>
</code></pre></div>


<p>As is, this has no errors.</p>
<p>If I change <code>parameters</code> to <code>variables</code>, then <code>prod_vec</code> doesn't "know how to synthesize placeholder" at <code>fᵥ</code>.</p>



<a name="202336520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202336520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202336520">(Jun 29 2020 at 16:41)</a>:</h4>
<p>But I if leave it with <code>parameters</code>, then I have the same problem attempting to use <code>fᵥ</code> from another file.</p>



<a name="202336762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202336762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202336762">(Jun 29 2020 at 16:43)</a>:</h4>
<p>The problem from the beginning is that I put too many things in parameters, which should probably be bundled into the class.</p>



<a name="202337152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202337152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202337152">(Jun 29 2020 at 16:46)</a>:</h4>
<p>But still, I'm very confused about the subtle differences between parameters and variables and the idiomatic ways to use them.</p>



<a name="202337216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202337216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202337216">(Jun 29 2020 at 16:47)</a>:</h4>
<p>As demonstrated in the <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> above</p>



<a name="202337235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202337235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202337235">(Jun 29 2020 at 16:47)</a>:</h4>
<p>idiomatic in the sense of mathlib is "don't use parameters"</p>



<a name="202337264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202337264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202337264">(Jun 29 2020 at 16:47)</a>:</h4>
<p>But I'm not a mathlib dictator!</p>



<a name="202337291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202337291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202337291">(Jun 29 2020 at 16:47)</a>:</h4>
<p>So feel free to use them. I've just never used them myself.</p>



<a name="202337342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202337342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202337342">(Jun 29 2020 at 16:48)</a>:</h4>
<p>then how to use variables to achieve similar purpose?</p>



<a name="202337374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202337374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202337374">(Jun 29 2020 at 16:48)</a>:</h4>
<p>I'm seeing the argument against using <code>parameters</code> since I've been trying to split a section in two, but I can't work out an alternative spelling of the above without <code>parameters</code> that doesn't need a gazillion <code>_</code> placeholders</p>



<a name="202337390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202337390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202337390">(Jun 29 2020 at 16:48)</a>:</h4>
<p>I wish to avoid relying on something not recommended by mathlib</p>



<a name="202337573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202337573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202337573">(Jun 29 2020 at 16:50)</a>:</h4>
<p>I think making <code>G</code> implicit in <code>fᵥ</code> is a bit strange. The issue is that when you write <code>fᵥ a</code> , Lean can't tell what <code>G</code> should be.</p>



<a name="202337662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202337662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202337662">(Jun 29 2020 at 16:51)</a>:</h4>
<p>Changing to <code>def fᵥ (G : Type*) : G₁ →+ G := f₁ G₀</code> in the example above results in an error at <code>→+</code></p>



<a name="202337796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202337796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202337796">(Jun 29 2020 at 16:51)</a>:</h4>
<p>The end goal is even to remove the need of fv...</p>



<a name="202337943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202337943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202337943">(Jun 29 2020 at 16:52)</a>:</h4>
<p>since they're not in the original math</p>



<a name="202338033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202338033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202338033">(Jun 29 2020 at 16:53)</a>:</h4>
<p>the arithmetic just works across "types"</p>



<a name="202338076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202338076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202338076">(Jun 29 2020 at 16:54)</a>:</h4>
<p>I'd still like to understand how to write the <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> above, even if we don't end up needing it</p>



<a name="202338155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202338155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202338155">(Jun 29 2020 at 16:54)</a>:</h4>
<p>yeah</p>



<a name="202340071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202340071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202340071">(Jun 29 2020 at 17:08)</a>:</h4>
<p>Oh, I was wrong. The issue wasn't with <code>G</code> being implicit, but with <code>G₀</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span><span class="bp">.</span><span class="n">hom</span>
<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>

<span class="n">class</span> <span class="n">geometric_algebra</span>
<span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">G₀</span><span class="o">]</span>
<span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span>
<span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span>
<span class="o">:=</span>
<span class="o">(</span><span class="n">f₁</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">geometric_algebra</span>
<span class="kn">section</span>

<span class="kn">variables</span>
<span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">G₀</span><span class="o">]</span> <span class="c1">-- I made G₀ explicit here</span>
<span class="o">{</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span>
<span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">geometric_algebra</span> <span class="n">G₀</span> <span class="n">G₁</span> <span class="n">G</span><span class="o">]</span>

<span class="n">def</span> <span class="n">f</span><span class="err">ᵥ</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">f₁</span> <span class="n">G₀</span>
<span class="n">def</span> <span class="n">prod_vec</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">G</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span><span class="err">ᵥ</span> <span class="n">G₀</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span><span class="err">ᵥ</span> <span class="n">G₀</span> <span class="n">b</span><span class="o">)</span>

<span class="kn">end</span>

<span class="kn">end</span> <span class="n">geometric_algebra</span>
</code></pre></div>



<a name="202340225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202340225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202340225">(Jun 29 2020 at 17:09)</a>:</h4>
<p>As Alex says, I get the feeling this would be easier with more bundling though.</p>



<a name="202340284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202340284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202340284">(Jun 29 2020 at 17:10)</a>:</h4>
<p>What do you mean by bundling in this case?</p>



<a name="202340454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202340454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202340454">(Jun 29 2020 at 17:11)</a>:</h4>
<p>Instead of:</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">geometric_algebra</span>
<span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">G₀</span><span class="o">]</span>
<span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span>
<span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span>
<span class="o">:=</span>
<span class="o">(</span><span class="n">f₁</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span><span class="o">)</span>
</code></pre></div>


<p>Something more like:</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">geometric_algebra</span>
<span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">:=</span>
<span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">field</span> <span class="n">G₀</span><span class="o">)</span>
<span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">acg</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">)</span>
<span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ring</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">f₁</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span><span class="o">)</span>
</code></pre></div>


<p>(I haven't tested the latter.)</p>



<a name="202340475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202340475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202340475">(Jun 29 2020 at 17:11)</a>:</h4>
<p>That was what I was about to ask</p>



<a name="202340597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202340597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202340597">(Jun 29 2020 at 17:12)</a>:</h4>
<p>That means the <code>field</code> and <code>add_comm_group</code> fields have to be provided explicitly though, right?</p>



<a name="202340644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202340644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202340644">(Jun 29 2020 at 17:12)</a>:</h4>
<p>They should only need to be provided once though when you create an instance of <code>geometric_algebra G</code>.</p>



<a name="202340701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202340701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202340701">(Jun 29 2020 at 17:13)</a>:</h4>
<p>There's a little more about bundled vs unbundled stuff in 4.1.1 of the <a href="https://arxiv.org/abs/1910.09336">mathlib paper</a>.</p>



<a name="202340736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202340736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202340736">(Jun 29 2020 at 17:13)</a>:</h4>
<p><code>by apply_instance</code> will supply the e.g. field instance if you're making an instance of the bundled structure</p>



<a name="202340759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202340759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202340759">(Jun 29 2020 at 17:13)</a>:</h4>
<p>I suppose we can make a helper <code>def</code> to obtain them automatically anyway?</p>



<a name="202340810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202340810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202340810">(Jun 29 2020 at 17:14)</a>:</h4>
<p><code>geometric_algebra.mk_from_instances</code> or something?</p>



<a name="202340900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202340900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202340900">(Jun 29 2020 at 17:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202340597">said</a>:</p>
<blockquote>
<p>That means the <code>field</code> and <code>add_comm_group</code> fields have to be provided explicitly though, right?</p>
</blockquote>
<p>You can also use <code>[]</code> for fields in a class.</p>



<a name="202341132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202341132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202341132">(Jun 29 2020 at 17:15)</a>:</h4>
<p>Right, so:</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">geometric_algebra</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">:=</span>
<span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">f</span> <span class="o">:</span> <span class="n">field</span> <span class="n">G₀</span><span class="o">]</span>
<span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ag</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span>
<span class="o">[</span><span class="n">r</span> <span class="o">:</span> <span class="n">ring</span> <span class="n">G</span><span class="o">]</span>
<span class="o">(</span><span class="n">f₁</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span><span class="o">)</span>
</code></pre></div>



<a name="202341277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202341277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202341277">(Jun 29 2020 at 17:16)</a>:</h4>
<p>Something in between would be to make the three types into arguments, but put all the other stuff in fields.</p>



<a name="202341344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202341344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202341344">(Jun 29 2020 at 17:17)</a>:</h4>
<p>Also, don't you need more functions, and injectivity assumptions?</p>



<a name="202341397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202341397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202341397">(Jun 29 2020 at 17:17)</a>:</h4>
<p>This becomes slightly painful because we have as a field that I removed, <code>(vec_sq_scalar : ∀ v : G₁, ∃ k : G₀, f₁ v * f₁ v = algebra_map _ _ k )</code>, where <code>algebra_map</code> needs the <code>[]</code> arguments</p>



<a name="202341426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202341426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202341426">(Jun 29 2020 at 17:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202341344">said</a>:</p>
<blockquote>
<p>Also, don't you need more functions, and injectivity assumptions?</p>
</blockquote>
<p>Yes, I stripped them to get a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> of parameter woes</p>



<a name="202341475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202341475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202341475">(Jun 29 2020 at 17:18)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span> <span class="n">data</span><span class="bp">.</span><span class="n">complex</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="kn">structure</span> <span class="n">geometric_algebra</span>
<span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">:=</span>
<span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">f</span> <span class="o">:</span> <span class="n">field</span> <span class="n">G₀</span><span class="o">]</span>
<span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">acg</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span>
<span class="o">[</span><span class="n">r</span> <span class="o">:</span> <span class="n">ring</span> <span class="n">G</span><span class="o">]</span>
<span class="o">(</span><span class="n">f₁</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">geometric_algebra</span> <span class="n">ℂ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">G₀</span> <span class="o">:=</span> <span class="n">ℂ</span><span class="o">,</span>
  <span class="n">G₁</span> <span class="o">:=</span> <span class="n">ℂ</span><span class="o">,</span>
  <span class="n">f₁</span> <span class="o">:=</span> <span class="n">add_monoid_hom</span><span class="bp">.</span><span class="n">id</span> <span class="n">ℂ</span> <span class="o">}</span>
</code></pre></div>


<p>It should surely be a structure not a class if it's bundled this much. How many terms of type <code>geometric_algebra ℂ</code> might there be? Surely "more than one" is a reasonable answer. So structure not class.</p>



<a name="202341614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202341614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202341614">(Jun 29 2020 at 17:19)</a>:</h4>
<p>I think "exactly one" is a perfectly reasonable answer</p>



<a name="202341979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202341979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202341979">(Jun 29 2020 at 17:22)</a>:</h4>
<p><code>ℂ</code> is canonically <code>Cl(0, 1)</code>, I think -  a GA with a one-dimensional vector space, with the sole basis vector squaring to -1</p>



<a name="202342027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202342027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202342027">(Jun 29 2020 at 17:23)</a>:</h4>
<p>Now maybe I misunderstand the question "how many terms of the form ..."</p>



<a name="202342203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202342203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202342203">(Jun 29 2020 at 17:24)</a>:</h4>
<p>I don't know what a geometric algebra is... so I can't really help there. (I know Clifford algebras, and I think they are examples.)</p>



<a name="202342287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202342287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202342287">(Jun 29 2020 at 17:25)</a>:</h4>
<p>The reason <code>[group G]</code> is a class is that if <code>G</code> is a set/type/whatever you want to call it, then it is generally unlikely that you will want to put more than one group structure on <code>G</code> (i.e. two different multiplications).</p>



<a name="202342290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202342290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202342290">(Jun 29 2020 at 17:25)</a>:</h4>
<p>I was under the impression they were synonymous, but I may be mistaken</p>



<a name="202342326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202342326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202342326">(Jun 29 2020 at 17:25)</a>:</h4>
<p>So under normal circumstances, if <code>G</code> is a type then there will be at most one term of type <code>group G</code></p>



<a name="202342372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202342372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202342372">(Jun 29 2020 at 17:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202342290">said</a>:</p>
<blockquote>
<p>I was under the impression they were synonymous, but I may be mistaken</p>
</blockquote>
<p>Maybe! Like I said, I don't know what a geom alg is</p>



<a name="202342388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202342388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202342388">(Jun 29 2020 at 17:25)</a>:</h4>
<p>The type class inference system algorithm assumes that there will be at most one instance per class.</p>



<a name="202342450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202342450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202342450">(Jun 29 2020 at 17:26)</a>:</h4>
<p>Wikipedia says "Real Clifford algebras are also sometimes referred to as geometric algebras."</p>



<a name="202342742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202342742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202342742">(Jun 29 2020 at 17:27)</a>:</h4>
<p>If you decided to make a vector space structure and wrote</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">vector_space</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">k</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">all</span> <span class="n">the</span> <span class="kn">structure</span> <span class="n">of</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">space</span> <span class="n">on</span> <span class="n">V</span><span class="o">)</span>
</code></pre></div>


<p>then this would be bad, because a term of type <code>vector_space k</code> would be a vector space over K, and because it's a class, each field is allowed to have at most one vector space over it.</p>



<a name="202342758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202342758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202342758">(Jun 29 2020 at 17:28)</a>:</h4>
<p>I think I now see Kevin's point. ℂ can be thought of as either a 0-d clifford algebra over itself, or a 1d clifford algebra over the reals</p>



<a name="202342893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202342893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202342893">(Jun 29 2020 at 17:28)</a>:</h4>
<p>So at least <code>G₀</code> needs to be an argument too</p>



<a name="202342923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202342923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202342923">(Jun 29 2020 at 17:29)</a>:</h4>
<p>The question with</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">geometric_algebra</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">:=</span>
<span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">f</span> <span class="o">:</span> <span class="n">field</span> <span class="n">G₀</span><span class="o">]</span>
<span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ag</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span>
<span class="o">[</span><span class="n">r</span> <span class="o">:</span> <span class="n">ring</span> <span class="n">G</span><span class="o">]</span>
<span class="o">(</span><span class="n">f₁</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span><span class="o">)</span>
</code></pre></div>


<p>is nothing to do with what happens when G changes. It's precisely to do with what happens if the other stuff changes.</p>



<a name="202343012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202343012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202343012">(Jun 29 2020 at 17:29)</a>:</h4>
<p>If you want more than one G_0 for a given G then you must make it a structure not a class.</p>



<a name="202343054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202343054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202343054">(Jun 29 2020 at 17:29)</a>:</h4>
<p>Or a class taking two arguments?</p>



<a name="202343060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202343060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202343060">(Jun 29 2020 at 17:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202342893">said</a>:</p>
<blockquote>
<p>So at least <code>G₀</code> needs to be an argument too</p>
</blockquote>
<p>No. Not if you make it a structure</p>



<a name="202343142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202343142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202343142">(Jun 29 2020 at 17:30)</a>:</h4>
<p>This is a design decision. You can make whatever you like an input or a structure field.</p>



<a name="202343182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202343182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202343182">(Jun 29 2020 at 17:30)</a>:</h4>
<p>My only point was simply that <code>class</code> means that you expect at most one instance, and <code>structure</code> means you are allowed as many as you like.</p>



<a name="202343278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202343278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202343278">(Jun 29 2020 at 17:31)</a>:</h4>
<p>but which mathematical object corresponds to "instance" depends on what you make as structure fields and what you make as inputs. The answer changes.</p>



<a name="202343328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202343328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202343328">(Jun 29 2020 at 17:32)</a>:</h4>
<p>All makes sense, thanks.</p>



<a name="202343476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202343476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202343476">(Jun 29 2020 at 17:33)</a>:</h4>
<p>I suppose the question now is whether I expect <code>G₀</code> to uniquely parameterize a geometric algebra <code>G</code>, or if there's a situation I haven't thought of where multiple choices of <code>G₁</code> are available</p>



<a name="202343547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202343547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202343547">(Jun 29 2020 at 17:33)</a>:</h4>
<p>If you want help with that decision, please write down 3 examples for me.</p>



<a name="202343639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202343639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202343639">(Jun 29 2020 at 17:34)</a>:</h4>
<p>Yes, the definition is completely confusing</p>



<a name="202343651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202343651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202343651">(Jun 29 2020 at 17:34)</a>:</h4>
<p>(in its current state, where G_0 plays no role at all)</p>



<a name="202343652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202343652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202343652">(Jun 29 2020 at 17:34)</a>:</h4>
<p>for a given G, there's only one G0</p>



<a name="202343704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202343704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202343704">(Jun 29 2020 at 17:35)</a>:</h4>
<p>Not if we generalize to the clifford algebras I think...</p>



<a name="202343767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202343767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202343767">(Jun 29 2020 at 17:35)</a>:</h4>
<p>it's still the same</p>



<a name="202343832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202343832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202343832">(Jun 29 2020 at 17:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202343639">said</a>:</p>
<blockquote>
<p>Yes, the definition is completely confusing</p>
</blockquote>
<p>That's because the one I post above was the minimum definition that showed a language difficulty, not a mathematically meaningful statement!</p>



<a name="202343886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202343886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202343886">(Jun 29 2020 at 17:36)</a>:</h4>
<p>Can you write down the definition in maths?</p>



<a name="202343890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202343890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202343890">(Jun 29 2020 at 17:36)</a>:</h4>
<p>Or link to one?</p>



<a name="202343901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202343901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202343901">(Jun 29 2020 at 17:36)</a>:</h4>
<blockquote>
<p>That's because the one I post above was the minimum definition that showed a language difficulty, not a mathematically meaningful statement!</p>
</blockquote>
<p>Yes, I know :-) That's why Johan just wants to see some examples. Then we'll get the hang of it.</p>



<a name="202343979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202343979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202343979">(Jun 29 2020 at 17:37)</a>:</h4>
<p>I can give the paper that <span class="user-mention" data-user-id="296911">@Utensil Song</span> started our formalization from: <a href="https://arxiv.org/abs/1205.5935">https://arxiv.org/abs/1205.5935</a></p>



<a name="202344001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202344001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202344001">(Jun 29 2020 at 17:37)</a>:</h4>
<p>I would rather see three examples of G, G_0 and G_1</p>



<a name="202344053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202344053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202344053">(Jun 29 2020 at 17:38)</a>:</h4>
<p>Ah, ok, got it</p>



<a name="202344164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202344164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202344164">(Jun 29 2020 at 17:39)</a>:</h4>
<p>The definition on wiki is vague and incomplete as far as I can tell</p>



<a name="202344213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202344213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202344213">(Jun 29 2020 at 17:39)</a>:</h4>
<p>Just some dumb examples</p>



<a name="202344292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202344292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202344292">(Jun 29 2020 at 17:40)</a>:</h4>
<p>Discussing offline with utensil to try and find some we agree on :)</p>



<a name="202344408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202344408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202344408">(Jun 29 2020 at 17:41)</a>:</h4>
<p>Hmm, from page 10 onwards in that link there is a pretty precise definition.</p>



<a name="202344421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202344421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202344421">(Jun 29 2020 at 17:41)</a>:</h4>
<p>However, there is a tonne of structure there.</p>



<a name="202344458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202344458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202344458">(Jun 29 2020 at 17:41)</a>:</h4>
<p>There will be some nontrivial design decisions here</p>



<a name="202344529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202344529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202344529">(Jun 29 2020 at 17:42)</a>:</h4>
<p>My intuition is: add all the structure into the definition, and ask for lots of compatibilities.</p>



<a name="202344563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202344563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202344563">(Jun 29 2020 at 17:42)</a>:</h4>
<p>What do you mean by "compatibilities"?</p>



<a name="202344572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202344572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202344572">(Jun 29 2020 at 17:42)</a>:</h4>
<p>Then build custom constructors that take less data, and generate the remaining structure (because there will be apparent redundancy in the definition)</p>



<a name="202344609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202344609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202344609">(Jun 29 2020 at 17:43)</a>:</h4>
<p>oh this is high-level structure making tips!</p>



<a name="202344685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202344685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202344685">(Jun 29 2020 at 17:43)</a>:</h4>
<p>Example: the inner product follows from other pieces of data, but you might want to explicitly include it in the definition, and then say that the inner product that you include is the same as the one built from the other pieces.</p>



<a name="202344765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202344765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202344765">(Jun 29 2020 at 17:44)</a>:</h4>
<p>The reason you want this redundancy is that it will give you flexibility in definitional equalities later on.</p>



<a name="202344797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202344797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202344797">(Jun 29 2020 at 17:44)</a>:</h4>
<p><a href="https://stackedit.io/viewer#!url=https://raw.githubusercontent.com/pygae/lean-ga/master/docs/misc/many_faces.md">https://stackedit.io/viewer#!url=https://raw.githubusercontent.com/pygae/lean-ga/master/docs/misc/many_faces.md</a> is an incomplete work-in-progress math description of the definition problem here.</p>



<a name="202344833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202344833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202344833">(Jun 29 2020 at 17:45)</a>:</h4>
<p>Like <code>&lt;</code> can be deduced from <code>&lt;=</code> in a partial order, but there's an axiom saying <code>a &lt; b ↔ a ≤ b ∧ ¬b ≤ a</code></p>



<a name="202344963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202344963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202344963">(Jun 29 2020 at 17:46)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>, is there an example of that approach I can look at in mathlib?</p>



<a name="202344991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202344991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202344991">(Jun 29 2020 at 17:46)</a>:</h4>
<p>Yes, <code>metric_space</code> is a classical example</p>



<a name="202345013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345013">(Jun 29 2020 at 17:46)</a>:</h4>
<p>It takes a topology, even though that's completely redundant. But...</p>



<a name="202345029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345029">(Jun 29 2020 at 17:46)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/metric_space">docs#metric_space</a></p>



<a name="202345030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345030">(Jun 29 2020 at 17:46)</a>:</h4>
<p>It takes a uniform structure now, I think</p>



<a name="202345072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345072">(Jun 29 2020 at 17:47)</a>:</h4>
<p>The product topology on the product of two metric spaces is not <em>definitionally</em> the same as the metric topology on the product.</p>



<a name="202345086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345086">(Jun 29 2020 at 17:47)</a>:</h4>
<p>It is a theorem that they are the same. And this theorem is now part of the definition</p>



<a name="202345117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345117">(Jun 29 2020 at 17:47)</a>:</h4>
<p>But there is a constructor that will ignore the topology and just generate it from the metric.</p>



<a name="202345166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345166">(Jun 29 2020 at 17:48)</a>:</h4>
<p>What is that constructor?</p>



<a name="202345174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345174">(Jun 29 2020 at 17:48)</a>:</h4>
<p>This is rather advanced structure-making.</p>



<a name="202345190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345190">(Jun 29 2020 at 17:48)</a>:</h4>
<p>But for the product metric/topology, you don't want to use that constructor!</p>



<a name="202345220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345220">(Jun 29 2020 at 17:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202345174">said</a>:</p>
<blockquote>
<p>This is rather advanced structure-making.</p>
</blockquote>
<p>Yup, but the example at hand (geometric algebra) seems quite a complex thing.</p>



<a name="202345266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345266">(Jun 29 2020 at 17:49)</a>:</h4>
<p>But I suspect that non-defeq diamonds are right now the least of their worries. We still don't even know if it's a structure or a class.</p>



<a name="202345315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345315">(Jun 29 2020 at 17:49)</a>:</h4>
<p>Looks like <a href="https://leanprover-community.github.io/mathlib_docs/notes.html#forgetful%20inheritance">https://leanprover-community.github.io/mathlib_docs/notes.html#forgetful%20inheritance</a> is related to this conversation?</p>



<a name="202345448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345448">(Jun 29 2020 at 17:50)</a>:</h4>
<p>But we can't even think about forgetful inheritence issues until we have decided what is an input and what is a structure field.</p>



<a name="202345548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345548">(Jun 29 2020 at 17:51)</a>:</h4>
<p><a href="/user_uploads/3121/Kcz5lPFQH2CVU-H7cwEdFEHi/IMG_1517.PNG">IMG_1517.PNG</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/Kcz5lPFQH2CVU-H7cwEdFEHi/IMG_1517.PNG" title="IMG_1517.PNG"><img src="/user_uploads/3121/Kcz5lPFQH2CVU-H7cwEdFEHi/IMG_1517.PNG"></a></div>



<a name="202345620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345620">(Jun 29 2020 at 17:52)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> <a href="https://github.com/leanprover-community/mathlib/blob/eb05a94/src/topology/metric_space/basic.lean#L71">https://github.com/leanprover-community/mathlib/blob/eb05a94/src/topology/metric_space/basic.lean#L71</a><br>
I was wrong, it's not a seperate constructor, but a default argument.</p>



<a name="202345668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345668">(Jun 29 2020 at 17:52)</a>:</h4>
<p>the current design is that it's a class</p>



<a name="202345671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345671">(Jun 29 2020 at 17:52)</a>:</h4>
<p>So for R R^1 C which is G, G_0, G_1?</p>



<a name="202345729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345729">(Jun 29 2020 at 17:53)</a>:</h4>
<p>Order is specified as <code>G_0 G_1 G</code></p>



<a name="202345758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345758">(Jun 29 2020 at 17:53)</a>:</h4>
<p>so if R R^1 C and C C C are both Ok, you can't have a class and just make G an input</p>



<a name="202345846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345846">(Jun 29 2020 at 17:54)</a>:</h4>
<p>Correct, but we can have a class and make both G_0 and G an input</p>



<a name="202345871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345871">(Jun 29 2020 at 17:54)</a>:</h4>
<p>The instended design is geometric_algebra R R^1 G(0, 1)</p>



<a name="202345898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345898">(Jun 29 2020 at 17:54)</a>:</h4>
<p>not R R C</p>



<a name="202345907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345907">(Jun 29 2020 at 17:55)</a>:</h4>
<p>What is G(0,1)?</p>



<a name="202345945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345945">(Jun 29 2020 at 17:55)</a>:</h4>
<p>The geometric algebra with 0 basis vectors with length 1 and 1 basis vector with length -1</p>



<a name="202345969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202345969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202345969">(Jun 29 2020 at 17:55)</a>:</h4>
<p>Unfortunately that definition is circular</p>



<a name="202346000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346000">(Jun 29 2020 at 17:55)</a>:</h4>
<p>Is G determined by G_0 and G_1?</p>



<a name="202346078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346078">(Jun 29 2020 at 17:56)</a>:</h4>
<p>I think the answer is probably yes.</p>



<a name="202346104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346104">(Jun 29 2020 at 17:56)</a>:</h4>
<p>Is there a reason you're asking for it at all?</p>



<a name="202346145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346145">(Jun 29 2020 at 17:56)</a>:</h4>
<p>I suggest also reading the story in §6.1 of <a href="https://arxiv.org/pdf/1910.12320.pdf">https://arxiv.org/pdf/1910.12320.pdf</a></p>



<a name="202346186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346186">(Jun 29 2020 at 17:57)</a>:</h4>
<p>Wait, G can be any implementation of that though right?</p>



<a name="202346203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346203">(Jun 29 2020 at 17:57)</a>:</h4>
<p>About how we approached valuations and especially the target type.</p>



<a name="202346241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346241">(Jun 29 2020 at 17:57)</a>:</h4>
<p>We made a lot of design decisions which turned out to be bad</p>



<a name="202346269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346269">(Jun 29 2020 at 17:57)</a>:</h4>
<p><span class="user-mention" data-user-id="296911">@Utensil Song</span> This <code>G(0,1)</code> looks fishy.</p>



<a name="202346274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346274">(Jun 29 2020 at 17:57)</a>:</h4>
<p>but it was OK, because we learnt a lot</p>



<a name="202346352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346352">(Jun 29 2020 at 17:58)</a>:</h4>
<p>It's may work very well for the abstract theory, but it looks bad for application to examples.</p>



<a name="202346381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346381">(Jun 29 2020 at 17:58)</a>:</h4>
<p>The answer is no actually</p>



<a name="202346485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346485">(Jun 29 2020 at 17:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202346241">said</a>:</p>
<blockquote>
<p>We made a lot of design decisions which turned out to be bad</p>
</blockquote>
<p>Another example was that we gave a mathematically correct definition of "Huber pair" (whatever that may be), but the canonical example that every mathematician will give first (p-adic integers, p-adic numbers) could not be made into an <code>instance</code> with our definition.</p>



<a name="202346518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346518">(Jun 29 2020 at 17:59)</a>:</h4>
<p>We could prove lots of stuff though! But all abstract.</p>



<a name="202346522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346522">(Jun 29 2020 at 17:59)</a>:</h4>
<p>it's also determined by the signature p q r and the specific way to implement a geometric algebra</p>



<a name="202346603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346603">(Jun 29 2020 at 18:00)</a>:</h4>
<p>I will repeat, give me an example.</p>



<a name="202346616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346616">(Jun 29 2020 at 18:00)</a>:</h4>
<p>The signature pqr is embedded in the <code>G_1</code> argument</p>



<a name="202346642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346642">(Jun 29 2020 at 18:00)</a>:</h4>
<p>Is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi><mo separator="true">,</mo><mi mathvariant="double-struck">R</mi><mo separator="true">,</mo><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}, \mathbb{R}, \mathbb{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.88333em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathbb">R</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathbb">R</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathbb">C</span></span></span></span></span> an example?</p>



<a name="202346646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346646">(Jun 29 2020 at 18:00)</a>:</h4>
<p>sorry I'm typing on my phone in bed...</p>



<a name="202346734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346734">(Jun 29 2020 at 18:01)</a>:</h4>
<p>I think all(?) examples are given by G = the Clifford algebra of a vector space V over a field k equipped with a quadratic form, G_0 = k, G_1 = V.</p>



<a name="202346740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346740">(Jun 29 2020 at 18:01)</a>:</h4>
<p>If that helps.</p>



<a name="202346768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346768">(Jun 29 2020 at 18:01)</a>:</h4>
<p>And obviously up to isomorphism.</p>



<a name="202346781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346781">(Jun 29 2020 at 18:01)</a>:</h4>
<p>will type examples out tmr</p>



<a name="202346790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346790">(Jun 29 2020 at 18:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202346768">said</a>:</p>
<blockquote>
<p>And obviously up to isomorphism.</p>
</blockquote>
<p>That's exactly my point.</p>



<a name="202346819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346819">(Jun 29 2020 at 18:01)</a>:</h4>
<p>You want a definition that also applies to objects isomorphic to that.</p>



<a name="202346991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202346991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202346991">(Jun 29 2020 at 18:03)</a>:</h4>
<p><a href="/user_uploads/3121/QudJk_fs8uprDxGkMWt0U-Ex/IMG_1518.PNG">IMG_1518.PNG</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/QudJk_fs8uprDxGkMWt0U-Ex/IMG_1518.PNG" title="IMG_1518.PNG"><img src="/user_uploads/3121/QudJk_fs8uprDxGkMWt0U-Ex/IMG_1518.PNG"></a></div>



<a name="202347072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202347072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202347072">(Jun 29 2020 at 18:03)</a>:</h4>
<p>some examples (<code>G₀ G₁ G</code>) that utensil may or may not agree with:</p>
<p>Euclidean space: <code>ℝ ℝ³ some_implementation_of_g3_i_wish_to_register</code><br>
spacetime: <code>ℝ ℝ³,¹ some_implementation_of_sta_i_wish_to_register</code><br>
an embedding of the builtin complex numbers: <code>ℝ ℝ⁰,¹ ℂ</code><br>
a different embedding of the builtin complex numbers: <code>ℂ ℂ⁰ ℂ</code></p>



<a name="202347293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202347293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202347293">(Jun 29 2020 at 18:05)</a>:</h4>
<p>So your third type should <em>not</em> be some construction, but allow for arbitrary types.</p>



<a name="202347386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202347386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202347386">(Jun 29 2020 at 18:06)</a>:</h4>
<p><code>G</code> you mean - yes, just like the <code>M</code> argument to <code>vector_space</code> currently behaves</p>



<a name="202347519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202347519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202347519">(Jun 29 2020 at 18:07)</a>:</h4>
<p>And maybe <code>G</code> already has some inner product (from a different part of mathlib), so you don't want to construct the inner product, but take it as an argument. (Even though you might want to give a default argument that constructs it from other data.)</p>



<a name="202347583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202347583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202347583">(Jun 29 2020 at 18:08)</a>:</h4>
<p>The (vector) inner product comes from <code>G₁</code></p>



<a name="202347616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202347616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202347616">(Jun 29 2020 at 18:08)</a>:</h4>
<p>And maybe your <code>G</code> is already naturally graded into pieces <code>G_0</code>, <code>G_1</code>, ... <code>G_r</code> by another piece of mathlib, so you might want to take all the <code>G_r</code> as parameters as well</p>



<a name="202347630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202347630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202347630">(Jun 29 2020 at 18:08)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> your examples made it clear to me that we don't need G1 in the parameters</p>



<a name="202347650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202347650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202347650">(Jun 29 2020 at 18:08)</a>:</h4>
<p>Etc... (this is why I said there is so much data flying around in this definition.)</p>



<a name="202347709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202347709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202347709">(Jun 29 2020 at 18:09)</a>:</h4>
<p>That's funny <span class="user-mention" data-user-id="296911">@Utensil Song</span>, because it made clear to me that we do if we want the algebra to know about it's own metric</p>



<a name="202347814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202347814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202347814">(Jun 29 2020 at 18:10)</a>:</h4>
<p>it's actually in G already</p>



<a name="202347863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202347863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202347863">(Jun 29 2020 at 18:10)</a>:</h4>
<p>the quadratic form and other stuff...</p>



<a name="202348127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202348127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202348127">(Jun 29 2020 at 18:12)</a>:</h4>
<p>we are talking about two different designs</p>



<a name="202348130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202348130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202348130">(Jun 29 2020 at 18:13)</a>:</h4>
<p><span class="user-mention" data-user-id="296911">@Utensil Song</span> Again, I'll claim that's only true in maths, not in lean.</p>



<a name="202348144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202348144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202348144">(Jun 29 2020 at 18:13)</a>:</h4>
<p>Up to isomorphism, everything is fine.</p>



<a name="202348725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202348725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202348725">(Jun 29 2020 at 18:17)</a>:</h4>
<p>We won't have C R^n Gsth, right? <span class="user-mention" data-user-id="310045">@Eric Wieser</span></p>



<a name="202348761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202348761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202348761">(Jun 29 2020 at 18:17)</a>:</h4>
<p><span class="user-mention" data-user-id="296911">@Utensil Song</span> Is <code>ℂ ℂ⁰ ℂ</code> an example of a geometric algebra? How about <code>ℝ ℝ⁰,¹ ℂ</code>?</p>



<a name="202348861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202348861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202348861">(Jun 29 2020 at 18:18)</a>:</h4>
<p>not in the design I'm referring to</p>



<a name="202348915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202348915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202348915">(Jun 29 2020 at 18:19)</a>:</h4>
<p>Then I can't use your theorems in some interesting concrete examples <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span> <span aria-label="cry" class="emoji emoji-1f622" role="img" title="cry">:cry:</span></p>



<a name="202348925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202348925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202348925">(Jun 29 2020 at 18:19)</a>:</h4>
<p>C will be proven to be isomorphic to the G something later</p>



<a name="202348943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202348943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202348943">(Jun 29 2020 at 18:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="296911">Utensil Song</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202348725">said</a>:</p>
<blockquote>
<p>We won't have C R^n Gsth, right? <span class="user-mention silent" data-user-id="310045">Eric Wieser</span></p>
</blockquote>
<p>No, because there is no instance of  <code>vector_space C R^n</code></p>



<a name="202348974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202348974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202348974">(Jun 29 2020 at 18:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="296911">Utensil Song</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202348925">said</a>:</p>
<blockquote>
<p>C will be proven to be isomorphic to the G something later</p>
</blockquote>
<p>Lean doesn't like such isomorphisms. They are a royal pita.</p>



<a name="202349061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202349061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202349061">(Jun 29 2020 at 18:20)</a>:</h4>
<p>If you create a more flexible definition, your proofs will probably also benefit.</p>



<a name="202349117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202349117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202349117">(Jun 29 2020 at 18:20)</a>:</h4>
<p>That's why G1 should not be special and it's redundant in the parameter and it's just a bundled field</p>



<a name="202349469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202349469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202349469">(Jun 29 2020 at 18:23)</a>:</h4>
<p>Please read §6.1 of the perfectoid paper (linked above). It's not that long.</p>



<a name="202349541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202349541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202349541">(Jun 29 2020 at 18:24)</a>:</h4>
<p>Note that this was not a problem that we hit during our project. We were done, and we tried to get some juicy examples. That's when we hit the problem.</p>



<a name="202349585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202349585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202349585">(Jun 29 2020 at 18:24)</a>:</h4>
<p>We could easily write 1000s of lines of interesting theorems... but they were useless, because we couldn't apply them to concrete examples.</p>



<a name="202349624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202349624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202349624">(Jun 29 2020 at 18:25)</a>:</h4>
<p>So, the case I'm thinking of is one where I want extra constraints on the vector space for a proof, perhaps that the square of a vector is always positive. I suppose that can be written whether G1 is an argument or not though, as <code>[ga G0 G1 G] (h : ∀ g : G1, p g)</code> or <code>[h : ga G0 G] (h : ∀ g : h.G1, p g)</code></p>



<a name="202349632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202349632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202349632">(Jun 29 2020 at 18:25)</a>:</h4>
<p>consider the complex numbers as either:</p>
<ul>
<li>G(0, 1) over R</li>
<li>G(0, 0) over C</li>
</ul>



<a name="202349689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202349689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202349689">(Jun 29 2020 at 18:25)</a>:</h4>
<p><span class="user-mention" data-user-id="296911">@Utensil Song</span>  Lean disagrees. It only knows <code>complex</code>. That's it.</p>



<a name="202349700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202349700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202349700">(Jun 29 2020 at 18:25)</a>:</h4>
<p>I'm working on reading it <span class="user-mention" data-user-id="112680">@Johan Commelin</span>, my math background is pretty weak :)</p>



<a name="202349715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202349715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202349715">(Jun 29 2020 at 18:25)</a>:</h4>
<p>Lean is pretty stubborn. It will not change it's mind.</p>



<a name="202349718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202349718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202349718">(Jun 29 2020 at 18:25)</a>:</h4>
<p>we need both</p>



<a name="202349732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202349732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202349732">(Jun 29 2020 at 18:25)</a>:</h4>
<p>I agree that you need both.</p>



<a name="202349791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202349791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202349791">(Jun 29 2020 at 18:26)</a>:</h4>
<p>so it seems isomorphism is the way to go</p>



<a name="202349812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202349812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202349812">(Jun 29 2020 at 18:26)</a>:</h4>
<p>And since both are examples of <code>foobar : Type*</code>, you should include a <code>foobar : Type*</code> that abstracts over this.</p>



<a name="202349837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202349837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202349837">(Jun 29 2020 at 18:26)</a>:</h4>
<p>No, abstracting into types with axioms about that type. That's the way to go.</p>



<a name="202349863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202349863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202349863">(Jun 29 2020 at 18:26)</a>:</h4>
<p>(deleted)</p>



<a name="202349945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202349945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202349945">(Jun 29 2020 at 18:27)</a>:</h4>
<p>A Huber pair is a pair <code>(R, A)</code> where <code>R</code> is a subring of <code>A</code>. Except that in mathlib <code>Z_p</code> is not a subring of <code>Q_p</code>. There is an injective ring homomorphism.</p>



<a name="202349994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202349994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202349994">(Jun 29 2020 at 18:28)</a>:</h4>
<p>So we changed the definition of Huber pair to: a pair <code>(R, A)</code> with an injective ring homomorphism <code>R →+* A</code>.</p>



<a name="202350065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202350065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202350065">(Jun 29 2020 at 18:28)</a>:</h4>
<p>Mathematically an isomorphic definition, but it makes a big difference in lean.</p>



<a name="202350099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202350099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202350099">(Jun 29 2020 at 18:28)</a>:</h4>
<p>And guess what! Some proofs became easier!</p>



<a name="202350149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202350149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202350149">(Jun 29 2020 at 18:28)</a>:</h4>
<p>abstracting into types with axioms about that type. That's the way to go.</p>
<p>I see, this is it.</p>



<a name="202350293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202350293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202350293">(Jun 29 2020 at 18:29)</a>:</h4>
<p>So to be clear, you replace the requirement "is a subring of" with a field providing that homomorphism?</p>



<a name="202350307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202350307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202350307">(Jun 29 2020 at 18:30)</a>:</h4>
<p>And my impression from what I've read so far about geometric algebras, is that there are lot's of things that can be abstracted into types and functions, and there will be many compatibility axioms.</p>



<a name="202350424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202350424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202350424">(Jun 29 2020 at 18:30)</a>:</h4>
<p>yes</p>



<a name="202350479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202350479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202350479">(Jun 29 2020 at 18:30)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> Yes, replace <code>(A : Type*) (R : subring A)</code> with <code>(A : Type*) (R : Type*) (f : R →+* A) (hf : injective f)</code>.</p>



<a name="202350565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202350565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202350565">(Jun 29 2020 at 18:31)</a>:</h4>
<p>And then presumably provide a constructor that populates <code>f</code> and <code>hf</code> for you if you can show <code>R : subring A</code>?</p>



<a name="202350608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202350608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202350608">(Jun 29 2020 at 18:31)</a>:</h4>
<p>We didn't provide such a constructor, but you could do that.</p>



<a name="202350671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202350671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202350671">(Jun 29 2020 at 18:32)</a>:</h4>
<p>Did you find it would never have been useful?</p>



<a name="202350729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202350729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202350729">(Jun 29 2020 at 18:33)</a>:</h4>
<p>It seems like you're obliged to provide that constructor to prove the statements are mathematically isomorphic ;)</p>



<a name="202350779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202350779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202350779">(Jun 29 2020 at 18:33)</a>:</h4>
<p>so now we all agree C cant directly stand at the position of G, but a structure abstracted over it, right?</p>



<a name="202350883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202350883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202350883">(Jun 29 2020 at 18:34)</a>:</h4>
<p>I'm confused...</p>



<a name="202350900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202350900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202350900">(Jun 29 2020 at 18:34)</a>:</h4>
<p>At me or utensil, <span class="user-mention" data-user-id="112680">@Johan Commelin</span>?</p>



<a name="202350912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202350912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202350912">(Jun 29 2020 at 18:34)</a>:</h4>
<p>Utensil</p>



<a name="202350966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202350966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202350966">(Jun 29 2020 at 18:35)</a>:</h4>
<p>I would think that when you create examples, you do want to be able to plug <code>C</code> into some field at some point.</p>



<a name="202351000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202351000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202351000">(Jun 29 2020 at 18:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202350293">said</a>:</p>
<blockquote>
<p>So to be clear, you replace the requirement "is a subring of" with a field providing that homomorphism?</p>
</blockquote>
<p>In type theory there is no such thing as a subring, really. There is some construction called a subring. But if A -&gt; B is an injective ring homomorphism then that does not make A a subring of B, and indeed it would be impossible in general to make A a subring of B. A and B are just different types. The whole "sub" thing is dangerous.</p>



<a name="202351023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202351023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202351023">(Jun 29 2020 at 18:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202350671">said</a>:</p>
<blockquote>
<p>Did you find it would never have been useful?</p>
</blockquote>
<p>We just directly plugged in <code>R</code>, <code>subtype.val</code> and <code>subtype.val_injective</code>. It's so short that it didn't merit a new constructor.</p>



<a name="202351564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202351564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202351564">(Jun 29 2020 at 18:40)</a>:</h4>
<p>This has been lots of useful discussion for me, thanks everyone</p>



<a name="202351788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202351788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202351788">(Jun 29 2020 at 18:42)</a>:</h4>
<p>sorry since its 2:39am in my timezone, I'll get some sleep first. I'm pretty sure I can come up with a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> to demonstrate what's in my mind after the discussion above, with defs and juicy concrete examples.</p>



<a name="202351829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202351829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202351829">(Jun 29 2020 at 18:42)</a>:</h4>
<p>So clearly, if you start with <code>Q : V → K</code>, and you construct the Clifford algebra, then you want <code>Q</code>, <code>V</code> and <code>K</code> to be fields in the structure. Not isomorphic things.</p>



<a name="202351846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202351846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202351846">(Jun 29 2020 at 18:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="296911">Utensil Song</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202351788">said</a>:</p>
<blockquote>
<p>sorry since its 2:39am in my timezone, I'll get some sleep first. I'm pretty sure I can come up with a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> to demonstrate what's in my mind after the discussion above, with defs and juicy concrete examples.</p>
</blockquote>
<p>Sleep well! <span aria-label="sleeping" class="emoji emoji-1f634" role="img" title="sleeping">:sleeping:</span></p>



<a name="202351873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202351873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202351873">(Jun 29 2020 at 18:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202351000">said</a>:</p>
<blockquote>
<p>In type theory there is no such thing as a subring, really. There is some construction called a subring. But if A -&gt; B is an injective ring homomorphism then that does not make A a subring of B, and indeed it would be impossible in general to make A a subring of B. A and B are just different types. The whole "sub" thing is dangerous.</p>
</blockquote>
<p>Speaking for myself, this has been one of the harder things to wrap my head around in formalization. (I spent a bunch of time trying to figure out how to define and work with submatroids and I'm still stuck...) I hope that MiL has a lot of discussion about this.</p>



<a name="202351880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202351880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202351880">(Jun 29 2020 at 18:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202351829">said</a>:</p>
<blockquote>
<p>So clearly, if you start with <code>Q : V → K</code>, and you construct the Clifford algebra, then you want <code>Q</code>, <code>V</code> and <code>K</code> to be fields in the structure. Not isomorphic things.</p>
</blockquote>
<p>Because in the end, you want to deduce facts about <code>Q</code>, <code>V</code> and <code>K</code>.</p>



<a name="202351884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202351884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202351884">(Jun 29 2020 at 18:43)</a>:</h4>
<p>thanks!</p>



<a name="202418534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202418534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202418534">(Jun 30 2020 at 10:37)</a>:</h4>
<p>I realized that I should first <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> the problem before writing a new <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> . The following will refer to the definitions in <a href="https://stackedit.io/viewer#!url=https://raw.githubusercontent.com/pygae/lean-ga/master/docs/misc/many_faces.md">The Many Faces of Geometric Algebra</a> by section titles with &lt;&gt; around them. I'll try to avoid mentioning any specific language structure in Lean such as structure/type class/instance, inheritance, parameters, bundled v.s. unbundled etc. because they're part of the y.</p>
<p>The grand design is somewhat top-down.</p>
<ol>
<li>Define general Geometric Algebra (GA) with axioms about its properties/behaviors instead of representations, avoid mentioning grades/coordinates/metric, etc., keep it as readable and intuitive as possible;</li>
<li>Define G(p, q, r) over a field which could be ℝ, ℂ or dual numbers 𝔻, hyperbolic numbers ℍ ( note that this is not quaternions ) but without specific metric, where (p, q, r) means <code>p</code> positive, <code>q</code> negative and <code>r</code> zero dimensions, e.g. Minkowski space is ℝ(1, 3, 0), dual number is G(0, 0, 1); Projective GA(PGA) and Conformal GA(CGA) are of specific interest at this abstraction layer with their own theorems and identities unrelated to specific metrics</li>
<li>Define G(p, q, r) over a field a specific metric(or quadratic form)</li>
<li>
<p>All of<br>
  a. Formalize data structures and the corresponding algorithms in sense of software libraries, such as using binary trees or prefix trees or whatever to implement GA<br>
  b. formalize GA in other ways so that it's equivalent to the definition in 1 (with certain limited scope), the formalization might be &lt;Lawson 1989&gt;, &lt;Clifford algebra as a quotient of the tensor algebra&gt; or &lt;Clifford 1882&gt;<br>
  c. ℝ, ℂ, dual numbers 𝔻, hyperbolic numbers ℍ, quaternions ℚ are all GAs</p>
</li>
<li>
<p>Prove general theorems and identities for 1,  prove 2 "is" 1, prove dedicated theorems and identities for PGA and CGA, prove 3 "is" 2, prove 4b is 2 or 1, prove 4a and 4c are 3.</p>
</li>
</ol>
<p>Last night, Eric was talking about at most the relationship between 3 and 4, and I was thinking about how to handle all the relationships between all of the above(and they might not be the same!). Maybe I've overcomplicated the problem at an initial stage. That's why I kept saying "not exactly" to Eric's examples.</p>
<p>Now let's come back to the current attempt in <a href="https://github.com/pygae/lean-ga/blob/master/src/geometric_algebra/nursery/chisolm.lean">https://github.com/pygae/lean-ga/blob/master/src/geometric_algebra/nursery/chisolm.lean</a> . It's trying to directly address 1 and it has at least the following mistakes:</p>
<ol>
<li>it should not directly try to address 1, instead, it should try something more concrete at the level of 2 or 3 and attack 1 based on what's learned during the process;</li>
<li>it should not choose the axiom sets in &lt;Chisolm 2012&gt;, the axioms treated G₀ and G₁ specially and I believe this is its weakness; on the opposite, something like &lt;Buchholz 2005&gt;, &lt;Definition by generators and relations&gt;, &lt;Lynn&gt; might be better alternatives;</li>
<li>it should not choose using [] parameters to specify most of the axioms, the axioms should be bundled fields</li>
<li>it could reduce the numbers of types in parameters, the possibilities are 2(only G₀ and G), 1(only G) or 0;</li>
<li>it should not stick to type class to implement the "is"s in 5, and might need to use the technique documented in <a href="https://leanprover-community.github.io/mathlib_docs/notes.html#forgetful%20inheritance">https://leanprover-community.github.io/mathlib_docs/notes.html#forgetful%20inheritance</a> for better definitionally equality; there might be other alternatives;</li>
<li>it should handle the equality across types (i.e. Gr) better, such as the way to deal with the fact that the square of G₁ is G₀, homs are used here, but there're alternatives like coe, set, subtype etc.</li>
<li>it should pick a way to prove that ℂ could "be" G(0, 1, 0) over ℝ or G(0, 0, 0) over ℂ, and find a way to allow plugging ℂ into proven theorems about abstract GA.</li>
</ol>



<a name="202421011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202421011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202421011">(Jun 30 2020 at 11:09)</a>:</h4>
<p>Some concrete examples of GA (but not of the <code>geometric_algebra G₀ G₁ G</code> here) are(note: it's not Lean): </p>
<div class="codehilite"><pre><span></span><code>    <span class="c"># Basic</span>
    <span class="n">ℝ</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>          <span class="c"># Real numbers.</span>
    <span class="n">ℂ</span>  <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>      <span class="c"># Complex numbers.</span>
    <span class="n">ℚ</span>  <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>      <span class="c"># Quaternions.</span>
    <span class="n">ℍ</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>           <span class="c"># Hyperbolic numbers.</span>
    <span class="n">𝔻</span>  <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Dual numbers.</span>


    <span class="c"># Clifford</span>
    <span class="n">Cl2</span>       <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>     <span class="c"># Clifford algebra for 2D vector space.</span>
    <span class="n">Cl3</span>       <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>     <span class="c"># Clifford algebra for 3D vector space.</span>
    <span class="n">Spacetime</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>   <span class="c"># Clifford algebra for timespace vectors.</span>

    <span class="c"># Geometric</span>
    <span class="n">PGA2D</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>     <span class="c"># Projective Euclidean 2D plane. (dual)</span>
    <span class="n">PGA3D</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>     <span class="c"># Projective Euclidean 3D space. (dual)</span>
    <span class="n">CGA2D</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>       <span class="c"># Conformal 2D space.</span>
    <span class="n">CGA3D</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>       <span class="c"># Conformal 3D space.</span>
</code></pre></div>



<a name="202430288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202430288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202430288">(Jun 30 2020 at 12:55)</a>:</h4>
<p>One curious thing about this notion of geometric algebra (at least in the Chisolm version) which is clarified by some of the other presentations is that it is not really an algebraic structure  at all, in the sense of describing a kind of algebra. Rather, it's attempting to axiomatize the <em>free</em> algebra of some sort: namely (noncommutative) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>-algebras equipped with a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>-linear map from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> compatible with the quadratic form on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> in a certain way.</p>



<a name="202430588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202430588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202430588">(Jun 30 2020 at 12:57)</a>:</h4>
<p>So maybe it would be worthwhile to start by formalizing that kind of algebra.</p>



<a name="202430627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202430627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202430627">(Jun 30 2020 at 12:57)</a>:</h4>
<p>I think equations which hold in all geometric algebras would also hold in all of these guys.</p>



<a name="202442123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202442123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202442123">(Jun 30 2020 at 14:23)</a>:</h4>
<p>Mathematically, it's correct. GA is simply a free algebra with one particular constraint on the quadratic form. But such a statement is of no interest to the community applied GA in mathematical physics, quantum physics, electromagnetism, astrophysics, computer graphics, machine vision, engineering, robotics etc. All rich structures and interesting behaviors arise from that one constraint, and in turn, embeds many concepts in different math areas with different appearances.</p>



<a name="202445723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202445723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202445723">(Jun 30 2020 at 14:48)</a>:</h4>
<blockquote>
<p>it is not really an algebraic structure at all, in the sense of describing a kind of algebra.</p>
</blockquote>
<p>I don't follow what qualifies as an algebra here. </p>
<blockquote>
<p>Repeatedly and independently a long list of Clifford's geometric algebras, their subalgebras have been studied and applied historically, often under different names. Some of these algebras are complex numbers (and the complex number plane), hyperbolic numbers (split complex numbers, real tessarines), dual numbers, quaternions, biquaternions (complex quaternions), dual quaternions, Plucker coordinates, bicomplex numbers (commutative quaternions, tessarines, Segre quaternions), Pauli algebra (space algebra), Dirac algebra (space-time algebra, Minkowski algebra), algebra of physical space, para-vector algebra, spinor algebra, Lie algebras, Cartan algebra, versor algebra, rotor algebra, motor algebra, Clifford bracket algebra, conformal algebra, algebra of differential forms, etc.</p>
</blockquote>



<a name="202528906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202528906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202528906">(Jul 01 2020 at 04:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202346145">said</a>:</p>
<blockquote>
<p>I suggest also reading the story in §6.1 of <a href="https://arxiv.org/pdf/1910.12320.pdf">https://arxiv.org/pdf/1910.12320.pdf</a></p>
</blockquote>
<p>I'm trying to sort out what's going on in that section. The storyline seems to be:</p>
<blockquote>
<p>The definition</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Γ</mi><mn>0</mn></msub><mo>:</mo><mo>=</mo><mi mathvariant="normal">Γ</mi><mo>∪</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\Gamma_0 := \Gamma \cup {0}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">Γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord">0</span></span></span></span></span> where the multiplication and order relation are extended by specifying that 0γ = 0 × 0 = 0 and 0 ≤ γ for every γ in Γ.<br>
focuses on the construction of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Γ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\Gamma_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">Γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, starting from an ordered group and adding an element, rather than the properties of the resulting object.</p>
</blockquote>
</blockquote>
<p>The latter (directly addressing the properties of the resulting object instead of piecing some construction together and suddenly new behaviors emerge out of no(intuitively)where) is exactly what I'm after. If I have to extend some structure or bundle some field, I'll rather be adding some behaviors rather than gluing some constructions.</p>
<blockquote>
<p>We used Lean’s coercion mechanism to automatically insert the “inclusion” map from Γ to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Γ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\Gamma_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">Γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. In set<br>
theory, this is indeed a true inclusion, but there are no inclusions between types in type theory as a term<br>
can only have one type. The <code>norm_cast</code> tactic, by Paul-Nicolas Madeleine [Mad19], greatly alleviates<br>
the pain of invoking lemmas about such coercions<br>
 Set-theoretically, it is almost true that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">R</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi mathvariant="double-struck">R</mi><mrow><mo>&gt;</mo><mn>0</mn></mrow></msub><msub><mo stretchy="false">)</mo><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\mathbb{R}_{\ge 0} = (\mathbb{R}_{\gt 0})_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.934069em;vertical-align:-0.24517899999999998em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">&gt;</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17737em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. This tiny lie only requires that we forget that the 0 in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi mathvariant="double-struck">R</mi><mrow><mo>&gt;</mo><mn>0</mn></mrow></msub><msub><mo stretchy="false">)</mo><mn>0</mn></msub></mrow><annotation encoding="application/x-tex"> (\mathbb{R}_{\gt 0})_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">&gt;</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17737em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is meant to be an extra element coming from nowhere in particular, hence has nothing to do with the neutral element of the additive group R. It gets harder to ignore with type-theoretic foundations. It means that merging the elementary theory with our abstract theory would require non-trivial glue.</p>
</blockquote>
<p>Generally I love type-theoretic foundations because it seems more strict and you can't blur things out unintentionally. But it's really problematic when you intentionally need to do something across types, it forces you to be verbosely formal and I'm yet to find the best practice to handle such situations. This story give hints about how to handle it, accompanied by old code presumably <a href="https://github.com/leanprover-community/lean-perfectoid-spaces/commit/bf2d30b1925f22b45b32308251b908c87a2b40a9#diff-b5acb6e2a77a37f3c4deca33d0ae14d2">here</a>.</p>
<blockquote>
<p>We defined the concept of totally ordered commutative monoid with zero as a type equipped with a composition law, a total order, and special elements 0 and 1 with enough properties to guarantee that all instances are isomorphic (as ordered commutative monoids) to some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Γ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\Gamma_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">Γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. This corresponds to a type class which admits both with_zero Γ and {x : R // 0 ≤ x} as instances. Once again, focusing on properties instead of constructions gives us the needed extra flexibility at no cost.</p>
</blockquote>
<p>So here's the solution. Basically I understood the last sentence and worked my way backwards with the help of the corresponding code <a href="https://github.com/leanprover-community/lean-perfectoid-spaces/pull/54/files">here</a>, particularly <code>src/valuation/basic.lean</code>(see also <a href="https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/valuation/linear_ordered_comm_group_with_zero.lean#L28">linear_ordered_comm_group_with_zero at master branch</a>). The core idea here seems to be we should model the properties in the definitions and prove some construction is an instance of it later and the benefit would be (I guess) better integration with elementary theory which involves more informal treatment?</p>



<a name="202533632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202533632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202533632">(Jul 01 2020 at 05:58)</a>:</h4>
<blockquote>
<p>The core idea here seems to be we should model the properties in the definitions and prove some construction is an instance of it later</p>
</blockquote>
<p>Yes, exactly.</p>
<blockquote>
<p>and the benefit would be (I guess) better integration with elementary theory which involves more informal treatment?</p>
</blockquote>
<p>The benefit would be that examples that are not by definition equal to you construction can still be turned into instances, whereas with the approach we took first this is simply impossible.</p>
<ul>
<li><code>nnreal</code> is not of the form <code>with_zero G</code>. It's only isomorphic to it.</li>
<li><code>Z_p</code> is not a <code>set Q_p</code> and hence <code>is_subring Z_p</code> will never work. But it does have an injective ring homomorphism to <code>Q_p</code>.</li>
</ul>



<a name="202535279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202535279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202535279">(Jul 01 2020 at 06:35)</a>:</h4>
<p>As a mathematician you might say "but what is the problem here? If X and Y are isomorphic then everything which is true for X is true for Y". This is problematic for two reasons. Firstly, the principle is not true in general. For example if P(T) is <code>T=X</code> (which makes sense in type theory) then P(X) is true and P(Y) might not be (in Lean at least -- in a univalent theory this would be true but their = is not proof-irrelevant and this seems to bring other problems). </p>
<p>And secondly, because all the <em>mathematical</em> facts about X, which of course do translate over to Y, actually have to be translated over. There is no "rewrite along an isomorphism" like there is a rewrite along an equality, and until such a tactic exists (and it will be hard to write because it's not always true, it's not true for P above for example) everything has to be transferred manually. Completely dumb proofs like if V and W are isomorphic algebras and V is 10 dimensional over some subalgebra isomorphic to the reals then so is W -- this is mathematically obvious but will not be a one-liner in Lean by any means</p>



<a name="202569843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202569843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202569843">(Jul 01 2020 at 13:40)</a>:</h4>
<p>I was trying to have a few examples under the current definition, and have difficulty proving <code>instance rrc_ga : geometric_algebra ℝ ℝ ℂ</code> at the <code>sorry /- here -/</code> in the following <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span><span class="bp">.</span><span class="n">hom</span>
<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">complex</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">complex</span><span class="bp">.</span><span class="n">module</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">u₀</span> <span class="n">u₁</span>

<span class="n">class</span> <span class="n">geometric_algebra</span>
<span class="c1">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>
<span class="o">(</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">G₀</span><span class="o">]</span>
<span class="c1">-- Axiom 3: G contains a subset G1 closed under addition,</span>
<span class="c1">-- and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>
<span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">G₀</span> <span class="n">G₁</span><span class="o">]</span>
<span class="c1">-- Axiom 1: G is a ring with unit.</span>
<span class="c1">-- The additive identity is called 0 and the multiplicative identity is called 1.</span>
<span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span>
<span class="o">[</span><span class="n">algebra</span> <span class="n">G₀</span> <span class="n">G</span><span class="o">]</span>
<span class="o">:=</span>
<span class="o">(</span><span class="n">f₁</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span><span class="o">)</span>
<span class="c1">-- Axiom 4: The square of every vector is a scalar.</span>
<span class="o">(</span><span class="n">vec_sq_scalar</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">G₀</span><span class="o">,</span> <span class="n">f₁</span> <span class="n">v</span> <span class="bp">*</span> <span class="n">f₁</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">algebra_map</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">k</span> <span class="o">)</span>

<span class="kn">namespace</span> <span class="n">geometric_algebra</span>

<span class="kn">section</span>

<span class="kn">parameters</span>
<span class="o">{</span><span class="n">G₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">G₀</span><span class="o">]</span>
<span class="o">{</span><span class="n">G₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">G₁</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">G₀</span> <span class="n">G₁</span><span class="o">]</span>
<span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">G₀</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">geometric_algebra</span> <span class="n">G₀</span> <span class="n">G₁</span> <span class="n">G</span><span class="o">]</span>

<span class="n">def</span> <span class="n">f</span><span class="err">ᵥ</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→+</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">f₁</span> <span class="n">G₀</span>

<span class="n">def</span> <span class="n">fₛ</span> <span class="o">:</span> <span class="n">G₀</span> <span class="bp">→+*</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">algebra_map</span> <span class="n">G₀</span> <span class="n">G</span>

<span class="n">noncomputable</span> <span class="kn">instance</span> <span class="n">rrc_ga</span> <span class="o">:</span> <span class="n">geometric_algebra</span> <span class="n">ℝ</span> <span class="n">ℝ</span> <span class="n">ℂ</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">f₁</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">map_zero&#39;</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">map_add&#39;</span> <span class="o">:=</span> <span class="k">begin</span>
      <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
      <span class="n">norm_cast</span><span class="o">,</span>
    <span class="kn">end</span>
  <span class="o">},</span>
  <span class="n">vec_sq_scalar</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intro</span> <span class="n">v</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">v</span> <span class="bp">*</span> <span class="n">v</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">add_monoid_hom</span><span class="bp">.</span><span class="n">coe_mk</span><span class="o">,</span> <span class="n">ring_hom</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">],</span>
    <span class="n">sorry</span> <span class="c">/-</span><span class="cm"> here -/</span>
  <span class="kn">end</span>
<span class="o">}</span>

<span class="c">/-</span><span class="cm"> For later discussion, the below doesn&#39;t matter for this question -/</span>

<span class="kn">instance</span> <span class="n">field_ga</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:</span> <span class="n">geometric_algebra</span> <span class="n">K</span> <span class="n">K</span> <span class="n">K</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">f₁</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span>
    <span class="n">map_zero&#39;</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">map_add&#39;</span> <span class="o">:=</span> <span class="k">begin</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">forall_const</span><span class="o">,</span> <span class="n">id</span><span class="bp">.</span><span class="n">def</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">]</span>
    <span class="kn">end</span>
  <span class="o">},</span>
  <span class="n">vec_sq_scalar</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intro</span> <span class="n">v</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">v</span> <span class="bp">*</span> <span class="n">v</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">algebra</span><span class="bp">.</span><span class="n">id</span><span class="bp">.</span><span class="n">map_eq_self</span><span class="o">,</span> <span class="n">add_monoid_hom</span><span class="bp">.</span><span class="n">coe_mk</span><span class="o">,</span> <span class="n">id</span><span class="bp">.</span><span class="n">def</span><span class="o">],</span>
  <span class="kn">end</span>
<span class="o">}</span>

<span class="c1">-- noncomputable instance rcc_ga : geometric_algebra ℝ ℂ ℂ := {</span>
<span class="c1">--   f₁ := {</span>
<span class="c1">--     to_fun := id,</span>
<span class="c1">--     map_zero&#39; := rfl,</span>
<span class="c1">--     map_add&#39; := by simp,</span>
<span class="c1">--   },</span>
<span class="c1">--   vec_sq_scalar := /- mathematically false due to the wrong mul equiped with ℂ -/</span>
<span class="c1">-- }</span>

<span class="kn">end</span>

<span class="kn">end</span> <span class="n">geometric_algebra</span>
</code></pre></div>



<a name="202569857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202569857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202569857">(Jul 01 2020 at 13:40)</a>:</h4>
<p>The goal state is</p>
<div class="codehilite"><pre><span></span><code><span class="n">v</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="err">⊢</span> <span class="err">↑</span><span class="n">v</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">v</span> <span class="bp">=</span> <span class="err">⇑</span><span class="o">(</span><span class="n">algebra_map</span> <span class="n">ℝ</span> <span class="n">ℂ</span><span class="o">)</span> <span class="n">v</span> <span class="bp">*</span> <span class="err">⇑</span><span class="o">(</span><span class="n">algebra_map</span> <span class="n">ℝ</span> <span class="n">ℂ</span><span class="o">)</span> <span class="n">v</span>
</code></pre></div>



<a name="202570448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202570448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202570448">(Jul 01 2020 at 13:46)</a>:</h4>
<p>The solution to your sorry is <code>refl</code></p>



<a name="202570461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202570461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202570461">(Jul 01 2020 at 13:46)</a>:</h4>
<p><code>unfold algebra_map</code> only gives</p>
<div class="codehilite"><pre><span></span><code><span class="n">v</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="err">⊢</span> <span class="err">↑</span><span class="n">v</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">v</span> <span class="bp">=</span> <span class="err">⇑</span><span class="n">algebra</span><span class="bp">.</span><span class="n">to_ring_hom</span> <span class="n">v</span> <span class="bp">*</span> <span class="err">⇑</span><span class="n">algebra</span><span class="bp">.</span><span class="n">to_ring_hom</span> <span class="n">v</span>
</code></pre></div>


<p>and I can't do any <code>rw</code> or <code>apply</code> with <code>algebra.to_ring_hom.xxx</code></p>



<a name="202570554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202570554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202570554">(Jul 01 2020 at 13:47)</a>:</h4>
<p>I tried everything except <code>refl</code>!</p>



<a name="202570698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202570698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202570698">(Jul 01 2020 at 13:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="296911">Utensil Song</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202445723">said</a>:</p>
<blockquote>
<blockquote>
<p>it is not really an algebraic structure at all, in the sense of describing a kind of algebra.</p>
</blockquote>
<p>I don't follow what qualifies as an algebra here. </p>
</blockquote>
<p>I mean in the sense of universal algebra. For example groups are the models of an algebraic theory in the sense that they are sets equipped with certain functions/constants which satisfy universally quantified equations (like "for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>, we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>∗</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>z</mi><mo>=</mo><mi>x</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>y</mi><mo>∗</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x * y) * z = x * (y * z)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>"). Free groups however are not the models of an algebraic theory.</p>



<a name="202570714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202570714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202570714">(Jul 01 2020 at 13:48)</a>:</h4>
<p>It's really weird that <code>simp</code> can't cover this and <code>refl</code> can.</p>



<a name="202572187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202572187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202572187">(Jul 01 2020 at 14:02)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>  After reading the group example in <a href="https://en.wikipedia.org/wiki/Universal_algebra">https://en.wikipedia.org/wiki/Universal_algebra</a> , I'm pretty sure GA can be rephrased so that it's also a universal algebra.</p>



<a name="202572435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202572435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202572435">(Jul 01 2020 at 14:05)</a>:</h4>
<p>There are many existing substitutions of "Axiom 4: The square of every vector is a scalar" in literature, I always wondered which's the best one.</p>



<a name="202573076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202573076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202573076">(Jul 01 2020 at 14:10)</a>:</h4>
<p>For example, would the following qualify for universal algebra?</p>
<p>Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">X</mi><mo separator="true">,</mo><mi mathvariant="normal">Q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathrm{X}, \mathrm{Q})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">X</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">Q</span></span><span class="mclose">)</span></span></span></span> be an arbitrary finite dimensional real quadratic space and let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">A</mi></mrow><annotation encoding="application/x-tex">\mathcal{A}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal">A</span></span></span></span></span> be a real associative algebra with identity. Furthermore, let<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>:</mo><mi mathvariant="double-struck">R</mi><mo>→</mo><mi mathvariant="script">A</mi></mrow><annotation encoding="application/x-tex">\alpha: \mathbb{R} \rightarrow \mathcal{A}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal">A</span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>:</mo><mi mathvariant="normal">X</mi><mo>→</mo><mi mathvariant="script">A</mi></mrow><annotation encoding="application/x-tex">v: \mathrm{X} \rightarrow \mathcal{A}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathrm">X</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal">A</span></span></span></span></span> be linear injections such that<br>
(i) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">A</mi></mrow><annotation encoding="application/x-tex">\mathcal{A}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal">A</span></span></span></span></span> is generated as an algebra by its distinct subspaces <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>v</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>∣</mo><mi>v</mi><mo>∈</mo><mi>X</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{v(v) \mid v \in X\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">}</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>α</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>∣</mo><mi>a</mi><mo>∈</mo><mi mathvariant="double-struck">R</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{\alpha(a) \mid a \in \mathbb{R}\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">R</span></span><span class="mclose">}</span></span></span></span><br>
(ii) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>v</mi><mo>∈</mo><mi>X</mi><mo>:</mo><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>=</mo><mi>α</mi><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall v \in X:(v(v))^{2}=\alpha(Q(v))</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
<p>Then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">A</mi></mrow><annotation encoding="application/x-tex">\mathcal{A}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal">A</span></span></span></span></span> is said to be a Clifford algebra for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">X</mi><mo separator="true">,</mo><mi mathvariant="normal">Q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathrm{X}, \mathrm{Q})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">X</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">Q</span></span><span class="mclose">)</span></span></span></span>. The elements of a Clifford algebra are<br>
called multivectors. The product of a Clifford algebra is named geometric product. The signature of the quadratic space is also the signature of the algebra.</p>



<a name="202573820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202573820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202573820">(Jul 01 2020 at 14:16)</a>:</h4>
<p>I guess not yet. It's still not only about n-ary operations and identities.</p>



<a name="202574727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202574727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202574727">(Jul 01 2020 at 14:24)</a>:</h4>
<p>If you remove part (i), then I think so</p>



<a name="202578591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202578591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202578591">(Jul 01 2020 at 14:55)</a>:</h4>
<p>I think (i) is not necessary but a natural result of the rest of the definition. Will have to verify that.</p>



<a name="202594691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202594691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202594691">(Jul 01 2020 at 16:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="296911">Utensil Song</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202570714">said</a>:</p>
<blockquote>
<p>It's really weird that <code>simp</code> can't cover this and <code>refl</code> can.</p>
</blockquote>
<p>A proof of equality by <code>simp</code> is "once we simplify both sides, using simp lemmas we created on purpose, they become syntactically equal".</p>
<p>A proof of equality by <code>refl</code> is "these are definitionally equal, you can check by unfolding the definitions"</p>



<a name="202595055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202595055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202595055">(Jul 01 2020 at 17:00)</a>:</h4>
<p>If <code>simp</code> can't solve something that you expect it to solve, there's implicitly a lemma that you think should be tagged with <code>@[simp]</code> but isn't.</p>



<a name="202596620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202596620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202596620">(Jul 01 2020 at 17:13)</a>:</h4>
<p><span class="user-mention" data-user-id="252300">@Jalex Stark</span>: So to be clear, if <code>simp</code> fails but <code>refl</code> succeeds, <code>refl</code> is unfolding definitions that <code>simp</code> is not?</p>



<a name="202597150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202597150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202597150">(Jul 01 2020 at 17:19)</a>:</h4>
<p><code>refl</code> will unfold everything. <code>simp</code> won't.</p>



<a name="202597222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202597222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202597222">(Jul 01 2020 at 17:19)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="bp">ℕ</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">=</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">simp</span><span class="o">,</span> <span class="c1">-- fails</span>
<span class="kn">end</span>
</code></pre></div>



<a name="202597293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202597293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202597293">(Jul 01 2020 at 17:20)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="bp">ℕ</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">=</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">foo</span><span class="o">],</span> <span class="c1">-- works</span>
<span class="kn">end</span>
</code></pre></div>


<p>Of course <code>refl</code> works.</p>



<a name="202597365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202597365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202597365">(Jul 01 2020 at 17:21)</a>:</h4>
<p><code>simp [foo]</code> looks a bit weird because <code>simp</code> likes to use lemmas of the form <code>A=B</code> or <code>A &lt;-&gt; B</code> -- it is a confluent rewriting system.</p>



<a name="202597435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202597435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202597435">(Jul 01 2020 at 17:21)</a>:</h4>
<p>Yes</p>



<a name="202597441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202597441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202597441">(Jul 01 2020 at 17:21)</a>:</h4>
<p>But</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="bp">ℕ</span>

<span class="bp">#</span><span class="kn">print</span> <span class="kn">prefix</span> <span class="n">foo</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">foo : Type</span>
<span class="cm">foo.equations._eqn_1 : foo = ℕ</span>
<span class="cm">-/</span>
</code></pre></div>


<p>and what's happening is that <code>simp</code> temporarily is adding <code>foo.equations._eqn_1</code> to the simp set</p>



<a name="202597547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202597547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202597547">(Jul 01 2020 at 17:22)</a>:</h4>
<p>This is how <code>unfold</code> works. <code>unfold X</code> is basically "simp only [X.equations*]" I think.</p>



<a name="202633955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202633955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202633955">(Jul 01 2020 at 23:05)</a>:</h4>
<p>This difference between <code>simp</code> and <code>refl</code> is quite instructive. At first everyone thinks of <code>refl</code> as a "really simply" tactic, that "just checks if things are equal". However it's actually potentially doing a huge amount of work, because it is willing to unfold definitions arbitrarily deeply.  This is what people are referring to when they say "a heavy <code>refl</code>".</p>



<a name="202634059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202634059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202634059">(Jul 01 2020 at 23:06)</a>:</h4>
<p>On the other hand <code>simp</code> looks complicated because it potentially makes use of a whole zoo of lemmas, but on the other hand it works at a syntactic level (it will unfold <code>reducible</code>, and this can be tweaked) so is in some sense much more controllable.</p>



<a name="202634091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202634091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202634091">(Jul 01 2020 at 23:07)</a>:</h4>
<p>I would say that is <code>refl</code> is succeeding and <code>simp</code> is failing, it's probably an indication you should try to add some <code>simp</code> lemmas.</p>



<a name="202644935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202644935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202644935">(Jul 02 2020 at 02:36)</a>:</h4>
<p>Thanks for the very informative answers!</p>
<p>By "weird", actually there's a whole bunch of questions:</p>
<p>Q1. As <span class="user-mention" data-user-id="252300">@Jalex Stark</span> <span class="user-mention" data-user-id="110087">@Scott Morrison</span> pointed out the potential possibility, is there some <code>simp</code> lemma missing for <code>algebra</code>, <code>ring_hom</code>? Should we and how can we do something about it?</p>
<p>Q2. Are all the understandings below correct or some of them are misleading? Particularly c, d, f, i, j, l. And the questions n through r.</p>
<p>a. Initially I enjoy the atomic <code>apply</code> and <code>rw</code> for <code>-&gt;</code> and <code>=</code>, respectively.<br>
b. <code>simp</code> was merely a tool helping me find out the stuff in <code>simp only [stuff]</code>.<br>
c. Using <code>simp only [stuff]</code> instead of <code>rw [stuff]</code> was merely saving me  the trouble from handling the order and the repetition of the rewrites.<br>
d. Then I noticed that sometimes seemingly complex goal can be simplified significantly by <code>simp only []</code> which indicates there must be something other than just rewrites using <code>simp</code> lemmas in <code>simp</code> which I have no idea what's going on.<br>
e. I try to avoid using <code>simp</code> in the middle of a proof and consider it a finishing tactic.<br>
f.  but I find myself repeatedly having to using <code>simp only []</code> or <code>simp only [stuff]</code> to clean up some noise in the goal and proceed. I don't know if it's something wrong with my use of coe/homs/alias etc.<br>
g. then I noticed the differences of syneq, defeq, propeq (and in this order the eq is from close to more far away)<br>
h. and start using <code>unfold</code> for defeq instead of <code>rw</code> since the latter can only apply the defeq rewrite for one pattern repeatedly but <code>unfold</code> can do this for all patterns repeatedly. by pattern I mean, if I have a def of <code>f</code>, than <code>rw</code> works on both <code>f(a)</code> in <code>f(a) + f(b) + f(a)</code> but not <code>f(b)</code> but <code>unfold</code> works on <code>f(*)</code>.<br>
i. then I noticed <code>dsimp</code>, which seems to be more powerful than <code>unfold</code> which should help me figure out the stuff in <code>unfold [stuff]</code><br>
j. and it's more conservative than <code>simp</code> since it only uses defeq<br>
k. but I haven't been able to use <code>dsimp</code> to solve any goal yet<br>
l. and I'm reluctant to use <code>dsimp</code> because I don't know how to squeeze it or trace it<br>
m. with the discussions above, it seems <code>refl</code> is much heavier than just check <code>defeq</code> at a shallow level and applying refl lemmas, and it's "willing" to check defeq at arbitrary depth<br>
n. then why there's the need of manual unfold and dsimp? is the difference only that refl is a finishing tactic and it fails if it can't close the goal?<br>
o. why I can't close the goal with <code>dsimp</code>? <br>
p. do I have some non-finishing tactic to do what's similar to <code>refl</code> did but in the middle of a proof?<br>
q. the most important question is, what defeq did <code>refl</code> check in this example?<br>
r. can I mimic it with other tactics which explicitly mention the defeq it used?</p>



<a name="202645186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202645186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202645186">(Jul 02 2020 at 02:43)</a>:</h4>
<p>Oof, too many questions to be able to answer...</p>



<a name="202645239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202645239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202645239">(Jul 02 2020 at 02:44)</a>:</h4>
<blockquote>
<p>o. why I can't close the goal with dsimp?</p>
</blockquote>
<p>because it doesn't have anything in it that could close a goal; it always replaces one goal with another. Anytime you think you might "close a goal with <code>dsimp</code>", you want to use <code>refl</code>.</p>



<a name="202645265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202645265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202645265">(Jul 02 2020 at 02:45)</a>:</h4>
<p>re: m. and n. Yes! I never use <code>unfold</code>, only <code>dsimp</code>.</p>



<a name="202645324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202645324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202645324">(Jul 02 2020 at 02:46)</a>:</h4>
<p>d. <code>simp only []</code> will do beta reduction, and I think also unfold projections(?)</p>



<a name="202645356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202645356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202645356">(Jul 02 2020 at 02:47)</a>:</h4>
<p><code>dsimp</code> is allowed mid-proof (although often can be removed once the proof is working, unless the following tactic is relying on the syntactic form that <code>dsimp</code> produced)</p>



<a name="202645402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202645402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202645402">(Jul 02 2020 at 02:48)</a>:</h4>
<p>(i.e. in anything of the form <code>dsimp, exact ...</code>, the <code>dsimp</code> is unnecessary. Often however a <code>dsimp</code> may be needed before <code>simp</code> or <code>rw</code>)</p>



<a name="202645421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202645421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202645421">(Jul 02 2020 at 02:49)</a>:</h4>
<p>re "n" again: the need for <code>dsimp</code> is that it unfolds definitions, and many other tactics won't, so you need to do it by hand before calling them</p>



<a name="202645472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202645472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202645472">(Jul 02 2020 at 02:50)</a>:</h4>
<p>Regarding Q1: anytime you think <code>simp</code> should help, but it doesn't, you should try to write the <code>simp</code> lemma that you think should have fired!</p>



<a name="202645483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202645483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202645483">(Jul 02 2020 at 02:50)</a>:</h4>
<p>This is a very important part of developing a new theory --- setting up the (hopefully confluent) rewriting rules that are always "safe" to use.</p>



<a name="202645493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202645493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202645493">(Jul 02 2020 at 02:50)</a>:</h4>
<p>You want as much as possible to be handled by <code>simp</code>, because it makes everything easier for anyone who comes afterwards to your theory.</p>



<a name="202648757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202648757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202648757">(Jul 02 2020 at 04:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202645239">said</a>:</p>
<blockquote>
<blockquote>
<p>o. why I can't close the goal with dsimp?</p>
</blockquote>
<p>because it doesn't have anything in it that could close a goal; it always replaces one goal with another. Anytime you think you might "close a goal with <code>dsimp</code>", you want to use <code>refl</code>.</p>
</blockquote>
<p>Ah, I phrased it wrong. The actual question is, now that refl can close the goal, and it's about defeq, why can't dsimp which focuses on defeq achieve the same thing? What can I do to help it to achieve this, like supply defs in <code>dsimp [defs]</code>?</p>



<a name="202648850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202648850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202648850">(Jul 02 2020 at 04:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202645472">said</a>:</p>
<blockquote>
<p>Regarding Q1: anytime you think <code>simp</code> should help, but it doesn't, you should try to write the <code>simp</code> lemma that you think should have fired!</p>
</blockquote>
<p>Yes, but the defs involved here are in <code>algebra</code> part of mathlib, I was wondering if anyone is aware of the situation that some <code>simp</code> lemma is missing.</p>



<a name="202649109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202649109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202649109">(Jul 02 2020 at 04:25)</a>:</h4>
<p><code>dsimp</code> will only use lemmas marked with <code>@[simp]</code>. So yes, you need to explicitly make these lemmas.</p>



<a name="202649151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202649151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202649151">(Jul 02 2020 at 04:26)</a>:</h4>
<p>And yes, @[simp] lemmas are missing all across mathlib! As you identify them, please make PRs adding <code>@[simp]</code> to them. :-)</p>



<a name="202649165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202649165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202649165">(Jul 02 2020 at 04:27)</a>:</h4>
<p>It's nontrivial to decide exactly which lemmas should be simp lemmas, and so it doesn't always get done thoroughly.</p>



<a name="202649172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202649172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202649172">(Jul 02 2020 at 04:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202645493">said</a>:</p>
<blockquote>
<p>You want as much as possible to be handled by <code>simp</code>, because it makes everything easier for anyone who comes afterwards to your theory.</p>
</blockquote>
<p>I totally agree to do so for the end-users and intend to do so in a later stage. And yet inside the library, I'm a little bit afraid of the lemmas proven <code>by simp</code>, which means I don't have any clue about the dependencies here, it feels circular to me somehow although I know this is unlikely the actual case.</p>
<p>So, what's the best practice here? I might be a little pedantic or overcautious here and was thinking about:</p>
<ol start="0">
<li>only use <code>simp only [xxx]</code> with the help of <code>squeeze_simp</code>;</li>
<li><code>simp</code> involving only the simp lemmas in mathlib is allowed;</li>
<li>use no <code>simp</code> inside the theory if it involves simp lemmas in the theory; -- to avoid the circular feeling</li>
<li>to relax 2 a little bit, if I can break the theory into a few layers, then the top layers can invoke the layers under it;  -- but I don't know how to prevent <code>simp</code> using <code>simp</code> lemmas from the same layer, except check manually or by a linter examining the <code>[xxx]</code> in <code>simp only [xxx]</code>.</li>
</ol>



<a name="202649482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202649482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202649482">(Jul 02 2020 at 04:34)</a>:</h4>
<p>i don't understand what circularity you are trying to avoid</p>



<a name="202649597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202649597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202649597">(Jul 02 2020 at 04:37)</a>:</h4>
<p>I'm not sure either.</p>



<a name="202649691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202649691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202649691">(Jul 02 2020 at 04:39)</a>:</h4>
<p>How could there be any circularity? <code>simp</code> will only use lemmas proved higher up the page</p>



<a name="202651418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202651418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202651418">(Jul 02 2020 at 05:25)</a>:</h4>
<p>The circularity does not exist in Lean. It exists in one's mind because one has read the simp lemmas higher up the page and everywhere else...</p>



<a name="202653121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202653121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202653121">(Jul 02 2020 at 06:05)</a>:</h4>
<p><span class="user-mention" data-user-id="296911">@Utensil Song</span> </p>
<blockquote>
<p>p. do I have some non-finishing tactic to do what's similar to refl did but in the middle of a proof?</p>
</blockquote>
<p>How about <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#change">tactic#change</a> ? Is that what you're looking for?</p>



<a name="202653280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202653280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202653280">(Jul 02 2020 at 06:08)</a>:</h4>
<p>I tried <code>change</code> but I fail to provide the new goal to <code>change</code>, copying from the goal and modifying it won't always work, what's printed in goal view is not always legal lean.</p>



<a name="202653303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202653303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202653303">(Jul 02 2020 at 06:09)</a>:</h4>
<p>e.g. copying the goal state in <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202569857">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202569857</a></p>



<a name="202653367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202653367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202653367">(Jul 02 2020 at 06:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="296911">Utensil Song</span> <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202653280">said</a>:</p>
<blockquote>
<p>I tried <code>change</code> but I fail to provide the new goal to <code>change</code>, copying from the goal and modifying it won't always work, what's printed in goal view is not always legal lean.</p>
</blockquote>
<p>Yup, this is a known issue, and it's hard to solve. Lean 4 will have a delaborator, and then life should be much better.</p>



<a name="202653378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202653378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202653378">(Jul 02 2020 at 06:10)</a>:</h4>
<p>However, usually you can  fix this by adding some type annotations and removing some up-arrows.</p>



<a name="202653388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202653388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202653388">(Jul 02 2020 at 06:10)</a>:</h4>
<p>or <code>{re := v, im := 0} * {re := v, im := 0} = ⇑(algebra_map ℝ ℂ) (v * v)</code></p>



<a name="202653393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202653393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202653393">(Jul 02 2020 at 06:10)</a>:</h4>
<p>What's printed in the goal is not always legal lean, but it is almost always almost legal lean.</p>



<a name="202653462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202653462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202653462">(Jul 02 2020 at 06:12)</a>:</h4>
<p>You can try using <code>set_option pp.implicit true</code> or other <code>pp</code> options, sometimes that helps to get something you can use.</p>



<a name="202653832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202653832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202653832">(Jul 02 2020 at 06:20)</a>:</h4>
<p>I find deleting the up arrows fixes 95% of pretty-printed output problems.</p>



<a name="202654683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202654683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202654683">(Jul 02 2020 at 06:38)</a>:</h4>
<p>That's basically <code>set_option pp.coercions false</code>?</p>



<a name="202654704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/202654704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#202654704">(Jul 02 2020 at 06:38)</a>:</h4>
<p>What's the quickest way to convert the structure stuff in goal view into legal Lean? like in <a href="#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202653388">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202653388</a></p>



<a name="204044670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/204044670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#204044670">(Jul 16 2020 at 04:46)</a>:</h4>
<p>We got stuck on how to implement the bundled version for a while and here's how far we have got ( <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> for unbundled, bundling V, and bundling both R&amp;V, demonstrated in 3 different namespaces). The most natural one seems to be bundling only V.</p>
<p>It there any way to make the references to the maps less verbose?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>

<span class="n">universes</span> <span class="n">u₀</span> <span class="n">u₁</span> <span class="n">u₂</span>

<span class="kn">namespace</span> <span class="n">unbundled</span>

<span class="n">class</span> <span class="n">mwc</span>
<span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₀</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">R</span> <span class="n">V</span><span class="o">]</span>
<span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₂</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span>
<span class="kn">extends</span> <span class="n">algebra</span> <span class="n">R</span> <span class="n">G</span>
<span class="o">:=</span>
<span class="o">(</span><span class="n">f</span><span class="err">ᵣ</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">f</span><span class="err">ᵥ</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→+</span> <span class="n">G</span><span class="o">)</span>

<span class="kn">section</span> <span class="n">lemmas</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₀</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">R</span> <span class="n">V</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₂</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">r₀</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">v₀</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">[</span><span class="n">mwc</span> <span class="n">R</span> <span class="n">V</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span>
  <span class="o">((</span><span class="n">mwc</span><span class="bp">.</span><span class="n">f</span><span class="err">ᵥ</span> <span class="n">R</span> <span class="n">v</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">mwc</span><span class="bp">.</span><span class="n">f</span><span class="err">ᵥ</span> <span class="n">R</span> <span class="n">v</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">mwc</span><span class="bp">.</span><span class="n">f</span><span class="err">ᵣ</span> <span class="n">V</span> <span class="n">r</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
<span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">end</span> <span class="n">lemmas</span>

<span class="kn">end</span> <span class="n">unbundled</span>

<span class="kn">namespace</span> <span class="n">V_bundled</span>

<span class="n">class</span> <span class="n">mwc</span>
<span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₀</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span>
<span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₂</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span>
<span class="kn">extends</span> <span class="n">algebra</span> <span class="n">R</span> <span class="n">G</span>
<span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">)</span>
<span class="o">[</span><span class="n">V_acg</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span>
<span class="o">[</span><span class="n">V_vs</span> <span class="o">:</span> <span class="n">vector_space</span> <span class="n">R</span> <span class="n">V</span><span class="o">]</span>
<span class="o">(</span><span class="n">f</span><span class="err">ᵣ</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">f</span><span class="err">ᵥ</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→+</span> <span class="n">G</span><span class="o">)</span>

<span class="kn">section</span> <span class="n">lemmas</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₀</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₂</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">mwc</span> <span class="n">R</span> <span class="n">G</span><span class="o">]</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">r₀</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">v₀</span> <span class="o">:</span> <span class="n">mwc</span><span class="bp">.</span><span class="n">V</span> <span class="n">R</span> <span class="n">G</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">mwc</span><span class="bp">.</span><span class="n">V</span> <span class="n">R</span> <span class="n">G</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span>
  <span class="o">(</span><span class="n">mwc</span><span class="bp">.</span><span class="n">f</span><span class="err">ᵥ</span> <span class="n">v</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">mwc</span><span class="bp">.</span><span class="n">f</span><span class="err">ᵥ</span> <span class="n">v</span><span class="o">)</span> <span class="bp">=</span> <span class="n">mwc</span><span class="bp">.</span><span class="n">f</span><span class="err">ᵣ</span> <span class="n">r</span>
<span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">end</span> <span class="n">lemmas</span>

<span class="kn">end</span> <span class="n">V_bundled</span>

<span class="kn">namespace</span> <span class="n">VR_bundled</span>

<span class="n">class</span> <span class="n">mwc</span>
<span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₂</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span>
<span class="o">:=</span>
<span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₀</span><span class="o">)</span>
<span class="o">[</span><span class="n">R_f</span> <span class="o">:</span> <span class="n">field</span> <span class="n">R</span><span class="o">]</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">)</span>
<span class="o">[</span><span class="n">V_acg</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span>
<span class="o">[</span><span class="n">V_vs</span> <span class="o">:</span> <span class="n">vector_space</span> <span class="n">R</span> <span class="n">V</span><span class="o">]</span>
<span class="o">(</span><span class="n">to_algebra</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">R</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">f</span><span class="err">ᵣ</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">f</span><span class="err">ᵥ</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→+</span> <span class="n">G</span><span class="o">)</span>

<span class="kn">section</span> <span class="n">lemmas</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₂</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">mwc</span> <span class="n">G</span><span class="o">]</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">r₀</span> <span class="o">:</span> <span class="n">mwc</span><span class="bp">.</span><span class="n">R</span> <span class="n">G</span><span class="o">)</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">v₀</span> <span class="o">:</span> <span class="n">mwc</span><span class="bp">.</span><span class="n">V</span> <span class="n">G</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">mwc</span><span class="bp">.</span><span class="n">V</span> <span class="n">G</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">mwc</span><span class="bp">.</span><span class="n">R</span> <span class="n">G</span><span class="o">,</span>
  <span class="o">(</span><span class="n">mwc</span><span class="bp">.</span><span class="n">f</span><span class="err">ᵥ</span> <span class="n">v</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">mwc</span><span class="bp">.</span><span class="n">f</span><span class="err">ᵥ</span> <span class="n">v</span><span class="o">)</span> <span class="bp">=</span> <span class="n">mwc</span><span class="bp">.</span><span class="n">f</span><span class="err">ᵣ</span> <span class="n">r</span>
<span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">end</span> <span class="n">lemmas</span>

<span class="kn">end</span> <span class="n">VR_bundled</span>
</code></pre></div>



<a name="204046527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/204046527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#204046527">(Jul 16 2020 at 05:25)</a>:</h4>
<p>Just a random comment --- using abbreviations like <code>mwc</code> is unhelpful. Presumably this is intended to be some standard mathematical object, and perhaps if you'd written out <code>mwc</code> I'd have heard of it, and not have to reverse engineer by _actually reading the code_. :-)</p>



<a name="204046588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/204046588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#204046588">(Jul 16 2020 at 05:26)</a>:</h4>
<p>Also -- given there's been a two week pause on this thread, and this doesn't seem to be about the original title anymore, perhaps moving this to a new thread would be easier.</p>



<a name="204046591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/204046591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#204046591">(Jul 16 2020 at 05:26)</a>:</h4>
<p>(and get more attention)</p>



<a name="204048595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/204048595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#204048595">(Jul 16 2020 at 06:06)</a>:</h4>
<p>Thanks, I'll start a new topic. As for the naming, because other mathematical properties are stripped away and only the technical issue (figuring out how bundling v.s. unbundling type classes works in Lean and how to refer to fields in them) is left, I don't have any meaningful name for it anymore...I'll add a description though.</p>



<a name="204051839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/synthesized%20not%20defeq%20inferred/near/204051839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred.html#204051839">(Jul 16 2020 at 07:04)</a>:</h4>
<p>Moved to <a href="#narrow/stream/113488-general/topic/unbundled.20v.2Es.2E.20%28semi-%29bundled/near/204049917">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unbundled.20v.2Es.2E.20%28semi-%29bundled/near/204049917</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
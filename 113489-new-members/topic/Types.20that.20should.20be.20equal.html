---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html">Types that should be equal</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="204706975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204706975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhangir Azerbayev <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204706975">(Jul 22 2020 at 18:50)</a>:</h4>
<p>When trying to define the exterior product, I've run into the following issue. </p>
<div class="codehilite"><pre><span></span><code><span class="kn">universe</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">K</span> <span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">K</span> <span class="n">V</span><span class="o">]</span>
<span class="kn">variable</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>

<span class="kn">inductive</span> <span class="n">eqv</span> <span class="o">:</span> <span class="n">free_add_monoid</span> <span class="o">(</span><span class="n">fin</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span> <span class="bp">→</span> <span class="n">free_add_monoid</span> <span class="o">(</span><span class="n">fin</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">A bunch of relations go here</span>
<span class="cm">-/</span>

<span class="n">def</span> <span class="n">exterior_product</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span> <span class="o">(</span><span class="n">add_con_gen</span> <span class="o">(</span><span class="n">exterior_product</span><span class="bp">.</span><span class="n">eqv</span> <span class="n">K</span> <span class="n">V</span> <span class="n">q</span><span class="o">))</span><span class="bp">.</span><span class="n">quotient</span>

<span class="n">def</span> <span class="n">mul</span> <span class="o">{</span><span class="n">q1</span> <span class="n">q2</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">exterior_product</span> <span class="n">K</span> <span class="n">V</span> <span class="n">q1</span> <span class="bp">→</span> <span class="n">exterior_product</span> <span class="n">K</span> <span class="n">V</span> <span class="n">q2</span> <span class="bp">→</span> <span class="n">exterior_product</span> <span class="n">K</span> <span class="n">V</span> <span class="o">(</span><span class="n">q1</span> <span class="bp">+</span> <span class="n">q2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">exterior_product</span> <span class="n">K</span> <span class="n">V</span> <span class="n">q1</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">exterior_product</span> <span class="n">K</span> <span class="n">V</span> <span class="n">q2</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">mul</span> <span class="n">K</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">mul</span> <span class="n">K</span> <span class="n">y</span> <span class="n">x</span> <span class="c1">--fails</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">exterior_algebra.lean:111:19</span>
<span class="cm">type mismatch at application</span>
<span class="cm">  mul K y</span>
<span class="cm">term</span>
<span class="cm">  y</span>
<span class="cm">has type</span>
<span class="cm">  exterior_product K V q2</span>
<span class="cm">but is expected to have type</span>
<span class="cm">  exterior_product K V q1</span>
<span class="cm">exterior_algebra.lean:111:19</span>
<span class="cm">type mismatch at application</span>
<span class="cm">  mul K ⁇ x</span>
<span class="cm">term</span>
<span class="cm">  x</span>
<span class="cm">has type</span>
<span class="cm">  exterior_product K V q1</span>
<span class="cm">but is expected to have type</span>
<span class="cm">  exterior_product K V q2</span>
<span class="cm">-/</span>
</code></pre></div>


<p>Lean doesn't understand that <code>exterior_algebra K V (q1 + q2)</code> and <code>exterior_algebra K V (q2 + q1)</code> are the same type. Always carrying around an isomorphism would make my code complicated and unusable. Is there a better way?</p>



<a name="204708384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204708384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204708384">(Jul 22 2020 at 19:00)</a>:</h4>
<p>congratulations, you've run into dependent type hell</p>



<a name="204709386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709386">(Jul 22 2020 at 19:08)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> will gladly give you a 1-hour lecture on how this is all doomed, but maybe you can read <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/breaking.20equality.20with.20sheaves.html">this thread</a> instead</p>



<a name="204709444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709444">(Jul 22 2020 at 19:09)</a>:</h4>
<p>You could try and work in the full exterior algebra instead I.e. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>⨁</mo><mi>q</mi></msub><msup><mo>∧</mo><mi>q</mi></msup></mrow><annotation encoding="application/x-tex">\bigoplus_q \wedge^q</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0016819999999999613em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mbin">∧</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span></span></span></span></span></span></span></span> instead of different <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>∧</mo><mi>q</mi></msup></mrow><annotation encoding="application/x-tex">\wedge^q</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mbin">∧</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span></span></span></span></span></span></span></span> separately</p>



<a name="204709576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709576">(Jul 22 2020 at 19:10)</a>:</h4>
<p>I guess a way to solve this is, as I have told you on Discord before, to use arbitrary fintype instead of <code>fin q</code></p>



<a name="204709603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709603">(Jul 22 2020 at 19:10)</a>:</h4>
<p>then you will get two types that are not (provably) equal, namely <code>A1 (+) A2</code> and <code>A2 (+) A1</code></p>



<a name="204709617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709617">(Jul 22 2020 at 19:11)</a>:</h4>
<p>and that will stop you from comparing the elements therein</p>



<a name="204709666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709666">(Jul 22 2020 at 19:11)</a>:</h4>
<p>But then how will he state associativity?</p>



<a name="204709745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709745">(Jul 22 2020 at 19:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> are we now stuck?</p>



<a name="204709748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709748">(Jul 22 2020 at 19:12)</a>:</h4>
<p>what does nLab have to say about this</p>



<a name="204709757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709757">(Jul 22 2020 at 19:12)</a>:</h4>
<p>But we know the trick</p>



<a name="204709766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709766">(Jul 22 2020 at 19:12)</a>:</h4>
<p>pentagon mode</p>



<a name="204709771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709771">(Jul 22 2020 at 19:12)</a>:</h4>
<p>Mario did the trick in the DGA thread</p>



<a name="204709792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709792">(Jul 22 2020 at 19:12)</a>:</h4>
<p><a href="https://ncatlab.org/nlab/show/pentagon+identity">https://ncatlab.org/nlab/show/pentagon+identity</a></p>



<a name="204709795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709795">(Jul 22 2020 at 19:12)</a>:</h4>
<p>the pentagon is the associativity</p>



<a name="204709803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709803">(Jul 22 2020 at 19:13)</a>:</h4>
<p>No, just do the mario trick</p>



<a name="204709809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709809">(Jul 22 2020 at 19:13)</a>:</h4>
<p>what is DGA?</p>



<a name="204709893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709893">(Jul 22 2020 at 19:13)</a>:</h4>
<p>I mean, what do you do in maths</p>



<a name="204709940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709940">(Jul 22 2020 at 19:14)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/CDGAs/near/167999328">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/CDGAs/near/167999328</a></p>



<a name="204709949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709949">(Jul 22 2020 at 19:14)</a>:</h4>
<p>it isn't like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>×</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>×</mo><mi>Z</mi><mo>=</mo><mi>X</mi><mo>×</mo><mo stretchy="false">(</mo><mi>Y</mi><mo>×</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X \times Y) \times Z = X \times (Y \times Z)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span></span></span></span> in ZFC either</p>



<a name="204709963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709963">(Jul 22 2020 at 19:14)</a>:</h4>
<p>See the link</p>



<a name="204709983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204709983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204709983">(Jul 22 2020 at 19:14)</a>:</h4>
<p>oh I remember that trick now</p>



<a name="204710023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204710023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204710023">(Jul 22 2020 at 19:15)</a>:</h4>
<p>so you say we keep using nat?</p>



<a name="204710084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204710084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204710084">(Jul 22 2020 at 19:15)</a>:</h4>
<p>Why not?</p>



<a name="204710099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204710099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204710099">(Jul 22 2020 at 19:15)</a>:</h4>
<p>The trick works well enough to make the definition</p>



<a name="204710107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204710107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204710107">(Jul 22 2020 at 19:15)</a>:</h4>
<p>I think it is worth trying</p>



<a name="204710178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204710178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204710178">(Jul 22 2020 at 19:16)</a>:</h4>
<p>Gouezel defined tangent spaces in a weird way but could still work with them</p>



<a name="204710212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204710212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204710212">(Jul 22 2020 at 19:16)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I'm sure you remember the sheaf hell</p>



<a name="204710225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204710225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204710225">(Jul 22 2020 at 19:16)</a>:</h4>
<p>where you have triple intersections of sets</p>



<a name="204710230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204710230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204710230">(Jul 22 2020 at 19:16)</a>:</h4>
<p>what did you do with it?</p>



<a name="204710238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204710238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204710238">(Jul 22 2020 at 19:16)</a>:</h4>
<p>No I completely forgot</p>



<a name="204710252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204710252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204710252">(Jul 22 2020 at 19:16)</a>:</h4>
<p>I want to go back to hell</p>



<a name="204710424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204710424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204710424">(Jul 22 2020 at 19:18)</a>:</h4>
<p>so it looks like <span class="user-mention" data-user-id="127136">@Alex J. Best</span> already gave the answer long before I recognized it</p>



<a name="204710432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204710432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204710432">(Jul 22 2020 at 19:18)</a>:</h4>
<p>i.e. just work with the full exterior algebra</p>



<a name="204722497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204722497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204722497">(Jul 22 2020 at 21:01)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> can you write the definition for <span class="user-mention" data-user-id="284997">@Zhangir Azerbayev</span>  so he can start on the API?</p>



<a name="204722565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204722565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204722565">(Jul 22 2020 at 21:01)</a>:</h4>
<p>not now</p>



<a name="204723546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204723546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhangir Azerbayev <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204723546">(Jul 22 2020 at 21:11)</a>:</h4>
<p>After looking at Mario's trick, doing the full algebra does seem like the best way. My current thoughts are that I could make a monoid on <code>fin k → V</code> where the multiplication is concatenation, define a free additive monoid on that structure, and then quotient by all the right relations. Does that sound like it will work?</p>



<a name="204728103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204728103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhangir Azerbayev <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204728103">(Jul 22 2020 at 22:05)</a>:</h4>
<p>Is it a general principle that in Lean it's better to work "top down" rather than "bottom up", because when you try to glue things together you tend to run into these kinds of problems?</p>



<a name="204731481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204731481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204731481">(Jul 22 2020 at 22:45)</a>:</h4>
<p>It is good to get the definitions right before you get too far in, but oftentimes the only way you know if the definitions work or not is if you try and use them, or by asking some experts first! The other way you can go is even if you aren't sure exactly how the definition will work limiting yourself to some interface of properties that you know must be true. For example with the real numbers lets say you wanted to define them but weren't sure wether to use dedekind cuts or completions of cauchy sequences, you could still start proving stuff about the reals provided you only used the fact they were an ordered field where every (nonempty bounded) set has a supremum.<br>
For the example of the exterior algebra, you could just take it as an axiom that you have a type satisfying the universal property <a href="https://en.wikipedia.org/wiki/Exterior_algebra#Universal_property">https://en.wikipedia.org/wiki/Exterior_algebra#Universal_property</a> even if you didn't yet construct it, or just assume you have any unital associative K-algebra A and a K-linear map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>:</mo><mi>V</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">j : V → A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mi>j</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">j(v)j(v) = 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> for every <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v \in V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> and prove things about that to start.</p>



<a name="204735725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204735725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204735725">(Jul 22 2020 at 23:40)</a>:</h4>
<p>That is, define the predicate <code>is_exterior_algebra V Λ</code> asserting that <code>Λ</code> satisfies the universal property. Now go develop the material you want about exterior algebras using that, and come back later to give a (gross, if necessary) construction.</p>



<a name="204735818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204735818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204735818">(Jul 22 2020 at 23:42)</a>:</h4>
<p>Best of all, you end up having developed a library that is immune to slow elaboration due to heavy rfl / weird definitional unification / fragility of theorems wrt definitions, etc.</p>



<a name="204736535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204736535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204736535">(Jul 22 2020 at 23:54)</a>:</h4>
<p>You can also define the exterior algebra using the universal property: </p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>
<span class="kn">import</span> <span class="n">linear_algebra</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kn">inductive</span> <span class="n">pre</span>
<span class="bp">|</span> <span class="n">of</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">pre</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">pre</span>
<span class="bp">|</span> <span class="n">one</span> <span class="o">:</span> <span class="n">pre</span>
<span class="bp">|</span> <span class="n">mul</span> <span class="o">:</span> <span class="n">pre</span> <span class="bp">→</span> <span class="n">pre</span> <span class="bp">→</span> <span class="n">pre</span>
<span class="bp">|</span> <span class="n">add</span> <span class="o">:</span> <span class="n">pre</span> <span class="bp">→</span> <span class="n">pre</span> <span class="bp">→</span> <span class="n">pre</span>
<span class="bp">|</span> <span class="n">smul</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">pre</span> <span class="bp">→</span> <span class="n">pre</span>

<span class="n">def</span> <span class="n">lift_fun</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">pre</span> <span class="n">R</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">A</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="n">pre</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">t</span> <span class="n">f</span> <span class="mi">0</span> <span class="mi">1</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="o">(</span><span class="bp">*</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="o">(</span><span class="bp">+</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="bp">_</span> <span class="n">a</span><span class="o">,</span> <span class="n">x</span> <span class="err">•</span> <span class="n">a</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">extalg</span>
<span class="n">def</span> <span class="n">rel</span> <span class="o">:</span> <span class="o">(</span><span class="n">pre</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">pre</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">ring</span> <span class="n">A</span><span class="o">),</span> <span class="k">by</span> <span class="n">letI</span> <span class="o">:=</span> <span class="n">h1</span><span class="bp">;</span> <span class="n">exact</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">),</span> <span class="k">by</span> <span class="n">letI</span> <span class="o">:=</span> <span class="n">h2</span><span class="bp">;</span> <span class="n">exact</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">A</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">m</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">→</span>
  <span class="o">(</span><span class="n">lift_fun</span> <span class="n">R</span> <span class="n">M</span> <span class="n">f</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">(</span><span class="n">lift_fun</span> <span class="n">R</span> <span class="n">M</span> <span class="n">f</span><span class="o">)</span> <span class="n">y</span>

<span class="n">def</span> <span class="n">setoid</span> <span class="o">:</span> <span class="n">setoid</span> <span class="o">(</span><span class="n">pre</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">rel</span> <span class="n">R</span> <span class="n">M</span><span class="o">,</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="bp">⟨_</span><span class="o">,</span><span class="bp">_</span><span class="o">,</span><span class="bp">_⟩</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">symmetry</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">h1</span> <span class="n">h2</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">],</span> <span class="n">assumption&#39;</span><span class="o">,</span> <span class="o">},</span>
<span class="kn">end</span><span class="bp">⟩</span>
<span class="kn">end</span> <span class="n">extalg</span>

<span class="n">def</span> <span class="n">extalg</span> <span class="o">:=</span> <span class="n">quotient</span> <span class="o">(</span><span class="n">extalg</span><span class="bp">.</span><span class="n">setoid</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="c1">-- the exterior algebra.</span>
</code></pre></div>



<a name="204738099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204738099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204738099">(Jul 23 2020 at 00:19)</a>:</h4>
<p>Nicely done! (Except, of course, it's not the exterior algebra until you've shown that it satisfies the universal property. :-)</p>



<a name="204738439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204738439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204738439">(Jul 23 2020 at 00:23)</a>:</h4>
<p>Yeah, I'm too lazy to even show it's a ring <span aria-label="laughing" class="emoji emoji-1f606" role="img" title="laughing">:laughing:</span></p>



<a name="204738510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204738510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204738510">(Jul 23 2020 at 00:24)</a>:</h4>
<p>I guess it makes sense to define the tensor algebra first?</p>



<a name="204738610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204738610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204738610">(Jul 23 2020 at 00:26)</a>:</h4>
<p>Sure, why not? </p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>
<span class="kn">import</span> <span class="n">linear_algebra</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kn">inductive</span> <span class="n">pre</span>
<span class="bp">|</span> <span class="n">of</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">pre</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">pre</span>
<span class="bp">|</span> <span class="n">one</span> <span class="o">:</span> <span class="n">pre</span>
<span class="bp">|</span> <span class="n">mul</span> <span class="o">:</span> <span class="n">pre</span> <span class="bp">→</span> <span class="n">pre</span> <span class="bp">→</span> <span class="n">pre</span>
<span class="bp">|</span> <span class="n">add</span> <span class="o">:</span> <span class="n">pre</span> <span class="bp">→</span> <span class="n">pre</span> <span class="bp">→</span> <span class="n">pre</span>
<span class="bp">|</span> <span class="n">smul</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">pre</span> <span class="bp">→</span> <span class="n">pre</span>

<span class="n">def</span> <span class="n">lift_fun</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">pre</span> <span class="n">R</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">A</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="n">pre</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">t</span> <span class="n">f</span> <span class="mi">0</span> <span class="mi">1</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="o">(</span><span class="bp">*</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="o">(</span><span class="bp">+</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="bp">_</span> <span class="n">a</span><span class="o">,</span> <span class="n">x</span> <span class="err">•</span> <span class="n">a</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">tensoralg</span>
<span class="n">def</span> <span class="n">rel</span> <span class="o">:</span> <span class="o">(</span><span class="n">pre</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">pre</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">ring</span> <span class="n">A</span><span class="o">),</span> <span class="k">by</span> <span class="n">letI</span> <span class="o">:=</span> <span class="n">h1</span><span class="bp">;</span> <span class="n">exact</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">),</span> <span class="k">by</span> <span class="n">letI</span> <span class="o">:=</span> <span class="n">h2</span><span class="bp">;</span> <span class="n">exact</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">A</span><span class="o">),</span>
  <span class="o">(</span><span class="n">lift_fun</span> <span class="n">R</span> <span class="n">M</span> <span class="n">f</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">(</span><span class="n">lift_fun</span> <span class="n">R</span> <span class="n">M</span> <span class="n">f</span><span class="o">)</span> <span class="n">y</span>

<span class="n">def</span> <span class="n">setoid</span> <span class="o">:</span> <span class="n">setoid</span> <span class="o">(</span><span class="n">pre</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">rel</span> <span class="n">R</span> <span class="n">M</span><span class="o">,</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="bp">⟨_</span><span class="o">,</span><span class="bp">_</span><span class="o">,</span><span class="bp">_⟩</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span>  <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">symmetry</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">h1</span> <span class="n">h2</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">],</span> <span class="o">},</span>
<span class="kn">end</span><span class="bp">⟩</span>
<span class="kn">end</span> <span class="n">tensoralg</span>

<span class="n">def</span> <span class="n">tensoralg</span> <span class="o">:=</span> <span class="n">quotient</span> <span class="o">(</span><span class="n">tensoralg</span><span class="bp">.</span><span class="n">setoid</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="c1">-- the tensor algebra.</span>
</code></pre></div>



<a name="204756871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204756871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204756871">(Jul 23 2020 at 03:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/Types.20that.20should.20be.20equal/near/204738510">said</a>:</p>
<blockquote>
<p>I guess it makes sense to define the tensor algebra first?</p>
</blockquote>
<p>Okay. I proved the universal property for the tensor algebra.<br>
<a href="https://gist.github.com/adamtopaz/84315ae5b11319013707b2d0804fb37e">https://gist.github.com/adamtopaz/84315ae5b11319013707b2d0804fb37e</a></p>



<a name="204758114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204758114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204758114">(Jul 23 2020 at 03:51)</a>:</h4>
<p>Quick, quick, make a PR! :-)</p>



<a name="204758336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204758336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204758336">(Jul 23 2020 at 03:55)</a>:</h4>
<p>Possible additions:</p>
<ol>
<li>define the structure <code>is_tensor_algebra</code> (which will be a Type-valued but still subsingleton "predicate") before you even start on the construction, and show at the end that you've built such a structure</li>
<li>we have the categories of R-algebras and R-modules, and the forgetful functor as well --- so check that we're really talking about the right universal property in the first place by checking this construction is the left adjoint of the forgetful functor.</li>
</ol>



<a name="204758349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204758349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204758349">(Jul 23 2020 at 03:55)</a>:</h4>
<p>Very nicely done!</p>



<a name="204758415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204758415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204758415">(Jul 23 2020 at 03:56)</a>:</h4>
<p>I'm a little concerned about universe issues with the way I've defined the relation...</p>



<a name="204758433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204758433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204758433">(Jul 23 2020 at 03:57)</a>:</h4>
<p>ooh... indeed. Time to add universe annotations everywhere and see what happens.</p>



<a name="204758487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204758487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204758487">(Jul 23 2020 at 03:58)</a>:</h4>
<p>Yeah. I'll have to play with it tomorrow. It's late here.</p>



<a name="204758522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204758522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204758522">(Jul 23 2020 at 03:59)</a>:</h4>
<p>But universes are not an issue for the left adjoint property, since objects in these categories all have the same universe level anyway</p>



<a name="204767998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204767998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204767998">(Jul 23 2020 at 07:38)</a>:</h4>
<p>Ping <span class="user-mention" data-user-id="296911">@Utensil Song</span> who is likely interested in this conversation</p>



<a name="204802535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Types%20that%20should%20be%20equal/near/204802535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Types.20that.20should.20be.20equal.html#204802535">(Jul 23 2020 at 14:14)</a>:</h4>
<p>Same <span class="user-mention" data-user-id="315523">@Colter MacDonald</span></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
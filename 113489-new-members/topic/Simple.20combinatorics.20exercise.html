---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Simple.20combinatorics.20exercise.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Simple.20combinatorics.20exercise.html">Simple combinatorics exercise</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="262272805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simple%20combinatorics%20exercise/near/262272805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Giacomo Maletto <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Simple.20combinatorics.20exercise.html#262272805">(Nov 22 2021 at 01:58)</a>:</h4>
<p>Here's a fun exercise (<a href="https://github.com/domenicozambella/teaching/blob/master/tarm/tarm.pdf">source</a>):<br>
Prove that if  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>A</mi><mi>n</mi></msub><mo>⊆</mo><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex"> A_1, \dots, A_n \subseteq \{ 1, \dots, m \} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">}</span></span></span></span> are distinct sets such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><msub><mi>A</mi><mi>i</mi></msub><mo>∩</mo><msub><mi>A</mi><mi>j</mi></msub><mo mathvariant="normal">≠</mo><mi mathvariant="normal">∅</mi><mtext> </mtext></mrow><annotation encoding="application/x-tex"> \ A_i \cap A_j \neq \empty \ </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">∅</span><span class="mspace"> </span></span></span></span> for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mtext> </mtext></mrow><annotation encoding="application/x-tex"> \ i, j, \ </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace"> </span></span></span></span> then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><mi>n</mi><mo>≤</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex"> \ n \le 2^{m-1} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>.<br>
I'm practicing my Lean skills, so I tried to formalize it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">open</span> <span class="n">finset</span>

<span class="kd">def</span> <span class="n">sdiff_range</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">range</span> <span class="n">n</span> <span class="bp">\</span> <span class="n">A</span>

<span class="kd">lemma</span> <span class="n">sdiff_range_inj_on</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">set.inj_on</span> <span class="o">(</span><span class="n">sdiff_range</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">powerset</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">A</span> <span class="n">hA</span> <span class="n">B</span> <span class="n">hB</span> <span class="n">heq</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">sdiff_range</span><span class="o">]</span> <span class="n">at</span> <span class="n">hA</span> <span class="n">hB</span> <span class="n">heq</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sdiff_eq_sdiff_iff_inter_eq_inter</span> <span class="n">at</span> <span class="n">heq</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="o">(</span><span class="n">inter_eq_right_iff_subset</span> <span class="n">A</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">hA</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="o">(</span><span class="n">inter_eq_right_iff_subset</span> <span class="n">B</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">hB</span><span class="o">,</span>
  <span class="n">assumption</span>
<span class="kd">end</span>


<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">lemma</span> <span class="n">inj_on_subset</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">⊆</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">set.inj_on</span> <span class="n">f</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">set.inj_on</span> <span class="n">f</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">H</span> <span class="n">a</span> <span class="n">ha</span> <span class="n">b</span> <span class="n">hb</span> <span class="n">heq</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">H</span> <span class="n">_</span> <span class="n">_</span> <span class="n">heq</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="n">ha</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="n">hb</span>
<span class="kd">end</span>


<span class="kd">theorem</span> <span class="n">katona_exercise</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">range</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">A</span> <span class="n">i</span> <span class="bp">⊆</span> <span class="n">range</span> <span class="n">m.succ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">range</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">j</span> <span class="bp">∈</span> <span class="n">range</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">A</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">A</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₃</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">range</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">j</span> <span class="bp">∈</span> <span class="n">range</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">A</span> <span class="n">i</span> <span class="bp">∩</span> <span class="n">A</span> <span class="n">j</span> <span class="bp">≠</span> <span class="bp">∅</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≤</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- If we have more than 2^m distinct subsets of {0,...,m},</span>
  <span class="c1">-- at least a couple of them are complementary, and this violates hypothesis h₃.</span>
  <span class="c1">-- The subsets are represented by A₁, their complements by A₂,</span>
  <span class="c1">-- and we prove that if 2^m &lt; n then their intersection is not empty.</span>
  <span class="n">by_contra</span> <span class="n">h_ctr</span><span class="o">,</span> <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h_ctr</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">A₁</span> <span class="o">:=</span> <span class="n">image</span> <span class="n">A</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">A₂</span> <span class="o">:=</span> <span class="n">image</span> <span class="o">(</span><span class="n">sdiff_range</span> <span class="n">m.succ</span><span class="o">)</span> <span class="n">A₁</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">Hc₁</span> <span class="o">:</span> <span class="n">A₁.card</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">card_range</span> <span class="n">n</span><span class="o">,</span> <span class="n">card_image_eq_iff_inj_on</span><span class="o">],</span> <span class="n">exact</span> <span class="n">h₂</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">Hs₁</span> <span class="o">:</span> <span class="n">A₁</span> <span class="bp">⊆</span> <span class="o">(</span><span class="n">range</span> <span class="n">m.succ</span><span class="o">)</span><span class="bp">.</span><span class="n">powerset</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">B</span> <span class="n">hB</span><span class="o">,</span> <span class="n">rw</span> <span class="n">mem_image</span> <span class="n">at</span> <span class="n">hB</span><span class="o">,</span> <span class="n">rcases</span> <span class="n">hB</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi₁</span><span class="o">,</span> <span class="n">hi₂</span><span class="o">⟩,</span>
      <span class="n">specialize</span> <span class="n">h₁</span> <span class="n">i</span> <span class="n">hi₁</span><span class="o">,</span> <span class="n">rw</span> <span class="n">hi₂</span> <span class="n">at</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h₁</span><span class="o">]</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">Hc₂</span> <span class="o">:</span> <span class="n">A₂.card</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">Hc₁</span><span class="o">,</span> <span class="n">card_image_eq_iff_inj_on</span><span class="o">],</span>
      <span class="n">exact</span> <span class="n">inj_on_subset</span> <span class="n">Hs₁</span> <span class="o">(</span><span class="n">sdiff_range_inj_on</span> <span class="n">m.succ</span><span class="o">)</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">Hs₂</span> <span class="o">:</span> <span class="n">A₂</span> <span class="bp">⊆</span> <span class="o">(</span><span class="n">range</span> <span class="n">m.succ</span><span class="o">)</span><span class="bp">.</span><span class="n">powerset</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">B</span> <span class="n">hB</span><span class="o">,</span> <span class="n">rw</span> <span class="n">mem_image</span> <span class="n">at</span> <span class="n">hB</span><span class="o">,</span> <span class="n">rcases</span> <span class="n">hB</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi₁</span><span class="o">,</span> <span class="n">hi₂</span><span class="o">⟩,</span>
      <span class="n">rw</span> <span class="n">sdiff_range</span> <span class="n">at</span> <span class="n">hi₂</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mem_powerset</span><span class="o">,</span> <span class="bp">←</span><span class="n">hi₂</span><span class="o">],</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">Hc₃</span> <span class="o">:</span> <span class="o">(</span><span class="n">A₁</span> <span class="bp">∪</span> <span class="n">A₂</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span> <span class="bp">≤</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m.succ</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">card_range</span> <span class="n">m.succ</span><span class="o">,</span> <span class="bp">←</span><span class="n">card_powerset</span><span class="o">],</span>
      <span class="n">exact</span> <span class="n">card_le_of_subset</span> <span class="o">(</span><span class="n">union_subset</span> <span class="n">Hs₁</span> <span class="n">Hs₂</span><span class="o">)</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">Hc₄</span> <span class="o">:=</span> <span class="n">card_union_add_card_inter</span> <span class="n">A₁</span> <span class="n">A₂</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H₁</span> <span class="o">:</span> <span class="o">(</span><span class="n">A₁</span> <span class="bp">∩</span> <span class="n">A₂</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">card_pos</span><span class="o">,</span>
      <span class="k">calc</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m.succ</span> <span class="o">:</span> <span class="kd">by</span> <span class="o">{</span><span class="n">rw</span> <span class="o">[</span><span class="n">pow_succ</span><span class="o">,</span> <span class="n">two_mul</span><span class="o">],</span> <span class="n">omega</span> <span class="o">}</span>
         <span class="bp">...</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">A₁</span> <span class="bp">∩</span> <span class="n">A₂</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span>     <span class="o">:</span> <span class="kd">by</span> <span class="n">omega</span> <span class="o">},</span>
  <span class="n">rcases</span> <span class="n">H₁</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span> <span class="n">hB</span><span class="o">⟩,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_image</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">exists_exists_and_eq_and</span><span class="o">,</span> <span class="n">mem_inter</span><span class="o">,</span> <span class="n">sdiff_range</span><span class="o">]</span> <span class="n">at</span> <span class="n">hB</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">hB</span> <span class="k">with</span> <span class="o">⟨⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi₁</span><span class="o">,</span> <span class="n">hi₂</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">hj₁</span><span class="o">,</span> <span class="n">hj₂</span><span class="o">⟩⟩,</span>
  <span class="k">have</span> <span class="n">H₂</span> <span class="o">:</span> <span class="n">A</span> <span class="n">i</span> <span class="bp">∩</span> <span class="n">A</span> <span class="n">j</span> <span class="bp">=</span> <span class="bp">∅</span><span class="o">,</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hi₂</span><span class="o">,</span> <span class="bp">←</span><span class="n">hj₂</span><span class="o">],</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="n">h₃</span> <span class="n">i</span> <span class="n">hi₁</span> <span class="n">j</span> <span class="n">hj₁</span> <span class="n">H₂</span>
<span class="kd">end</span>
</code></pre></div>
<p>It's a bit awkward that <code>A</code> ranges over all natural numbers, and I wonder if there's a better alternative.<br>
Is this how you would have formalized the statement and the proof? Any comments on style?</p>



<a name="262272931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simple%20combinatorics%20exercise/near/262272931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Simple.20combinatorics.20exercise.html#262272931">(Nov 22 2021 at 02:00)</a>:</h4>
<p>You could use the type <code>fin m</code> (see <a href="https://leanprover-community.github.io/mathlib_docs/find/fin">docs#fin</a>) rather than taking a subset of the naturals</p>



<a name="262273006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simple%20combinatorics%20exercise/near/262273006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Simple.20combinatorics.20exercise.html#262273006">(Nov 22 2021 at 02:02)</a>:</h4>
<p>Likewise for the domain of <code>A</code>, and then your condition <code>h2</code> could be written as <code>function.injective A</code></p>



<a name="262273427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simple%20combinatorics%20exercise/near/262273427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Simple.20combinatorics.20exercise.html#262273427">(Nov 22 2021 at 02:12)</a>:</h4>
<p>I might formalize it like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">card_le_of_pairwise_not_disjoint</span>
  <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)))</span>
  <span class="o">(</span><span class="n">disj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">),</span> <span class="bp">¬</span><span class="n">disjoint</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">A.card</span> <span class="bp">≤</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">m</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>Since it's a list of distinct sets, you can instead use a set of sets, and then <code>n</code> can be replaced with the cardinality of that set.  I used <code>disjoint</code> rather than saying the intersection isn't empty just because it seems to be the mathlib-canonical way to say that.</p>
<p>Another thing you can do is, rather than use natural numbers for the elements of the sets, use an arbitrary finite type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">card_le_of_pairwise_not_disjoint</span>
  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">))</span>
  <span class="o">(</span><span class="n">disj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">),</span> <span class="bp">¬</span><span class="n">disjoint</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">A.card</span> <span class="bp">≤</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">fintype.card</span> <span class="n">α</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="262273602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simple%20combinatorics%20exercise/near/262273602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Simple.20combinatorics.20exercise.html#262273602">(Nov 22 2021 at 02:17)</a>:</h4>
<p>(I'm surprised that <code>finset</code> requires <code>decidable_eq</code> for its <code>disjoint</code>.  That should only be needed to make it <code>decidable</code>.)</p>



<a name="262273741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simple%20combinatorics%20exercise/near/262273741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Giacomo Maletto <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Simple.20combinatorics.20exercise.html#262273741">(Nov 22 2021 at 02:21)</a>:</h4>
<p>Thank you both, I'll try following these approaches and see where they lead.<br>
In my first attempt I tried using <code>fin m</code> but ran in some troubles - but that might be because I was trying to solve the exercise in another way: I wanted to define a particular function of type <code>finset (fin m.succ) → finset (fin m)</code> in order to use the pigeonhole principle, but defining such a function turned out to be a huge hassle simply because of the choice of domain and codomain.</p>



<a name="262277561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simple%20combinatorics%20exercise/near/262277561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Simple.20combinatorics.20exercise.html#262277561">(Nov 22 2021 at 03:59)</a>:</h4>
<p><span class="user-mention" data-user-id="431177">@Giacomo Maletto</span> The idea you used about how none of the pairs of sets are complementary made me think that there might be a more direct combinatorial proof.  It comes down to the fact that complementation of subsets is an involution, and it carries your set of sets <code>A</code> to a disjoint set of sets, which implies the cardinality of <code>A</code> is at most half of <code>m</code> (the cardinality of the type the sets are drawn from).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">open</span> <span class="n">finset</span>

<span class="kd">lemma</span> <span class="n">card_le_div_two_of_invol</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function.involutive</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="bp">¬</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">s.card</span> <span class="bp">≤</span> <span class="n">fintype.card</span> <span class="n">α</span> <span class="bp">/</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">s.card</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">fintype.card</span> <span class="n">α</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">nat.mul_div_cancel</span> <span class="n">s.card</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">nat.div_le_div_right</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">f'</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">≃</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">hf.to_equiv</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">transitivity</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∪</span> <span class="o">(</span><span class="n">s.map</span> <span class="n">f'.to_embedding</span><span class="o">))</span><span class="bp">.</span><span class="n">card</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">card_union_eq</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_two</span><span class="o">]</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="n">disjoint_left</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">not_exists</span><span class="o">,</span> <span class="n">mem_map</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">not_and</span><span class="o">],</span>
    <span class="n">rintros</span> <span class="n">a</span> <span class="n">ha</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hs</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">ha</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">card_le_univ</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">card_le_of_pairwise_not_disjoint</span>
  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">))</span>
  <span class="o">(</span><span class="n">disj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">),</span> <span class="bp">¬</span><span class="n">disjoint</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">A.card</span> <span class="bp">≤</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">fintype.card</span> <span class="n">α</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert_to</span> <span class="n">A.card</span> <span class="bp">≤</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">fintype.card_finset</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">fintype.card</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">fintype.card_pos</span><span class="o">,</span>
    <span class="n">generalize</span> <span class="n">hn</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hn</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">this</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">nat.succ_eq_add_one</span><span class="o">,</span> <span class="n">pow_add</span><span class="o">],</span> <span class="o">},</span> <span class="o">},</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">),</span> <span class="bp">¬</span> <span class="n">s</span><span class="bp">ᶜ</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">s</span> <span class="n">hs</span> <span class="n">hs'</span><span class="o">,</span>
    <span class="n">specialize</span> <span class="n">disj</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hs</span> <span class="n">hs'</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">not_disjoint_iff</span> <span class="n">at</span> <span class="n">disj</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">disj</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="n">card_le_div_two_of_invol</span> <span class="n">compl_involutive</span> <span class="n">_</span> <span class="n">this</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="262277883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simple%20combinatorics%20exercise/near/262277883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Simple.20combinatorics.20exercise.html#262277883">(Nov 22 2021 at 04:09)</a>:</h4>
<p>Regarding style:</p>
<p>In begin/end blocks, usually tactics are each supposed to go on their own line.  Also, beware <a href="https://leanprover-community.github.io/extras/simp.html">non-terminal simps</a> (this page explains the problem and has some pointers on how to eliminate them).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">...</span>
  <span class="n">intros</span> <span class="n">A</span> <span class="n">hA</span> <span class="n">B</span> <span class="n">hB</span> <span class="n">heq</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">sdiff_range</span><span class="o">]</span> <span class="n">at</span> <span class="n">hA</span> <span class="n">hB</span> <span class="n">heq</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sdiff_eq_sdiff_iff_inter_eq_inter</span> <span class="n">at</span> <span class="n">heq</span><span class="o">,</span>
<span class="bp">...</span>
</code></pre></div>
<p>For tactics that create multiple subgoals, make sure to enclose those goals in curly braces to help keep track of the proof structure.  For example, instead of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">...</span>
  <span class="n">refine</span> <span class="n">H</span> <span class="n">_</span> <span class="n">_</span> <span class="n">heq</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="n">ha</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="n">hb</span>
<span class="bp">...</span>
</code></pre></div>
<p>it's better to do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">refine</span> <span class="n">H</span> <span class="n">_</span> <span class="n">_</span> <span class="n">heq</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span> <span class="n">ha</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span> <span class="n">hb</span> <span class="o">}</span>
</code></pre></div>
<p>or in this case, this is fine:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">refine</span> <span class="n">H</span> <span class="o">(</span><span class="n">h</span> <span class="n">ha</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="n">hb</span><span class="o">)</span> <span class="n">heq</span><span class="o">,</span>
</code></pre></div>
<p>Mathlib style for curly brace blocks is to put them at the same indentation rather than indenting them.  So instead of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">have</span> <span class="n">Hc₁</span> <span class="o">:</span> <span class="n">A₁.card</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">card_range</span> <span class="n">n</span><span class="o">,</span> <span class="n">card_image_eq_iff_inj_on</span><span class="o">],</span> <span class="n">exact</span> <span class="n">h₂</span> <span class="o">},</span>
</code></pre></div>
<p>it'd be this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">have</span> <span class="n">Hc₁</span> <span class="o">:</span> <span class="n">A₁.card</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">card_range</span> <span class="n">n</span><span class="o">,</span> <span class="n">card_image_eq_iff_inj_on</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">h₂</span> <span class="o">},</span>
</code></pre></div>
<p>Other than these small things, the style seemed fine.</p>



<a name="262290966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simple%20combinatorics%20exercise/near/262290966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Giacomo Maletto <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Simple.20combinatorics.20exercise.html#262290966">(Nov 22 2021 at 08:33)</a>:</h4>
<p>I was under the impression that non-terminal simps were only problematic when they acted on the goal. Should they be avoided also when used in hypotheses?</p>



<a name="262291097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simple%20combinatorics%20exercise/near/262291097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Simple.20combinatorics.20exercise.html#262291097">(Nov 22 2021 at 08:35)</a>:</h4>
<p>Yes, for the exact same reasons.</p>



<a name="262306066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simple%20combinatorics%20exercise/near/262306066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Simple.20combinatorics.20exercise.html#262306066">(Nov 22 2021 at 11:18)</a>:</h4>
<blockquote>
<p>(I'm surprised that <code>finset</code> requires <code>decidable_eq</code> for its <code>disjoint</code>.  That should only be needed to make it <code>decidable</code>.)</p>
</blockquote>
<p>This is because disjointness goes through the <code>semilattice_inf_bot</code> structure, which requires decidable equality.</p>



<a name="262306163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simple%20combinatorics%20exercise/near/262306163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Simple.20combinatorics.20exercise.html#262306163">(Nov 22 2021 at 11:19)</a>:</h4>
<p>And that's because the inf is defined as a filter. To define it, you must compute it.</p>



<a name="297889051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simple%20combinatorics%20exercise/near/297889051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Simple.20combinatorics.20exercise.html#297889051">(Sep 08 2022 at 23:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Simple.20combinatorics.20exercise/near/262273602">said</a>:</p>
<blockquote>
<p>(I'm surprised that <code>finset</code> requires <code>decidable_eq</code> for its <code>disjoint</code>.  That should only be needed to make it <code>decidable</code>.)</p>
</blockquote>
<p>I've attempted to follow up on that thought in <a href="https://github.com/leanprover-community/mathlib/pull/16436">#16436</a>, with definition</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">disjoint</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">x</span><span class="o">⦄,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">≤</span> <span class="bp">⊥</span>
</code></pre></div>



<a name="297889547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simple%20combinatorics%20exercise/near/297889547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Simple.20combinatorics.20exercise.html#297889547">(Sep 08 2022 at 23:57)</a>:</h4>
<p>An alternative approach would be to make <code>disjoint</code> be a data field of <a href="https://leanprover-community.github.io/mathlib_docs/find/order_bot">docs#order_bot</a> satisfying the above, which would let us pick a nice defeq.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
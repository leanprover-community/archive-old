---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Integer.20divisors.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html">Integer divisors</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="305181813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305181813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Will Midwood <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305181813">(Oct 20 2022 at 15:57)</a>:</h4>
<p>Hi all,</p>
<p>I'm want to be able to construct a set of all integers that divide another integer 'x'. I understand there is something similar in mathlib with the nats, so I tried a similar implementation:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">definition</span> <span class="n">int_divisors</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">):</span> <span class="n">finset</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="n">finset.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∣</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">finset.Ico</span> <span class="bp">-</span><span class="n">n.nat_abs</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">.</span><span class="n">nat_abs</span><span class="o">)</span>
</code></pre></div>
<p>This gives me an error, so I imagine that I am doing it incorrectly. Is  this the right line of thinking or is there a more reasonable way to construct this set. Thank you!</p>



<a name="305184917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305184917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305184917">(Oct 20 2022 at 16:11)</a>:</h4>
<p>something like what you have works, with a few changes, first you need the right imports to know that integers have finite intervals, then I use <code>Icc</code> (the closed interval) and bracket everything properly and lean is happy:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.int.interval</span>

<span class="kd">definition</span> <span class="n">int_divisors</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">):</span> <span class="n">finset</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="n">finset.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∣</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">finset.Icc</span> <span class="o">(</span><span class="bp">-</span><span class="n">n</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>



<a name="305185097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305185097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305185097">(Oct 20 2022 at 16:12)</a>:</h4>
<p>You can even check the implementation does what you think with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.int.interval</span>

<span class="kd">definition</span> <span class="n">int_divisors</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">):</span> <span class="n">finset</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="n">finset.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∣</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">finset.Icc</span> <span class="o">(</span><span class="bp">-</span><span class="n">n</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span>
<span class="k">#eval</span> <span class="n">int_divisors</span> <span class="mi">6</span>
</code></pre></div>



<a name="305235561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305235561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305235561">(Oct 20 2022 at 20:50)</a>:</h4>
<p>This doesn't give the right answer for 0</p>



<a name="305235910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305235910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305235910">(Oct 20 2022 at 20:52)</a>:</h4>
<p>What is "the right answer"?</p>



<a name="305236070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305236070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305236070">(Oct 20 2022 at 20:53)</a>:</h4>
<p>Its a junk value right? Maybe the empty set is a better junk value? But that depends on what theorems you want I suppose</p>



<a name="305238625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305238625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305238625">(Oct 20 2022 at 21:10)</a>:</h4>
<p>There's certainly a set of integers that divide 0. In the natural language description of the question there was no finiteness assumed but in the lean code there was; I was just pointing out the discrepancy</p>



<a name="305238761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305238761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305238761">(Oct 20 2022 at 21:11)</a>:</h4>
<p>Ah I see, for <code>set</code>s there is a right answer indeed <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="305238979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305238979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305238979">(Oct 20 2022 at 21:12)</a>:</h4>
<p>I thought you were complaining that this has a different convention to the nat version (which sets divisors of zero to be empty)</p>



<a name="305239054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305239054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305239054">(Oct 20 2022 at 21:13)</a>:</h4>
<p>Naah I was just being a pedant</p>



<a name="305239115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305239115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305239115">(Oct 20 2022 at 21:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Integer.20divisors/near/305238625">said</a>:</p>
<blockquote>
<p>There's certainly a set of integers that divide 0.</p>
</blockquote>
<p>Obviously these would be the zero-divisors.</p>



<a name="305239433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305239433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305239433">(Oct 20 2022 at 21:15)</a>:</h4>
<p>There's also <a href="https://leanprover-community.github.io/mathlib_docs/find/polynomial.roots">docs#polynomial.roots</a></p>



<a name="305245862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305245862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305245862">(Oct 20 2022 at 22:06)</a>:</h4>
<p>Sure. The issue is whether one definitely wants to return a finite set in all cases (in which case you have to return a junk value for 0) or whether you are happy to return a set in all cases and perhaps later on a proof that it's finite if n!=0.</p>



<a name="305687968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305687968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Will Midwood <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305687968">(Oct 23 2022 at 17:44)</a>:</h4>
<p>Thanks everyone for the help! It's much appreciated!<br>
Follow up question: How could I prove that the divisors of a set are equal to a given set? E.G:<br>
<code>⊢ int_divisors ↑5 = {-1, -↑5, 1, ↑5}</code><br>
Thanks again!</p>



<a name="305688009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305688009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305688009">(Oct 23 2022 at 17:44)</a>:</h4>
<p>What's with the up-arrows? And what definition are you using?</p>



<a name="305688154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305688154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Will Midwood <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305688154">(Oct 23 2022 at 17:46)</a>:</h4>
<p>Erm im not sure what the up arrows are, lean just adds them in for me. I believe its casting the 5 from nat to integer? But I'm unsure.<br>
The definition I've used is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">definition</span> <span class="n">int_divisors</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">):</span> <span class="n">finset</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="n">finset.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∣</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">finset.Icc</span> <span class="o">(</span><span class="bp">-</span><span class="n">n</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>



<a name="305688814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305688814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305688814">(Oct 23 2022 at 17:54)</a>:</h4>
<p>yeah, Lean 3 wasn't really designed to do calculations; it's better at proving theorems.</p>



<a name="305688852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305688852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305688852">(Oct 23 2022 at 17:54)</a>:</h4>
<p>Lean 4 will be better in this regard.</p>



<a name="305688953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305688953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305688953">(Oct 23 2022 at 17:55)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> had an outline of how to write a <code>norm_num</code> extension to do this in another thread.</p>



<a name="305688973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305688973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305688973">(Oct 23 2022 at 17:55)</a>:</h4>
<p>But in this case, I think probably <code>refl</code> might be able to prove this as <code>5</code> is pretty small</p>



<a name="305688997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305688997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Will Midwood <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305688997">(Oct 23 2022 at 17:56)</a>:</h4>
<p>I was hoping I could use this definition to define prime numbers. I.E p is prime if  p &gt; 1 and int_divisors p = {-1, -p, 1, p}</p>



<a name="305689020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305689020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305689020">(Oct 23 2022 at 17:56)</a>:</h4>
<p>Or <code>rw int_divisors, dec_trivial</code></p>



<a name="305689086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305689086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305689086">(Oct 23 2022 at 17:56)</a>:</h4>
<p>This works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.int.interval</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">definition</span> <span class="n">int_divisors</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">):</span> <span class="n">finset</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="n">finset.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∣</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">finset.Icc</span> <span class="o">(</span><span class="bp">-</span><span class="n">n</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">int_divisors</span> <span class="mi">5</span> <span class="bp">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="bp">-</span><span class="mi">1</span><span class="o">,</span><span class="bp">-</span><span class="mi">5</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">int_divisors</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.mem_filter</span><span class="o">,</span> <span class="n">finset.mem_Icc</span><span class="o">,</span> <span class="n">finset.mem_insert</span><span class="o">,</span> <span class="n">finset.mem_singleton</span><span class="o">,</span> <span class="n">and_imp</span><span class="o">],</span>
    <span class="n">rintro</span> <span class="n">h1</span> <span class="n">h2</span> <span class="n">h3</span><span class="o">,</span>
    <span class="n">interval_cases</span> <span class="n">a</span><span class="bp">;</span> <span class="c1">-- now check all 11 cases</span>
    <span class="n">try</span> <span class="o">{</span><span class="n">cc</span><span class="o">}</span><span class="bp">;</span>
    <span class="n">try</span> <span class="o">{</span><span class="n">norm_num</span> <span class="n">at</span> <span class="n">h3</span><span class="o">},</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.mem_insert</span><span class="o">,</span> <span class="n">finset.mem_singleton</span><span class="o">,</span> <span class="n">finset.mem_filter</span><span class="o">,</span> <span class="n">finset.mem_Icc</span><span class="o">],</span>
    <span class="n">rintro</span> <span class="o">(</span><span class="n">rfl</span> <span class="bp">|</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">norm_num</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>Sure you could use this to define prime numbers. But defining prime numbers and computing examples of prime numbers are two different things; Lean 3 is good at the first and not so good at the second.</p>



<a name="305689154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305689154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305689154">(Oct 23 2022 at 17:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/Integer.20divisors/near/305689020">said</a>:</p>
<blockquote>
<p>Or <code>rw int_divisors, dec_trivial</code></p>
</blockquote>
<p>this works and is much quicker than my approach.</p>



<a name="305689280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305689280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305689280">(Oct 23 2022 at 17:59)</a>:</h4>
<p>I would imagine it's much easier to define this in terms of <code>nat.divisors</code></p>



<a name="305689288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305689288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305689288">(Oct 23 2022 at 17:59)</a>:</h4>
<p>Since then you don't have to reprove everything from scratch</p>



<a name="305689563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305689563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Will Midwood <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305689563">(Oct 23 2022 at 18:02)</a>:</h4>
<p>I'm attempting to formalise my universities number theory course, and that's how we defined prime numbers.</p>



<a name="305699708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305699708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305699708">(Oct 23 2022 at 19:32)</a>:</h4>
<p><span class="user-mention" data-user-id="545295">@Will Midwood</span> As Kevin said, "Lean 3 wasn't really designed to do calculations; it's better at proving theorems." One thing you could try to do is prove a theorem that states that your definition of prime numbers is equivalent to mathlib's definition of prime numbers. That might be a useful exercise.</p>



<a name="305701008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305701008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305701008">(Oct 23 2022 at 19:45)</a>:</h4>
<p>something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.prime</span>
<span class="kn">import</span> <span class="n">data.int.interval</span>

<span class="kd">def</span> <span class="n">int_divisors</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">):</span> <span class="n">finset</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="n">finset.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∣</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">finset.Icc</span> <span class="o">(</span><span class="bp">-</span><span class="n">n</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat.prime</span> <span class="n">n</span> <span class="bp">↔</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">int_divisors</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">{</span><span class="bp">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">}</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="305704335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305704335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305704335">(Oct 23 2022 at 20:16)</a>:</h4>
<p>I think one of those <code>n</code>s should be <code>-n</code></p>



<a name="305705885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/305705885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#305705885">(Oct 23 2022 at 20:32)</a>:</h4>
<p>oh duh, whoops! fixed it</p>



<a name="308004205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/308004205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Will Midwood <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#308004205">(Nov 04 2022 at 16:56)</a>:</h4>
<p>Hey all, thanks for the feedback, I'm attempting the example you suggested <span class="user-mention" data-user-id="380294">@Matt Diamond</span> , but I've run into a road block. This might be my inexperience with lean but essentially I now need to prove Euclid's Lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">p</span><span class="o">:</span> <span class="n">ℕ</span>
<span class="n">hp</span><span class="o">:</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">p</span>
<span class="n">hdp</span><span class="o">:</span> <span class="n">int_divisors</span> <span class="bp">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="o">{</span><span class="bp">-</span><span class="mi">1</span><span class="o">,</span> <span class="bp">-↑</span><span class="n">p</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="bp">↑</span><span class="n">p</span><span class="o">}</span>
<span class="n">ab</span><span class="o">:</span> <span class="n">ℕ</span>
<span class="n">hpp</span><span class="o">:</span> <span class="n">prime_int</span> <span class="n">p</span>
<span class="bp">⊢</span> <span class="n">p</span> <span class="bp">∣</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∣</span> <span class="n">a</span> <span class="bp">∨</span> <span class="n">p</span> <span class="bp">∣</span> <span class="n">b</span>
</code></pre></div>
<p>with my definition of prime_int:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">definition</span> <span class="n">int_divisors</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">):</span> <span class="n">set</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">∣</span> <span class="n">n</span><span class="o">}</span>

<span class="kd">definition</span> <span class="n">prime_int</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">):</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="o">)</span><span class="bp">∧</span><span class="o">(</span><span class="n">int_divisors</span> <span class="n">p</span> <span class="bp">=</span> <span class="o">{</span><span class="bp">-</span><span class="mi">1</span><span class="o">,</span> <span class="bp">-</span><span class="n">p</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">p</span><span class="o">})</span>
</code></pre></div>
<p>I'm not sure how I can work the with this definition here, so I would appreciate some help please :). I fear the answer may lie in my definition, but I'm hopeful that there's a way around it.</p>



<a name="308025879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/308025879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#308025879">(Nov 04 2022 at 18:36)</a>:</h4>
<p>If you're making your own definition of prime then it's your problem to prove all the standard theorems about primes. If you look at the core Lean 3 / mathlib definitions you'll see that this is a non-trivial amount of work. Fortunately you can borrow some of it. Assume <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> divides <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">ab</span></span></span></span> and assume it doesn't divide <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>; you need to prove it divides <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>. You can do this by first showing that the gcd of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> must be 1, then using Bezout's lemma to write 1 as a linear combination of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>, then multiply both sides by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>. This is the standard proof in the books and if you're making your own primes then this is the kind of thing you have to formalise yourself.</p>
<p>An alternative approach would be to prove that your definition of prime coincides with Lean's definition of prime and then you have access to Lean's API for primes where this theorem will already be there.</p>



<a name="308041009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/308041009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#308041009">(Nov 04 2022 at 20:12)</a>:</h4>
<blockquote>
<p>An alternative approach would be to prove that your definition of prime coincides with Lean's definition of prime</p>
</blockquote>
<p>I think that's what Will is currently trying to do</p>



<a name="308041726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/308041726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#308041726">(Nov 04 2022 at 20:16)</a>:</h4>
<p><span class="user-mention" data-user-id="545295">@Will Midwood</span> Could you post the current state of your proof, including imports? That would make it easier for people to help.</p>



<a name="308049351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/308049351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Will Midwood <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#308049351">(Nov 04 2022 at 21:07)</a>:</h4>
<p>Good idea <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> , how can I make the assumption that p doesn't divide a?</p>



<a name="308049668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/308049668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#308049668">(Nov 04 2022 at 21:09)</a>:</h4>
<p>Assuming your goal is <code>P \or Q</code> then you can do a case split on whether <code>P</code> is true or not with <code>cases hP : P</code>, then you'll have two goals. You can resolve the first one with <code>left, exact hP</code> and then you can do <code>right</code> in the "not P" goal and you should be left in the situation we discussed earlier.</p>



<a name="308147602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/308147602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Will Midwood <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#308147602">(Nov 05 2022 at 14:17)</a>:</h4>
<p>This is my current proof <span class="user-mention" data-user-id="380294">@Matt Diamond</span> :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">definition</span> <span class="n">prime_iff_prime_int</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">prime_int</span> <span class="n">p</span> <span class="bp">↔</span> <span class="n">nat.prime</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">hp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">nat.prime_iff</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">prime</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">ne_zero_of_lt</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">prime_int</span> <span class="n">at</span> <span class="n">hp</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hp.left</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">nat.is_unit_iff</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">ne</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">ne_iff_lt_or_gt</span><span class="o">,</span>
  <span class="n">right</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">prime_int</span> <span class="n">at</span> <span class="n">hp</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hp.left</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>With current state:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">2</span> <span class="n">goals</span>
  <span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
  <span class="n">hp</span> <span class="o">:</span> <span class="n">prime_int</span> <span class="n">p</span><span class="o">,</span>
  <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
  <span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∣</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span>
  <span class="bp">⊢</span> <span class="n">p</span> <span class="bp">∣</span> <span class="n">a</span> <span class="bp">∨</span> <span class="n">p</span> <span class="bp">∣</span> <span class="n">b</span>

  <span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span>
  <span class="bp">⊢</span> <span class="n">nat.prime</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">prime_int</span> <span class="n">p</span>
</code></pre></div>
<p>I have a lot of imports as the file I'm writing is about 700 lines long, but I will post them as well if it's necessary</p>



<a name="308147798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/308147798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Will Midwood <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#308147798">(Nov 05 2022 at 14:18)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.int.basic</span>
<span class="kn">import</span> <span class="n">data.int.gcd</span>
<span class="kn">import</span> <span class="n">data.int.modeq</span>
<span class="kn">import</span> <span class="n">data.int.interval</span>

<span class="kn">import</span> <span class="n">data.list.defs</span>

<span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">data.nat.cast.defs</span>
<span class="kn">import</span> <span class="n">data.nat.prime</span>

<span class="kn">import</span> <span class="n">order.basic</span>
<span class="kn">import</span> <span class="n">order.locally_finite</span>

<span class="kn">import</span> <span class="n">algebra.associated</span>
<span class="kn">import</span> <span class="n">algebra.big_operators.basic</span>

<span class="kn">import</span> <span class="n">ring_theory.int.basic</span>

<span class="kn">import</span> <span class="n">data.fin.basic</span>

<span class="kn">import</span> <span class="n">logic.basic</span>

<span class="kn">import</span> <span class="n">set_theory.zfc.basic</span>

<span class="kn">import</span> <span class="n">tactic.suggest</span>
<span class="kn">import</span> <span class="n">tactic.ring</span>
<span class="kn">import</span> <span class="n">tactic.interactive</span>

<span class="kn">import</span> <span class="n">analysis.normed.field.unit_ball</span>
</code></pre></div>



<a name="308148161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/308148161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#308148161">(Nov 05 2022 at 14:21)</a>:</h4>
<p>Note that because lean does transitive imports and mathlib is heavily cross connected, you rarely need more than 3 or 4 imports because the more advanced ones imply all the earlier ones. The easiest way to make an <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> is to copy the proof into a new file, put all those includes at the top, and then delete them as long as the proof continues to work</p>



<a name="308148353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Integer%20divisors/near/308148353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Integer.20divisors.html#308148353">(Nov 05 2022 at 14:22)</a>:</h4>
<p><del>However I don't think any of those imports contains <code>prime_int</code>, so this still isn't a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a></del> saw your definition above. This is why it's better to post self contained examples</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html">Generalized Rolle theorem</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="205729557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/205729557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#205729557">(Aug 02 2020 at 14:27)</a>:</h4>
<p>Trying to reproduce in Lean some results in numerical analysis that have been obtained in Coq, article by T. Coquand and B. Spitters <a href="https://arxiv.org/pdf/1202.3460.pdf">here</a>. To do so I need a generalized version of Rolle's theorem: if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>-times differentiable and has <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n+1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> zeroes in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">f^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> has at least one zero in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>. I basically have the proof of one version of this ready, so I'm looking for input on the way I formulated the statement in case this ends up in <code>mathlib</code>.  A slightly stronger version which would be enough for my purpose and roughly correspond to <code>exists_has_deriv_at_eq_zero</code>, would be:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">general_rolle</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hAB</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">&lt;</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">times_cont_diff_on</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span>
    <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span>
        <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)),</span> <span class="n">x</span> <span class="n">i</span> <span class="err">∈</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">i</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">x</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="n">j</span><span class="o">)</span> <span class="o">)</span> <span class="bp">→</span>
    <span class="bp">∃</span> <span class="n">c</span> <span class="err">∈</span> <span class="n">Ioo</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">iterated_deriv</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>


<p>while relaxing to <code>times_cont_diff_on ℝ n</code> would correspond to <code>exists_deriv_eq_zero</code>. Unless I'm wrong, the latter can be used for example to produce a point <code>c \in Ioo -1 1</code> where <code>deriv abs</code> is zero, which is not surprising since <code>deriv</code> is set to zero wherever not defined.<br>
<span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span>  wrote the standard versions so in particular I'm pinging him here for guidance.</p>



<a name="205741895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/205741895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#205741895">(Aug 02 2020 at 20:03)</a>:</h4>
<p>A few comments. I'll try to leave more later tonight.</p>
<ol>
<li>Why do you need <code>n &gt; 0</code>?</li>
<li>You should make <code>x</code> an argument and separate <code>∀ i, x i ∈ Icc A B</code>, <code>∀ i, f (x i) = 0</code> and <code>strict_mono x</code> into different assumptions.</li>
<li>Another way is to assume that there exists <code>s : finset ℝ</code>, <code>s.card = n + 2</code> etc.</li>
<li>Would it be hard to prove a version with a <code>multiset</code> instead of a <code>finset</code>?</li>
<li>Your version requires that the <code>(n+1)</code>st derivative is continuous. I think that this is not required.</li>
</ol>



<a name="205742822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/205742822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#205742822">(Aug 02 2020 at 20:28)</a>:</h4>
<p>Thank you Yury! My feedback:<br>
(5) You're right about (5) and I mentioned that in my original post. See also the weaker variant below. I thought we should have both, just like the two standard versions.<br>
(1) Not sure I understand (1); <code>n=0</code> is allowed and it folds back onto the standard Rolle in <code>mathlib</code>. Again, see below.<br>
(2) Great idea. I'm slowly getting used to the many tools in <code>mathlib</code>.<br>
(4) Not sure about <code>multiset</code>, didn't use it before, but I see no advantage in having to worry about duplicates. Also related to (3), it seemed to me that out of all variants, the <code>fin \to \R</code> is the best to work with because of easy coercions.</p>
<p>One more thing that I didn't mention before: when I got started I had <code>(f : ℝ → ℝ)</code> before the colon, but I was having trouble with that when in the induction proof I needed to move the induction hypothesis from <code>f</code> to <code>deriv f</code>. There may be some way to do that, but it was easier to use the universal quantifier after the colon.  </p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">weak_general_rolle</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hAB</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">&lt;</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">times_cont_diff_on</span> <span class="n">ℝ</span> <span class="n">n</span> <span class="n">f</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span>
    <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span>
        <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)),</span> <span class="n">x</span> <span class="n">i</span> <span class="err">∈</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">i</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">x</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="n">j</span><span class="o">)</span> <span class="o">)</span> <span class="bp">→</span>
    <span class="bp">∃</span> <span class="n">c</span> <span class="err">∈</span> <span class="n">Ioo</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">iterated_deriv</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="205749698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/205749698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#205749698">(Aug 03 2020 at 00:04)</a>:</h4>
<p><code>revert</code> is adjoint to <code>intro</code> and is often useful right before calling an induction lemma</p>



<a name="205750027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/205750027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#205750027">(Aug 03 2020 at 00:15)</a>:</h4>
<p>Thanks Jalex, I tried using <code>revert</code> in this case with no success. It may just be me though!</p>



<a name="205751163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/205751163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#205751163">(Aug 03 2020 at 00:53)</a>:</h4>
<p>I'm not sure I follow, but the usual pattern is to <code>revert</code> stuff that "varies" in the induction (like <code>f</code> here), use <code>induction</code>, then <code>intro</code> the things you reverted again--now you have the same goal as originally but the induction hypothesis is more general</p>



<a name="205754401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/205754401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#205754401">(Aug 03 2020 at 02:17)</a>:</h4>
<p>Here's a MWE to show what I mean, and I'll also post the other scenario:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">calculus</span><span class="bp">.</span><span class="n">local_extr</span>
<span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">calculus</span><span class="bp">.</span><span class="n">iterated_deriv</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="kn">theorem</span> <span class="n">general_rolle</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hAB</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">&lt;</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">times_cont_diff_on</span> <span class="n">ℝ</span> <span class="n">n</span> <span class="n">f</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span>
    <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span>
        <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)),</span> <span class="n">x</span> <span class="n">i</span> <span class="err">∈</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">i</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">x</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="n">j</span><span class="o">)</span> <span class="o">)</span> <span class="bp">→</span>
    <span class="bp">∃</span> <span class="n">c</span> <span class="err">∈</span> <span class="n">Ioo</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">iterated_deriv</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
    <span class="o">{</span> <span class="c1">-- base case, unfolds to plain Rolle `exists_deriv_eq_zero`</span>
      <span class="n">sorry</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span> <span class="c1">-- induction step</span>
        <span class="c1">-- the derivative is in Cᵈ</span>
        <span class="n">intros</span> <span class="n">f</span> <span class="n">hf</span> <span class="n">hxf</span><span class="o">,</span>
        <span class="n">set</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">deriv</span> <span class="n">f</span> <span class="k">with</span> <span class="n">hg</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">hder</span> <span class="o">:</span> <span class="n">times_cont_diff_on</span> <span class="n">ℝ</span> <span class="n">d</span> <span class="n">g</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">A</span> <span class="n">B</span><span class="o">),</span> <span class="n">sorry</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">hdg</span> <span class="o">:=</span> <span class="n">hd</span> <span class="n">g</span> <span class="n">hder</span><span class="o">,</span> <span class="n">clear</span> <span class="n">hd</span><span class="o">,</span> <span class="c1">--apply hd to g = deriv f; works here</span>
        <span class="n">sorry</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="n">done</span>
<span class="kn">end</span>
</code></pre></div>



<a name="205754799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/205754799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#205754799">(Aug 03 2020 at 02:27)</a>:</h4>
<p>Here's the way I started but couldn't make it work:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">general_rolle</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hAB</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">&lt;</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
   <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">times_cont_diff_on</span> <span class="n">ℝ</span> <span class="n">n</span> <span class="n">f</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
   <span class="o">(</span><span class="n">hx</span> <span class="o">:</span>  <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)),</span> <span class="n">x</span> <span class="n">i</span> <span class="err">∈</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">i</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">x</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="n">j</span><span class="o">)</span> <span class="o">)</span>  <span class="o">:</span>
    <span class="bp">∃</span> <span class="n">c</span> <span class="err">∈</span> <span class="n">Ioo</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">iterated_deriv</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
    <span class="o">{</span> <span class="c1">-- base case, unfolds to plain Rolle `exists_deriv_eq_zero`</span>
      <span class="n">sorry</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span> <span class="c1">-- induction step</span>
        <span class="c1">-- the derivative is in Cᵈ</span>
        <span class="n">set</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">deriv</span> <span class="n">f</span> <span class="k">with</span> <span class="n">hg</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">hder</span> <span class="o">:</span> <span class="n">times_cont_diff_on</span> <span class="n">ℝ</span> <span class="n">d</span> <span class="n">g</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">A</span> <span class="n">B</span><span class="o">),</span> <span class="n">sorry</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">hdg</span> <span class="o">:=</span> <span class="n">hd</span> <span class="n">g</span><span class="o">,</span>  <span class="c1">--apply hd to g = deriv f; can&#39;t do that here</span>
        <span class="n">sorry</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="n">done</span>
<span class="kn">end</span>
</code></pre></div>



<a name="205754849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/205754849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#205754849">(Aug 03 2020 at 02:28)</a>:</h4>
<p><code>revert f</code> first, then you should be in the same situation as in the first example</p>



<a name="205754862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/205754862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#205754862">(Aug 03 2020 at 02:28)</a>:</h4>
<p>I get an error if I do that.</p>



<a name="205754865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/205754865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#205754865">(Aug 03 2020 at 02:29)</a>:</h4>
<p>Not the same.</p>



<a name="205754945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/205754945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#205754945">(Aug 03 2020 at 02:31)</a>:</h4>
<p>revert <code>x</code> too</p>



<a name="205755111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/205755111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#205755111">(Aug 03 2020 at 02:35)</a>:</h4>
<p>I tried that too and couldn't make it work. Can someone do it on the MWE? <br>
If I revert <code>f</code> I don't have <code>deriv f</code> any longer. To get it, I have to <code>intro f</code> and that places me in the same spot as before. Of course I may be missing something-:(</p>



<a name="205904055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/205904055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#205904055">(Aug 04 2020 at 13:12)</a>:</h4>
<p>I thought this, the last <code>sorry</code> in my main proof, was easy. It turns out I can't find an easy way, if there's one. Help appreciated!</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">calculus</span><span class="bp">.</span><span class="n">local_extr</span>
<span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">calculus</span><span class="bp">.</span><span class="n">times_cont_diff</span>
<span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">calculus</span><span class="bp">.</span><span class="n">iterated_deriv</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">times_cont_diff_on</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="o">(</span><span class="n">Ioo</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">)</span> <span class="o">:</span>
    <span class="n">times_cont_diff_on</span> <span class="n">ℝ</span> <span class="n">n</span> <span class="o">(</span><span class="n">deriv</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">Ioo</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>


<p>In my initial setup I have <code>Icc</code> instead in fact, which perfectly folds the induction base case onto the standard Rolle version in <code>mathlib</code>, but am not sure was a good decision.</p>



<a name="205952468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/205952468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#205952468">(Aug 04 2020 at 19:54)</a>:</h4>
<p>Here is a proof:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">calculus</span><span class="bp">.</span><span class="n">local_extr</span>
<span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">calculus</span><span class="bp">.</span><span class="n">times_cont_diff</span>
<span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">calculus</span><span class="bp">.</span><span class="n">iterated_deriv</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">times_cont_diff_on</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="o">(</span><span class="n">Ioo</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">)</span> <span class="o">:</span>
  <span class="n">times_cont_diff_on</span> <span class="n">ℝ</span> <span class="n">n</span> <span class="o">(</span><span class="n">deriv</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">Ioo</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">deriv</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">u</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">u</span> <span class="mi">1</span><span class="o">)</span> <span class="err">∘</span> <span class="o">(</span><span class="n">fderiv</span> <span class="n">ℝ</span> <span class="n">f</span><span class="o">),</span> <span class="k">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">this</span><span class="o">],</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">times_cont_diff_on</span> <span class="n">ℝ</span> <span class="n">n</span> <span class="o">(</span><span class="n">fderiv</span> <span class="n">ℝ</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">Ioo</span> <span class="n">a</span> <span class="n">b</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="o">((</span><span class="n">times_cont_diff_on_succ_iff_fderiv_within</span> <span class="o">(</span><span class="n">unique_diff_on_Ioo</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hf</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="n">congr</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="k">calc</span> <span class="n">fderiv</span> <span class="n">ℝ</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">fderiv_within</span> <span class="n">ℝ</span> <span class="n">f</span> <span class="n">univ</span> <span class="n">x</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">fderiv_within</span> <span class="n">ℝ</span> <span class="n">f</span> <span class="o">(</span><span class="n">univ</span> <span class="err">∩</span> <span class="n">Ioo</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">x</span> <span class="o">:</span>
      <span class="o">(</span><span class="n">fderiv_within_inter</span> <span class="o">(</span><span class="n">Ioo_mem_nhds</span> <span class="n">hx</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hx</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="n">unique_diff_within_at_univ</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">fderiv_within</span> <span class="n">ℝ</span> <span class="n">f</span> <span class="o">(</span><span class="n">Ioo</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">x</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">apply</span> <span class="n">times_cont_diff</span><span class="bp">.</span><span class="n">comp_times_cont_diff_on</span> <span class="bp">_</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">is_bounded_bilinear_map_apply</span><span class="bp">.</span><span class="n">is_bounded_linear_map_left</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">times_cont_diff</span>
<span class="kn">end</span>
</code></pre></div>


<p>We have essentially no specific results for smooth functions in one dimension, this is why it is a little bit painful.</p>



<a name="205956781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/205956781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#205956781">(Aug 04 2020 at 20:32)</a>:</h4>
<p>Thank you, <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> !</p>



<a name="205962531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/205962531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#205962531">(Aug 04 2020 at 21:22)</a>:</h4>
<p>So if I understand correctly we need more API in 1D.</p>



<a name="205962584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/205962584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#205962584">(Aug 04 2020 at 21:22)</a>:</h4>
<p>Can this be extended to <code>Icc a b</code>? Must confess currently I wouldn't know how.</p>



<a name="206755040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/206755040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#206755040">(Aug 12 2020 at 21:31)</a>:</h4>
<p>This proof is now ready. Submitting to <code>mathlib</code> still hinges on the lemma due to <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span>  above in this thread and a few other <code>fin</code> lemmas. Maybe I should also say there's some cleaning that needs to be done. Here's a link to the proof for anyone interested:</p>
<p><a href="https://github.com/stanescuUW/numerical-analysis-with-Lean/blob/master/src/Interpolation/rolle_general-fin.lean">https://github.com/stanescuUW/numerical-analysis-with-Lean/blob/master/src/Interpolation/rolle_general-fin.lean</a></p>
<p><span class="user-group-mention" data-user-group-id="2494">@maintainers</span> Will you please provide write access to a branch of <code>mathlib</code> for <span class="user-mention" data-user-id="306964">@A. Stone Olguin</span> ?</p>



<a name="206755449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/206755449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#206755449">(Aug 12 2020 at 21:34)</a>:</h4>
<p>What's their github username?</p>



<a name="206756315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/206756315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> A. Stone Olguin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#206756315">(Aug 12 2020 at 21:43)</a>:</h4>
<p>Hi, my GitHub username is StoneOlguin</p>



<a name="206757670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/206757670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#206757670">(Aug 12 2020 at 21:57)</a>:</h4>
<p>Invitation sent! <a href="https://github.com/leanprover-community/mathlib/invitations">https://github.com/leanprover-community/mathlib/invitations</a></p>



<a name="206757955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/206757955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#206757955">(Aug 12 2020 at 22:00)</a>:</h4>
<p>How does this generalized Rolle compare with the result called higher order Rolle in <a href="https://gowers.wordpress.com/2014/02/11/taylors-theorem-with-the-lagrange-form-of-the-remainder/">https://gowers.wordpress.com/2014/02/11/taylors-theorem-with-the-lagrange-form-of-the-remainder/</a> ?</p>



<a name="206761260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/206761260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#206761260">(Aug 12 2020 at 22:41)</a>:</h4>
<p>The version that is proved here is the usual generalization on Wikipedia, because that's what's needed to obtain the truncation error for interpolation, see also the link to T. Coquand's paper in the first message in this thred:</p>
<p><a href="https://en.wikipedia.org/wiki/Rolle%27s_theorem#Generalization">https://en.wikipedia.org/wiki/Rolle%27s_theorem#Generalization</a></p>
<p>Will need to take a closer look at the link you point to <span class="user-mention" data-user-id="127136">@Alex J. Best</span>, at first glance it seems an equivalent formulation that I have never seen used before.</p>



<a name="206761419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/206761419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#206761419">(Aug 12 2020 at 22:43)</a>:</h4>
<p>Yeah this was just idle curiosity on my part, I'll check out Coquand thanks!</p>



<a name="206763386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/206763386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#206763386">(Aug 12 2020 at 23:03)</a>:</h4>
<p>No way! Instead, thank you for bringing it to my attention.</p>



<a name="208673598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Generalized%20Rolle%20theorem/near/208673598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Generalized.20Rolle.20theorem.html#208673598">(Sep 01 2020 at 11:27)</a>:</h4>
<p>One-dimensional iterated smoothness result PRed in <a href="https://github.com/leanprover-community/mathlib/issues/4017">#4017</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html">Rearranging terms with commutative operator</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="293029551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Rearranging%20terms%20with%20commutative%20operator/near/293029551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin C. Martin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html#293029551">(Aug 12 2022 at 00:18)</a>:</h4>
<p>Below I declare a binary operator, and assert it is associative and commutative.  Then I try to use simp to rearrange some terms, but it fails.  What am I doing wrong?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">op</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">op_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">n</span> <span class="o">(</span><span class="n">op</span> <span class="n">m</span> <span class="n">k</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">op_comm</span> <span class="o">:</span>  <span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">op</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">rearrange</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="n">l</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">l</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">l</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span> <span class="n">k</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">op_assoc</span><span class="o">,</span> <span class="n">op_comm</span><span class="o">]</span>
</code></pre></div>



<a name="293030186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Rearranging%20terms%20with%20commutative%20operator/near/293030186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin C. Martin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html#293030186">(Aug 12 2022 at 00:29)</a>:</h4>
<p>I figured it out: I need to tell it that it can use <code>op_assoc</code> in the other direction as well.</p>



<a name="293030198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Rearranging%20terms%20with%20commutative%20operator/near/293030198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html#293030198">(Aug 12 2022 at 00:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="348963">Martin C. Martin</span> has marked this topic as resolved.</p>



<a name="293030529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Rearranging%20terms%20with%20commutative%20operator/near/293030529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html#293030529">(Aug 12 2022 at 00:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="348963">Martin C. Martin</span> has marked this topic as unresolved.</p>



<a name="293030586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Rearranging%20terms%20with%20commutative%20operator/near/293030586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin C. Martin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html#293030586">(Aug 12 2022 at 00:35)</a>:</h4>
<p>I spoke too soon.  If I change the last line to:<br>
<code>by simp [op_assoc, op_comm, ← op_assoc]</code><br>
I get a <code>(deterministic) timeout</code>.</p>
<p>How do I get this working?</p>



<a name="293030876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Rearranging%20terms%20with%20commutative%20operator/near/293030876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html#293030876">(Aug 12 2022 at 00:40)</a>:</h4>
<p>You need one more rule, <code>op_left_comm (a b c : nat) : op a (op b c) = op b (op a c)</code></p>



<a name="293030895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Rearranging%20terms%20with%20commutative%20operator/near/293030895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html#293030895">(Aug 12 2022 at 00:41)</a>:</h4>
<p>That should be enough with <code>simp [op_comm, op_assoc, op_left_comm]</code></p>



<a name="293109719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Rearranging%20terms%20with%20commutative%20operator/near/293109719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin C. Martin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html#293109719">(Aug 12 2022 at 13:32)</a>:</h4>
<p>Thanks!  Why does it time out?  There should only be a few hundred combinations for 4 leaves and a single operator.  Doesn't simp keep track of previous expressions it has generated, so it knows when it has a duplicate?</p>
<p>In general, how do you know when it's ok to add an expression to a <code>simp</code> list?  Just try it and see if you get a timeout?  And how do you know what alternate to put in it's place, i.e. how would you think of <code>op_left_comm</code> above?</p>



<a name="293119479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Rearranging%20terms%20with%20commutative%20operator/near/293119479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html#293119479">(Aug 12 2022 at 14:25)</a>:</h4>
<p>I don't think <code>simp</code> is smart enough to "cancel" out <code>simp [my_lemma, &lt;-my_lemma]</code>. Think of each mentioned lemma a rule. So simp tries to apply any rules it can, and this makes it enter a loop. Just <code>simp [my_comm_lemma]</code> won't enter a loop because for the one rule, there is an "order" of expressions where one is preferred over the other. If you had dome <code>simp [my_comm_lemma, &lt;-my_comm_lemma]</code>, that would loop. The 3 rules I provided are sufficient to normalize commutative left associative operation.</p>



<a name="293119830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Rearranging%20terms%20with%20commutative%20operator/near/293119830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html#293119830">(Aug 12 2022 at 14:27)</a>:</h4>
<p>That's my headcanon, I think there are more precise/rigorous definitions</p>



<a name="293122335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Rearranging%20terms%20with%20commutative%20operator/near/293122335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin C. Martin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html#293122335">(Aug 12 2022 at 14:41)</a>:</h4>
<p>Thanks Yakov.  Another question, this time about rw in calc mode.  To prove <code>op_left_comm</code>, this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">op_left_comm</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">b</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">calc</span>
      <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">op_assoc</span>
                <span class="bp">...</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="n">c</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">op_comm</span> <span class="n">a</span>
                <span class="bp">...</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">b</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">op_assoc</span>
</code></pre></div>
<p>But if I try to combine the first two <code>rw</code>, it fails:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">op_left_comm'</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">b</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">calc</span>
      <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="n">c</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">op_assoc</span><span class="o">,</span> <span class="n">op_comm</span> <span class="n">a</span> <span class="n">b</span><span class="o">]</span>
                <span class="bp">...</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">b</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">op_assoc</span>
</code></pre></div>
<p>with </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rewrite</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">did</span> <span class="n">not</span> <span class="n">find</span> <span class="kd">instance</span> <span class="n">of</span> <span class="n">the</span> <span class="n">pattern</span> <span class="k">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">expression</span>
  <span class="n">op</span> <span class="n">a</span> <span class="n">b</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span>
<span class="bp">⊢</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">b</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">c</span><span class="o">)</span>
</code></pre></div>
<p>It seems to be trying to apply <code>op_comm a b</code> to the original LHS.  Combining the 2nd and 3rd <code>rw</code> works fine though.  Is this just a quirk of the first line of calc mode?</p>



<a name="293122821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Rearranging%20terms%20with%20commutative%20operator/near/293122821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html#293122821">(Aug 12 2022 at 14:44)</a>:</h4>
<p>You are just not telling it to do what you want it to do. Look at the state after the first <code>rw</code> (you can put your cursor on the <code>,</code> or so).</p>



<a name="293123189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Rearranging%20terms%20with%20commutative%20operator/near/293123189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin C. Martin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html#293123189">(Aug 12 2022 at 14:45)</a>:</h4>
<p>This is what I'm remembering, from TPiL section 5.7:<br>
"It may seem that commutativity and left-commutativity are problematic, in that repeated application of either causes looping. But the simplifier detects identities that permute their arguments, and uses a technique known as ordered rewriting. This means that the system maintains an internal ordering of terms, and only applies the identity if doing so decreases the order. With the three identities mentioned above, this has the effect that all the parentheses in an expression are associated to the right, and the expressions are ordered in a canonical (though somewhat arbitrary) way. Two expressions that are equivalent up to associativity and commutativity are then rewritten to the same canonical form."</p>
<p>So as you say, it's a local choice per identity looking at ordering, not a global "remember all generated expressions to detect loops" as I somehow thought.</p>



<a name="293126956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Rearranging%20terms%20with%20commutative%20operator/near/293126956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin C. Martin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html#293126956">(Aug 12 2022 at 14:47)</a>:</h4>
<p>Thanks Reid, it looks like it's transforming the RHS into the LHS, I assumed it would do the opposite, which seems more natural to me.</p>



<a name="293127152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Rearranging%20terms%20with%20commutative%20operator/near/293127152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html#293127152">(Aug 12 2022 at 14:48)</a>:</h4>
<p>Right, because that is the only thing <code>op_assoc</code> can do when used for rewriting in the forward direction.</p>



<a name="293128060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Rearranging%20terms%20with%20commutative%20operator/near/293128060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin C. Martin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html#293128060">(Aug 12 2022 at 14:53)</a>:</h4>
<p>Ah got it, thanks.  I pictured calc mode as manipulating an expression (the LHS), not manipulating an equation.  TIL!</p>



<a name="293164988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Rearranging%20terms%20with%20commutative%20operator/near/293164988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html#293164988">(Aug 12 2022 at 18:03)</a>:</h4>
<p>I still remember the day I learnt this :-) (and was equally confused before the penny dropped!)</p>



<a name="293190541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Rearranging%20terms%20with%20commutative%20operator/near/293190541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin C. Martin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html#293190541">(Aug 12 2022 at 20:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator/near/293030895">said</a>:</p>
<blockquote>
<p>That should be enough with <code>simp [op_comm, op_assoc, op_left_comm]</code></p>
</blockquote>
<p>So that's still not working, although now I can't make sense of the error message:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">op</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">op_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">n</span> <span class="o">(</span><span class="n">op</span> <span class="n">m</span> <span class="n">k</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">op_comm</span> <span class="o">:</span>  <span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">op</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">op_left_comm</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">b</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">op_assoc</span><span class="o">,</span> <span class="n">op_comm</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">op_assoc</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">rearrange</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="n">l</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">l</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">l</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span> <span class="n">k</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">op_assoc</span><span class="o">,</span> <span class="n">op_comm</span><span class="o">,</span> <span class="n">op_left_comm</span><span class="o">]</span>
</code></pre></div>
<p>The <code>simp</code> fails with: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">there</span> <span class="n">are</span> <span class="n">unsolved</span> <span class="n">goals</span>
<span class="n">state</span><span class="o">:</span>
<span class="bp">⊢</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">true</span>
</code></pre></div>
<p>What exactly is the remaining goal?  What is it that's left to prove?</p>



<a name="293195928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Rearranging%20terms%20with%20commutative%20operator/near/293195928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Rearranging.20terms.20with.20commutative.20operator.html#293195928">(Aug 12 2022 at 21:28)</a>:</h4>
<p><code>simp</code> doesn't do <code>intros</code> by default. The mathlib convention would be to move all of the variables left of the colon as you did with <code>op_left_comm</code>. Alternatively you can add something like <code>{contextual := true}</code> to the <code>simp</code> call</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
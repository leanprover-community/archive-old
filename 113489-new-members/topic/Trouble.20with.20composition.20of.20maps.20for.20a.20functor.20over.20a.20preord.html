---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Trouble.20with.20composition.20of.20maps.20for.20a.20functor.20over.20a.20preord.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Trouble.20with.20composition.20of.20maps.20for.20a.20functor.20over.20a.20preord.html">Trouble with composition of maps for a functor over a preord</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="291901957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Trouble%20with%20composition%20of%20maps%20for%20a%20functor%20over%20a%20preord/near/291901957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Trouble.20with.20composition.20of.20maps.20for.20a.20functor.20over.20a.20preord.html#291901957">(Aug 03 2022 at 18:35)</a>:</h4>
<p>I'm not sure how to describe my problem. I'm trying to construct, given an inverse system of types, the subsystem consisting of the "surjective" parts <a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20category_theory.filtered%0Aimport%20topology.category.Top.limits%0Aimport%20data.finset.basic%0Aimport%20category_theory.category.basic%0Aimport%20category_theory.full_subcategory%0Aimport%20data.set.finite%0Aimport%20data.sym.sym2%0Aimport%20combinatorics.simple_graph.basic%0Aimport%20combinatorics.simple_graph.connectivity%0Aimport%20topology.metric_space.basic%0Aimport%20data.setoid.partition%0Aimport%20set_theory.cardinal.basic%0Aimport%20data.fintype.basic%0A%0Auniverses%20u%20v%20w%0A%0Aopen%20classical%0Aopen%20category_theory%0A%0Anoncomputable%20theory%0Alocal%20attribute%20%5Binstance%5D%20prop_decidable%0A%0Adef%20fis.to_surjective%20%20%7BJ%20%3A%20Type%20u%7D%20%5Bpreorder%20J%5D%20%5Bis_directed%20J%20has_le.le%5D%0A%20%20%28F%20%3A%20J%E1%B5%92%E1%B5%96%20%E2%A5%A4%20Type%20v%29%20%2F-%20%5B%CE%A0%20%28j%20%3A%20J%E1%B5%92%E1%B5%96%29%2C%20fintype%20%28F.obj%20j%29%5D%20%5B%E2%88%80%20%28j%20%3A%20J%E1%B5%92%E1%B5%96%29%2C%20nonempty%20%28F.obj%20j%29%5D%20-%2F%20%3A%20J%E1%B5%92%E1%B5%96%20%E2%A5%A4%20Type%20v%20%3A%3D%0Abegin%0A%20%20let%20bigger%20%3A%20%CE%A0%20%28j%20%3A%20J%E1%B5%92%E1%B5%96%29%2C%20set%20J%E1%B5%92%E1%B5%96%20%3A%3D%20%CE%BB%20j%2C%20%7Bi%20%3A%20J%E1%B5%92%E1%B5%96%20%7C%20j.unop%20%E2%89%A4%20i.unop%7D%2C%0A%20%20let%20Fsur_obj%20%3A%20%CE%A0%20%28j%20%3A%20J%E1%B5%92%E1%B5%96%29%2C%20set%20%28F.obj%20j%29%20%3A%3D%20%CE%BB%20j%2C%20%E2%8B%82%20%28i%20%3A%20bigger%20j%29%2C%20set.range%20%28F.map%20%20%28op_hom_of_le%20i.prop%29%29%2C%0A%0A%20%20have%20subfunctor%20%3A%20%CE%A0%20%28i%20j%20%3A%20J%E1%B5%92%E1%B5%96%29%20%28hij%20%3A%20i%20%E2%9F%B6%20j%29%2C%20set.maps_to%20%28F.map%20hij%29%20%28Fsur_obj%20i%29%20%28Fsur_obj%20j%29%2C%20by%0A%20%20%7B%20rintro%20i%20j%20hij%2C%0A%20%20%20%20rintro%20x%20h%2C%0A%20%20%20%20%2F-%0A%20%20%20%20Assume%20x%20%E2%88%88%20Fsur_obj%20i.%20Need%20to%20show%20F.map%20hij%20x%20%E2%88%88%20Fsur_obj%20j.%0A%20%20%20%20This%20amounts%20to%20showing%20that%20for%20all%20kj%20%3A%20k%20%E2%9F%B6%20j%2C%20F.map%20hij%20x%20%E2%88%88%20set.range%20%28F.map%20kj%29%0A%20%20%20%20-%2F%0A%20%20%20%20suffices%20h%20%3A%20%E2%88%80%20%28k%20%3A%20bigger%20j%29%2C%20F.map%20hij%20x%20%E2%88%88%20set.range%20%28F.map%20%28op_hom_of_le%20k.prop%29%29%2C%0A%20%20%20%20%7B%20rw%20set.mem_Inter%2C%0A%20%20%20%20%20%20exact%20h%2C%20%7D%2C%0A%20%20%20%20rintros%20%E2%9F%A8k%2Ckj%E2%9F%A9%2C%0A%20%20%20%20simp%20only%20%5Bset.mem_set_of_eq%5D%20at%20kj%2C%0A%20%20%20%20obtain%20%E2%9F%A8l'%2Clk'%2Cli'%E2%9F%A9%20%3A%3D%20directed_of%20%28%E2%89%A4%29%20k.unop%20i.unop%2C%0A%20%20%20%20let%20l%20%3A%3D%20opposite.op%20l'%2C%0A%20%20%20%20have%20lk%20%3A%20opposite.unop%20k%20%E2%89%A4%20opposite.unop%20l%2C%20by%20%7Bsimp%2Cexact%20lk'%7D%2C%0A%20%20%20%20have%20li%20%3A%20opposite.unop%20i%20%E2%89%A4%20opposite.unop%20l%2C%20by%20%7Bsimp%2Cexact%20li'%7D%2C%0A%20%20%20%20let%20hlk%20%3A%3D%20op_hom_of_le%20lk%2C%0A%20%20%20%20let%20hli%20%3A%3D%20op_hom_of_le%20li%2C%0A%20%20%20%20let%20hkj%20%3A%3D%20op_hom_of_le%20kj%2C%0A%20%20%20%20simp%20only%20%5Bset.mem_Inter%2C%20set.mem_range%5D%20at%20h%2C%0A%20%20%20%20obtain%20%E2%9F%A8y%2Crfl%E2%9F%A9%20%3A%3D%20h%20%E2%9F%A8l%2Cli%E2%9F%A9%2C%0A%20%20%20%20simp%20only%20%5Bset.mem_range%5D%2C%0A%20%20%20%20use%20F.map%20hlk%20y%2C%0A%20%20%20%20simp%20*%2C%0A%20%20%20%20refine%20%40eq.trans%20_%20_%20%28F.map%20%28hlk%20%E2%89%AB%20hkj%29%20y%29%20_%20_%20_%2C%0A%20%20%20%20%7B%20simp%20*%2C%0A%20%20%20%20%20%20dsimp%2Csorry%2C%0A%20%20%20%20%7D%2C%0A%20%20%20%20%7B%20have%20%3A%20hlk%20%E2%89%AB%20hkj%20%3D%20hli%20%E2%89%AB%20hij%2C%20by%20%7B%20simp%20only%20%5Beq_iff_true_of_subsingleton%5D%2C%20%7D%2C%0A%20%20%20%20%20%20rw%20this%2C%0A%20%20%20%20%20%20simp%2C%0A%20%20%20%20%20%20sorry%2C%0A%20%20%20%20%7D%2C%0A%20%20%7D%2C%0A%20%20refine%20%E2%9F%A8%28%CE%BB%20j%2C%20subtype%20%28Fsur_obj%20j%29%29%2C_%2C_%2C_%E2%9F%A9%2C%0A%20%20%7B%20rintro%20j'%20j%20m%2C%20exact%20set.maps_to.restrict%20_%20_%20_%20%28subfunctor%20j'%20j%20m%29%7D%2C%0A%20%20%7B%20rintro%20j%2C%0A%20%20%20%20apply%20funext%2C%0A%20%20%20%20rintro%20%E2%9F%A8x%2Cxh%E2%9F%A9%2C%0A%20%20%20%20rw%20%E2%86%90subtype.coe_inj%2C%0A%20%20%20%20simp%20only%20%5Bcategory_theory.functor.map_id%2C%20set.maps_to.coe_restrict_apply%2C%20category_theory.types_id_apply%5D%2C%7D%2C%0A%20%20%7B%20rintro%20j%20j'%20j''%20m%20m'%2C%0A%20%20%20%20apply%20funext%2C%0A%20%20%20%20rintro%20%E2%9F%A8x%2Cxh%E2%9F%A9%2C%0A%20%20%20%20rw%20%E2%86%90subtype.coe_inj%2C%0A%20%20%20%20simp%20only%20%5Bcategory_theory.functor.map_comp%2C%20set.maps_to.coe_restrict_apply%2C%20category_theory.types_comp_apply%5D%2C%7D%2C%0Aend">here</a> and I'm having trouble showing what should be obvious, or so I thought. What am I doing wrong here?<br>
To be a bit more precise, at some point I have the goal </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">F.map</span> <span class="o">(</span><span class="n">op_hom_of_le</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">F.map</span> <span class="o">(</span><span class="n">op_hom_of_le</span> <span class="n">lk</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">F.map</span> <span class="o">(</span><span class="n">op_hom_of_le</span> <span class="n">kj</span><span class="o">)</span> <span class="o">(</span><span class="n">F.map</span> <span class="o">(</span><span class="n">op_hom_of_le</span> <span class="n">lk</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>
<p>where I would swear the <code>_</code> should be a shorthand for <code>op_hom_of_le kj</code>, thus making the goal trivial. I can't pinpoint the reason it isn't the case, and I didn't figure out how to ask lean to tell me what exactly should be at the <code>_</code>.<br>
Ah, I might as well paste the whole goal context:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">J</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">preorder</span> <span class="n">J</span><span class="o">,</span>
<span class="n">_inst_2</span> <span class="o">:</span> <span class="n">is_directed</span> <span class="n">J</span> <span class="n">has_le.le</span><span class="o">,</span>
<span class="n">F</span> <span class="o">:</span> <span class="n">J</span><span class="bp">ᵒᵖ</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">,</span>
<span class="n">bigger</span> <span class="o">:</span> <span class="n">J</span><span class="bp">ᵒᵖ</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">J</span><span class="bp">ᵒᵖ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="bp">ᵒᵖ</span><span class="o">),</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">J</span><span class="bp">ᵒᵖ</span> <span class="bp">|</span> <span class="n">opposite.unop</span> <span class="n">j</span> <span class="bp">≤</span> <span class="n">opposite.unop</span> <span class="n">i</span><span class="o">},</span>
<span class="n">Fsur_obj</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="bp">ᵒᵖ</span><span class="o">),</span> <span class="n">set</span> <span class="o">(</span><span class="n">F.obj</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="bp">ᵒᵖ</span><span class="o">),</span> <span class="bp">⋂</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">↥</span><span class="o">(</span><span class="n">bigger</span> <span class="n">j</span><span class="o">)),</span> <span class="n">set.range</span> <span class="o">(</span><span class="n">F.map</span> <span class="o">(</span><span class="n">op_hom_of_le</span> <span class="n">_</span><span class="o">)),</span>
<span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="bp">ᵒᵖ</span><span class="o">,</span>
<span class="n">hij</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">j</span><span class="o">,</span>
<span class="n">k</span> <span class="o">:</span> <span class="n">J</span><span class="bp">ᵒᵖ</span><span class="o">,</span>
<span class="n">kj</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">∈</span> <span class="n">bigger</span> <span class="n">j</span><span class="o">,</span>
<span class="n">kj</span> <span class="o">:</span> <span class="n">opposite.unop</span> <span class="n">j</span> <span class="bp">≤</span> <span class="n">opposite.unop</span> <span class="n">k</span><span class="o">,</span>
<span class="n">l'</span> <span class="o">:</span> <span class="n">J</span><span class="o">,</span>
<span class="n">lk'</span> <span class="o">:</span> <span class="n">opposite.unop</span> <span class="n">k</span> <span class="bp">≤</span> <span class="n">l'</span><span class="o">,</span>
<span class="n">li'</span> <span class="o">:</span> <span class="n">opposite.unop</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">l'</span><span class="o">,</span>
<span class="n">l</span> <span class="o">:</span> <span class="n">J</span><span class="bp">ᵒᵖ</span> <span class="o">:=</span> <span class="n">opposite.op</span> <span class="n">l'</span><span class="o">,</span>
<span class="n">lk</span> <span class="o">:</span> <span class="n">opposite.unop</span> <span class="n">k</span> <span class="bp">≤</span> <span class="n">opposite.unop</span> <span class="n">l</span><span class="o">,</span>
<span class="n">li</span> <span class="o">:</span> <span class="n">opposite.unop</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">opposite.unop</span> <span class="n">l</span><span class="o">,</span>
<span class="n">hlk</span> <span class="o">:</span> <span class="n">l</span> <span class="bp">⟶</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">op_hom_of_le</span> <span class="n">lk</span><span class="o">,</span>
<span class="n">hli</span> <span class="o">:</span> <span class="n">l</span> <span class="bp">⟶</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">op_hom_of_le</span> <span class="n">li</span><span class="o">,</span>
<span class="n">hkj</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">⟶</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">op_hom_of_le</span> <span class="n">kj</span><span class="o">,</span>
<span class="n">y</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="bp">↑</span><span class="o">⟨</span><span class="n">l</span><span class="o">,</span> <span class="n">li</span><span class="o">⟩,</span>
<span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i_1</span> <span class="o">:</span> <span class="bp">↥</span><span class="o">(</span><span class="n">bigger</span> <span class="n">i</span><span class="o">)),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y_1</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="bp">↑</span><span class="n">i_1</span><span class="o">),</span> <span class="n">F.map</span> <span class="o">(</span><span class="n">op_hom_of_le</span> <span class="n">_</span><span class="o">)</span> <span class="n">y_1</span> <span class="bp">=</span> <span class="n">F.map</span> <span class="o">(</span><span class="n">op_hom_of_le</span> <span class="n">_</span><span class="o">)</span> <span class="n">y</span>
<span class="bp">⊢</span> <span class="n">F.map</span> <span class="o">(</span><span class="n">op_hom_of_le</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">F.map</span> <span class="o">(</span><span class="n">op_hom_of_le</span> <span class="n">lk</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">F.map</span> <span class="o">(</span><span class="n">op_hom_of_le</span> <span class="n">kj</span><span class="o">)</span> <span class="o">(</span><span class="n">F.map</span> <span class="o">(</span><span class="n">op_hom_of_le</span> <span class="n">lk</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>



<a name="291903084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Trouble%20with%20composition%20of%20maps%20for%20a%20functor%20over%20a%20preord/near/291903084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Trouble.20with.20composition.20of.20maps.20for.20a.20functor.20over.20a.20preord.html#291903084">(Aug 03 2022 at 18:44)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">functor_to_types.map_comp_apply</span><span class="o">,</span> <span class="bp">←</span> <span class="n">functor_to_types.map_comp_apply</span><span class="o">],</span>
<span class="n">refl</span>
</code></pre></div>
<p>solves the particular goal you described.</p>



<a name="291903126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Trouble%20with%20composition%20of%20maps%20for%20a%20functor%20over%20a%20preord/near/291903126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Trouble.20with.20composition.20of.20maps.20for.20a.20functor.20over.20a.20preord.html#291903126">(Aug 03 2022 at 18:44)</a>:</h4>
<p>Or even a single <code>refl</code> suffices if I am not mistaken.</p>



<a name="291903487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Trouble%20with%20composition%20of%20maps%20for%20a%20functor%20over%20a%20preord/near/291903487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Trouble.20with.20composition.20of.20maps.20for.20a.20functor.20over.20a.20preord.html#291903487">(Aug 03 2022 at 18:48)</a>:</h4>
<p>Huh, it's very confusing, I tried things very close to that. So my intuition was correct? that is, the underscore really was <code>op_hom_of_le kj</code>?</p>



<a name="291904101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Trouble%20with%20composition%20of%20maps%20for%20a%20functor%20over%20a%20preord/near/291904101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Trouble.20with.20composition.20of.20maps.20for.20a.20functor.20over.20a.20preord.html#291904101">(Aug 03 2022 at 18:53)</a>:</h4>
<p>You can click on the <code>_</code> in the info view to see the hidden term. In this case it is <code>subtype.prop ⟨k, kj⟩</code> which is definitionally equal to <code>kj</code>, but not syntactically equal, so <code>dsimp</code> did not close the goal for you.</p>
<p>In fact, due to proof irrelavence, two Props are defeq whenever they have the same type, so it doesn't even matter what the term is (and hence it is hidden in the infoview).</p>



<a name="291904532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Trouble%20with%20composition%20of%20maps%20for%20a%20functor%20over%20a%20preord/near/291904532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Trouble.20with.20composition.20of.20maps.20for.20a.20functor.20over.20a.20preord.html#291904532">(Aug 03 2022 at 18:56)</a>:</h4>
<p>OK, that does match my intuition, thanks a lot! So, what I did wrong was essentially to not try for <code>refl</code> early enough, since I _did_ have defeq terms?</p>



<a name="291906744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Trouble%20with%20composition%20of%20maps%20for%20a%20functor%20over%20a%20preord/near/291906744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Trouble.20with.20composition.20of.20maps.20for.20a.20functor.20over.20a.20preord.html#291906744">(Aug 03 2022 at 19:14)</a>:</h4>
<p>Probably yes. It never hurts to try <code>refl</code>.<br>
This is how I would approach <code>subfunctor</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">{</span> <span class="n">rintro</span> <span class="n">i</span> <span class="n">j</span> <span class="n">hij</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="n">x</span> <span class="n">h</span> <span class="n">s</span> <span class="o">⟨⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">l</span><span class="o">,</span><span class="n">lk</span><span class="o">,</span><span class="n">li</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">directed_of</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="n">k.unop</span> <span class="n">i.unop</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">set.mem_Inter</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="o">⟨</span><span class="n">opposite.op</span> <span class="n">l</span><span class="o">,</span> <span class="n">li</span><span class="o">⟩,</span>
    <span class="n">use</span> <span class="n">F.map</span> <span class="o">(</span><span class="n">hom_of_le</span> <span class="n">lk</span><span class="o">)</span><span class="bp">.</span><span class="n">op</span> <span class="n">y</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">functor_to_types.map_comp_apply</span><span class="o">,</span> <span class="bp">←</span> <span class="n">functor_to_types.map_comp_apply</span><span class="o">],</span>
    <span class="n">refl</span> <span class="o">},</span>
</code></pre></div>



<a name="291969483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Trouble%20with%20composition%20of%20maps%20for%20a%20functor%20over%20a%20preord/near/291969483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Trouble.20with.20composition.20of.20maps.20for.20a.20functor.20over.20a.20preord.html#291969483">(Aug 04 2022 at 06:25)</a>:</h4>
<p>I'm also wondering: The following doesn't typecheck. That's because of the lifting involved in the instantiation of <code>J</code> as a category, am I right?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">J</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">J</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="bp">ᵒᵖ</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span> <span class="kd">by</span> <span class="n">reflexivity</span>
</code></pre></div>
<p>And the following does typecheck:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">J</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">J</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="bp">ᵒᵖ</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">≫</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="n">j</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">≫</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>becauses it forces the passage through a Prop. That's fun</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
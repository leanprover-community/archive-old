---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html">type of nonempty finset?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="203871753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203871753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vaibhav Karve <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203871753">(Jul 14 2020 at 18:48)</a>:</h4>
<p>Given a type <code>A</code>, how do I represent the type of all nonempty finsets of <code>A</code>. Is it <code>inhabited (finset A)</code> or <code>nonempty (finset A)</code> or something completely different?</p>



<a name="203872031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203872031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203872031">(Jul 14 2020 at 18:51)</a>:</h4>
<p>(deleted)</p>



<a name="203872415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203872415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203872415">(Jul 14 2020 at 18:55)</a>:</h4>
<p><code>{ s : finset A // s ≠ ∅ }</code></p>



<a name="203872496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203872496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203872496">(Jul 14 2020 at 18:56)</a>:</h4>
<p><span class="user-mention" data-user-id="252300">@Jalex Stark</span> If you want <code>nonempty</code>, maybe <code>{s : finset A // nonempty (↑s : set A)}</code>.  I think I like Kenny's more, though.</p>



<a name="203872555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203872555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203872555">(Jul 14 2020 at 18:56)</a>:</h4>
<p><code>s.nonempty</code> avoids all that coercion</p>



<a name="203872579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203872579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203872579">(Jul 14 2020 at 18:56)</a>:</h4>
<p>but yes, i also like the version with <code>\ne</code></p>



<a name="203872632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203872632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203872632">(Jul 14 2020 at 18:57)</a>:</h4>
<p>Oh, didn't know about that.  <code>{s : finset A // s.nonempty}</code></p>



<a name="203872796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203872796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203872796">(Jul 14 2020 at 18:58)</a>:</h4>
<p><code>s.nonempty</code> is approximately equal to <code>finset.nonempty s</code></p>



<a name="203872863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203872863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203872863">(Jul 14 2020 at 18:59)</a>:</h4>
<p>I wonder if the <code>s.nonempty</code> version might be better in practice because you get a witness, and you don't have to rewrite with <code>nonempty_iff_ne_empty</code>.</p>



<a name="203872870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203872870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203872870">(Jul 14 2020 at 18:59)</a>:</h4>
<p>you also see things like <code>n.succ</code> for <code>nat.succ n</code> sometimes, though I think many people find the latter form preferable</p>



<a name="203872911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203872911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203872911">(Jul 14 2020 at 18:59)</a>:</h4>
<p>Sorry, I just meant I didn't know about <code>finset.nonempty</code>.</p>



<a name="203874356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203874356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vaibhav Karve <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203874356">(Jul 14 2020 at 19:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> that works perfectly. Thanks!</p>



<a name="203879944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203879944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vaibhav Karve <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203879944">(Jul 14 2020 at 19:58)</a>:</h4>
<p>I have a new problem now:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">constant</span> <span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kn">constant</span> <span class="n">myset</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">A</span> <span class="bp">//</span> <span class="n">x</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">}</span>
<span class="kn">constant</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">myset</span>
</code></pre></div>


<p>This final check gives me the error</p>
<div class="codehilite"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span> <span class="n">for</span>
<span class="err">⊢</span> <span class="n">has_mem</span> <span class="n">A</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">x</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">}</span>
</code></pre></div>


<p>How do I create this instance <code>has_mem</code>? I think I somehow need to derive it using <code>finset.has_mem</code>?</p>



<a name="203883711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203883711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203883711">(Jul 14 2020 at 20:30)</a>:</h4>
<p>The <code>subtype</code> doesn't inherit any of the instances from <code>finset</code>, and I think you have to manually derive all the ones you want yourself (as far as I know).  One thing you can do without doing that is write <code>a ∈ myset.val</code> instead.</p>



<a name="203884176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203884176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vaibhav Karve <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203884176">(Jul 14 2020 at 20:33)</a>:</h4>
<p>Phew. I will do that. I definitely don't want to derive these instances by hand if I can avoid it.</p>



<a name="203884337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203884337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203884337">(Jul 14 2020 at 20:34)</a>:</h4>
<p>Remember that the <code>{ ... // ... }</code> notation is shorthand for this type:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">subtype</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">property</span> <span class="o">:</span> <span class="n">p</span> <span class="n">val</span><span class="o">)</span>
</code></pre></div>


<p>It bundles together a value with the property the value satisfies.  Depending on what you're doing, it might be easier to make all your functions/lemmas take two arguments: <code>(x : finset A) (h : x.nonempty)</code></p>



<a name="203884350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203884350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203884350">(Jul 14 2020 at 20:34)</a>:</h4>
<p>What are you actually trying to do?</p>



<a name="203884396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203884396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203884396">(Jul 14 2020 at 20:34)</a>:</h4>
<p>All those <code>constant</code> are not in your real code, right?</p>



<a name="203884638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203884638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203884638">(Jul 14 2020 at 20:36)</a>:</h4>
<p>Why not just write the instances you want by hand?</p>



<a name="203885435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203885435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203885435">(Jul 14 2020 at 20:42)</a>:</h4>
<p>There's only \in and maybe \subset, right?</p>



<a name="203886383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203886383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vaibhav Karve <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203886383">(Jul 14 2020 at 20:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F/near/203884396">said</a>:</p>
<blockquote>
<p>All those <code>constant</code> are not in your real code, right?</p>
</blockquote>
<p>Right. This was just for the sake of the MWE.</p>



<a name="203886884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203886884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vaibhav Karve <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203886884">(Jul 14 2020 at 20:54)</a>:</h4>
<p>Slightly larger MWE to show what I am doing:</p>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm">Define CNFs in Lean-/</span>

<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">bool</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>
<span class="kn">import</span> <span class="n">tactic</span>


<span class="kn">variables</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span>


<span class="c">/-</span><span class="cm">Literals of V are either positive V, negative V, or booleans.-/</span>
<span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">decidable_eq</span><span class="o">]</span>
<span class="kn">inductive</span> <span class="n">Lit</span>
<span class="bp">|</span> <span class="n">pos</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">Lit</span>
<span class="bp">|</span> <span class="n">neg</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">Lit</span>
<span class="bp">|</span> <span class="n">bool</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">Lit</span>

<span class="n">def</span> <span class="n">neg</span> <span class="o">:</span> <span class="n">Lit</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">Lit</span> <span class="n">V</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Lit</span><span class="bp">.</span><span class="n">pos</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Lit</span><span class="bp">.</span><span class="n">neg</span> <span class="n">v</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Lit</span><span class="bp">.</span><span class="n">neg</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Lit</span><span class="bp">.</span><span class="n">pos</span> <span class="n">v</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Lit</span><span class="bp">.</span><span class="n">bool</span> <span class="n">tt</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Lit</span><span class="bp">.</span><span class="n">bool</span> <span class="n">ff</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Lit</span><span class="bp">.</span><span class="n">bool</span> <span class="n">ff</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Lit</span><span class="bp">.</span><span class="n">bool</span> <span class="n">tt</span>

<span class="c">/-</span><span class="cm">A Clause is a non-empty, finite set of Literals of V.-/</span>
<span class="kn">structure</span> <span class="n">Clause</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">lits</span> <span class="o">:</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">Lit</span> <span class="n">V</span><span class="o">)</span> <span class="bp">//</span> <span class="n">c</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">})</span>

<span class="c">/-</span><span class="cm">A Cnf is a non-empty, finite set of Clauses of V.-/</span>
<span class="kn">structure</span> <span class="n">Cnf</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">clauses</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">Clause</span> <span class="n">V</span><span class="o">)</span> <span class="bp">//</span> <span class="n">x</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">})</span>
</code></pre></div>



<a name="203887172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203887172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vaibhav Karve <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203887172">(Jul 14 2020 at 20:56)</a>:</h4>
<p>Another thing I am unsure about is if I should make defs instead of structures.</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">Clause</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">Lit</span> <span class="n">V</span><span class="o">)</span> <span class="bp">//</span> <span class="n">c</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">}</span>
</code></pre></div>



<a name="203887280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203887280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vaibhav Karve <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203887280">(Jul 14 2020 at 20:57)</a>:</h4>
<p>Cnf stands for <em>conjunctive normal form</em></p>



<a name="203887298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203887298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203887298">(Jul 14 2020 at 20:57)</a>:</h4>
<p>Does a CNF actually need to be nonempty?</p>



<a name="203887648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203887648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203887648">(Jul 14 2020 at 21:00)</a>:</h4>
<p>There's also the consideration of using lists instead of finsets.  A finset is a list with no duplicates modulo permutations, but a specific CNF might be an actual expression in a specific order.  You could have lemmas that say you can reorder things while preserving satisfiability.</p>



<a name="203887739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203887739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203887739">(Jul 14 2020 at 21:01)</a>:</h4>
<p>I forgot to mention that you might not need the no duplicates assumption.  You could have additional lemmas that let you deduplicate literals or clauses in the CNF.</p>



<a name="203888214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203888214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203888214">(Jul 14 2020 at 21:05)</a>:</h4>
<p>(Just for completeness: you could interpret an empty clause as being false, and an empty CNF as being true.  If I remember correctly, these sorts of things can naturally occur over the course of SAT solving.)</p>



<a name="203890020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203890020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vaibhav Karve <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203890020">(Jul 14 2020 at 21:21)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> <br>
I agree with everything you have said. However, I am trying to build towards to type of all "reduced" CNFs i.e. CNFs that have been reduced under the following tautologies:</p>
<ul>
<li><code>a ∨ a = a</code></li>
<li><code>a ∧ a = a</code></li>
<li><code>a ∨ ¬ a = ⊤</code></li>
<li><code>a ∧ ¬ a = ⊥</code><br>
If I implement them as lists instead of finsets then I will have to define these recursive maps simplification maps, right? And then I'll have to prove that once all the tautology-rewriting is done then the resultant has no duplicates. And then I will finally be able to create a reduced CNF type. Hence I thought I will use finsets to enforce tautologies 1 and 2 from the very beginning.</li>
</ul>



<a name="203891976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203891976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203891976">(Jul 14 2020 at 21:40)</a>:</h4>
<p>Don't you need to allow the empty lists to represent the true clause / false formula, then?</p>



<a name="203891982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203891982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203891982">(Jul 14 2020 at 21:40)</a>:</h4>
<p><span class="user-mention" data-user-id="241485">@Vaibhav Karve</span> Take what I'm saying with a grain of salt because I haven't done enough Lean, but I would probably go through the following:</p>
<ul>
<li>Define the unreduced version of a CNF</li>
<li>Define what it means for a clause to be reduced (see <code>list.nodup</code>)</li>
<li>Define what it means for a CNF to be reduced</li>
<li>Define a subtype of reduced CNFs</li>
<li>Define a function <code>reduce</code> that reduces a CNF (and prove <code>reduce</code> results in a reduced CNF)</li>
<li>Define a satisfying assignment and the set of satisfying assignments for a CNF</li>
<li>Show that the set of satisfying assignments is unchanged after <code>reduce</code>.  Then you'll have some confidence the definitions are good.</li>
</ul>
<p>A complication with <code>finset</code> is that it is a quotient.  If you use <code>finset</code> instead of <code>list</code>, then you are going to have to deal with expressions being defined only up to permutation all the time.  If you really want this property, that two CNFs are equal even after permuting clauses and variables, then you might instead define an equivalence relation on CNFs (a <code>setoid</code> instance) and take the <code>quotient</code>, after the above work.</p>



<a name="203893652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20of%20nonempty%20finset%3F/near/203893652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vaibhav Karve <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20of.20nonempty.20finset.3F.html#203893652">(Jul 14 2020 at 21:59)</a>:</h4>
<p>Thank you so much for that detailed outline. I am going to follow the <code>list</code> path.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
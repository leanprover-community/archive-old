---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html">Efficiently unfolding notation</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="197793073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793073">(May 16 2020 at 12:18)</a>:</h4>
<p>How is one supposed to unfold notation that comes from type classes? E.g. :</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">not_mem_mem_compl</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">S</span><span class="o">))</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="o">(</span><span class="bp">-</span> <span class="n">S</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>


<p>I want to be able to unfold the notation <code>-S</code> using the definition of <code>compl</code>, so I would write <code>unfold compl</code>. This doesn't work, as I need to also tell it to unfold <code>has_neg.neg</code>, as the <code>-</code> notation is given for compl as an instance of the type class <code>has_neg</code>. Is there a better way to do this than <code>unfold has_neg.neg compl</code>? I want to be able to think of the notation as an abbreviation for <code>compl</code>, but here it is demanding an extra step. It doesn't seem similar steps are necessary for the notation <code>+</code> on <code>nat</code>, which is introduced the same way, with <code>has_add</code>. Is there an attribute I can give something so that <code>unfold</code> knows to incorporate <code>has_neg</code>?</p>



<a name="197793092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793092">(May 16 2020 at 12:19)</a>:</h4>
<p>Three backticks and then a newline</p>



<a name="197793101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793101">(May 16 2020 at 12:20)</a>:</h4>
<p>Thanks, fixed it.</p>



<a name="197793146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793146">(May 16 2020 at 12:20)</a>:</h4>
<p>I think you also need these two steps to unfold <code>+</code> on nats, no?</p>



<a name="197793156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793156">(May 16 2020 at 12:20)</a>:</h4>
<p>Or maybe the difference is <code>+</code> has an equational lemma which is phrased in terms of the notation?</p>



<a name="197793176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793176">(May 16 2020 at 12:21)</a>:</h4>
<p>Because you probably only want to unfold <code>+</code> when you're also applying one of the two defining equations.</p>



<a name="197793181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793181">(May 16 2020 at 12:21)</a>:</h4>
<p>Why does this work?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">):=</span>
<span class="k">begin</span>
    <span class="n">refl</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="197793189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793189">(May 16 2020 at 12:21)</a>:</h4>
<p>Because <code>refl</code> works up to definitional equality</p>



<a name="197793235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793235">(May 16 2020 at 12:22)</a>:</h4>
<p>Er, well okay the exact reason is a bit complicated</p>



<a name="197793239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793239">(May 16 2020 at 12:22)</a>:</h4>
<p>If you said <code>exact rfl</code>, then the reason would be that <code>exact</code> works up to definitional equality</p>



<a name="197793243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793243">(May 16 2020 at 12:22)</a>:</h4>
<p>How does <code>refl</code> know to access <code>has_add.add</code> while <code>unfold</code> and <code>dunfold</code> doesn't?</p>



<a name="197793252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793252">(May 16 2020 at 12:23)</a>:</h4>
<p><code>refl</code> doesn't know anything about <code>has_add</code></p>



<a name="197793279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793279">(May 16 2020 at 12:23)</a>:</h4>
<p><code>refl</code> says: the goal is equality, so I'll supply <code>eq.rfl</code> as the proof term</p>



<a name="197793293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793293">(May 16 2020 at 12:23)</a>:</h4>
<p>and <code>eq.rfl : 1 + 0 = 1</code>, so Lean is happy</p>



<a name="197793357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793357">(May 16 2020 at 12:25)</a>:</h4>
<p>In order to check this <code>eq.rfl : 1 + 0 = 1</code>, Lean knows that <code>+</code> is notation for <code>has_add.add</code> and it knows how to reduce <code>has_add.add</code> applied to the <code>has_add</code> instance for <code>nat</code> to get <code>nat.add</code>, and then how to unfold <code>nat.add</code> to its definition in terms of <code>nat.rec</code>, and then how to reduce <code>nat.rec</code> applied to <code>0</code>, etc. But this is all happening outside the tactic layer.</p>



<a name="197793369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793369">(May 16 2020 at 12:25)</a>:</h4>
<p>On the other hand, <code>unfold</code> means: replace the named thing with its definition (possibly applying equational lemmas).</p>



<a name="197793411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793411">(May 16 2020 at 12:26)</a>:</h4>
<p>You didn't give an example involving <code>+</code> and <code>unfold</code>, so it's not analogous.</p>



<a name="197793420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793420">(May 16 2020 at 12:26)</a>:</h4>
<p>So in some sense <code>refl</code> is "smarter" or has access to more stuff than <code>unfold' (but as you say it's all happening outside of tactic layer). So </code>refl<code> can figure out definitions that </code>unfold` can't without being fed them explicitly?</p>



<a name="197793427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793427">(May 16 2020 at 12:27)</a>:</h4>
<p>If anything, <code>refl</code> is dumber.</p>



<a name="197793432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793432">(May 16 2020 at 12:27)</a>:</h4>
<p>There are several layers at work here, and several different notions of equality.</p>



<a name="197793476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793476">(May 16 2020 at 12:28)</a>:</h4>
<p>And your point about not having an example of <code>+</code> and <code>unfold</code> is fair; you made me realize why I thought you didn't need the two unfolding steps for <code>nat</code>, which was wrong, but that led to the question about <code>refl</code>.</p>



<a name="197793486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793486">(May 16 2020 at 12:28)</a>:</h4>
<p>If you don't mind, whenever you say <code>refl</code>, I'll pretend you said <code>exact rfl</code>, since that cuts out an irrelevant step (deciding which kind of reflexivity to use).</p>



<a name="197793502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793502">(May 16 2020 at 12:29)</a>:</h4>
<p>I think I'm getting the general picture now. My final question about this topic is how you would prove the (trivial) theorem above:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">not_mem_mem_compl</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">S</span><span class="o">))</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="o">(</span><span class="bp">-</span> <span class="n">S</span><span class="o">)</span>
</code></pre></div>



<a name="197793513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793513">(May 16 2020 at 12:29)</a>:</h4>
<p><code>exact</code> is a tactic that uses the term you give it to close the goal. The term only has to match the goal up to definitional equality, which means up to unfolding anything that needs unfolding.</p>



<a name="197793554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793554">(May 16 2020 at 12:30)</a>:</h4>
<p>Noting that</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">compl</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">a</span> <span class="bp">|</span> <span class="n">a</span> <span class="err">∉</span> <span class="n">s</span><span class="o">}</span>
</code></pre></div>



<a name="197793557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793557">(May 16 2020 at 12:30)</a>:</h4>
<p>Well, one way is just <code>:= h</code></p>



<a name="197793577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793577">(May 16 2020 at 12:31)</a>:</h4>
<p>or <code>:= by exact h</code>--this takes advantage of definitional equality</p>



<a name="197793586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793586">(May 16 2020 at 12:31)</a>:</h4>
<p>Ok, because everything holds definitionally, exact can figure it out.</p>



<a name="197793591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793591">(May 16 2020 at 12:31)</a>:</h4>
<p>alternatively, there is probably already a lemma which says precisely this</p>



<a name="197793598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793598">(May 16 2020 at 12:31)</a>:</h4>
<p>Probably named something like <code>mem_compl</code> or <code>mem_compl_iff</code></p>



<a name="197793646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793646">(May 16 2020 at 12:32)</a>:</h4>
<p>Using that is better practice in principle, since it insulates you from the specific definition of <code>compl</code></p>



<a name="197793654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197793654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197793654">(May 16 2020 at 12:32)</a>:</h4>
<p>Yeah, I just wanted an example. Thanks for your help! I think (most of) my confusion has been resolved. And your last comment makes sense.</p>



<a name="197794665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Efficiently%20unfolding%20notation/near/197794665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Efficiently.20unfolding.20notation.html#197794665">(May 16 2020 at 12:59)</a>:</h4>
<p>In the natural number game, <code>zero_add</code> is a theorem which is proved by induction, but <code>add_zero</code> can be proved by <code>refl</code>. Definitional equality is not mathematical, in some sense; it depends on exactly how an object is defined, rather than the way a mathematician thinks about it (where there might be several different definitions of one thing, all equivalent).</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
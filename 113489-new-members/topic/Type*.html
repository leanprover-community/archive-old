---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Type*.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html">Type*</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="184686187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184686187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Enrico Borba <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#184686187">(Jan 02 2020 at 21:33)</a>:</h4>
<p>Hi, thank you all for the awesome work done on Lean. I have been messing with it for the past month or so, and I'm absolutely amazed by it. Quick question: what does <code>Type*</code> mean? I haven't encountered an asterisk like that before, and first encountered it when reading Logic and Proof after doing all of the exercises in TPiL.</p>



<a name="184686474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184686474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#184686474">(Jan 02 2020 at 21:36)</a>:</h4>
<p>It usually means <code>Type u</code> where <code>u</code> is a universe variable. Basically it lets Lean choose the universe, and it usually chooses the most polymorphic option.</p>



<a name="184686544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184686544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Enrico Borba <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#184686544">(Jan 02 2020 at 21:37)</a>:</h4>
<p>Oh interesting. Is this a more general notation that can be used elsewhere or is it specific to being a placeholder for universes?</p>



<a name="184689349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184689349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#184689349">(Jan 02 2020 at 22:24)</a>:</h4>
<p>I think it's just <code>Type*</code> and <code>Sort*</code>. I think <code>Type*</code> might be the same as <code>Type _</code> and underscores can be used in a lot of places</p>



<a name="184715911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184715911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#184715911">(Jan 03 2020 at 07:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span>  Does this means that if I don't want to go through the universe details, then I can use Type * or Type _ ?</p>



<a name="184718394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184718394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#184718394">(Jan 03 2020 at 08:40)</a>:</h4>
<p>Yes. <code>Type*</code> is what is used most of the time to avoid having to think about universes.</p>



<a name="184828115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184828115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#184828115">(Jan 05 2020 at 01:35)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span>  Sorry for disturbing you, but could you please tell me that why the second one is not accepted by Lean? <br>
This is accepted by Lean:</p>
<div class="codehilite"><pre><span></span>universe u
class Associative {G : Type u} (f : G → G → G) : Type u :=
(Hassoc : ∀ x y z : G, f (f x y) z = f x (f y z))
</pre></div>


<p>But this one not:</p>
<div class="codehilite"><pre><span></span>class Associative {G : Type _} (f : G → G → G) : Type _ :=
(Hassoc : ∀ x y z : G, f (f x y) z = f x (f y z))
</pre></div>



<a name="184828333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184828333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#184828333">(Jan 05 2020 at 01:42)</a>:</h4>
<p>I guess I was wrong about <code>Type*</code> being the same as <code>Type _</code>. <code>Type _</code> will probably try to infer from the context what the universe should be - it will fill it in with whatever it is forced to be, and will fail if there's nothing forcing it to be a particular universe. and <code>Type*</code> will fill it in with something sensible basically. I don't know the precise algorithms.</p>



<a name="184829264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184829264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#184829264">(Jan 05 2020 at 02:17)</a>:</h4>
<p>These are not the same; one uses <code>Type u</code> and the other uses <code>Type _</code>. I'm pretty sure that <code>Type*</code> and <code>Type _</code> are identical</p>



<a name="184829336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184829336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#184829336">(Jan 05 2020 at 02:19)</a>:</h4>
<p>The error message makes it clear what the problem is:</p>
<div class="codehilite"><pre><span></span>failed to add declaration &#39;Associative&#39; to environment, type has metavariables
</pre></div>


<p>It successfully unified, but it wasn't completely able to pin down the target type because this is also valid:</p>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>
<span class="n">class</span> <span class="n">Associative</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">37</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">Hassoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">(</span><span class="n">f</span> <span class="n">y</span> <span class="n">z</span><span class="o">))</span>
</pre></div>



<a name="184834481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184834481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mukesh Tiwari <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#184834481">(Jan 05 2020 at 05:20)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  Thanks for the answer. The purpose of the question was to avoid universe hierarchy, and let Lean figured out the universe; hence, I left the return type as Type _.  If I do not mention any return type, then it is fine. </p>
<div class="codehilite"><pre><span></span>class Associative {G : Type _} (f : G → G → G) :=
(Hassoc : ∀ x y z : G, f (f x y) z = f x (f y z))

#check Associative
returns Associative : (?M_1 → ?M_1 → ?M_1) → Type
</pre></div>


<p>Coming back to my question (also because of my Coq background), if I want to avoid the universe hierarchy, then what is the best way to go?</p>



<a name="184847581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184847581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#184847581">(Jan 05 2020 at 12:45)</a>:</h4>
<p><span class="user-mention" data-user-id="239476">@Mukesh Tiwari</span> This technique almost always works, but inductive types are special because you actually have to make a choice of what universe they should live in; the target type is only lower bounded, and different choices above that lead to different types. For definitions and theorems, the universe is uniquely determined from the inputs so you can use <code>Type*</code> consistently and lean will just figure everything out.</p>



<a name="198549633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198549633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198549633">(May 23 2020 at 20:01)</a>:</h4>
<p>What does <code>Type*</code> mean? I saw it in Mathlib (in particular <a href="https://github.com/leanprover-community/mathlib/blob/master/src/data/real/cau_seq.lean">https://github.com/leanprover-community/mathlib/blob/master/src/data/real/cau_seq.lean</a>). I couldn't find it in Theorem Proving in Lean or Lean Reference Manual. <code>#check Type*</code> prints <code>Type u_1 : Type (u_1+1)</code>, but what's <code>u_1</code>? <code>#check u_1</code> gives <code>unknown identifier 'u_1'</code>.</p>



<a name="198549888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198549888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198549888">(May 23 2020 at 20:07)</a>:</h4>
<p><code>Type*</code> means the same as <code>Type _</code>, that is, a type in an arbitrary universe</p>



<a name="198549948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198549948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198549948">(May 23 2020 at 20:08)</a>:</h4>
<p>However lean deals with universe metavariables a bit differently from regular metavariables; in particular if after elaborating the whole definition/theorem there are still outstanding universe metavariables, they are all converted to fresh universe variables (<code>u_1</code> in this case)</p>



<a name="198549992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198549992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198549992">(May 23 2020 at 20:09)</a>:</h4>
<p>It's basically an easy way to create universe polymorphic definitions/theorems without ever naming a universe (and needing to declare universes)</p>



<a name="198550037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198550037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198550037">(May 23 2020 at 20:10)</a>:</h4>
<p>What is the advantage/disadvantages of the following declarations at the beginning of your file then:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">universe</span> <span class="n">u</span>
<span class="kn">variable</span> <span class="o">{</span><span class="err">\</span><span class="n">alpha</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
</code></pre></div>


<p>vs.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variable</span> <span class="o">{</span><span class="err">\</span><span class="n">alpha</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
</code></pre></div>


<p>?</p>



<a name="198550059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198550059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198550059">(May 23 2020 at 20:11)</a>:</h4>
<p>In a variable, it actually does declare the universe variable as well. The second line is equivalent to the first line (except the universe is called <code>u_1</code> not <code>u</code>)</p>



<a name="198550065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198550065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198550065">(May 23 2020 at 20:11)</a>:</h4>
<p>I get the impression that it's more important to declare the universes explicitly when you have multiple of them, as happens in category theory work?</p>



<a name="198550106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198550106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198550106">(May 23 2020 at 20:12)</a>:</h4>
<p>The style I try to stick to in mathlib is to never declare universes unless necessary</p>



<a name="198550110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198550110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198550110">(May 23 2020 at 20:12)</a>:</h4>
<p>this is both less to type and also usually gets the right answer</p>



<a name="198550166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198550166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198550166">(May 23 2020 at 20:14)</a>:</h4>
<p>In category theory, there is the problem that <code>category</code> has an internal universe variable, so it sometimes doesn't get inferred correctly. I think this has been fixed in later versions of lean 3 so you might start to see those universe declarations disappear</p>



<a name="198550210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198550210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198550210">(May 23 2020 at 20:15)</a>:</h4>
<p>I have the following lines in the top of a file I'm working proving basic topology facts (just for practice, not for Mathlib).</p>
<div class="codehilite"><pre><span></span><code><span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">t</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">{</span><span class="n">δ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">t</span><span class="o">}</span>
</code></pre></div>


<p>Jalex's comment implies that there is no reason to have distinct universes for your different types, but there is more generality giving each type it's own universe, correct?</p>
<p>Would you instead declare this as:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span>  <span class="n">δ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
</code></pre></div>


<p>or perhaps as:</p>
<div class="codehilite"><pre><span></span><code><span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">δ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
</code></pre></div>


<p>Does the latter allow for each type to be in a distinct universe while the former doesn't?</p>



<a name="198550277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198550277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198550277">(May 23 2020 at 20:17)</a>:</h4>
<p>I would like to be able to write <code>variables {α β γ δ : Type*}</code> but there is an outstanding parser bug that causes this to fail (last I checked, <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> has this changed?)</p>



<a name="198550283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198550283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198550283">(May 23 2020 at 20:18)</a>:</h4>
<p>so you have to write <code>variables {α : Type*} {β : Type*} {γ : Type*} {δ : Type*}</code> instead</p>



<a name="198550331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198550331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198550331">(May 23 2020 at 20:18)</a>:</h4>
<p>But doesn't <code>variables {α β γ δ : Type*}</code> make the assumption that <code>α β γ δ </code> all have the same type, which is more restrictive than <code>variables {α : Type*} {β : Type*} {γ : Type*} {δ : Type*} </code>? (Assuming it worked)</p>



<a name="198550339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198550339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198550339">(May 23 2020 at 20:19)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I don't think anything has changed in this area recently.  PRs and/or issues are always welcome.</p>



<a name="198550360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198550360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198550360">(May 23 2020 at 20:19)</a>:</h4>
<p>The first line is equivalent to</p>
<div class="codehilite"><pre><span></span><code><span class="kn">universe</span> <span class="n">u_1</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span>
<span class="kn">universe</span> <span class="n">u_1</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span>
<span class="kn">universe</span> <span class="n">u_1</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span>
<span class="kn">universe</span> <span class="n">u_1</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">δ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span>
</code></pre></div>


<p>and lean complains about the redeclaration of <code>u_1</code></p>



<a name="198550403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198550403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198550403">(May 23 2020 at 20:20)</a>:</h4>
<p>however if it wasn't for that this would make them all different types</p>



<a name="198550415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198550415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198550415">(May 23 2020 at 20:20)</a>:</h4>
<p>If you do this in the binders of a def or theorem, it works fine</p>



<a name="198550434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198550434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198550434">(May 23 2020 at 20:22)</a>:</h4>
<p>It doesn't mean that they get the same type (admittedly this might be a bit counter intuitive). They get the same type pre-expression, that is <code>Type _</code>, but this is elaborated 4 times for 4 variables and so they are not related to each other</p>



<a name="198550895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198550895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198550895">(May 23 2020 at 20:34)</a>:</h4>
<p>One reason I've had to explicitly write universe variables is when formalising a universal property or more generally a property that involves quantifying over "all topological spaces" or some such thing: in lean this might translate to "all topological spaces in the same universe as the one you're talking about"</p>



<a name="198550925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198550925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198550925">(May 23 2020 at 20:35)</a>:</h4>
<p>There was a thread somewhere about a topological space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> being compact if and only if the projection <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>×</mo><mi>Y</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\times Y\to Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> was closed for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> and here one could not get away with <code>Type*</code></p>



<a name="198550989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198550989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198550989">(May 23 2020 at 20:37)</a>:</h4>
<p>PS <span class="user-mention" data-user-id="300684">@Keefer Rowan</span> did you try <code>variables {a b c d : Type*}</code> before you wrote your guess about what it did?</p>



<a name="198551255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198551255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198551255">(May 23 2020 at 20:43)</a>:</h4>
<p>No, but Mario's comment made it clear this wouldn't work, so I was wondering how it was supposed to work. And interesting example, I see how it could help to be explicit there.</p>



<a name="198551794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/198551794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type*.html#198551794">(May 23 2020 at 20:58)</a>:</h4>
<p>One day hopefully it will make them all have different universes, because this is by far the most common use case.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
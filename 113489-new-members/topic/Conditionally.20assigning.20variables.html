---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Conditionally.20assigning.20variables.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html">Conditionally assigning variables</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="208598325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208598325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208598325">(Aug 31 2020 at 18:38)</a>:</h4>
<p>Hi,</p>
<p>I have written this MWE to illustrate my question.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">test</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">∨</span> <span class="n">q</span> <span class="bp">=</span> <span class="mi">5</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">5</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">p</span><span class="o">,</span>
        <span class="n">left</span><span class="o">,</span>
        <span class="n">use</span> <span class="n">n</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">h1</span>
    <span class="o">},</span>
    <span class="o">{</span>
        <span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">q</span><span class="o">,</span>
        <span class="n">right</span><span class="o">,</span>
        <span class="n">use</span> <span class="n">n</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">h2</span>
    <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>


<p>I would like to write a proof that was closer to:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">test</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">∨</span> <span class="n">q</span> <span class="bp">=</span> <span class="mi">5</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">5</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">hi</span> <span class="n">hi</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">p</span><span class="o">,</span>
        <span class="n">left</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
        <span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">q</span><span class="o">,</span>
        <span class="n">right</span><span class="o">,</span>
    <span class="o">}</span>
   <span class="n">use</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hi</span>
<span class="kn">end</span>
</code></pre></div>


<p>How would I do that?</p>



<a name="208598603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208598603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208598603">(Aug 31 2020 at 18:40)</a>:</h4>
<p>And what exactly is the question <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> ?</p>



<a name="208598685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208598685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208598685">(Aug 31 2020 at 18:40)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">lemma</span> <span class="n">test</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">∨</span> <span class="n">q</span> <span class="bp">=</span> <span class="mi">5</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">5</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">use</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">left</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h1</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">use</span> <span class="n">q</span><span class="o">,</span>
    <span class="n">right</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h2</span> <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208598756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208598756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208598756">(Aug 31 2020 at 18:41)</a>:</h4>
<p><code>or.elim</code>?</p>



<a name="208598910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208598910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208598910">(Aug 31 2020 at 18:42)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> this works for this example, but I want something general. I want to apply a bunch of tactics to the two goals that I obtain from the cases, after I set some variables for example.</p>



<a name="208599005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208599005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208599005">(Aug 31 2020 at 18:43)</a>:</h4>
<p>Here is the proof that I really have (you can ignore what key_lemma is for the purpose of this question).</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">pr_dvd_xm1_or_xp1</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span><span class="o">))</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h_odd</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">tactic</span><span class="bp">.</span><span class="n">unfreeze_local_instances</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">key_lemma</span> <span class="n">x</span> <span class="n">h</span> <span class="k">with</span> <span class="n">hp</span> <span class="n">hm</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="k">let</span> <span class="n">ε</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span>
        <span class="n">left</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">part1</span> <span class="n">ε</span> <span class="n">h</span> <span class="n">h_odd</span><span class="o">,</span>
        <span class="n">dec_trivial</span><span class="o">,</span>
        <span class="n">exact_mod_cast</span> <span class="n">hp</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
        <span class="k">let</span> <span class="n">ε</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span>
        <span class="n">right</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">part1</span> <span class="n">ε</span> <span class="n">h</span> <span class="n">h_odd</span><span class="o">,</span>
        <span class="n">dec_trivial</span><span class="o">,</span>
        <span class="n">exact_mod_cast</span> <span class="n">hm</span><span class="o">,</span>
    <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208599016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208599016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208599016">(Aug 31 2020 at 18:43)</a>:</h4>
<p><span class="user-mention" data-user-id="254058">@Marc Masdeu</span> You mean that you want to apply the same tactics to both goals, after doing some groundwork?</p>



<a name="208599183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208599183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208599183">(Aug 31 2020 at 18:44)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> exactly, in the proof I set epsilon to either 1 or -1, then the rest is the same.</p>



<a name="208599269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208599269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208599269">(Aug 31 2020 at 18:45)</a>:</h4>
<p><code>cases foobar with h h; [use 1; left, use -1; right]; { tactics, for, both, goals }</code></p>



<a name="208599304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208599304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208599304">(Aug 31 2020 at 18:45)</a>:</h4>
<p>Note that you have a <code>hp</code> in the first goal, and <code>hm</code> in the second.</p>



<a name="208599309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208599309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208599309">(Aug 31 2020 at 18:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Conditionally.20assigning.20variables/near/208598756">said</a>:</p>
<blockquote>
<p><code>or.elim</code>?</p>
</blockquote>
<p>Maybe it's doable with this? I'll have to look closer...</p>



<a name="208599360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208599360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208599360">(Aug 31 2020 at 18:46)</a>:</h4>
<p>You will have to give <code>hp</code> and <code>hm</code> the same name, so that you can call <code>exact_mod_cast same_name</code> in both branches.</p>



<a name="208599440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208599440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208599440">(Aug 31 2020 at 18:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/Conditionally.20assigning.20variables/near/208599360">said</a>:</p>
<blockquote>
<p>You will have to give <code>hp</code> and <code>hm</code> the same name, so that you can call <code>exact_mod_cast same_name</code> in both branches.</p>
</blockquote>
<p>Yes, I was assuming I'd have to do that. Great!! I was looking for the syntax with the square brackets and so on...</p>



<a name="208599487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208599487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208599487">(Aug 31 2020 at 18:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="254058">Marc Masdeu</span> <a href="#narrow/stream/113489-new-members/topic/Conditionally.20assigning.20variables/near/208599309">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Conditionally.20assigning.20variables/near/208598756">said</a>:</p>
<blockquote>
<p><code>or.elim</code>?</p>
</blockquote>
<p>Maybe it's doable with this? I'll have to look closer...</p>
</blockquote>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">test</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">∨</span> <span class="n">q</span> <span class="bp">=</span> <span class="mi">5</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">5</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">h</span><span class="bp">⟩</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">q</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="n">h</span><span class="bp">⟩</span><span class="o">)</span>
</code></pre></div>



<a name="208599522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208599522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208599522">(Aug 31 2020 at 18:47)</a>:</h4>
<p>but this is essentially what's going on in your original proof :)</p>



<a name="208599525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208599525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208599525">(Aug 31 2020 at 18:47)</a>:</h4>
<p>Alternative:</p>
<div class="codehilite"><pre><span></span><code><span class="n">cases</span> <span class="n">foobar</span> <span class="k">with</span> <span class="n">hp</span> <span class="n">hm</span><span class="o">,</span>
<span class="n">use</span> <span class="mi">1</span><span class="o">,</span> <span class="n">left</span>
<span class="n">swap</span><span class="o">,</span>
<span class="n">use</span> <span class="bp">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span>
<span class="n">all_goals</span> <span class="o">{</span>
<span class="n">apply</span> <span class="n">part1</span> <span class="n">e</span> <span class="n">h</span> <span class="n">h_odd</span><span class="o">,</span>
<span class="n">dec_trivial</span><span class="o">,</span>
<span class="n">assumption_mod_cast</span>
<span class="o">}</span>
</code></pre></div>



<a name="208599737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208599737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208599737">(Aug 31 2020 at 18:49)</a>:</h4>
<p>Is there a lemma that distributes the <code>\Ex</code> over the <code>\or</code>?</p>



<a name="208599975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208599975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208599975">(Aug 31 2020 at 18:50)</a>:</h4>
<p>The first solutions is giving me trouble... I want to set \epsilon to either 1 or -1, so I don't want to use "use".</p>



<a name="208600264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208600264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208600264">(Aug 31 2020 at 18:53)</a>:</h4>
<p>This doesn't work:</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">cases</span> <span class="o">(</span><span class="n">key_lemma</span> <span class="n">x</span> <span class="n">h</span><span class="o">)</span> <span class="k">with</span> <span class="n">hkl</span> <span class="n">hkl</span><span class="bp">;</span> <span class="o">[</span><span class="k">let</span> <span class="n">ε</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span><span class="bp">;</span> <span class="n">left</span><span class="o">,</span> <span class="k">let</span> <span class="n">ε</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span><span class="bp">;</span> <span class="n">right</span><span class="o">],</span>
    <span class="o">{</span>
        <span class="n">apply</span> <span class="n">part1</span> <span class="n">ε</span> <span class="n">h</span> <span class="n">h_odd</span><span class="o">,</span>
        <span class="n">dec_trivial</span><span class="o">,</span>
        <span class="n">exact_mod_cast</span> <span class="n">hkl</span><span class="o">,</span>
    <span class="o">},</span>
</code></pre></div>


<p>It says "focus' tactic failed, insufficient number of tactics"</p>



<a name="208608591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208608591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208608591">(Aug 31 2020 at 20:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/Conditionally.20assigning.20variables/near/208599737">said</a>:</p>
<blockquote>
<p>Is there a lemma that distributes the <code>\Ex</code> over the <code>\or</code>?</p>
</blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/exists_or_distrib">docs#exists_or_distrib</a></p>



<a name="208608771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208608771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208608771">(Aug 31 2020 at 20:06)</a>:</h4>
<p><span class="user-mention" data-user-id="254058">@Marc Masdeu</span>  what happens if you use a <code>;</code> instead of <code>,</code> after the <code>[ ...  ]</code> block?</p>



<a name="208608830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208608830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208608830">(Aug 31 2020 at 20:07)</a>:</h4>
<p>Use <code>exists_or_distrib</code> you can do something like:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">logic</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">lemma</span> <span class="n">test</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">∨</span> <span class="n">q</span> <span class="bp">=</span> <span class="mi">5</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">5</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">exists_or_distrib</span><span class="o">],</span> <span class="n">refine</span> <span class="n">h</span><span class="bp">.</span><span class="n">imp</span> <span class="bp">_</span> <span class="bp">_;</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">h2</span><span class="o">,</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">h2</span><span class="bp">⟩</span> <span class="o">}</span>
</code></pre></div>



<a name="208648568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208648568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208648568">(Sep 01 2020 at 06:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/Conditionally.20assigning.20variables/near/208599525">said</a>:</p>
<blockquote>
<p>Alternative:</p>
<div class="codehilite"><pre><span></span><code><span class="n">cases</span> <span class="n">foobar</span> <span class="k">with</span> <span class="n">hp</span> <span class="n">hm</span><span class="o">,</span>
<span class="n">use</span> <span class="mi">1</span><span class="o">,</span> <span class="n">left</span>
<span class="n">swap</span><span class="o">,</span>
<span class="n">use</span> <span class="bp">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span>
<span class="n">all_goals</span> <span class="o">{</span>
<span class="n">apply</span> <span class="n">part1</span> <span class="n">e</span> <span class="n">h</span> <span class="n">h_odd</span><span class="o">,</span>
<span class="n">dec_trivial</span><span class="o">,</span>
<span class="n">assumption_mod_cast</span>
<span class="o">}</span>
</code></pre></div>


</blockquote>
<p>This one is the kind of solution that I was looking for! (I couldn't make to work the other one you gave me).</p>
<p>Thanks all!</p>



<a name="208649084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208649084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208649084">(Sep 01 2020 at 06:32)</a>:</h4>
<p><span class="user-mention" data-user-id="254058">@Marc Masdeu</span> you might also like the <code>work_on_goal</code> tactic.</p>



<a name="208696459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208696459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208696459">(Sep 01 2020 at 14:40)</a>:</h4>
<p>Yes <span class="user-mention" data-user-id="112680">@Johan Commelin</span>, that was liked indeed. Here is the proof in a more readable format:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">pr_dvd_xm1_or_xp1</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span><span class="o">))</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h_odd</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">tactic</span><span class="bp">.</span><span class="n">unfreeze_local_instances</span><span class="o">,</span>
    <span class="n">cases</span> <span class="o">(</span><span class="n">key_lemma</span> <span class="n">x</span> <span class="n">h</span><span class="o">)</span> <span class="k">with</span> <span class="n">hkl</span> <span class="n">hkl</span><span class="o">,</span>
    <span class="n">work_on_goal</span> <span class="mi">0</span>
    <span class="o">{</span>
        <span class="k">let</span> <span class="n">ε</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span>
        <span class="n">left</span>
    <span class="o">},</span>
    <span class="n">work_on_goal</span> <span class="mi">1</span>
    <span class="o">{</span>
        <span class="k">let</span> <span class="n">ε</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span>
        <span class="n">right</span>
    <span class="o">},</span>
    <span class="n">all_goals</span> <span class="o">{</span>
        <span class="n">apply</span> <span class="n">part1</span> <span class="n">ε</span> <span class="n">h</span> <span class="n">h_odd</span><span class="o">,</span>
        <span class="n">dec_trivial</span><span class="o">,</span>
        <span class="n">exact_mod_cast</span> <span class="n">hkl</span><span class="o">,</span>
    <span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208696822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208696822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208696822">(Sep 01 2020 at 14:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/Conditionally.20assigning.20variables/near/208608771">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="254058">Marc Masdeu</span>  what happens if you use a <code>;</code> instead of <code>,</code> after the <code>[ ...  ]</code> block?</p>
</blockquote>
<p>It still didn't work :-(. I like the answer provided by <span class="user-mention" data-user-id="112680">@Johan Commelin</span>, since it's the most readable (to me, at least).</p>



<a name="208700938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208700938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208700938">(Sep 01 2020 at 15:09)</a>:</h4>
<p>Do you mind sharing <code>key_lemma</code> and <code>part1</code>? I want to try some <code>refine</code> tactics.</p>



<a name="208715809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208715809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208715809">(Sep 01 2020 at 16:49)</a>:</h4>
<p>The proofs are super long, and I am sure that they can be simplified a whole lot...sorry for that!</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">subgroup</span>
<span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">coset</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">finite</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">zmod</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">gcd_monoid</span>
<span class="kn">import</span> <span class="n">basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">big_operators</span>
<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">p</span> <span class="n">r</span> <span class="n">n</span> <span class="n">m</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">fact</span> <span class="n">p</span><span class="bp">.</span><span class="n">prime</span><span class="o">]</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)]</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">m</span><span class="o">)]</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">≤</span> <span class="n">r</span><span class="o">)]</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="bp">^</span><span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pos_pow_of_pos</span> <span class="n">r</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">prime</span><span class="bp">.</span><span class="n">pos</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">key_lemma</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span><span class="o">))</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">tactic</span><span class="bp">.</span><span class="n">unfreeze_local_instances</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="n">p</span><span class="o">,</span> <span class="k">by</span> <span class="n">assumption</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span><span class="bp">^</span><span class="n">r</span> <span class="err">∣</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">rw</span> <span class="err">←</span><span class="n">sub_eq_zero</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">h&#39;</span> <span class="o">:</span> <span class="o">(((</span><span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">zmod</span><span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">finish</span><span class="o">,</span>
        <span class="n">apply_mod_cast</span> <span class="o">(</span><span class="n">zmod</span><span class="bp">.</span><span class="n">int_coe_zmod_eq_zero_iff_dvd</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">h&#39;</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span><span class="mi">1</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">w</span> <span class="n">h1w</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">h1w</span><span class="o">,</span>
        <span class="n">ring</span><span class="o">,</span>
        <span class="n">fconstructor</span><span class="o">,</span>
        <span class="n">use</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="o">(</span><span class="n">r</span><span class="bp">-</span><span class="mi">1</span><span class="o">))</span> <span class="bp">*</span> <span class="n">w</span><span class="o">,</span>
        <span class="n">rw</span> <span class="err">←</span> <span class="n">int</span><span class="bp">.</span><span class="n">mul_assoc</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">hp</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span><span class="bp">^</span><span class="n">r</span> <span class="bp">=</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">p</span><span class="bp">^</span><span class="o">(</span><span class="n">r</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span>
        <span class="o">{</span>
            <span class="n">cases</span> <span class="n">r</span><span class="o">,</span>
            <span class="n">norm_num</span><span class="o">,</span>
            <span class="n">exfalso</span><span class="o">,</span>
            <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_asymm</span> <span class="bp">_</span><span class="n">inst_4</span> <span class="bp">_</span><span class="n">inst_4</span><span class="o">,</span>
            <span class="n">induction</span> <span class="n">r</span> <span class="k">with</span> <span class="n">d</span> <span class="n">cases</span> <span class="bp">_</span><span class="n">inst_4</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
            <span class="o">{</span>
                <span class="n">ring</span><span class="o">,</span>
                <span class="n">ring</span><span class="o">,</span>
            <span class="o">}</span>
        <span class="o">},</span>
        <span class="n">rw</span> <span class="err">←</span><span class="n">hp</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">mul_comm</span> <span class="n">w</span> <span class="o">(</span><span class="err">↑</span><span class="n">p</span> <span class="bp">^</span> <span class="n">r</span><span class="o">),</span>
    <span class="o">},</span>
    <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="k">have</span> <span class="n">hfac</span> <span class="o">:</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span><span class="mi">1</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="k">by</span> <span class="n">ring</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">hfac</span> <span class="n">at</span> <span class="n">h2</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">int</span><span class="bp">.</span><span class="n">prime</span><span class="bp">.</span><span class="n">dvd_mul&#39;</span> <span class="n">hp</span> <span class="n">h2</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="n">cases</span> <span class="n">h3</span> <span class="k">with</span> <span class="n">h3l</span> <span class="n">h3r</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">left</span><span class="o">,</span>
        <span class="n">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">sub_eq_zero</span><span class="bp">.</span><span class="n">mp</span> <span class="n">this</span><span class="o">,</span>
        <span class="n">rw</span><span class="err">←</span> <span class="n">zmod</span><span class="bp">.</span><span class="n">int_coe_zmod_eq_zero_iff_dvd</span> <span class="o">(</span><span class="n">x</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="n">p</span> <span class="n">at</span> <span class="n">h3l</span><span class="o">,</span>
        <span class="n">push_cast</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">h3l</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
        <span class="n">right</span><span class="o">,</span>
        <span class="n">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">eq_neg_of_add_eq_zero</span> <span class="n">this</span><span class="o">,</span>
        <span class="n">rw</span><span class="err">←</span> <span class="n">zmod</span><span class="bp">.</span><span class="n">int_coe_zmod_eq_zero_iff_dvd</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">p</span> <span class="n">at</span> <span class="n">h3r</span><span class="o">,</span>
        <span class="n">push_cast</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">h3r</span><span class="o">,</span>
    <span class="o">}</span>
<span class="kn">end</span>


<span class="kn">lemma</span> <span class="n">part1</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">ε</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span><span class="o">))</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h_odd</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">h_eps</span> <span class="o">:</span> <span class="n">ε</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="n">ε</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ε</span> <span class="bp">→</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="o">(</span><span class="n">x</span><span class="bp">-</span><span class="n">ε</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">tactic</span><span class="bp">.</span><span class="n">unfreeze_local_instances</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">p_ne_zero</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
        <span class="k">by</span> <span class="n">exact_mod_cast</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span><span class="bp">.</span><span class="n">ne_zero</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h_prdiv</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="o">(</span><span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">),</span>
    <span class="o">{</span>
        <span class="n">rw</span> <span class="err">←</span><span class="n">eq_iff_n_divides&#39;</span><span class="o">,</span>
        <span class="n">exact_mod_cast</span> <span class="n">h</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="k">have</span> <span class="n">h_fact</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">p</span><span class="bp">^</span><span class="o">(</span><span class="n">r</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span>
        <span class="k">by</span> <span class="n">exact_mod_cast</span> <span class="o">(</span><span class="bp">@</span><span class="n">pr_eq_p_mul_pr1</span> <span class="n">p</span> <span class="n">r</span> <span class="bp">_</span><span class="n">inst_1</span> <span class="bp">_</span><span class="n">inst_4</span><span class="o">),</span>
    <span class="n">cases</span> <span class="n">h_prdiv</span> <span class="k">with</span> <span class="n">f</span> <span class="n">hf</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hp</span><span class="o">,</span>
    <span class="n">replace</span> <span class="n">hp</span> <span class="o">:</span> <span class="o">((</span><span class="n">x</span> <span class="bp">-</span> <span class="n">ε</span> <span class="o">:</span><span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">exact_mod_cast</span> <span class="n">sub_eq_zero</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">hp</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">zero_iff_n_divides&#39;</span> <span class="n">at</span> <span class="n">hp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hp</span> <span class="k">with</span> <span class="n">e</span> <span class="n">he</span><span class="o">,</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="o">(</span><span class="n">r</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="n">e</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">cases</span> <span class="n">this</span> <span class="k">with</span> <span class="n">f</span> <span class="n">hf</span><span class="o">,</span>
        <span class="n">use</span> <span class="n">f</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">he</span><span class="o">,</span> <span class="n">hf</span><span class="o">,</span> <span class="err">←</span><span class="n">mul_assoc</span><span class="o">,</span> <span class="err">←</span><span class="n">h_fact</span><span class="o">],</span>
    <span class="o">},</span>
    <span class="k">have</span> <span class="n">hcalc</span> <span class="o">:=</span>
        <span class="k">calc</span>
        <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">p</span> <span class="bp">^</span> <span class="o">(</span><span class="n">r</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p</span><span class="bp">^</span><span class="n">r</span> <span class="bp">*</span> <span class="n">f</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">mul_assoc</span><span class="o">,</span> <span class="n">h_fact</span><span class="o">]</span>
        <span class="bp">...</span>    <span class="bp">=</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">hf</span>
        <span class="bp">...</span>    <span class="bp">=</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">ε</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:</span> <span class="k">by</span> <span class="o">{</span><span class="n">cases</span> <span class="n">h_eps</span><span class="bp">;</span> <span class="n">finish</span><span class="o">}</span>
        <span class="bp">...</span>    <span class="bp">=</span> <span class="o">(</span><span class="n">x</span><span class="bp">-</span><span class="n">ε</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">2</span><span class="bp">*</span><span class="n">ε</span><span class="bp">*</span><span class="o">(</span><span class="n">x</span><span class="bp">-</span><span class="n">ε</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">ring</span>
        <span class="bp">...</span>    <span class="bp">=</span>  <span class="o">(</span><span class="n">p</span> <span class="bp">*</span> <span class="n">e</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">ε</span> <span class="bp">*</span> <span class="o">(</span><span class="n">p</span><span class="bp">*</span><span class="n">e</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">he</span> <span class="n">at</span> <span class="bp">*</span>
        <span class="bp">...</span>    <span class="bp">=</span> <span class="n">p</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">ε</span> <span class="bp">*</span> <span class="n">e</span> <span class="bp">+</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">e</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span>  <span class="o">:</span> <span class="k">by</span> <span class="n">ring</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mul_right_inj&#39;</span> <span class="n">p_ne_zero</span> <span class="n">at</span> <span class="n">hcalc</span><span class="o">,</span>
    <span class="n">replace</span> <span class="n">hcalc</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="o">(</span><span class="n">r</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">ε</span> <span class="bp">*</span> <span class="n">e</span> <span class="bp">+</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">e</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:=</span> <span class="n">dvd</span><span class="bp">.</span><span class="n">intro</span> <span class="n">f</span> <span class="n">hcalc</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">,</span> <span class="n">mul_comm</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="n">pow_two</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="err">←</span><span class="n">mul_add</span> <span class="n">e</span><span class="o">]</span> <span class="n">at</span> <span class="n">hcalc</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">p_not_dvd_2pe</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">ε</span> <span class="bp">+</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">p</span><span class="o">),</span>
    <span class="o">{</span>
        <span class="n">rintro</span> <span class="bp">⟨</span> <span class="n">s</span><span class="o">,</span> <span class="n">hs</span> <span class="bp">⟩</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">p_dvd_2</span> <span class="o">:</span> <span class="n">p</span> <span class="err">∣</span> <span class="mi">2</span><span class="o">,</span>
        <span class="o">{</span>
            <span class="n">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="mi">2</span><span class="o">,</span> <span class="k">from</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_dvd_left</span><span class="bp">.</span><span class="n">mp</span> <span class="n">this</span><span class="o">,</span>
            <span class="n">use</span> <span class="n">ε</span> <span class="bp">*</span> <span class="o">(</span><span class="n">s</span><span class="bp">-</span><span class="n">e</span><span class="o">),</span>
            <span class="n">rw</span> <span class="n">mul_sub</span><span class="o">,</span>
            <span class="n">cases</span> <span class="n">h_eps</span><span class="bp">;</span>
            <span class="o">{</span>
                <span class="n">rw</span> <span class="n">h_eps</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
                <span class="n">ring</span><span class="o">,</span>
                <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mul_one</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">mul_neg_eq_neg_mul_symm</span><span class="o">]</span> <span class="n">at</span> <span class="n">hs</span><span class="o">,</span>
                <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mul_sub</span><span class="o">,</span> <span class="n">neg_sub_neg</span><span class="o">],</span>
                <span class="n">rw</span> <span class="err">←</span><span class="n">hs</span><span class="o">,</span>
                <span class="n">ring</span><span class="o">,</span>
            <span class="o">},</span>
        <span class="o">},</span>
        <span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime_dvd_prime_iff_eq</span>  <span class="bp">_</span><span class="n">inst_1</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime_two</span> <span class="n">at</span> <span class="n">p_dvd_2</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">p_dvd_2</span> <span class="n">at</span> <span class="n">h_odd</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_asymm</span> <span class="n">h_odd</span> <span class="n">h_odd</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="k">have</span> <span class="n">h_coprime</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="o">(</span><span class="n">r</span><span class="bp">-</span><span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="n">coprime</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">ε</span> <span class="bp">+</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">nat_abs</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">suffices</span> <span class="o">:</span> <span class="n">p</span><span class="bp">.</span><span class="n">coprime</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">ε</span> <span class="bp">+</span> <span class="n">e</span> <span class="bp">*</span><span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">nat_abs</span><span class="o">,</span> <span class="k">from</span> <span class="n">nat</span><span class="bp">.</span><span class="n">coprime</span><span class="bp">.</span><span class="n">pow_left</span> <span class="o">(</span><span class="n">r</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="n">this</span><span class="o">,</span>
        <span class="n">refine</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">prime</span><span class="bp">.</span><span class="n">coprime_iff_not_dvd</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="bp">_</span><span class="o">,</span>
        <span class="n">intro</span> <span class="n">hc</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">p_not_dvd_2pe</span><span class="o">,</span>
        <span class="n">rw</span> <span class="err">←</span><span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_dvd_left</span> <span class="n">at</span> <span class="n">hc</span><span class="o">,</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">hc</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="k">have</span> <span class="n">pow_div_abs</span> <span class="o">:</span> <span class="n">p</span><span class="bp">^</span><span class="o">(</span><span class="n">r</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="err">∣</span> <span class="n">e</span><span class="bp">.</span><span class="n">nat_abs</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">apply</span> <span class="n">nat</span><span class="bp">.</span><span class="n">coprime</span><span class="bp">.</span><span class="n">dvd_of_dvd_mul_right</span> <span class="n">h_coprime</span><span class="o">,</span>
        <span class="n">rw</span> <span class="err">←</span><span class="n">int</span><span class="bp">.</span><span class="n">nat_abs_mul</span><span class="o">,</span>
        <span class="n">cases</span> <span class="n">hcalc</span> <span class="k">with</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
        <span class="n">use</span> <span class="n">s</span><span class="bp">.</span><span class="n">nat_abs</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">hs</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">nat_abs_mul</span><span class="o">],</span>
        <span class="n">norm_cast</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="n">cases</span> <span class="n">pow_div_abs</span> <span class="k">with</span> <span class="n">t</span> <span class="n">ht</span><span class="o">,</span>
    <span class="n">use</span> <span class="o">(</span><span class="n">t</span> <span class="bp">*</span> <span class="n">e</span><span class="bp">.</span><span class="n">sign</span><span class="o">),</span>
    <span class="n">replace</span> <span class="n">ht</span> <span class="o">:</span> <span class="n">e</span><span class="bp">.</span><span class="n">sign</span> <span class="bp">*</span> <span class="n">abs</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">p</span><span class="bp">^</span><span class="o">(</span><span class="n">r</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">t</span> <span class="bp">*</span> <span class="n">e</span><span class="bp">.</span><span class="n">sign</span><span class="o">),</span>
    <span class="o">{</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">int</span><span class="bp">.</span><span class="n">abs_eq_nat_abs</span><span class="o">,</span> <span class="n">ht</span><span class="o">],</span>
        <span class="n">finish</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="n">rw</span> <span class="n">int</span><span class="bp">.</span><span class="n">sign_mul_abs</span> <span class="n">e</span> <span class="n">at</span> <span class="n">ht</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">ht</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208719092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208719092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208719092">(Sep 01 2020 at 17:16)</a>:</h4>
<p>I know you didn't ask but I read through your proofs that could be simplified and made some tweaks to maybe make it simpler, but still with the same proof strategy. Hope something here is useful to you!</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">key_lemma</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span><span class="o">))</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">haveI</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="n">p</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">assumption</span><span class="o">,</span>
    <span class="c1">-- using haveI casesI tactics instead of unfreezing local instances</span>
    <span class="c1">-- personally i like this more when it works, as tactic.unfreeze_local_instances isnt a mathematical proof step</span>
    <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span><span class="bp">^</span><span class="n">r</span> <span class="err">∣</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">rw</span> <span class="err">←</span><span class="n">sub_eq_zero</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">h&#39;</span> <span class="o">:</span> <span class="o">(((</span><span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">zmod</span><span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">finish</span><span class="o">,</span>
        <span class="n">apply_mod_cast</span> <span class="o">(</span><span class="n">zmod</span><span class="bp">.</span><span class="n">int_coe_zmod_eq_zero_iff_dvd</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">h&#39;</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span><span class="mi">1</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">w</span> <span class="n">h1w</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">h1w</span><span class="o">,</span>
        <span class="c1">-- ring wasn&#39;t doing anything now</span>
        <span class="c1">-- fconstructor isnt needed lean works out what you want to use</span>
        <span class="n">use</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="o">(</span><span class="n">r</span><span class="bp">-</span><span class="mi">1</span><span class="o">))</span> <span class="bp">*</span> <span class="n">w</span><span class="o">,</span>
        <span class="n">rw</span> <span class="err">←</span> <span class="n">int</span><span class="bp">.</span><span class="n">mul_assoc</span><span class="o">,</span>
        <span class="n">congr</span><span class="o">,</span> <span class="c1">-- just a simpler way of ending up in the same place you did, two things times w are equal because the two things were</span>
        <span class="n">casesI</span> <span class="n">r</span><span class="o">,</span>
        <span class="n">norm_num</span><span class="o">,</span>
        <span class="n">exfalso</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_asymm</span> <span class="bp">_</span><span class="n">inst_4</span> <span class="bp">_</span><span class="n">inst_4</span><span class="o">,</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ_sub_succ_eq_sub</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">sub_zero</span><span class="o">],</span> <span class="c1">-- simp and then library search</span>
        <span class="n">exact</span> <span class="n">pow_succ</span> <span class="err">↑</span><span class="n">p</span> <span class="n">r</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="k">have</span> <span class="n">hfac</span> <span class="o">:</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span><span class="mi">1</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="k">by</span> <span class="n">ring</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">hfac</span> <span class="n">at</span> <span class="n">h2</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">int</span><span class="bp">.</span><span class="n">prime</span><span class="bp">.</span><span class="n">dvd_mul&#39;</span> <span class="n">hp</span> <span class="n">h2</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="n">cases</span> <span class="n">h3</span> <span class="k">with</span> <span class="n">h3l</span> <span class="n">h3r</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">left</span><span class="o">,</span>
        <span class="n">rw</span> <span class="err">←</span> <span class="n">sub_eq_zero</span><span class="o">,</span>
        <span class="c1">-- i removed suffices when the proof was simpler without, if its a long proof suffices is good</span>
        <span class="c1">-- but if its a one-liner in my opinion its clear enough just to rewrite</span>
        <span class="n">rw</span><span class="err">←</span> <span class="n">zmod</span><span class="bp">.</span><span class="n">int_coe_zmod_eq_zero_iff_dvd</span> <span class="o">(</span><span class="n">x</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="n">p</span> <span class="n">at</span> <span class="n">h3l</span><span class="o">,</span>
        <span class="n">assumption_mod_cast</span><span class="o">,</span> <span class="c1">-- combine a couple of steps</span>
    <span class="o">},</span>
    <span class="o">{</span>
        <span class="n">right</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">eq_neg_of_add_eq_zero</span><span class="o">,</span>
        <span class="n">rw</span><span class="err">←</span> <span class="n">zmod</span><span class="bp">.</span><span class="n">int_coe_zmod_eq_zero_iff_dvd</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">p</span> <span class="n">at</span> <span class="n">h3r</span><span class="o">,</span>
        <span class="n">assumption_mod_cast</span><span class="o">,</span> <span class="c1">-- combine a couple of steps</span>
    <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208725563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208725563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208725563">(Sep 01 2020 at 18:10)</a>:</h4>
<p>And here are the steps after <code>h3</code> that are simplified, in a way that uses the common structure:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">key_lemma</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span><span class="o">))</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">haveI</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="n">p</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">assumption</span><span class="o">,</span>
    <span class="c1">-- using haveI casesI tactics instead of unfreezing local instances</span>
    <span class="c1">-- personally i like this more when it works, as tactic.unfreeze_local_instances isnt a mathematical proof step</span>
    <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span><span class="bp">^</span><span class="n">r</span> <span class="err">∣</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">rw</span> <span class="err">←</span><span class="n">sub_eq_zero</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">h&#39;</span> <span class="o">:</span> <span class="o">(((</span><span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">zmod</span><span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">finish</span><span class="o">,</span>
        <span class="n">apply_mod_cast</span> <span class="o">(</span><span class="n">zmod</span><span class="bp">.</span><span class="n">int_coe_zmod_eq_zero_iff_dvd</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">h&#39;</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span><span class="mi">1</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">w</span> <span class="n">h1w</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">h1w</span><span class="o">,</span>
        <span class="c1">-- ring wasn&#39;t doing anything now</span>
        <span class="c1">-- fconstructor isnt needed lean works out what you want to use</span>
        <span class="n">use</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="o">(</span><span class="n">r</span><span class="bp">-</span><span class="mi">1</span><span class="o">))</span> <span class="bp">*</span> <span class="n">w</span><span class="o">,</span>
        <span class="n">rw</span> <span class="err">←</span> <span class="n">int</span><span class="bp">.</span><span class="n">mul_assoc</span><span class="o">,</span>
        <span class="n">congr</span><span class="o">,</span> <span class="c1">-- just a simpler way of ending up in the same place you did, two things times w are equal because the two things were</span>
        <span class="n">casesI</span> <span class="n">r</span><span class="o">,</span>
        <span class="n">norm_num</span><span class="o">,</span>
        <span class="n">exfalso</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_asymm</span> <span class="bp">_</span><span class="n">inst_4</span> <span class="bp">_</span><span class="n">inst_4</span><span class="o">,</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ_sub_succ_eq_sub</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">sub_zero</span><span class="o">],</span> <span class="c1">-- simp and then library search</span>
        <span class="n">exact</span> <span class="n">pow_succ</span> <span class="err">↑</span><span class="n">p</span> <span class="n">r</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="k">have</span> <span class="n">hfac</span> <span class="o">:</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span><span class="mi">1</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="k">by</span> <span class="n">ring</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">hfac</span> <span class="n">at</span> <span class="n">h2</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">int</span><span class="bp">.</span><span class="n">prime</span><span class="bp">.</span><span class="n">dvd_mul&#39;</span> <span class="n">hp</span> <span class="n">h2</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="err">←</span><span class="n">zmod</span><span class="bp">.</span><span class="n">int_coe_zmod_eq_zero_iff_dvd</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">cast_add</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">cast_one</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">cast_sub</span><span class="o">]</span> <span class="n">at</span> <span class="n">h3</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h3</span><span class="bp">.</span><span class="n">imp</span> <span class="n">sub_eq_zero</span><span class="bp">.</span><span class="n">mp</span> <span class="n">eq_neg_of_add_eq_zero</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208725702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208725702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208725702">(Sep 01 2020 at 18:10)</a>:</h4>
<p>Which uses the fact that <code>p</code> and the summands are inferrable.</p>



<a name="208726070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208726070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208726070">(Sep 01 2020 at 18:13)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> and <span class="user-mention" data-user-id="127136">@Alex J. Best</span> ! I had arrived at this version after reading Alex's improvements:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">key_lemma</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span><span class="o">))</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">haveI</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="n">p</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">assumption</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">sub_eq_zero</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw_mod_cast</span> <span class="n">zmod</span><span class="bp">.</span><span class="n">int_coe_zmod_eq_zero_iff_dvd</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h_p_dvd</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
    <span class="o">{</span>
        <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">w</span> <span class="n">hw</span><span class="o">,</span>
        <span class="n">ring</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">hw</span><span class="o">,</span>
        <span class="n">casesI</span> <span class="n">r</span><span class="o">,</span>
        <span class="o">{</span>
            <span class="n">exfalso</span><span class="o">,</span>
            <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_asymm</span> <span class="bp">_</span><span class="n">inst_4</span> <span class="bp">_</span><span class="n">inst_4</span><span class="o">,</span>
        <span class="o">},</span>
        <span class="o">{</span>
            <span class="n">refine</span> <span class="n">dvd_mul_of_dvd_left</span> <span class="bp">_</span> <span class="n">w</span><span class="o">,</span>
            <span class="n">use</span> <span class="n">p</span><span class="bp">^</span><span class="n">r</span><span class="o">,</span>
            <span class="n">exact</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_pow</span> <span class="n">p</span> <span class="o">(</span><span class="n">r</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
        <span class="o">}</span>
    <span class="o">},</span>
    <span class="n">cases</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">prime</span><span class="bp">.</span><span class="n">dvd_mul&#39;</span> <span class="n">hp</span> <span class="n">h_p_dvd</span><span class="o">)</span> <span class="k">with</span> <span class="n">h&#39;</span> <span class="n">h&#39;</span><span class="o">,</span>
    <span class="n">left</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">x&#39;</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">,</span>
    <span class="n">swap</span><span class="o">,</span>
    <span class="n">right</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">x&#39;</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
    <span class="n">all_goals</span>
    <span class="o">{</span>
        <span class="n">rw</span> <span class="err">←</span><span class="n">sub_eq_zero</span><span class="o">,</span>
        <span class="n">try</span> <span class="o">{</span><span class="n">ring</span><span class="o">},</span>
        <span class="n">rw</span><span class="err">←</span> <span class="n">zmod</span><span class="bp">.</span><span class="n">int_coe_zmod_eq_zero_iff_dvd</span> <span class="n">x&#39;</span> <span class="n">p</span> <span class="n">at</span> <span class="n">h&#39;</span><span class="o">,</span>
        <span class="n">assumption_mod_cast</span>
    <span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208726603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208726603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208726603">(Sep 01 2020 at 18:17)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> I don't see how I would get the last two lines of your proof. Plain simp did not succeed, and for the last line library_search didn't work either!</p>



<a name="208726894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208726894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208726894">(Sep 01 2020 at 18:20)</a>:</h4>
<p>I took Alex's proof and saw the common <code>zmod.int_coe_zmod_eq_zero_iff_dvd</code>. So I wanted to rw it in the <code>h3</code>, but didn't feel like doing <code>rw</code> twice or <code>repeat { rw ... }</code>. So I did <code>simp [&lt;-zmod.int_coe_zmod_eq_zero_iff_dvd _ p] at h3</code> prior to the <code>cases h3</code>.</p>



<a name="208726946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208726946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208726946">(Sep 01 2020 at 18:20)</a>:</h4>
<p>Then I changed it to a <code>squeeze_simp</code> which gave the more detailed and faster <code>simp only</code>.</p>



<a name="208727123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208727123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208727123">(Sep 01 2020 at 18:22)</a>:</h4>
<p>Then instead of <code>cases C, { left, ..., exact F }, { right, ..., exact G }</code>, one can try something like <code>refine or.imp _ _ C</code>, or using projection notation, <code>refine C.imp _ _</code>.</p>



<a name="208727269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208727269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208727269">(Sep 01 2020 at 18:22)</a>:</h4>
<p>Then you have two subgoals that you know how to solve. <code>rw &lt;-iff_lemma</code> is using the <code>iff_lemma.mpr</code> implication.</p>



<a name="208727301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208727301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208727301">(Sep 01 2020 at 18:23)</a>:</h4>
<p>So, a little bit of golfing.</p>



<a name="208727360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208727360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208727360">(Sep 01 2020 at 18:23)</a>:</h4>
<p>I'm not a fan of explicitly invoking <code>_inst_4</code>. Trying to find a way to hide that atm.</p>



<a name="208727711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208727711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208727711">(Sep 01 2020 at 18:26)</a>:</h4>
<p>I'm not familiar with the <code>zmod</code> side of the lib, is storing positivity or nonnegativity in <code>fact</code> instances the common way to do it there? As opposed to</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">(</span><span class="n">rpos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span><span class="o">)</span>
<span class="n">include</span> <span class="n">rpos</span>
</code></pre></div>



<a name="208727932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208727932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208727932">(Sep 01 2020 at 18:28)</a>:</h4>
<p>These explanations are really useful!</p>



<a name="208733140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208733140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208733140">(Sep 01 2020 at 19:06)</a>:</h4>
<p>More golf:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">key_lemma</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span><span class="o">))</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">haveI</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="n">p</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">assumption</span><span class="o">,</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">sub_eq_zero</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw_mod_cast</span> <span class="n">zmod</span><span class="bp">.</span><span class="n">int_coe_zmod_eq_zero_iff_dvd</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h_p_dvd</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
  <span class="o">{</span> <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">w</span><span class="o">,</span> <span class="n">hw</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">ring</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hw</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">dvd_mul_of_dvd_left</span> <span class="bp">_</span> <span class="n">w</span><span class="o">,</span>
    <span class="n">casesI</span> <span class="n">r</span><span class="o">,</span>
    <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="mi">0</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">assumption</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">absurd</span> <span class="n">nat</span><span class="bp">.</span><span class="n">one_pos</span> <span class="o">(</span><span class="n">not_lt_of_le</span> <span class="n">this</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">use</span> <span class="n">p</span><span class="bp">^</span><span class="n">r</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_pow</span> <span class="n">p</span> <span class="o">(</span><span class="n">r</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="n">or</span><span class="bp">.</span><span class="n">imp</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">prime</span><span class="bp">.</span><span class="n">dvd_mul&#39;</span> <span class="n">hp</span> <span class="n">h_p_dvd</span><span class="o">)</span><span class="bp">;</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h&#39;</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="o">[</span><span class="err">←</span><span class="n">zmod</span><span class="bp">.</span><span class="n">int_coe_zmod_eq_zero_iff_dvd</span><span class="o">,</span> <span class="err">←</span><span class="n">sub_eq_zero</span><span class="o">]</span> <span class="kn">using</span> <span class="n">h&#39;</span> <span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208733347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208733347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208733347">(Sep 01 2020 at 19:08)</a>:</h4>
<p>Remove the explicit <code>_inst_4</code> by using <code>by assumption</code>. That tactic will still work if you switch away from <code>fact ...</code> instance to a provided hypothesis (along with <code>casesI r</code> to <code>cases r</code>. Skipped doing an <code>exfalso</code> step into an <code>exact absurd ...</code> step.</p>



<a name="208733521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208733521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208733521">(Sep 01 2020 at 19:09)</a>:</h4>
<p>Changed a <code>cases h with w hw</code>to an <code>obtain</code> to be more explicit about picking a value and a corresponding proof of what it satisfies, as opposed to cases, which works, but I usually use for disjunctions.</p>



<a name="208733964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208733964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208733964">(Sep 01 2020 at 19:12)</a>:</h4>
<p>And since you finish the proof with an <code>all_goals</code>, convert the final block to something that is valid for both. You had some <code>left, right, swap</code> to provide two distinct values for <code>x</code>. I just let them work implicitly. Whatever the value, we have one of the two implications from the <code>dvd_mul'</code> disjunction, so in either case, moving the summand and using <code>zero_iff_dvd</code> is enough for the hypothesis in the implication.</p>



<a name="208734065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208734065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208734065">(Sep 01 2020 at 19:13)</a>:</h4>
<p><code>simpa [...] using H</code> is good for when you have tactic steps like <code>simp [...] at H, simp only [...], exact H</code> or similar.</p>



<a name="208742127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208742127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208742127">(Sep 01 2020 at 20:16)</a>:</h4>
<p>I've also made the eps argument to <code>part1</code> implicit, which allows the following for the original lemma you posted about:</p>



<a name="208742145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Conditionally%20assigning%20variables/near/208742145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Conditionally.20assigning.20variables.html#208742145">(Sep 01 2020 at 20:16)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">pr_dvd_xm1_or_xp1</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span><span class="o">))</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h_odd</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">-</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span> <span class="k">by</span> <span class="n">ring</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">(</span><span class="n">key_lemma</span> <span class="n">x</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">imp</span> <span class="bp">_</span> <span class="bp">_;</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
      <span class="n">try</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">this</span> <span class="o">},</span>
      <span class="n">apply</span> <span class="n">part1</span> <span class="n">h</span> <span class="n">h_odd</span><span class="o">,</span>
      <span class="n">dec_trivial</span><span class="o">,</span>
      <span class="n">exact_mod_cast</span> <span class="n">H</span> <span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
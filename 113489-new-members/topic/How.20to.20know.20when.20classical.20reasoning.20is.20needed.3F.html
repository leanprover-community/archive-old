---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/How.20to.20know.20when.20classical.20reasoning.20is.20needed.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20know.20when.20classical.20reasoning.20is.20needed.3F.html">How to know when classical reasoning is needed?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="264863182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20know%20when%20classical%20reasoning%20is%20needed%3F/near/264863182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin C. Martin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20know.20when.20classical.20reasoning.20is.20needed.3F.html#264863182">(Dec 14 2021 at 14:16)</a>:</h4>
<p>Exercise 5.3.4 <a href="https://leanprover.github.io/logic_and_proof/classical_reasoning.html">here</a> asks to prove 𝑃  from ¬𝑃→(𝑄∨𝑅), ¬𝑄, and ¬𝑅.  It's easy to prove  ¬ ¬𝑃 intuitionistically, and it seems you need proof by contradiction to get to P.  Is there a way to convince myself that it really can't be done through intuitionistic reasoning?  Say, using a 3-valued truth table or something?</p>



<a name="264863434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20know%20when%20classical%20reasoning%20is%20needed%3F/near/264863434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20know.20when.20classical.20reasoning.20is.20needed.3F.html#264863434">(Dec 14 2021 at 14:18)</a>:</h4>
<p>One way to see it is that there is no way to introduce <code>P</code>. You have no arrow going to <code>P</code>, and you need one if you go constructively.</p>



<a name="264867777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20know%20when%20classical%20reasoning%20is%20needed%3F/near/264867777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20know.20when.20classical.20reasoning.20is.20needed.3F.html#264867777">(Dec 14 2021 at 14:46)</a>:</h4>
<p>I think it's easier to justify the truth table approach. Whenever you have a special kind of partial order called a <a href="https://en.wikipedia.org/wiki/Heyting_algebra">Heyting algebra</a>, you can interpret intuitionistic logic in it. Exercise 5.3.4 is in fact equivalent to double negation elimination, so your question reduces to finding some element <code>p</code> of some Heyting algebra such that <code>p &lt; ¬¬p</code>. Indeed the 3-element Heyting algebra {0, 1, maybe} does the job.</p>
<p>One simple way of understanding the 3-element Heyting algebra is by checking more generally that any bounded total order <code>P</code> is a Heyting algebra. Given <code>p q : P</code>, you define logical connectives as follows: <code>p ∨ q</code> is <code>max(p,q)</code>, <code>p ∧ q</code> is <code>min(p,q)</code>, and <code>p → q</code> is <code>⊤</code> if <code>p ≤ q</code> and <code>q</code> otherwise.</p>



<a name="264875503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20know%20when%20classical%20reasoning%20is%20needed%3F/near/264875503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20know.20when.20classical.20reasoning.20is.20needed.3F.html#264875503">(Dec 14 2021 at 15:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/How.20to.20know.20when.20classical.20reasoning.20is.20needed.3F/near/264863434">said</a>:</p>
<blockquote>
<p>One way to see it is that there is no way to introduce <code>P</code>. You have no arrow going to <code>P</code>, and you need one if you go constructively.</p>
</blockquote>
<p>This line of reasoning is essentially true, but <img alt=":bourbaki:" class="emoji" src="https://zulip-avatars.s3.amazonaws.com/3121/emoji/images/17547.png" title="bourbaki">: <code>P → ¬ P → Q</code> is intuitionistically valid!</p>
<p>I think the correct way to argue this is to start out from the fact that polymorphic lambda terms are natural in their parameters. So you can't do case distinction on the types themselves, which is why truth tables don't work :)</p>



<a name="264885655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20know%20when%20classical%20reasoning%20is%20needed%3F/near/264885655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20know.20when.20classical.20reasoning.20is.20needed.3F.html#264885655">(Dec 14 2021 at 16:39)</a>:</h4>
<p><span class="user-mention" data-user-id="238446">@Anne Baanen</span> If false is defined by its principle of explosion (which it is anyway in Lean with <code>false.elim</code>), then I guess even that dangerous bend can still be solved by Yael's criterion. It's just that we've now left propositional logic.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">false'</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">r</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">false'</span><span class="o">)</span> <span class="bp">→</span> <span class="n">q</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span> <span class="n">h'</span><span class="o">,</span> <span class="n">h'</span> <span class="n">h</span> <span class="n">_</span>
</code></pre></div>



<a name="264891535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20know%20when%20classical%20reasoning%20is%20needed%3F/near/264891535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20know.20when.20classical.20reasoning.20is.20needed.3F.html#264891535">(Dec 14 2021 at 17:13)</a>:</h4>
<p>Yes of course. Because <code>false</code> is included in the original problem (because of the <code>not</code>), you need to account for its eliminator.</p>



<a name="264894405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20know%20when%20classical%20reasoning%20is%20needed%3F/near/264894405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20know.20when.20classical.20reasoning.20is.20needed.3F.html#264894405">(Dec 14 2021 at 17:30)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> But then doesn't that mean the original problem has two arrows to <code>P</code> from the two negations?</p>



<a name="264897384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20know%20when%20classical%20reasoning%20is%20needed%3F/near/264897384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20know.20when.20classical.20reasoning.20is.20needed.3F.html#264897384">(Dec 14 2021 at 17:49)</a>:</h4>
<p>Yes it has, I was wrong. But applying one of them leaves you with <code>Q</code> or <code>R</code> as a goal which you can only prove using <code>false.elim</code> (which doesn't buy you anything new because you didn't intro anything since last time) or <code>or.elim</code> (which doesn't buy you anything either, but that looks a bit fiddly at first)</p>



<a name="264899109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20know%20when%20classical%20reasoning%20is%20needed%3F/near/264899109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20know.20when.20classical.20reasoning.20is.20needed.3F.html#264899109">(Dec 14 2021 at 17:58)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.itauto</span>

<span class="c1">-- one way to convince yourself that the theorem isn't intuitionistic:</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∨</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h₃</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">itauto</span> <span class="c1">-- failed</span>

<span class="c1">-- another way, which doesn't always work, is to use it to prove LEM</span>
<span class="kd">theorem</span> <span class="n">foo</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∨</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h₃</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">itauto</span><span class="bp">!</span>

<span class="kd">theorem</span> <span class="n">em''</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">have</span> <span class="bp">¬¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">p</span><span class="o">),</span> <span class="kd">by</span> <span class="n">itauto</span><span class="o">,</span>
<span class="n">foo</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="n">this</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">)</span> <span class="n">not_false</span> <span class="n">not_false</span>
</code></pre></div>



<a name="265132376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20know%20when%20classical%20reasoning%20is%20needed%3F/near/265132376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Taucher <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20know.20when.20classical.20reasoning.20is.20needed.3F.html#265132376">(Dec 16 2021 at 09:56)</a>:</h4>
<p>First off I am a programmer first and a newbie at proofs here and in general.</p>
<p>In reading this StackExchange Computer Science Q&amp;A the part about intuitionistic logic made sense and I was wondering if it also made sense with regards to this topic.</p>
<p><a href="https://cs.stackexchange.com/a/146519/268">Answer</a> by <a href="https://cs.stackexchange.com/users/39/gilles-so-stop-being-evil">Gilles 'SO- stop being evil'</a></p>
<blockquote>
<blockquote>
<p>in disjunction you can have both values present at the same time</p>
</blockquote>
<p>In classical logic, yes. ... And in intuitionistic logic, to speak intuitively, when you know that A∨B is true, you know which one is true.</p>
<p>The idea of intuitionistic logic is that if you can prove a proposition P, it doesn't mean “P is true” (as it does in classical logic), but “I know how to prove P”. When the proposition is of the form A∨B, the way to prove A∨B must either involve a proof of A or a proof of B, plus the information of which side you chose to prove. This is not true in classical logic, which has A∨¬A as an axiom, which doesn't tell you which of A or ¬A is true or how you'd prove it. The absence of this axiom, the excluded middle, is the defining feature of intuitionistic logic compared to classical logic.</p>
</blockquote>



<a name="265138579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20know%20when%20classical%20reasoning%20is%20needed%3F/near/265138579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20know.20when.20classical.20reasoning.20is.20needed.3F.html#265138579">(Dec 16 2021 at 10:53)</a>:</h4>
<p>Indeed, there is a rigorous way to say the above, in there is a <a href="https://en.wikipedia.org/wiki/Modal_companion">modal companion</a> of intuitionistic logic. This is a translation into classical logic + the S4 modal axioms, where you put a box (standing for "I know a proof of") in front of every subexpression of a proposition. So <code>A ∨ ¬A</code> becomes <code>[]([]A ∨ []¬[]A)</code>. You can prove using the S4 axioms it is equivalent to put a box only in front of <code>¬</code> and <code>→</code>, so you get <code>[]A ∨ []¬[]A</code>: "either I know a proof of A or I know a proof that there is no proof of A".</p>



<a name="265138665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20know%20when%20classical%20reasoning%20is%20needed%3F/near/265138665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20know.20when.20classical.20reasoning.20is.20needed.3F.html#265138665">(Dec 16 2021 at 10:54)</a>:</h4>
<p>So if you know modal logic but not intuitionistic logic, this might help to give a bit of intuition :)</p>



<a name="265245053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20know%20when%20classical%20reasoning%20is%20needed%3F/near/265245053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20know.20when.20classical.20reasoning.20is.20needed.3F.html#265245053">(Dec 17 2021 at 01:56)</a>:</h4>
<p>A more elementary way to do this is to consider any topology, say the usual one on the real line.</p>
<p>So <code>false</code> is interpreted as the empty set, <code>true</code> the whole set. Conjunction/disjunction corresponds to the usual intersection/union. And <code>p -&gt; q</code> means <code>(R \ p) ∪ q</code>, and <em>take the interior</em>. Note that this ensures that every set you deal with is an open set.</p>



<a name="265245562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20know%20when%20classical%20reasoning%20is%20needed%3F/near/265245562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20know.20when.20classical.20reasoning.20is.20needed.3F.html#265245562">(Dec 17 2021 at 02:05)</a>:</h4>
<p>So in this case Q, R are empty, and <code>not P -&gt; (Q or R)</code> means the <em>closure</em> of P is the whole set, which by no means implies that P is the whole set.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
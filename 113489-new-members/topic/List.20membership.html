---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/List.20membership.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html">List membership</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="242205134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242205134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Simmons <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242205134">(Jun 10 2021 at 13:27)</a>:</h4>
<p>I hope this "oh no help" question is acceptable here... I'm coming after a long break from Agda, and was trying to do some list membership definitions, reprising this Agda:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">data</span> <span class="n">_</span><span class="bp">∈</span><span class="n">_</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">Set</span> <span class="n">a</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">Set</span> <span class="n">a</span> <span class="n">where</span>
  <span class="n">Z</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">{</span><span class="n">x</span> <span class="n">xs</span><span class="o">}</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span>
  <span class="n">S</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">xs</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">xs</span><span class="o">)</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">y</span> <span class="o">::</span> <span class="n">xs</span>
</code></pre></div>
<p>my first attempt looked like this, but I'm getting a universe error (<code>universe level of type_of(arg #2) of 'isin.z' is too big for the corresponding inductive datatype</code>), which I'm taking to mean that I'm surely doing something that I didn't mean to be doing:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">isin</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="n">List</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">z</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">List</span> <span class="n">A</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">isin</span> <span class="n">x</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">s</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">List</span> <span class="n">A</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">isin</span> <span class="n">x</span> <span class="n">l</span> <span class="bp">-&gt;</span> <span class="n">isin</span> <span class="n">x</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span>
</code></pre></div>
<p>(also, some beginner guidance as to how I could find such a definition and associated lemmas, if they exist, would be awesome)</p>



<a name="242205289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242205289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242205289">(Jun 10 2021 at 13:28)</a>:</h4>
<p>Are you trying to define an inductive predicate?</p>



<a name="242205311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242205311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242205311">(Jun 10 2021 at 13:28)</a>:</h4>
<p>If so then the syntax is wrong.</p>



<a name="242205445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242205445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Simmons <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242205445">(Jun 10 2021 at 13:29)</a>:</h4>
<p>Actually I think I figured out the problem by looking more closely at the Agda definition again: I needed to specify <code>{A : Type}</code> in the Lean definition! Because it was trying to generalize <code>{A}</code> to <code>{A : Type u}</code> which wouldn't work.</p>



<a name="242205504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242205504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242205504">(Jun 10 2021 at 13:30)</a>:</h4>
<p>Wait, I want to be sure that you are trying to define an inductive predicate, since I am Agda illiterate. Can you confirm?</p>



<a name="242205588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242205588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Simmons <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242205588">(Jun 10 2021 at 13:30)</a>:</h4>
<p>Yes. The top <code>data</code> definition is an Agda inductive definition</p>



<a name="242205654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242205654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Simmons <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242205654">(Jun 10 2021 at 13:30)</a>:</h4>
<p>The bottom <code>inductive</code> definition is me trying to transliterate that inductive definition into Lean</p>



<a name="242206014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242206014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242206014">(Jun 10 2021 at 13:32)</a>:</h4>
<p>This is the correct syntax:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">is_in</span> <span class="o">{</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">}</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_in</span> <span class="n">x</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">l</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">trans</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_in</span> <span class="n">x</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">is_in</span> <span class="n">x</span> <span class="o">(</span><span class="n">y</span><span class="o">::</span><span class="n">l</span><span class="o">)</span>
</code></pre></div>
<p>Is that your approach?</p>



<a name="242206272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242206272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242206272">(Jun 10 2021 at 13:34)</a>:</h4>
<p>But honestly I wouldn't use an inductive predicate since an inductive predicate is uncomputable and a computable definition is just more natural.</p>



<a name="242206281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242206281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Simmons <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242206281">(Jun 10 2021 at 13:34)</a>:</h4>
<p>Yes that seems like what I was trying to express, except that is there a reason for it to be a <code>Prop</code> instead of a <code>Type</code>?</p>



<a name="242206378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242206378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242206378">(Jun 10 2021 at 13:34)</a>:</h4>
<p>Aren't propositions types? But because of proof irrelevance, they are in a different universe, called Prop.</p>



<a name="242206392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242206392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242206392">(Jun 10 2021 at 13:34)</a>:</h4>
<p>Type is short for Type 0.</p>



<a name="242206664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242206664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Simmons <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242206664">(Jun 10 2021 at 13:36)</a>:</h4>
<p>Hmm... I'm going to want to do induction over this definition, will <code>Prop</code> allow me to do that?</p>



<a name="242206737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242206737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Simmons <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242206737">(Jun 10 2021 at 13:36)</a>:</h4>
<p>Seems like this now works as the definition I want:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">is_in</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">z</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">is_in</span> <span class="n">x</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">s</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">is_in</span> <span class="n">x</span> <span class="n">l</span> <span class="bp">-&gt;</span> <span class="n">is_in</span> <span class="n">x</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span>
</code></pre></div>



<a name="242206828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242206828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242206828">(Jun 10 2021 at 13:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="419650">Rob Simmons</span> <a href="#narrow/stream/113489-new-members/topic/List.20membership/near/242206664">said</a>:</p>
<blockquote>
<p>Hmm... I'm going to want to do induction over this definition, will <code>Prop</code> allow me to do that?</p>
</blockquote>
<p>Then yes. Prop allows you to do that. And you have proof irrelevance too, which can be really helpful in proofs.</p>



<a name="242206872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242206872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242206872">(Jun 10 2021 at 13:37)</a>:</h4>
<p>Also, you can specify a decision procedure for the inductive predicate. Type doesn't let you do that.</p>



<a name="242206873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242206873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242206873">(Jun 10 2021 at 13:37)</a>:</h4>
<blockquote>
<p>But honestly I wouldn't use an inductive predicate since an inductive predicate is uncomputable and a computable definition is just more natural.</p>
</blockquote>
<p>But inductive predicates are in many cases easier to reason about (and I would say even more intuitive, but that's a matter of taste)</p>



<a name="242207036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242207036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242207036">(Jun 10 2021 at 13:38)</a>:</h4>
<p>I agree. I was just commenting on <em>that specific instance</em>.</p>



<a name="242207540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242207540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242207540">(Jun 10 2021 at 13:41)</a>:</h4>
<blockquote>
<p>Hmm... I'm going to want to do induction over this definition, will <code>Prop</code> allow me to do that?</p>
</blockquote>
<p>But if you choose to do it with <code>Prop</code> and then will want to define data, i.e. things in <code>Type</code> by induction, (or recursion, however you prefer to call it) on <code>isin</code> proofs then you won't be able to. So you should also take into consideration what you intend to do with <code>isin</code></p>



<a name="242215343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242215343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242215343">(Jun 10 2021 at 14:28)</a>:</h4>
<p>I do not agree that an inductive predicate is uncomputable. <a href="https://leanprover-community.github.io/mathlib_docs/find/list.decidable_mem">docs#list.decidable_mem</a></p>



<a name="242221431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242221431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Simmons <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242221431">(Jun 10 2021 at 15:03)</a>:</h4>
<p>Thanks, this is helpful. Do you have any guidance as to whether I can find something similar that someone else might have already done?</p>



<a name="242221955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242221955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242221955">(Jun 10 2021 at 15:06)</a>:</h4>
<p>Similar to what? Definitions of data structures? Or predicates on them?</p>



<a name="242222070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242222070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242222070">(Jun 10 2021 at 15:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="419650">Rob Simmons</span> <a href="#narrow/stream/113489-new-members/topic/List.20membership/near/242221431">said</a>:</p>
<blockquote>
<p>Thanks, this is helpful. Do you have any guidance as to whether I can find something similar that someone else might have already done?</p>
</blockquote>
<p>If you want to learn how Lean generally works, you can clone mathlib and read the source code. Don't worry, the source code is generally very readable.</p>



<a name="242237051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242237051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242237051">(Jun 10 2021 at 16:53)</a>:</h4>
<p>I don't have the code anymore, but I actually tried to work with a similar inductive definition but for list inclusion, and as <code>Type</code>, not <code>Prop</code> (which as a coincidence was also based on some Agda code), that would also carry the information of "if <code>x</code> is the i-th element in the list <code>l</code> and <code>l</code> is included in <code>l2</code>, then this occurence of <code>x</code> is the j-th element of <code>l2</code>".</p>



<a name="242237320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242237320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242237320">(Jun 10 2021 at 16:55)</a>:</h4>
<p>But I eventually ended up dropping it, because it didn't work well with the termination checking, and I didn't want to have to deal with termination proofs all over my code.</p>



<a name="242237681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242237681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242237681">(Jun 10 2021 at 16:58)</a>:</h4>
<p>I am actually working on a proof of exactly this at the moment:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">sublist_iff_nth_eq</span> <span class="o">{</span><span class="n">l</span> <span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">l</span> <span class="bp">&lt;+</span> <span class="n">l'</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">↪</span><span class="n">o</span> <span class="n">ℕ</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">ix</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">l.nth</span> <span class="n">ix</span> <span class="bp">=</span> <span class="n">l'.nth</span> <span class="o">(</span><span class="n">f</span> <span class="n">ix</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">H</span> <span class="k">with</span> <span class="n">xs</span> <span class="n">ys</span> <span class="n">y</span> <span class="n">H</span> <span class="n">IH</span> <span class="n">xs</span> <span class="n">ys</span> <span class="n">x</span> <span class="n">H</span> <span class="n">IH</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">hf</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">IH</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">f.trans</span> <span class="o">(</span><span class="n">nat.add_order_embedding</span> <span class="mi">1</span><span class="o">),</span>
      <span class="n">simpa</span> <span class="n">using</span> <span class="n">hf</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">hf</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">IH</span><span class="o">,</span>
      <span class="n">refine</span> <span class="o">⟨⟨⟨</span><span class="bp">λ</span> <span class="n">ix</span><span class="o">,</span> <span class="k">if</span> <span class="n">ix</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">(</span><span class="n">f</span> <span class="n">ix.pred</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">⟩,</span>
      <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">_</span><span class="bp">|</span><span class="n">a</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">_</span><span class="bp">|</span><span class="n">b</span><span class="o">⟩,</span>
        <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="o">(</span><span class="n">nat.order_embedding_succ_pos</span> <span class="n">f</span> <span class="n">a₂</span><span class="o">)</span><span class="bp">.</span><span class="n">ne</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">simp</span> <span class="o">}</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">_</span><span class="bp">|</span><span class="n">a</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">_</span><span class="bp">|</span><span class="n">b</span><span class="o">⟩</span><span class="bp">;</span>
        <span class="n">simp</span> <span class="o">[</span><span class="n">nat.succ_le_succ_iff</span><span class="o">]</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">_</span><span class="bp">|</span><span class="n">i</span><span class="o">⟩,</span>
        <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">hf</span> <span class="n">ix</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">hf</span><span class="o">⟩,</span>
    <span class="gr">sorry</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="242239243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242239243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242239243">(Jun 10 2021 at 17:09)</a>:</h4>
<p>That's wonderful! It looks like the idea I ended up with after dropping the inductive definition, but yours is more advanced and much better integrated with the standard library.</p>



<a name="242239536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242239536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242239536">(Jun 10 2021 at 17:10)</a>:</h4>
<p>What does the righthookarrow with an o to its right mean? (sorry, I'm not at my computer and I can't type unicode)</p>



<a name="242240125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242240125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242240125">(Jun 10 2021 at 17:14)</a>:</h4>
<p>It means an <a href="https://leanprover-community.github.io/mathlib_docs/find/order_embedding">docs#order_embedding</a>. Basically, a function <code>f</code> with the property that if <code>x &lt;= y</code> then <code>f x &lt;= f y</code>.</p>



<a name="242240753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242240753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242240753">(Jun 10 2021 at 17:19)</a>:</h4>
<p>And do you think I would hit any major obstacle if I were to adapt it to use subtype instead of exists? Because ideally I would need to define data based on that index</p>



<a name="242240928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242240928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242240928">(Jun 10 2021 at 17:20)</a>:</h4>
<p>What do you mean? You mean build such a function, given the prop that sublist?</p>



<a name="242241060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242241060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242241060">(Jun 10 2021 at 17:21)</a>:</h4>
<p>Yes</p>



<a name="242241525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242241525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242241525">(Jun 10 2021 at 17:24)</a>:</h4>
<p>Your construction of f seems constructive at first sight</p>



<a name="242245268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242245268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242245268">(Jun 10 2021 at 17:52)</a>:</h4>
<p>Is this more of the thing you're thinking of?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">list_embed</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">l</span> <span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">),</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">[]</span>        <span class="n">_</span>         <span class="o">:=</span> <span class="n">id</span>
<span class="bp">|</span> <span class="n">_</span>         <span class="o">[]</span>        <span class="o">:=</span> <span class="n">id</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">ys</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>
  <span class="k">then</span> <span class="n">list_embed</span> <span class="n">xs</span> <span class="n">ys</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="k">else</span> <span class="o">(</span><span class="n">list_embed</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="n">ys</span> <span class="n">i</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
</code></pre></div>



<a name="242246108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242246108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242246108">(Jun 10 2021 at 17:59)</a>:</h4>
<p>But this would mean than any list is included in the empty list, right?</p>



<a name="242246184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242246184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242246184">(Jun 10 2021 at 17:59)</a>:</h4>
<p>This is just a mapping function. It might behave how you expect it to if you have an <code>(h : l &lt;+ l')</code> hypothesis. Haven't tried it out.</p>



<a name="242246269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242246269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242246269">(Jun 10 2021 at 18:00)</a>:</h4>
<p>It's the mathlib style of "define a total function, but it behave correctly only under some assumption"</p>



<a name="242246478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242246478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242246478">(Jun 10 2021 at 18:01)</a>:</h4>
<p>Oh, I see what you mean. I'll try it out, thank you, this was very helpful</p>



<a name="242256798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/List%20membership/near/242256798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/List.20membership.html#242256798">(Jun 10 2021 at 19:19)</a>:</h4>
<p>By the way <span class="user-mention" data-user-id="270523">@Huỳnh Trần Khanh</span> , I think <span class="user-mention silent" data-user-id="419650">Rob Simmons</span> is using lean 4, that snippet is valid lean 4. <span class="user-mention" data-user-id="419650">@Rob Simmons</span> We generally assume you are using lean 3 unless you are on the <a class="stream" data-stream-id="270676" href="/#narrow/stream/270676-lean4">#lean4</a> or <a class="stream" data-stream-id="287929" href="/#narrow/stream/287929-mathlib4">#mathlib4</a> streams</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
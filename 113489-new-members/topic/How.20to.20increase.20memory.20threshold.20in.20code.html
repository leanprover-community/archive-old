---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html">How to increase memory threshold in code</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="220839306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220839306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220839306">(Dec 24 2020 at 00:18)</a>:</h4>
<p>I am in <code>code</code> on <code>ubuntu</code>.  I get this message:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">excessive</span> <span class="n">memory</span> <span class="n">consumption</span> <span class="n">detected</span> <span class="n">at</span> <span class="bp">'</span><span class="n">expression</span> <span class="n">equality</span> <span class="n">test'</span> <span class="o">(</span><span class="n">potential</span> <span class="n">solution</span><span class="o">:</span> <span class="n">increase</span> <span class="n">memory</span> <span class="n">consumption</span> <span class="n">threshold</span><span class="o">)</span>
</code></pre></div>
<p>How do I increase the memory consumption threshold when <code>lean</code> is getting started up under the hood of <code>code</code>?</p>



<a name="220839531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220839531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220839531">(Dec 24 2020 at 00:22)</a>:</h4>
<p>Ctrl-, to bring up settings. Search for Lean memory. Mine is set at 8K.</p>



<a name="220839534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220839534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220839534">(Dec 24 2020 at 00:22)</a>:</h4>
<p><code>Lean: Memory Limit</code> is the setting</p>



<a name="220839546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220839546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220839546">(Dec 24 2020 at 00:23)</a>:</h4>
<p>but whatever term you're trying to <code>#reduce</code>, the amount you increase to might not be sufficient</p>



<a name="220839791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220839791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220839791">(Dec 24 2020 at 00:28)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span>  I am trying to do a proof of the theorem that "The cancellation law of multiplication for integral domains is equivalent in a commutative ring to the assertion that a product of nonzero factors is not 0."  </p>
<p>I am translating this as <code> (c ≠ 0 → c*a = c*b → a = b) ↔ (a ≠ 0 → b ≠ 0 → a * b ≠ 0) </code>.  With this translation, at a certain point, <code>library_search</code> and <code>suggest</code> run out of memory.   I don't know how to prove it from the <code>comm_ring</code> axioms:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ring.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">z</span> <span class="n">x₁</span> <span class="n">x₂</span> <span class="o">:</span>  <span class="n">α</span><span class="o">}</span>

<span class="c">/-</span><span class="cm"> Theorem 1. The cancellation law of multiplication for integral domains</span>
<span class="cm">is equivalent in a commutative ring to the assertion that</span>
<span class="cm">a product of nonzero factors is not 0. -/</span>

<span class="kd">lemma</span> <span class="n">lemma_1_LR</span><span class="o">:</span> <span class="o">(</span><span class="n">c</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">c</span><span class="bp">*</span><span class="n">a</span> <span class="bp">=</span> <span class="n">c</span><span class="bp">*</span><span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>  <span class="bp">→</span> <span class="o">(</span><span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h3</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h4</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h5</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h6</span> <span class="o">:=</span> <span class="n">h1</span> <span class="n">h5</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h7</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h8</span> <span class="o">:=</span> <span class="n">h6</span> <span class="n">h7</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">lemma_1_RL</span><span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">c</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">c</span><span class="bp">*</span><span class="n">a</span> <span class="bp">=</span> <span class="n">c</span><span class="bp">*</span><span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>  <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h3</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h4</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h5</span> <span class="o">:=</span> <span class="n">h1</span> <span class="n">h4</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h6</span> <span class="o">:</span> <span class="n">c</span><span class="bp">*</span><span class="n">a</span> <span class="bp">=</span> <span class="n">c</span><span class="bp">*</span><span class="n">b</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h7</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h8</span> <span class="o">:=</span> <span class="n">h5</span> <span class="n">h7</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">theorem_1</span> <span class="o">:</span> <span class="o">(</span><span class="n">c</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">c</span><span class="bp">*</span><span class="n">a</span> <span class="bp">=</span> <span class="n">c</span><span class="bp">*</span><span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">lemma_1_LR</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">lemma_1_RL</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="220841363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220841363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220841363">(Dec 24 2020 at 01:11)</a>:</h4>
<p>your theorems need additional forall quantifications on each side</p>



<a name="220841416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220841416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220841416">(Dec 24 2020 at 01:12)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> , I will refine.</p>



<a name="220841433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220841433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220841433">(Dec 24 2020 at 01:12)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">theorem_1</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">c</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">c</span><span class="bp">*</span><span class="n">a</span> <span class="bp">=</span> <span class="n">c</span><span class="bp">*</span><span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="bp">↔</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="220841458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220841458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220841458">(Dec 24 2020 at 01:13)</a>:</h4>
<p>generally when it says you should increase your memory limit, you should ignore the suggestion because something else is going wrong</p>



<a name="220841750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220841750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220841750">(Dec 24 2020 at 01:20)</a>:</h4>
<p>Here's a partial proof to help you get started:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">theorem_1</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">c</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">c</span><span class="bp">*</span><span class="n">a</span> <span class="bp">=</span> <span class="n">c</span><span class="bp">*</span><span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="bp">↔</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">H</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span> <span class="n">ab</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">hb</span> <span class="o">(</span><span class="n">H</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">ha</span> <span class="n">_</span><span class="o">),</span>
    <span class="gr">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">H</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">hc</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">sub_eq_zero</span> <span class="n">at</span> <span class="n">e</span> <span class="bp">⊢</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">by_contra</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">refine</span> <span class="n">H</span> <span class="n">c</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="n">hc</span> <span class="n">h</span> <span class="n">_</span><span class="o">,</span>
    <span class="gr">sorry</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="220841841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220841841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220841841">(Dec 24 2020 at 01:22)</a>:</h4>
<p>For some reason using <code>by_contra h</code> instead of <code>refine by_contra (λ h, _),</code> is taking a really long time for me (but it doesn't time out or run out of memory). Possibly something weird ended up in the typeclass search for <code>decidable_eq A</code></p>



<a name="220842597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220842597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220842597">(Dec 24 2020 at 01:40)</a>:</h4>
<p>minimized:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ring.basic</span>
<span class="kn">import</span> <span class="n">data.set.basic</span>

<span class="kd">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">trivial</span>

<span class="kd">set_option</span> <span class="n">trace.class_instances</span> <span class="n">true</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">semigroup</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span>
  <span class="n">tgt</span> <span class="bp">←</span> <span class="n">tactic.target</span><span class="o">,</span>
  <span class="n">tactic.mk_mapp</span> <span class="bp">`</span><span class="n">foo</span> <span class="o">[</span><span class="n">some</span> <span class="n">tgt</span><span class="o">,</span> <span class="n">none</span><span class="o">]</span>
</code></pre></div>
<p>You can also play with the import set to make it take longer; <code>import tactic</code> is quite bad.</p>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> Could you take a look at whether the typeclass problem is reasonably sized here? It seems like the decision to make <code>linear_order</code> inherit from <code>decidable_eq</code> means that the decidability problem gets quite large, and while caching seems to help I see a lot of repetition from a cursory glance at the log.</p>



<a name="220843450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220843450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220843450">(Dec 24 2020 at 02:04)</a>:</h4>
<p>Thanks again <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> here is the finished Theorem 1:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"> Theorem 1. The cancellation law of multiplication for integral domains</span>
<span class="cm">is equivalent in a commutative ring to the assertion that</span>
<span class="cm">a product of nonzero factors is not 0. -/</span>

<span class="kd">lemma</span> <span class="n">left_distrib_minus</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">-</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ring</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">theorem_1</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">c</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">c</span><span class="bp">*</span><span class="n">a</span> <span class="bp">=</span> <span class="n">c</span><span class="bp">*</span><span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="bp">↔</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">H</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span> <span class="n">ab</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">hb</span> <span class="o">(</span><span class="n">H</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">ha</span> <span class="n">_</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">hc</span> <span class="o">:=</span> <span class="n">mul_zero</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hc</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">ab</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">H</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">hc</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">sub_eq_zero</span> <span class="n">at</span> <span class="n">e</span> <span class="bp">⊢</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">by_contra</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">refine</span> <span class="n">H</span> <span class="n">c</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="n">hc</span> <span class="n">h</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">left_distrib_minus</span> <span class="n">at</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">e</span><span class="o">,</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="220843507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220843507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220843507">(Dec 24 2020 at 02:06)</a>:</h4>
<p><code>left_distrib_minus</code> has a name, can you find it?</p>



<a name="220844481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220844481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220844481">(Dec 24 2020 at 02:39)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <code>left_distrib</code> doesn't quite fit because it is phrased for <code>a+b</code> and this is <code>a-b</code> and if you instantiate it you get <code>a+(-b)</code> which doesn't quite match the hypothesis set.  I played around with it and ended up having to use a different lemma which instead of sugaring <code>ring</code>, sugars <code>rfl</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">deminus_plus</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">):</span> <span class="n">a</span> <span class="bp">+</span> <span class="bp">-</span><span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">-</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">theorem_1</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">c</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">c</span><span class="bp">*</span><span class="n">a</span> <span class="bp">=</span> <span class="n">c</span><span class="bp">*</span><span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="bp">↔</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">H</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span> <span class="n">ab</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">hb</span> <span class="o">(</span><span class="n">H</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">ha</span> <span class="n">_</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">hc</span> <span class="o">:=</span> <span class="n">mul_zero</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hc</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">ab</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">H</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">hc</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">sub_eq_zero</span> <span class="n">at</span> <span class="n">e</span> <span class="bp">⊢</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">by_contra</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">refine</span> <span class="n">H</span> <span class="n">c</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="n">hc</span> <span class="n">h</span> <span class="n">_</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hd</span> <span class="o">:=</span> <span class="n">left_distrib</span> <span class="n">c</span> <span class="n">a</span> <span class="o">(</span><span class="bp">-</span><span class="n">b</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">he</span> <span class="o">:=</span> <span class="n">deminus_plus</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">he</span> <span class="n">at</span> <span class="n">hd</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hf</span> <span class="o">:=</span> <span class="n">norm_num.mul_pos_neg</span> <span class="n">c</span> <span class="n">b</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hf</span> <span class="n">at</span> <span class="n">hd</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hg</span> <span class="o">:=</span> <span class="n">deminus_plus</span> <span class="o">(</span><span class="n">c</span><span class="bp">*</span><span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span><span class="bp">*</span><span class="n">b</span><span class="o">),</span>
    <span class="n">rw</span> <span class="n">hg</span> <span class="n">at</span> <span class="n">hd</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hd</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">e</span><span class="o">,</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>I don't know how to make use of <code>rfl</code> "inline" as a tactic in this case.  If you can help me rewrite one of the <code>deminus_plus</code> lines to use <code>rfl</code> then I can finish it.</p>



<a name="220844526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220844526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220844526">(Dec 24 2020 at 02:40)</a>:</h4>
<p>Recall the <a href="https://leanprover-community.github.io/contribute/naming.html">#naming</a> convention</p>



<a name="220844533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220844533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220844533">(Dec 24 2020 at 02:40)</a>:</h4>
<p>what would be the name of a lemma that combines multiplication and subtraction?</p>



<a name="220844588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220844588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220844588">(Dec 24 2020 at 02:42)</a>:</h4>
<p><code>deminus_plus</code> also has a name that the naming convention will guide you to</p>



<a name="220844603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220844603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220844603">(Dec 24 2020 at 02:43)</a>:</h4>
<p>If you want to prove the <code>have he := deminus_plus ...</code> lines using <code>rfl</code> you will have to state the expected type as in <code>have he : &lt;type&gt; := rfl</code></p>



<a name="220844724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220844724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220844724">(Dec 24 2020 at 02:46)</a>:</h4>
<p>I have one hypotheses I need to edit:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">hd</span><span class="o">:</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="bp">-</span><span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">*</span> <span class="bp">-</span><span class="n">b</span>
</code></pre></div>
<p>to become</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">hd</span><span class="o">:</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">-</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span>
</code></pre></div>
<p>I'll look for <code>add_neg</code> names or <code>plus_neg</code> names.</p>



<a name="220844996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220844996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220844996">(Dec 24 2020 at 02:54)</a>:</h4>
<p>Ah <a href="https://leanprover-community.github.io/mathlib_docs/find/sub_eq_add_neg">docs#sub_eq_add_neg</a>.</p>



<a name="220845248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220845248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220845248">(Dec 24 2020 at 03:02)</a>:</h4>
<p>DONE:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ring.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span>

<span class="c">/-</span><span class="cm"> Theorem 1. The cancellation law of multiplication for integral domains</span>
<span class="cm">is equivalent in a commutative ring to the assertion that</span>
<span class="cm">a product of nonzero factors is not 0. -/</span>

<span class="kd">theorem</span> <span class="n">theorem_1</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">c</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">c</span><span class="bp">*</span><span class="n">a</span> <span class="bp">=</span> <span class="n">c</span><span class="bp">*</span><span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="bp">↔</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">H</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span> <span class="n">ab</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">hb</span> <span class="o">(</span><span class="n">H</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">ha</span> <span class="n">_</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">hc</span> <span class="o">:=</span> <span class="n">mul_zero</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hc</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">ab</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">H</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">hc</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">sub_eq_zero</span> <span class="n">at</span> <span class="n">e</span> <span class="bp">⊢</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">by_contra</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">refine</span> <span class="n">H</span> <span class="n">c</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="n">hc</span> <span class="n">h</span> <span class="n">_</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hd</span> <span class="o">:=</span> <span class="n">left_distrib</span> <span class="n">c</span> <span class="n">a</span> <span class="o">(</span><span class="bp">-</span><span class="n">b</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">he</span> <span class="o">:=</span> <span class="n">sub_eq_add_neg</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">he</span> <span class="n">at</span> <span class="n">hd</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hf</span> <span class="o">:=</span> <span class="n">norm_num.mul_pos_neg</span> <span class="n">c</span> <span class="n">b</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hf</span> <span class="n">at</span> <span class="n">hd</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hg</span> <span class="o">:=</span> <span class="n">sub_eq_add_neg</span> <span class="o">(</span><span class="n">c</span><span class="bp">*</span><span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span><span class="bp">*</span><span class="n">b</span><span class="o">),</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">hg</span> <span class="n">at</span> <span class="n">hd</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hd</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">e</span><span class="o">,</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="220846269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220846269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220846269">(Dec 24 2020 at 03:34)</a>:</h4>
<blockquote>
<p>I'll look for add_neg names or plus_neg names.</p>
</blockquote>
<p>Always <code>add</code>, never <code>plus</code></p>



<a name="220846338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220846338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220846338">(Dec 24 2020 at 03:36)</a>:</h4>
<p>Your original proof used a theorem <code>a * (b - c) = a * b - a * c</code>. Have you found that lemma yet?</p>



<a name="220847252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220847252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220847252">(Dec 24 2020 at 04:06)</a>:</h4>
<p>The code underneath DONE above is pure <code>matlib</code>, there is no extra lemma.  I use the built-in <code>left_distrib</code> and built-in <code>sub_eq_add_neg</code>.</p>



<a name="220851868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20increase%20memory%20threshold%20in%20code/near/220851868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20increase.20memory.20threshold.20in.20code.html#220851868">(Dec 24 2020 at 06:20)</a>:</h4>
<p>You are proving this fact <code>a * (b - c) = a * b - a * c</code> in the middle of your proof, and you don't need to. It's good to get a sense for what to expect in the library, and a distribution lemma like this will certainly be in there. (Since you missed the naming hints, the name is <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_sub">docs#mul_sub</a>.)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
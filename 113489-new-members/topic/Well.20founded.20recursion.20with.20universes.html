---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html">Well founded recursion with universes</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="206400549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206400549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fox Thomson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206400549">(Aug 09 2020 at 15:58)</a>:</h4>
<p>I am attempting to prove the Spauge-Grundy theorem which I am stating as </p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">Sprague_Grundy</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">pgame</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">2</span><span class="o">})</span> <span class="o">[</span><span class="n">G</span><span class="bp">.</span><span class="n">impartial</span><span class="o">],</span> <span class="n">inhabited</span> <span class="o">{</span> <span class="n">O</span> <span class="o">:</span> <span class="n">ordinal</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="bp">//</span> <span class="n">G</span> <span class="bp">≈</span> <span class="n">nim</span> <span class="n">O</span> <span class="o">}</span>
</code></pre></div>


<p>In order to prove this I need to induct on G using the <code>pgame.pgame_wf_tac</code> tactic and using the theorem on <code>G.move_left i</code> for some left move <code>i</code> but I am getting an error about universe levels which I think is due to the subsequent games being of type <code>pgame.{u+1}</code>. How can I make a more flexible universe variable?<br>
My attempted proof and related definitions is here:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">nonmoves</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">_</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ordinal</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ordinal</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">O</span> <span class="o">:</span> <span class="n">ordinal</span> <span class="bp">|</span> <span class="bp">¬</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">ordinal</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)}</span> <span class="o">(</span><span class="n">M</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">O</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">nonmoves_nonempty</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">_</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ordinal</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">O</span> <span class="o">:</span> <span class="n">ordinal</span><span class="o">,</span> <span class="n">O</span> <span class="err">∈</span> <span class="n">nonmoves</span> <span class="n">M</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">ordinal</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)}</span> <span class="o">(</span><span class="n">M</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ordinal</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">principal_seg</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)}</span><span class="bp">.</span><span class="n">top</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="bp">⟨</span> <span class="n">a</span><span class="o">,</span> <span class="n">ha</span> <span class="bp">⟩</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">down</span> <span class="o">:=</span> <span class="n">ordinal</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">principal_seg</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)}</span><span class="bp">.</span><span class="n">down</span> <span class="o">(</span><span class="n">ordinal</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)}</span> <span class="o">(</span><span class="n">M</span> <span class="n">a</span><span class="o">)),</span>
    <span class="k">have</span> <span class="n">h&#39;</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ordinal</span><span class="o">),</span> <span class="n">ordinal</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">principal_seg</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)}</span> <span class="n">b</span> <span class="bp">=</span> <span class="o">(</span><span class="n">ordinal</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)}</span> <span class="o">(</span><span class="n">M</span> <span class="n">a</span><span class="o">)),</span>
        <span class="n">use</span> <span class="n">M</span> <span class="n">a</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">ordinal</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">principal_seg_coe</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hcontra</span> <span class="o">:=</span> <span class="n">down</span><span class="bp">.</span><span class="mi">2</span> <span class="n">h&#39;</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">(</span><span class="n">lt_iff_le_and_ne</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hcontra</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
    <span class="n">contradiction</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">ordinal</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">principal_seg</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)}</span><span class="bp">.</span><span class="n">top</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">Sprague_Grundy</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">pgame</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">2</span><span class="o">})</span> <span class="o">[</span><span class="n">G</span><span class="bp">.</span><span class="n">impartial</span><span class="o">],</span> <span class="n">inhabited</span> <span class="o">{</span> <span class="n">O</span> <span class="o">:</span> <span class="n">ordinal</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="bp">//</span> <span class="n">G</span> <span class="bp">≈</span> <span class="n">nim</span> <span class="n">O</span> <span class="o">}</span>
<span class="bp">|</span> <span class="n">G</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">classical</span><span class="o">,</span>
    <span class="n">introI</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">M</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">Sprague_Grundy</span> <span class="o">(</span><span class="n">G</span><span class="bp">.</span><span class="n">move_left</span> <span class="n">i</span><span class="o">))</span><span class="bp">.</span><span class="n">default</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
    <span class="n">fconstructor</span><span class="o">,</span>
    <span class="n">fconstructor</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">nonmoves</span> <span class="n">M</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">ordinal</span><span class="bp">.</span><span class="n">omin</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">nonmoves_nonempty</span> <span class="n">M</span><span class="o">,</span>
    <span class="c1">-- exact ordinal.omin.{u+1} (nonmoves M) (nonmoves_nonempty M)</span>
    <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="206421590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206421590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206421590">(Aug 10 2020 at 01:59)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mwe.html">#mwe</a>, or a branch to look at?</p>



<a name="206421647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206421647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206421647">(Aug 10 2020 at 02:00)</a>:</h4>
<p>Without catching on what you've been doing, it's hard to say. The fact that <code>G.impartial</code> is a typeclass strikes me as unlikely to be a good choice, however!</p>



<a name="206446883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206446883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fox Thomson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206446883">(Aug 10 2020 at 10:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span>  I have made a GitHub repository at <a href="https://github.com/foxthomson/impartial">https://github.com/foxthomson/impartial</a>. The problem is in src/nim.lean.</p>



<a name="206447406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206447406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206447406">(Aug 10 2020 at 10:35)</a>:</h4>
<p>Why isn't your theorem statement simply</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">Sprague_Grundy</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">pgame</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">[</span><span class="n">G</span><span class="bp">.</span><span class="n">impartial</span><span class="o">],</span> <span class="n">inhabited</span> <span class="o">{</span> <span class="n">O</span> <span class="o">:</span> <span class="n">ordinal</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="bp">//</span> <span class="n">G</span> <span class="bp">≈</span> <span class="n">nim</span> <span class="n">O</span> <span class="o">}</span>
</code></pre></div>


<p>with a single universe level? I think the issue is in your definition of <code>nim</code>.</p>



<a name="206447648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206447648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206447648">(Aug 10 2020 at 10:38)</a>:</h4>
<p>As currently stated, the theorem is false.</p>



<a name="206447678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206447678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206447678">(Aug 10 2020 at 10:39)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">nim</span> <span class="o">:</span> <span class="n">ordinal</span> <span class="bp">→</span> <span class="n">pgame</span>
<span class="bp">|</span> <span class="n">O₁</span> <span class="o">:=</span> <span class="bp">⟨</span> <span class="o">{</span> <span class="n">O₂</span> <span class="o">:</span> <span class="n">ordinal</span> <span class="bp">//</span> <span class="n">O₂</span> <span class="bp">&lt;</span> <span class="n">O₁</span> <span class="o">},</span>
</code></pre></div>


<p>this construction is tempting, but it blows up the universe level unnecessarily.</p>



<a name="206447693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206447693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fox Thomson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206447693">(Aug 10 2020 at 10:40)</a>:</h4>
<p>If <code>O</code> is <code>ordinal.{u}</code> then ordinals less than <code>O</code> are in the universe <code>u</code>. This means that <code>nim O</code> is in the universe <code>u+1</code>.</p>



<a name="206447739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206447739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206447739">(Aug 10 2020 at 10:40)</a>:</h4>
<p>Right, which is wrong.</p>



<a name="206447768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206447768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fox Thomson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206447768">(Aug 10 2020 at 10:40)</a>:</h4>
<p>How come?</p>



<a name="206447773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206447773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206447773">(Aug 10 2020 at 10:40)</a>:</h4>
<p>If <code>O : ordinal.{u}</code> then <code>O</code> is the order type of some type in <code>Type u</code>, and that's the correct universe level to be in</p>



<a name="206447806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206447806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206447806">(Aug 10 2020 at 10:41)</a>:</h4>
<p><code>{ O₂ : ordinal // O₂ &lt; O₁ }</code> has the same order type but it's in <code>Type (u+1)</code></p>



<a name="206447824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206447824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fox Thomson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206447824">(Aug 10 2020 at 10:41)</a>:</h4>
<p>So I should try to get the order type out of the quotient?</p>



<a name="206447888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206447888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206447888">(Aug 10 2020 at 10:42)</a>:</h4>
<p>Yeah, if you can define <code>nim</code> directly as a <code>game</code>, you could try to use <code>lift</code>, otherwise use <code>quot.out</code> in some form.</p>



<a name="206447933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206447933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fox Thomson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206447933">(Aug 10 2020 at 10:43)</a>:</h4>
<p>Thank you, I will try</p>



<a name="206448168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206448168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206448168">(Aug 10 2020 at 10:47)</a>:</h4>
<p>Another thing you could maybe do is have <code>nim</code> take a well-ordered type, rather than an ordinal</p>



<a name="206462263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206462263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fox Thomson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206462263">(Aug 10 2020 at 13:49)</a>:</h4>
<p>I have a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> which does not depend on <code>nim</code> at all</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory</span><span class="bp">.</span><span class="n">ordinal</span>
<span class="kn">import</span> <span class="n">set_theory</span><span class="bp">.</span><span class="n">pgame</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">nth_rewrite</span><span class="bp">.</span><span class="n">default</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kn">namespace</span> <span class="n">pgame</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="bp">≈</span> <span class="bp">`</span> <span class="o">:=</span> <span class="n">pgame</span><span class="bp">.</span><span class="n">equiv</span>

<span class="bp">@</span><span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="n">def</span> <span class="n">impartial</span> <span class="o">:</span> <span class="n">pgame</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">G</span> <span class="bp">≈</span> <span class="bp">-</span><span class="n">G</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">impartial</span> <span class="o">(</span><span class="n">G</span><span class="bp">.</span><span class="n">move_left</span> <span class="n">i</span><span class="o">))</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">j</span><span class="o">,</span> <span class="n">impartial</span> <span class="o">(</span><span class="n">G</span><span class="bp">.</span><span class="n">move_right</span> <span class="n">j</span><span class="o">))</span>
<span class="n">using_well_founded</span> <span class="o">{</span><span class="n">dec_tac</span> <span class="o">:=</span> <span class="n">pgame_wf_tac</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">impartial_def</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">pgame</span><span class="o">}</span> <span class="o">:</span>
    <span class="n">G</span><span class="bp">.</span><span class="n">impartial</span> <span class="bp">↔</span> <span class="n">G</span> <span class="bp">≈</span> <span class="bp">-</span><span class="n">G</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">impartial</span> <span class="o">(</span><span class="n">G</span><span class="bp">.</span><span class="n">move_left</span> <span class="n">i</span><span class="o">))</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">j</span><span class="o">,</span> <span class="n">impartial</span> <span class="o">(</span><span class="n">G</span><span class="bp">.</span><span class="n">move_right</span> <span class="n">j</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span>   <span class="n">intro</span> <span class="n">hi</span><span class="o">,</span>
        <span class="n">unfold1</span> <span class="n">impartial</span> <span class="n">at</span> <span class="n">hi</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">hi</span> <span class="o">},</span>
    <span class="o">{</span>   <span class="n">intro</span> <span class="n">hi</span><span class="o">,</span>
        <span class="n">unfold1</span> <span class="n">impartial</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">hi</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">impartial_move_left_impartial</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">pgame</span><span class="o">}</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">impartial</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">left_moves</span><span class="o">)</span> <span class="o">:</span> <span class="n">impartial</span> <span class="o">(</span><span class="n">G</span><span class="bp">.</span><span class="n">move_left</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">rw</span> <span class="n">impartial_def</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span> <span class="n">i</span><span class="o">,</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">nonmoves</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">_</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ordinal</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ordinal</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">O</span> <span class="o">:</span> <span class="n">ordinal</span> <span class="bp">|</span> <span class="bp">¬</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">ordinal</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)}</span> <span class="o">(</span><span class="n">M</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">O</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">nonmoves_nonempty</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">_</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ordinal</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">O</span> <span class="o">:</span> <span class="n">ordinal</span><span class="o">,</span> <span class="n">O</span> <span class="err">∈</span> <span class="n">nonmoves</span> <span class="n">M</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">ordinal</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)}</span> <span class="o">(</span><span class="n">M</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ordinal</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">principal_seg</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)}</span><span class="bp">.</span><span class="n">top</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="bp">⟨</span> <span class="n">a</span><span class="o">,</span> <span class="n">ha</span> <span class="bp">⟩</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">down</span> <span class="o">:=</span> <span class="n">ordinal</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">principal_seg</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)}</span><span class="bp">.</span><span class="n">down</span> <span class="o">(</span><span class="n">ordinal</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)}</span> <span class="o">(</span><span class="n">M</span> <span class="n">a</span><span class="o">)),</span>
    <span class="k">have</span> <span class="n">h&#39;</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ordinal</span><span class="o">),</span> <span class="n">ordinal</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">principal_seg</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)}</span> <span class="n">b</span> <span class="bp">=</span> <span class="o">(</span><span class="n">ordinal</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)}</span> <span class="o">(</span><span class="n">M</span> <span class="n">a</span><span class="o">)),</span>
        <span class="n">use</span> <span class="n">M</span> <span class="n">a</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">ordinal</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">principal_seg_coe</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hcontra</span> <span class="o">:=</span> <span class="n">down</span><span class="bp">.</span><span class="mi">2</span> <span class="n">h&#39;</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">(</span><span class="n">lt_iff_le_and_ne</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hcontra</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
    <span class="n">contradiction</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">ordinal</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">principal_seg</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)}</span><span class="bp">.</span><span class="n">top</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">Grundy_value</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">pgame</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">[</span><span class="n">G</span><span class="bp">.</span><span class="n">impartial</span><span class="o">],</span> <span class="n">ordinal</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span>
<span class="bp">|</span> <span class="n">G</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">introI</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">M</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">Grundy_value</span> <span class="o">(</span><span class="n">G</span><span class="bp">.</span><span class="n">move_left</span> <span class="n">i</span><span class="o">),</span>
    <span class="n">exact</span> <span class="n">ordinal</span><span class="bp">.</span><span class="n">omin</span> <span class="o">(</span><span class="n">nonmoves</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">nonmoves_nonempty</span> <span class="n">M</span><span class="o">),</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">pgame</span>
</code></pre></div>


<p>I am getting an error as <code>M</code> in <code>Grundy_value</code> is of the form <code>G.left_moves -&gt; ordinal.{u+1}</code> so <code>nonmoves M</code> is a set of <code>ordinal.{u+2}</code> a universe too big. I think I am loking for a way to write <code>ordinal.{2*u}</code></p>



<a name="206463914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206463914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fox Thomson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206463914">(Aug 10 2020 at 14:04)</a>:</h4>
<p>Actually I think it is due to <code>Grundy_value</code> not stepping down a universe when it is used recursively, Lean has understood <code>M</code> as a function from <code>G.left_moves</code> to <code>ordinal.{u+1}</code> when I want it to be sent to <code>ordinal.{u}</code></p>



<a name="206464017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206464017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206464017">(Aug 10 2020 at 14:05)</a>:</h4>
<p>Well you wrote <code>Π (G : pgame.{u}) [G.impartial], ordinal.{u+1}</code>--it should take values in <code>ordinal.{u}</code></p>



<a name="206464018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206464018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fox Thomson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206464018">(Aug 10 2020 at 14:05)</a>:</h4>
<p>Which should work as <code>G.move_left i</code> is a member of <code>pgame.{u-1}</code></p>



<a name="206464070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206464070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206464070">(Aug 10 2020 at 14:06)</a>:</h4>
<p>As the type of <code>Grundy_value</code> I mean</p>



<a name="206464181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206464181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fox Thomson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206464181">(Aug 10 2020 at 14:07)</a>:</h4>
<p>I want it to take values in the universe <code>u</code> understood as a variable so I can call it with each universe a level down</p>



<a name="206464234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206464234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206464234">(Aug 10 2020 at 14:07)</a>:</h4>
<p>You can't do recursion with varying universe levels, but in any case, the Grundy value of a game is supposed to be an ordinal in the same universe as the game</p>



<a name="206464328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206464328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206464328">(Aug 10 2020 at 14:08)</a>:</h4>
<p>for example an "ordinary" game is one that lives in universe level 0, and its Grundy value is an ordinary ordinal which also lives in universe level 0</p>



<a name="206464576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206464576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fox Thomson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206464576">(Aug 10 2020 at 14:10)</a>:</h4>
<p>But if I have shown that all ordinary games have a Grundy value shouldn't I be able to access their Grundy value viewed as an ordinary ordinal when talking about universe 1 games?</p>



<a name="206464617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206464617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206464617">(Aug 10 2020 at 14:10)</a>:</h4>
<p>Lean doesn't work that way</p>



<a name="206464654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206464654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206464654">(Aug 10 2020 at 14:11)</a>:</h4>
<p>I agree in normal math you could do it</p>



<a name="206464663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206464663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fox Thomson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206464663">(Aug 10 2020 at 14:11)</a>:</h4>
<p>Is there any known tricks to get around this?</p>



<a name="206464678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206464678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206464678">(Aug 10 2020 at 14:11)</a>:</h4>
<p>I claim it's impossible to actually have this problem in Lean</p>



<a name="206464737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206464737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206464737">(Aug 10 2020 at 14:11)</a>:</h4>
<p>actually I'm not really sure whether that is true</p>



<a name="206464758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206464758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206464758">(Aug 10 2020 at 14:12)</a>:</h4>
<p>but if you have this problem then something went wrong earlier</p>



<a name="206465352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206465352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206465352">(Aug 10 2020 at 14:16)</a>:</h4>
<p>Why would you need this?</p>



<a name="206465396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206465396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fox Thomson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206465396">(Aug 10 2020 at 14:16)</a>:</h4>
<p>The S-G theorem requires <code>nonmoves</code> to be able to find the mex. This requires <code>nonmoves</code> to be nonempty so <code>nonmoves</code> has to be defined as a set of <code>ordinal.{u+1}</code> otherwise we could feed it the identity function on <code>ordinal.{u}</code> and it would be empty.</p>



<a name="206465448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206465448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206465448">(Aug 10 2020 at 14:17)</a>:</h4>
<p>I think <code>nonmoves</code> also has the wrong result universe level, it should be <code>set ordinal.{u}</code>.</p>



<a name="206465525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206465525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fox Thomson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206465525">(Aug 10 2020 at 14:18)</a>:</h4>
<p>This means that the Grundy value has to be strictly universe higher than the Grundy value of all subsequent games</p>



<a name="206465558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206465558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206465558">(Aug 10 2020 at 14:18)</a>:</h4>
<p>There's no way to index all of <code>ordinal.{u}</code> with a <code>Type u</code>-sized family--but there is a theorem to be proved here!</p>



<a name="206465578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206465578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206465578">(Aug 10 2020 at 14:18)</a>:</h4>
<p>No, you can't do it that way in Lean (and you wouldn't do it that way in math either)</p>



<a name="206465626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206465626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206465626">(Aug 10 2020 at 14:18)</a>:</h4>
<p>Only one universe is needed</p>



<a name="206465747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206465747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206465747">(Aug 10 2020 at 14:19)</a>:</h4>
<p>The classical way to describe the situation would be: to an impartial game we assign the least ordinal which is not the value of any option of the game; such an ordinal exists because ordinals form a proper class but the options of the game only form a set.</p>



<a name="206465805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206465805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fox Thomson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206465805">(Aug 10 2020 at 14:20)</a>:</h4>
<p>Oh, so saying alpha is type u means that nonmoves is nonempty without jumping up a universe</p>



<a name="206466090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206466090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206466090">(Aug 10 2020 at 14:22)</a>:</h4>
<p>I think there's a theorem to this effect somewhere in <code>set_theory.ordinal</code> or <code>set_theory.cardinal</code></p>



<a name="206502032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206502032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206502032">(Aug 10 2020 at 19:21)</a>:</h4>
<p>I tried to make an API for this sort of construction, but I wasn't able to make anything sufficiently general to cover all the use cases. But you can get a type with the order type of the ordinal using <code>quot.out</code>, and use that</p>



<a name="206502165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Well%20founded%20recursion%20with%20universes/near/206502165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Well.20founded.20recursion.20with.20universes.html#206502165">(Aug 10 2020 at 19:23)</a>:</h4>
<p><code>o.out.α</code> has the right size</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
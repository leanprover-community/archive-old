---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html">structures, subtypes, coercions and rw</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="260344264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/260344264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#260344264">(Nov 04 2021 at 22:37)</a>:</h4>
<p>I have two questions that puzzle me.<br>
The context is similar in both, a group <code>G</code> acting on a type <code>X</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">G</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">{</span><span class="n">X</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">G</span> <span class="n">X</span><span class="o">]</span>
</code></pre></div>
<p>1) The first one is about <code>is_pretransitive</code>, defined as a structure.<br>
Assume I have <code>H: subgroup G</code> and the hypothesis <code>h: is_pretransitive ↥H X</code> (meaning that <code>H</code>acts pretransitively on <code>X</code>), as well as two members <code>x y : X</code>. <br>
I want to recover the defining property of <code>is_pretransitive</code>,  <code>exists_smul_eq</code>, which expands as <code>∀ (x y : X), ∃ (g : ↥H), g • x = y</code>, and apply it to <code>x</code>and <code>y</code>, to recover <code>g</code>, but while the following </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">h.exists_smul_eq</span><span class="o">,</span>
<span class="n">obtain</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span><span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">z</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
</code></pre></div>
<p>gives me what I want, namely, <code>g: ↥H</code> and <code>h: g • x = y</code>, the following </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">obtain</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span><span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h.exists_smul_eq</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
</code></pre></div>
<p>returns a cryptic </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="n">invalid</span> <span class="n">field</span> <span class="kd">notation</span><span class="o">,</span>
<span class="n">function</span> <span class="bp">'</span><span class="n">mul_action.is_pretransitive.exists_smul_eq'</span> <span class="n">does</span> <span class="n">not</span> <span class="k">have</span> <span class="n">explicit</span> <span class="n">argument</span>
<span class="k">with</span> <span class="n">type</span> <span class="o">(</span><span class="n">mul_action.is_pretransitive</span> <span class="bp">...</span><span class="o">)</span>
</code></pre></div>
<p>2)  Anyway, at that point, I arrive at the following context, </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">x</span> <span class="n">y</span><span class="o">:</span>  <span class="n">X</span>
<span class="n">g</span><span class="o">:</span> <span class="bp">↥</span><span class="n">H</span>
<span class="n">hgxy</span><span class="o">:</span> <span class="n">g</span> <span class="bp">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>
<span class="n">z'</span><span class="o">:</span> <span class="n">T</span> <span class="o">(</span><span class="bp">↑</span><span class="n">g</span> <span class="bp">•</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⇑</span><span class="n">mul_aut.conj</span> <span class="bp">↑</span><span class="n">g</span> <span class="bp">•</span> <span class="n">T</span> <span class="n">x</span>
<span class="bp">⊢</span> <span class="n">T</span> <span class="o">(</span><span class="n">g</span> <span class="bp">•</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">H</span> <span class="bp">⊔</span> <span class="n">T</span> <span class="n">x</span>
</code></pre></div>
<p>but I get coercions <code>↑g</code> that prevent me to <code>rw z'</code>. Can you explain me what I did wrong, or what goes on?<br>
Thank you !</p>



<a name="260344775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/260344775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#260344775">(Nov 04 2021 at 22:43)</a>:</h4>
<p>Can you paste a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>? Then people can start playing with the code</p>



<a name="260344947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/260344947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#260344947">(Nov 04 2021 at 22:45)</a>:</h4>
<p>I think I got it. Don't worry, Ruben.</p>



<a name="260345392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/260345392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#260345392">(Nov 04 2021 at 22:50)</a>:</h4>
<p>This works for me:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.group_action.basic</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">G</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">G</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span>
  <span class="o">[</span><span class="n">mul_action.is_pretransitive</span> <span class="n">H</span> <span class="n">X</span><span class="o">]</span>

<span class="kn">include</span> <span class="n">G</span> <span class="n">X</span> <span class="n">H</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">H</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">infer_instance</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span><span class="n">hg</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mul_action.exists_smul_eq</span> <span class="n">H</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260345407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/260345407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#260345407">(Nov 04 2021 at 22:50)</a>:</h4>
<p>For 1), <code>is_pretransitive</code> is a <code>class</code> which makes it awkward to use values of the type directly--you're intended to write---what Adam just wrote.</p>



<a name="260345447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/260345447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#260345447">(Nov 04 2021 at 22:51)</a>:</h4>
<p>For 2), hard to say without knowing where <code>z'</code> came from</p>



<a name="260345701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/260345701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#260345701">(Nov 04 2021 at 22:54)</a>:</h4>
<p>I guess that <code>hgxy</code> is about the action of <code>H</code> while <code>z'</code> is about the action of <code>G</code>--are these the same by definition? If so you might be able to use <code>change</code> to massage <code>z'</code> into the form you want</p>



<a name="260345801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/260345801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#260345801">(Nov 04 2021 at 22:55)</a>:</h4>
<p>or you can rewrite using <a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup.smul_def">docs#subgroup.smul_def</a></p>



<a name="260345921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/260345921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#260345921">(Nov 04 2021 at 22:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="307953">Ruben Van de Velde</span> <a href="#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/260344775">said</a>:</p>
<blockquote>
<p>Can you paste a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>? Then people can start playing with the code</p>
</blockquote>
<p>Here it is !</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">H</span><span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span>
  <span class="o">(</span><span class="n">is_conj</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">g</span><span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">T</span> <span class="o">(</span><span class="n">g</span> <span class="bp">•</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">mul_aut.conj</span> <span class="n">g</span> <span class="bp">•</span> <span class="o">(</span><span class="n">T</span> <span class="n">x</span><span class="o">))</span>
  <span class="o">(</span><span class="n">is_generator</span><span class="o">:</span> <span class="n">supr</span> <span class="n">T</span> <span class="bp">=</span> <span class="bp">⊤</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_pretransitive</span> <span class="n">H</span> <span class="n">X</span> <span class="bp">→</span> <span class="bp">∀</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">X</span><span class="o">),</span> <span class="n">H</span> <span class="bp">⊔</span> <span class="n">T</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">⊤</span>   <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">hHX</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">le_antisymm</span> <span class="n">le_top</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">is_generator</span><span class="o">],</span>
    <span class="n">rw</span> <span class="n">supr</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">Sup_le</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">K</span> <span class="n">hK</span><span class="o">,</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hKy</span><span class="o">⟩:=</span> <span class="n">hK</span><span class="o">,</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">hKy</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">hHX.exists_smul_eq</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span><span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">z</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">z'</span> <span class="o">:=</span> <span class="n">is_conj</span> <span class="o">(</span><span class="n">g</span><span class="o">:</span><span class="n">G</span><span class="o">)</span> <span class="n">x</span><span class="o">,</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="kd">end</span>
</code></pre></div>



<a name="260346536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/260346536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#260346536">(Nov 04 2021 at 23:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/260345447">said</a>:</p>
<blockquote>
<p>For 2), hard to say without knowing where <code>z'</code> came from</p>
</blockquote>
<p>As you can see on the MWE, I have an hypothesis <code>is_conj: ∀ g: G, ∀ x : X, T (g • x) = mul_aut.conj g • (T x)</code> and I create <code>z'</code> by <code>let z' := is_conj (g:G) x</code>.</p>



<a name="260347248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/260347248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#260347248">(Nov 04 2021 at 23:11)</a>:</h4>
<p>I think using <code>subgroup.smul_def</code> is the way to go</p>



<a name="262448248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262448248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262448248">(Nov 23 2021 at 12:24)</a>:</h4>
<p>A new question that puzzled me for a few hours : <br>
I need to make sense of something like this :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">A</span><span class="o">),</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">a</span> <span class="o">}</span> <span class="bp">=</span> <span class="o">{</span> <span class="n">b</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">|</span> <span class="n">p</span> <span class="bp">↑</span><span class="n">b</span> <span class="o">}</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
</code></pre></div>
<p>What I could do is </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">A</span><span class="o">),</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">a</span> <span class="o">}</span> <span class="bp">⊆</span> <span class="n">B</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span> <span class="n">rw</span> <span class="n">set.mem_set_of_eq</span> <span class="n">at</span> <span class="n">ha</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hp</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>but I am stuck of ideas to help me pass from the elementary second example to something that looks like the first one.</p>
<p>Actually, this comes from a more complicated context, <code>group A</code>, <code>B : subgroup A</code>, and ultimately, I will need to apply <code>subgroup.closure</code> to both sets to identify <code>subgroup.closure { a : A | p a }</code> with <code>subgroup.closure { b : B | p ↑b }</code>.</p>



<a name="262448745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262448745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262448745">(Nov 23 2021 at 12:29)</a>:</h4>
<p>This looks like you got lost in subtyping hell. Can you give the original problem instead?</p>



<a name="262449231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262449231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262449231">(Nov 23 2021 at 12:35)</a>:</h4>
<p>Can the first example even be proved? The structure of the two types are different: you have <code>(x : { b : B | p b }).1.1.1 : α</code> but <code>(x : { b : A | p b }).1.1 : α</code>.</p>



<a name="262449290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262449290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262449290">(Nov 23 2021 at 12:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/262448745">said</a>:</p>
<blockquote>
<p>This looks like you got lost in subtyping hell. Can you give the original problem instead?</p>
</blockquote>
<p>Sure. I want to prove that the alternating group is simple, and to start with, that it is perfect (<code>commutator (alternating_group α) = ⊤</code>).<br>
I have already proved : </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">three_cycle_is_commutator</span> <span class="c1">-- {α : Type*} [decidable_eq α] [fintype α]</span>
  <span class="o">[</span><span class="n">h5</span><span class="o">:</span> <span class="mi">5</span> <span class="bp">≤</span> <span class="n">fintype.card</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">alternating_group</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
   <span class="n">is_three_cycle</span> <span class="o">(</span><span class="n">g</span><span class="o">:</span><span class="n">perm</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">g</span> <span class="bp">∈</span> <span class="n">commutator</span> <span class="o">(</span><span class="n">alternating_group</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">hg</span><span class="o">,</span>
    <span class="c1">-- g^2 est conjugué de g : g^2 = h g h⁻¹ , donc hg = [h,g]</span>
  <span class="k">let</span> <span class="n">hg2</span> <span class="o">:=</span> <span class="n">hg.is_three_cycle_sq</span><span class="o">,</span> <span class="c1">-- g^2 is a 3-cycle</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">subgroup.coe_mul</span> <span class="n">_</span> <span class="n">g</span> <span class="n">g</span> <span class="n">at</span> <span class="n">hg2</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">h</span><span class="o">,</span> <span class="n">hh</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">alternating_group.is_three_cycle_is_conj</span> <span class="n">h5</span> <span class="n">hg</span> <span class="n">hg2</span><span class="o">,</span>
  <span class="c1">-- g^2 is conjugate to g ;  hh :  g^2 * h = h * g</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">h</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">h</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">subgroup.closure_le_normal_closure</span> <span class="o">,</span>
    <span class="n">apply</span> <span class="n">subgroup.subset_closure</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">set.mem_set_of_eq</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">h</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">this.symm</span><span class="o">⟩},</span>
  <span class="n">exact</span> <span class="k">calc</span> <span class="n">g</span> <span class="bp">=</span> <span class="o">(</span><span class="n">g</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">*</span> <span class="bp">↑</span><span class="n">h</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">↑</span><span class="n">h</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">⁻¹</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">simp</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">↑</span><span class="n">h</span> <span class="bp">*</span> <span class="n">g</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">↑</span><span class="n">h</span><span class="o">)</span><span class="bp">⁻¹</span>  <span class="bp">*</span> <span class="n">g</span><span class="bp">⁻¹</span>  <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">hh.symm</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="bp">↑</span><span class="n">h</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">↑</span><span class="n">h</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>and I want to combine this with <br>
<code>alternating_group.closure_three_cycles_eq_alternating :  closure {σ : perm α | is_three_cycle σ} = alternating_group α</code><br>
(which is in <code>alternating.lean</code>) to get my result.</p>



<a name="262449382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262449382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262449382">(Nov 23 2021 at 12:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/262449231">said</a>:</p>
<blockquote>
<p>Can the first example even be proved? The structure of the two types are different: you have <code>(x : { b : B | p b }).1.1.1 : α</code> but <code>(x : { b : A | p b }).1.1 : α</code>.</p>
</blockquote>
<p>No, the types are different, but I need somehow to tell Lean that the two sets are equal, so that they will generate the same stuff afterwards…</p>



<a name="262449446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262449446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262449446">(Nov 23 2021 at 12:37)</a>:</h4>
<p>This typechecks:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">A</span><span class="o">),</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">a</span> <span class="o">}</span> <span class="bp">=</span> <span class="n">subtype.val</span> <span class="bp">''</span> <span class="o">{</span> <span class="n">b</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">|</span> <span class="n">p</span> <span class="bp">↑</span><span class="n">b</span> <span class="o">}</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="262449627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262449627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262449627">(Nov 23 2021 at 12:39)</a>:</h4>
<p>Right, like <span class="user-mention" data-user-id="112680">@Johan Commelin</span> suggested, we need a map to translate <code>closure_three_cycles_eq_alternating</code>, a statement on subgroups of <code>perm α</code> to a statement on subgroups of <code>alternating_group α</code> like your goal and <code>three_cycle_is_commutator</code>.</p>



<a name="262449811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262449811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262449811">(Nov 23 2021 at 12:41)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">A</span><span class="o">),</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">a</span> <span class="o">}</span> <span class="bp">=</span> <span class="n">subtype.val</span> <span class="bp">''</span> <span class="o">{</span> <span class="n">b</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">|</span> <span class="n">p</span> <span class="bp">↑</span><span class="n">b</span> <span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_image</span><span class="o">,</span> <span class="n">set_coe.exists</span><span class="o">,</span> <span class="n">exists_and_distrib_right</span><span class="o">,</span> <span class="n">subtype.mk_eq_mk</span><span class="o">,</span>
    <span class="n">exists_eq_right</span><span class="o">,</span> <span class="n">subtype.exists</span><span class="o">,</span> <span class="n">set.mem_set_of_eq</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">,</span> <span class="n">subtype.val_eq_coe</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">hpa</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">hp</span> <span class="n">_</span> <span class="n">hpa</span><span class="o">,</span> <span class="n">hpa</span><span class="o">⟩,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">H1</span><span class="o">,</span> <span class="n">H2</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="n">H2</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="262450018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262450018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262450018">(Nov 23 2021 at 12:43)</a>:</h4>
<p>So what we're actually after is the dual form, <code>subtype.val '⁻¹ {a : A | p a} = {b : B | p B}</code>. Or in group-theoretic language <code>comap (alternating_group α).subtype (closure {σ : perm α | is_three_cycle σ}) = \top</code>.</p>



<a name="262450208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262450208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262450208">(Nov 23 2021 at 12:45)</a>:</h4>
<p>Every time I see <code>.subtype</code> I think it's a pretty horrible name for the inclusion map.</p>



<a name="262450384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262450384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262450384">(Nov 23 2021 at 12:47)</a>:</h4>
<p>I'm confused, isn't <code>comap H.subtype H' = ⊤</code> simply saying that <code>H'</code> contains <code>H</code>?</p>



<a name="262450402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262450402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262450402">(Nov 23 2021 at 12:47)</a>:</h4>
<p>Wouldn't it be better to write <code>H ≤ H'</code> in that case?</p>



<a name="262450484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262450484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262450484">(Nov 23 2021 at 12:48)</a>:</h4>
<p>Indeed, that would be the next step towards proving the result :)</p>



<a name="262450760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262450760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262450760">(Nov 23 2021 at 12:51)</a>:</h4>
<p>At least, I'm thinking of a proof of the lines </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">calc</span> <span class="n">commutator</span> <span class="o">(</span><span class="n">alternating_group</span> <span class="n">α</span><span class="o">)</span>
    <span class="bp">=</span> <span class="n">closure</span> <span class="o">(</span><span class="n">conjugates_of_set</span> <span class="n">_</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">comap</span> <span class="o">(</span><span class="n">alternating_group</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">subtype</span> <span class="o">(</span><span class="n">closure</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">is_three_cycle</span> <span class="n">σ</span><span class="o">})</span> <span class="o">:</span> <span class="gr">sorry</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="bp">⊤</span> <span class="o">:</span> <span class="n">comap_subtype_eq_top</span> <span class="gr">sorry</span>
</code></pre></div>
<p>(with <code>comap_subtype_eq_top</code> exactly what you mentioned)</p>



<a name="262450819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262450819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262450819">(Nov 23 2021 at 12:52)</a>:</h4>
<p>(Some of these <code>=</code>es can equivalently be replaced <code>≤</code>s of course.)</p>



<a name="262458797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262458797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262458797">(Nov 23 2021 at 14:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/262450208">said</a>:</p>
<blockquote>
<p>Every time I see <code>.subtype</code> I think it's a pretty horrible name for the inclusion map.</p>
</blockquote>
<p>Note that for <code>subalgebra</code> it's called <a href="https://leanprover-community.github.io/mathlib_docs/find/subalgebra.val">docs#subalgebra.val</a> instead</p>



<a name="262460639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262460639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262460639">(Nov 23 2021 at 14:14)</a>:</h4>
<p>Which makes sense, I guess. Although I think <code>.incl</code> is even more descriptive.</p>



<a name="262461257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262461257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262461257">(Nov 23 2021 at 14:19)</a>:</h4>
<p>I think we use that name elsewhere for the inclusion map between two subobjects <code>p1 ≤ p2</code></p>



<a name="262461305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262461305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262461305">(Nov 23 2021 at 14:19)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/submonoid.inclusion">docs#submonoid.inclusion</a>?</p>



<a name="262461491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262461491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262461491">(Nov 23 2021 at 14:20)</a>:</h4>
<p>Right, we want both</p>



<a name="262464222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262464222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262464222">(Nov 23 2021 at 14:40)</a>:</h4>
<p>I suppose <code>incl</code> and <code>incl_of_le</code> would be reasonable names</p>



<a name="262464274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262464274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262464274">(Nov 23 2021 at 14:41)</a>:</h4>
<p>Although you could maybe argue that <code>subtype.val</code> should be renamed to <code>subtype.incl</code> too...</p>



<a name="262464653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262464653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262464653">(Nov 23 2021 at 14:43)</a>:</h4>
<p>The difference is that <code>x.val</code> is dot-notation on a term of a subtype, whereas <code>H.incl</code> is dot-notation on a <code>subgroup</code> (or whatever).<br>
Both are also function-like gadgets. But <code>subtype.val</code> doesn't involve a <code>coe_to_sort</code>, whereas <code>H.incl</code> does.<br>
Maybe <code>set.incl</code> should exist.</p>



<a name="262470064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262470064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262470064">(Nov 23 2021 at 15:22)</a>:</h4>
<p>Your discussion lost me! I'm trying to understand what <code>subtype.val</code> does… Is it the inclusion map from a <code>B</code> (viewed as a subtype of <code>A</code>) to <code>A</code>?</p>



<a name="262472079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262472079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262472079">(Nov 23 2021 at 15:37)</a>:</h4>
<p>Thanks ! Now, to go back to my context, where I have <code>group A</code> and <code>B: subgroup A</code>, it seems that what I need to compare a given subgroup of <code>B</code>with another given subgroup of <code>A</code>, such as in </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- does not type - fill in ...</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">subgroup.closure</span> <span class="o">({</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">a</span> <span class="o">})</span> <span class="bp">=</span> <span class="bp">...</span> <span class="o">(</span><span class="n">subgroup.closure</span><span class="o">({</span> <span class="n">b</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">|</span> <span class="n">p</span> <span class="bp">↑</span><span class="n">b</span><span class="o">}))</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="262472480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262472480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262472480">(Nov 23 2021 at 15:40)</a>:</h4>
<p>Indeed! And the thing you want to fill for the dots are <code>subgroup.map B.subtype</code>, or what I think will turn out to be easier: put <code>subgroup.comap B.subtype</code> on the left instead.</p>



<a name="262472583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262472583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262472583">(Nov 23 2021 at 15:41)</a>:</h4>
<p>(Easier means here: "saves one rewrite step", if we did it right.)</p>



<a name="262476057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262476057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262476057">(Nov 23 2021 at 16:05)</a>:</h4>
<p>BTW <span class="user-mention" data-user-id="130609">@Antoine Chambert-Loir</span> <code>[B  : subgroup A]</code> should probably be <code>(B : subgroup A)</code> or <code>{B : subgroup A}</code>, as <code>subgroup</code> is not a class so square brackets won't do anything. The point is that 99 times out 100 a type has at most one group structure on it, but certainly it's commonplace that a group can have two subgroups, so <code>subgroup</code> shouldn't be a class.</p>



<a name="262493435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262493435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262493435">(Nov 23 2021 at 18:14)</a>:</h4>
<p>I'm making progress… but don't you find that the following sequence of instructions is absolutely ridiculous ?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">∈</span> <span class="n">map</span> <span class="n">B.subtype</span> <span class="n">C</span> <span class="bp">↔</span> <span class="o">(⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">C</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">H</span><span class="o">,</span> <span class="n">hH</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">subgroup.mem_map.mp</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">((⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">eq.symm</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">set_like.coe_mk</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="n">this</span> <span class="n">at</span> <span class="n">hH</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subgroup.coe_subtype</span><span class="o">,</span> <span class="n">subgroup.coe_mk</span><span class="o">]</span> <span class="n">at</span> <span class="n">hH</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">this</span> <span class="n">at</span> <span class="n">hH</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set_like.coe_eq_coe</span> <span class="o">]</span> <span class="n">at</span> <span class="n">hH</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">hH</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">subgroup.mem_map.mpr</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">use</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subgroup.coe_subtype</span><span class="o">,</span> <span class="n">subgroup.coe_mk</span><span class="o">],</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="262494062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262494062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262494062">(Nov 23 2021 at 18:20)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">∈</span> <span class="n">map</span> <span class="n">B.subtype</span> <span class="n">C</span> <span class="bp">↔</span> <span class="o">(⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">C</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">tidy</span>
</code></pre></div>



<a name="262494428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262494428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262494428">(Nov 23 2021 at 18:23)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">∈</span> <span class="n">map</span> <span class="n">B.subtype</span> <span class="n">C</span> <span class="bp">↔</span> <span class="o">(⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">C</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩,</span> <span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="n">h</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩,</span> <span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="262494681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262494681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262494681">(Nov 23 2021 at 18:25)</a>:</h4>
<p>I also found <code>by { simp [subgroup.mem_map, set_like.exists], tauto }</code> which may or may not be considered good style</p>



<a name="262500176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262500176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262500176">(Nov 23 2021 at 19:10)</a>:</h4>
<p>Golfed further:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.subgroup.basic</span>
<span class="kn">open</span> <span class="n">subgroup</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">∈</span> <span class="n">map</span> <span class="n">B.subtype</span> <span class="n">C</span> <span class="bp">↔</span> <span class="o">(⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">C</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">function.injective.mem_set_image</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">subtype.coe_injective</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span>
</code></pre></div>



<a name="262503666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262503666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262503666">(Nov 23 2021 at 19:42)</a>:</h4>
<p>Y'all, you're sorcerers…</p>



<a name="262504145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262504145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262504145">(Nov 23 2021 at 19:46)</a>:</h4>
<p>Would you have a link to a description of what <code>rintro</code> is used, especially with<code>rfl</code>?</p>



<a name="262504429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262504429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262504429">(Nov 23 2021 at 19:49)</a>:</h4>
<p>Hopefully <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#rintro">tactic#rintro</a> or <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#rcases">tactic#rcases</a> is helpful (edit: I guess you need to read both <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>)</p>



<a name="262504653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262504653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262504653">(Nov 23 2021 at 19:51)</a>:</h4>
<p>Thanks ! Meanwhile, I tried entering <code>rintro</code>in the google search window, and guess what?…</p>



<a name="262516361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262516361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262516361">(Nov 23 2021 at 21:31)</a>:</h4>
<p>Just for fun, here is an incomprehensible version of Kevin's proof ;)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">∈</span> <span class="n">map</span> <span class="n">B.subtype</span> <span class="n">C</span> <span class="bp">↔</span> <span class="o">(⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">C</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span><span class="o">⟨⟨</span><span class="n">_</span><span class="o">,</span><span class="n">_</span><span class="o">⟩,</span><span class="n">h</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩,</span><span class="n">h</span><span class="o">,</span><span class="bp">λ</span><span class="n">h</span><span class="o">,⟨⟨</span><span class="n">a</span><span class="o">,</span><span class="n">_</span><span class="o">⟩,</span><span class="n">h</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩⟩</span>
</code></pre></div>



<a name="262516927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262516927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262516927">(Nov 23 2021 at 21:36)</a>:</h4>
<p><code>⟨a,_⟩</code> can be <em>golfed</em> to <code>⟨_,_⟩</code></p>



<a name="262516977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262516977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262516977">(Nov 23 2021 at 21:37)</a>:</h4>
<p>That last <code>rfl</code> is doing it's job!</p>



<a name="262516999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262516999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262516999">(Nov 23 2021 at 21:37)</a>:</h4>
<p>I say <code>⟨λ⟨⟨_,_⟩,h,rfl⟩,h,λh,⟨_,h,rfl⟩⟩</code></p>



<a name="262517161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262517161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262517161">(Nov 23 2021 at 21:39)</a>:</h4>
<p>I am surprised this works -- I thought the <code>rfl</code> hack would not work with a lambda in term mode.</p>



<a name="262517291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262517291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262517291">(Nov 23 2021 at 21:40)</a>:</h4>
<p>And now with even more underscores:<br>
<code>⟨λ⟨⟨_,_⟩,_,rfl⟩,‹_›,λ_,⟨⟨_,_⟩,‹_›,rfl⟩⟩</code></p>



<a name="262517412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262517412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262517412">(Nov 23 2021 at 21:41)</a>:</h4>
<p>Wow!! I've never really understood what <code>‹_›</code> means, but it's very nice</p>



<a name="262517917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262517917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262517917">(Nov 23 2021 at 21:45)</a>:</h4>
<p>it's basically just a short way to write <code>by assumption</code>!</p>



<a name="262518132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262518132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262518132">(Nov 23 2021 at 21:47)</a>:</h4>
<p><span class="user-mention" data-user-id="130609">@Antoine Chambert-Loir</span> here's an example of the rfl hack:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">open</span> <span class="n">function</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">Z</span><span class="o">)</span>

<span class="c1">-- recall that surjective f := ∀ y : Y, ∃ x : X, f x = y</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">surjective</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">z</span><span class="o">,</span>
  <span class="c1">-- goal `⊢ ∃ (x : X), (g ∘ f) x = z`</span>
  <span class="n">rcases</span> <span class="n">hg</span> <span class="n">z</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">⟩,</span>
  <span class="c1">-- `hy : g y = z`</span>
  <span class="c1">-- so we have a *formula* for z now, it's g(y)</span>
  <span class="n">rcases</span> <span class="n">hf</span> <span class="n">y</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩,</span>
  <span class="c1">-- and now `hx : f x = y`</span>
  <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  z : Z</span>
<span class="cm">  y : Y</span>
<span class="cm">  hy : g y = z</span>
<span class="cm">  x : X</span>
<span class="cm">  hx : f x = y</span>
<span class="cm">  ⊢ (g ∘ f) x = z</span>
<span class="cm">  -/</span>
  <span class="c1">-- there are now several ways to finish, e.g.</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">hy</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">hx</span><span class="o">,</span>
  <span class="c1">-- goal got closed because it's now refl and rw tries this</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">surjective</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">z</span><span class="o">,</span>
  <span class="c1">-- goal `⊢ ∃ (x : X), (g ∘ f) x = z`</span>
  <span class="n">rcases</span> <span class="n">hg</span> <span class="n">z</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="c1">-- *define* z to be g(y)</span>
  <span class="c1">-- goal now `⊢ ∃ (a : X), (g ∘ f) a = g y`</span>
  <span class="n">rcases</span> <span class="n">hf</span> <span class="n">y</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="c1">-- now there are no y's or z's in the local context, just</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  x: X</span>
<span class="cm">  ⊢ ∃ (a : X), (g ∘ f) a = g (f x)</span>
<span class="cm">  -/</span>
  <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
  <span class="c1">-- goal was rfl so got closed because `use` tries `triv` which tries `refl`</span>
<span class="kd">end</span>
</code></pre></div>



<a name="262589210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262589210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262589210">(Nov 24 2021 at 13:40)</a>:</h4>
<p>Little progress, Lean knows that the alternating group is perfect… With coercion hacks showing that I didn't really understand what y'all told me yesterday. See <a href="https://github.com/leanprover-community/mathlib/issues/10253">#10253</a></p>



<a name="262593359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262593359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262593359">(Nov 24 2021 at 14:12)</a>:</h4>
<p><span class="user-mention" data-user-id="130609">@Antoine Chambert-Loir</span> What do you think of the following approach?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- still quite stupid, but maybe not too bad</span>
<span class="kd">theorem</span> <span class="n">ok_lemma</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">closure</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">closure</span> <span class="o">{</span><span class="n">g</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">g</span><span class="o">}</span> <span class="bp">|</span> <span class="n">p</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)}</span> <span class="bp">=</span> <span class="bp">⊤</span> <span class="o">:=</span>
<span class="kd">begin</span>

<span class="kd">end</span>

<span class="sd">/-- If n ≥ 5, then the alternating group on n letters is perfect -/</span>
<span class="kd">theorem</span> <span class="n">alternating_group_is_perfect</span> <span class="o">(</span><span class="n">h5</span> <span class="o">:</span> <span class="mi">5</span> <span class="bp">≤</span> <span class="n">fintype.card</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">commutator</span> <span class="o">(</span><span class="n">alternating_group</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⊤</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">closure</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">alternating_group</span> <span class="n">α</span> <span class="bp">|</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">is_three_cycle</span><span class="o">}</span> <span class="bp">=</span> <span class="bp">⊤</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">eq_top_iff</span><span class="o">,</span> <span class="bp">←</span> <span class="n">this</span><span class="o">,</span> <span class="n">subgroup.closure_le</span><span class="o">],</span>
    <span class="n">intros</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">three_cycle_mem_commutator</span> <span class="n">h5</span> <span class="n">hb</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">closure_three_cycles_eq_alternating</span><span class="o">,</span> <span class="n">ok_lemma</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="262594139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262594139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262594139">(Nov 24 2021 at 14:18)</a>:</h4>
<p>Let my try that, thanks! <br>
(On the other hand, <span class="user-mention" data-user-id="310045">@Eric Wieser</span> noted that the <code>ugly_lemma</code> matches  <code>submodule.comap_subtype_self</code> and should be put in <code>subgroup/basic.lean</code>  (Aside : how to refer to a file of the library or to a function so that it adds a link?)</p>



<a name="262594662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262594662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262594662">(Nov 24 2021 at 14:22)</a>:</h4>
<p>you can type <a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.comap_subtype_self">docs#submodule.comap_subtype_self</a> or <a href="https://tqft.net/mathlib/group_theory/subgroup/basic">file#group_theory/subgroup/basic</a> in Zulip, if that's what you mean</p>



<a name="262594768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262594768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262594768">(Nov 24 2021 at 14:23)</a>:</h4>
<p>Is <code>ok_lemma</code> at all related to <a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup.closure_closure_coe_preimage">docs#subgroup.closure_closure_coe_preimage</a>?</p>



<a name="262595433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262595433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262595433">(Nov 24 2021 at 14:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/262594768">said</a>:</p>
<blockquote>
<p>Is <code>ok_lemma</code> at all related to <a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup.closure_closure_coe_preimage">docs#subgroup.closure_closure_coe_preimage</a>?</p>
</blockquote>
<p>Ugh! That statement is unreadable in the docs <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span></p>



<a name="262595457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262595457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262595457">(Nov 24 2021 at 14:27)</a>:</h4>
<p>But I think it is exactly <code>ok_lemma</code></p>



<a name="262595907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262595907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262595907">(Nov 24 2021 at 14:31)</a>:</h4>
<p>It would be nice if we could teach doc-gen (or maybe the pretty-printer?) to show  unapplied<code>coe</code> with a type annotation</p>



<a name="262597753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262597753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262597753">(Nov 24 2021 at 14:47)</a>:</h4>
<p>It seems my bersion of subgroup.basic.lean is not recent enough… I tried <code>leanproject get-cache</code>, <code>leanproject up</code>, <code>leanproject pull</code> but nothing happens.…</p>



<a name="262598527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262598527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262598527">(Nov 24 2021 at 14:53)</a>:</h4>
<p><span class="user-mention" data-user-id="130609">@Antoine Chambert-Loir</span> Please take these steps:</p>
<ol>
<li>save and commit whatever you've still open</li>
<li>run <code>git pull</code></li>
<li>run <code>git merge master</code></li>
<li>run <code>leanproject get-cache</code></li>
</ol>



<a name="262598573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262598573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262598573">(Nov 24 2021 at 14:53)</a>:</h4>
<p>Here's my own proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">_root_.subgroup.subtype_injective</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">function.injective</span> <span class="n">H.subtype</span> <span class="o">:=</span>
<span class="n">subtype.val_injective</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">_root_.subgroup.map_top</span> <span class="o">{</span><span class="n">G</span> <span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">H</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">subgroup.map</span> <span class="n">f</span> <span class="bp">⊤</span> <span class="bp">=</span> <span class="n">f.range</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">iff_self</span><span class="o">,</span> <span class="n">mem_map</span><span class="o">,</span> <span class="n">monoid_hom.mem_range</span><span class="o">,</span> <span class="n">exists_true_left</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span> <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="bp">-</span><span class="o">,</span> <span class="n">hg</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">hg</span><span class="o">⟩</span> <span class="o">},</span> <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">hg</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">mem_top</span> <span class="n">_</span><span class="o">,</span> <span class="n">hg</span><span class="o">⟩</span> <span class="o">}</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">_root_.subgroup.map_closure</span>
  <span class="o">{</span><span class="n">G</span> <span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">H</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">subgroup.map</span> <span class="n">f</span> <span class="o">(</span><span class="n">closure</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">closure</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">h</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mem_map</span><span class="o">],</span> <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">hg</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="n">closure_induction</span> <span class="n">hg</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span> <span class="n">hh</span><span class="o">,</span> <span class="n">exact</span> <span class="n">subset_closure</span> <span class="o">(</span><span class="n">set.mem_image_of_mem</span> <span class="n">_</span> <span class="n">hh</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">f.map_one</span><span class="o">,</span> <span class="n">exact</span> <span class="n">one_mem</span> <span class="n">_</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">hh₁</span> <span class="n">hh₂</span><span class="o">,</span> <span class="n">rw</span> <span class="n">f.map_mul</span><span class="o">,</span> <span class="n">exact</span> <span class="n">mul_mem</span> <span class="n">_</span> <span class="n">hh₁</span> <span class="n">hh₂</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span> <span class="n">hh</span><span class="o">,</span> <span class="n">rw</span> <span class="n">f.map_inv</span><span class="o">,</span> <span class="n">exact</span> <span class="n">inv_mem</span> <span class="n">_</span> <span class="n">hh</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">hh</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">closure_induction</span> <span class="n">hh</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">hg</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">subset_closure</span> <span class="n">hg</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">one_mem</span> <span class="n">_</span><span class="o">,</span> <span class="n">f.map_one</span><span class="o">⟩</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="n">_</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">g₁</span><span class="o">,</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">g₂</span><span class="o">,</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">g₁</span> <span class="bp">*</span> <span class="n">g₂</span><span class="o">,</span> <span class="n">mul_mem</span> <span class="n">_</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">f.map_mul</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">hg</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">g</span><span class="bp">⁻¹</span><span class="o">,</span> <span class="n">inv_mem</span> <span class="n">_</span> <span class="n">hg</span><span class="o">,</span> <span class="n">f.map_inv</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">_root_.set.coe_image_subtype_coe</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">coe</span> <span class="bp">''</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">subtype</span> <span class="n">p</span> <span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">a</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">exists_prop</span><span class="o">,</span> <span class="n">set.mem_image</span><span class="o">,</span> <span class="n">subtype.exists</span><span class="o">,</span> <span class="n">set.mem_set_of_eq</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span> <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="n">h2</span> <span class="o">},</span> <span class="o">{</span> <span class="n">intro</span> <span class="n">ha</span><span class="o">,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">h</span> <span class="n">_</span> <span class="n">ha</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">ok_lemma</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">closure</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">closure</span> <span class="n">s</span> <span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}</span> <span class="bp">=</span> <span class="bp">⊤</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">map_injective</span> <span class="o">(</span><span class="n">subgroup.subtype_injective</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subgroup.map_closure</span><span class="o">,</span> <span class="n">subgroup.map_closure</span><span class="o">,</span> <span class="n">subgroup.map_top</span><span class="o">,</span> <span class="n">subtype_range</span><span class="o">,</span>
    <span class="n">subgroup.coe_subtype</span><span class="o">],</span>
  <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span> <span class="n">erw</span> <span class="o">[</span><span class="n">set.coe_image_subtype_coe</span><span class="o">],</span> <span class="n">intros</span> <span class="n">g</span> <span class="n">hg</span><span class="o">,</span> <span class="n">exact</span> <span class="n">subset_closure</span> <span class="n">hg</span>
<span class="kd">end</span>
</code></pre></div>



<a name="262598630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262598630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262598630">(Nov 24 2021 at 14:54)</a>:</h4>
<p>Looks like there's a bunch of missing lemmas. (At least I couldn't find them.)</p>



<a name="262598741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262598741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262598741">(Nov 24 2021 at 14:55)</a>:</h4>
<p><code>subgroup.map_top</code> is <a href="https://leanprover-community.github.io/mathlib_docs/find/monoid_hom.range_eq_map">docs#monoid_hom.range_eq_map</a></p>



<a name="262598893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262598893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262598893">(Nov 24 2021 at 14:56)</a>:</h4>
<p><del><code>subgroup.map_closure</code> might be <a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup.closure_image">docs#subgroup.closure_image</a></del></p>



<a name="262598954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262598954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262598954">(Nov 24 2021 at 14:56)</a>:</h4>
<p>This works nicely, without any additional lemma !</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- If n ≥ 5, then the alternating group on n letters is perfect -/</span>
<span class="kd">theorem</span> <span class="n">alternating_group_is_perfect</span> <span class="o">(</span><span class="n">h5</span> <span class="o">:</span> <span class="mi">5</span> <span class="bp">≤</span> <span class="n">fintype.card</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">commutator</span> <span class="o">(</span><span class="n">alternating_group</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⊤</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">closure</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">alternating_group</span> <span class="n">α</span> <span class="bp">|</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">is_three_cycle</span><span class="o">}</span> <span class="bp">=</span> <span class="bp">⊤</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">eq_top_iff</span><span class="o">,</span> <span class="bp">←</span> <span class="n">this</span><span class="o">,</span> <span class="n">subgroup.closure_le</span><span class="o">],</span>
    <span class="n">intros</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">three_cycle_mem_commutator</span> <span class="n">h5</span> <span class="n">hb</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">closure_three_cycles_eq_alternating</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">subgroup.closure_closure_coe_preimage</span> <span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="262599093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262599093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262599093">(Nov 24 2021 at 14:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/262598527">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="130609">Antoine Chambert-Loir</span> Please take these steps:</p>
<ol>
<li>save and commit whatever you've still open</li>
<li>run <code>git pull</code></li>
<li>run <code>git merge master</code></li>
<li>run <code>leanproject get-cache</code></li>
</ol>
</blockquote>
<p>What is the difference with <code>leanproject rebase</code>, which ultimately worked?<br>
 (I had done a <code>git stash</code> to preserve my modifications, and a <code>git stash pop</code> afterwards!)</p>



<a name="262599868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262599868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262599868">(Nov 24 2021 at 15:03)</a>:</h4>
<p>Aah, I didn't yet know about <code>leanproject rebase</code>. But it does almost the same thing under the hood.</p>



<a name="262600070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262600070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262600070">(Nov 24 2021 at 15:05)</a>:</h4>
<p>In fact, I'm not sure, I had an ugly <code>git merge</code> to do, but the new PR is done !</p>



<a name="262601668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262601668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262601668">(Nov 24 2021 at 15:19)</a>:</h4>
<p>Is it reasonable that I <code>merge 232 commits into master</code> ? <br>
It seems I should rather revert my previous commit…</p>



<a name="262602457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262602457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262602457">(Nov 24 2021 at 15:25)</a>:</h4>
<p>Yeah, that doesn't sound good.</p>



<a name="262602467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262602467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262602467">(Nov 24 2021 at 15:25)</a>:</h4>
<p>The merge should rather go in the other direction</p>



<a name="262603165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262603165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262603165">(Nov 24 2021 at 15:30)</a>:</h4>
<p>This is what I think too. <br>
I tried to do a revert, but that didn't change anything.</p>



<a name="262603639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262603639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262603639">(Nov 24 2021 at 15:34)</a>:</h4>
<p>(I think GitHub diff is just confused possibly, looking at and merging the branch locally it looks fine to me)</p>



<a name="262603653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262603653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262603653">(Nov 24 2021 at 15:34)</a>:</h4>
<p>What's your branch called?</p>



<a name="262604240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262604240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262604240">(Nov 24 2021 at 15:39)</a>:</h4>
<p>It sounds like you made this classic mistake:</p>
<ul>
<li><code>git rebase</code></li>
<li><code>git push</code>, which errors saying that upstream has diverged</li>
<li><code>git pull</code> (the mistake)</li>
</ul>
<p>After a rebase, you have to <code>git push -f</code>, not <code>git pull</code></p>



<a name="262604357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262604357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262604357">(Nov 24 2021 at 15:40)</a>:</h4>
<p>So now, what should I do ? <br>
I have tried to revert to the earlier stuff (and I have a copy of the files in their correct versions).</p>



<a name="262604702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262604702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262604702">(Nov 24 2021 at 15:43)</a>:</h4>
<p>What do you mean by "revert"?</p>



<a name="262604720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262604720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262604720">(Nov 24 2021 at 15:43)</a>:</h4>
<p>do you mean <code>git revert</code> or <code>git reset</code>?</p>



<a name="262604835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262604835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262604835">(Nov 24 2021 at 15:44)</a>:</h4>
<p><code>revert</code> is not "undo the git action I just did", it's "create a new commit that restores the files to how they were before the action I just did, on top of that action"</p>



<a name="262604934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262604934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262604934">(Nov 24 2021 at 15:45)</a>:</h4>
<p>I meant <code>revert</code>.…</p>



<a name="262605194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262605194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262605194">(Nov 24 2021 at 15:47)</a>:</h4>
<p><code>git reset --hard THE_BAD_MERGE_COMMIT^</code> should get you back to where you were before the merge (and discard your local changes)</p>



<a name="262605223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262605223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262605223">(Nov 24 2021 at 15:47)</a>:</h4>
<p>You might want to stash before that</p>



<a name="262605245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262605245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262605245">(Nov 24 2021 at 15:48)</a>:</h4>
<p>why not just make the PR and see what happens before doing anything drastic?</p>



<a name="262605267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262605267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262605267">(Nov 24 2021 at 15:48)</a>:</h4>
<p>bors squashes commits though no Eric? So yeah there's a bunch of noise there but technically it should be fine no? I think you can probably get the diff un-confused even by just pushing an empty commit, or if not just opening a new PR?</p>



<a name="262605364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262605364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262605364">(Nov 24 2021 at 15:48)</a>:</h4>
<p>I would generally not suggest <code>reset --hard</code> to someone who doesn't know what that does :)</p>



<a name="262605373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262605373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262605373">(Nov 24 2021 at 15:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/262605245">said</a>:</p>
<blockquote>
<p>why not just make the PR and see what happens before doing anything drastic?</p>
</blockquote>
<p>The best time to unbork git history is immediatey after you bork it</p>



<a name="262605387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262605387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262605387">(Nov 24 2021 at 15:49)</a>:</h4>
<p>Otherwise you build actual work on top of it and then you're in trouble</p>



<a name="262605420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262605420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262605420">(Nov 24 2021 at 15:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/262605245">said</a>:</p>
<blockquote>
<p>why not just make the PR and see what happens before doing anything drastic?</p>
</blockquote>
<p>Nothing is really drastic, I have copies of the two files which I have modified.</p>



<a name="262605450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262605450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262605450">(Nov 24 2021 at 15:49)</a>:</h4>
<p>then why not just make a new branch off master and copy-paste the files in :-)</p>



<a name="262605478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262605478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262605478">(Nov 24 2021 at 15:49)</a>:</h4>
<p>that's what I usually do ;-)</p>



<a name="262605499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262605499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262605499">(Nov 24 2021 at 15:50)</a>:</h4>
<p>There's no need to use a new branch; just <code>git reset --hard origin/master</code> and paste the files in</p>



<a name="262605536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262605536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262605536">(Nov 24 2021 at 15:50)</a>:</h4>
<p>That way you can reuse the existing PR</p>



<a name="262605646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262605646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262605646">(Nov 24 2021 at 15:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/262605194">said</a>:</p>
<blockquote>
<p><code>git reset --hard THE_BAD_MERGE_COMMIT^</code> should get you back to where you were before the merge (and discard your local changes)</p>
</blockquote>
<p>I retract this comment, it looks like you added extra commits after you made the offending merge in <code>e5552fd2add5b8c1b157345c525484617b36d1a2</code>, so the cleanup is much harder.</p>



<a name="262605799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262605799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262605799">(Nov 24 2021 at 15:52)</a>:</h4>
<p>All the commits that came afterwards were inoccuous.</p>



<a name="262605949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262605949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262605949">(Nov 24 2021 at 15:53)</a>:</h4>
<p>Then probably the quickest recovery is:</p>
<div class="codehilite" data-code-language="Bash"><pre><span></span><code>git reset --hard d1ca2d4c03cff5087afa52545b2f35bfd7449a0b

<span class="c1"># paste back over your files and check if anything changed that you weren't expecting, and commit them</span>

git push --force
</code></pre></div>



<a name="262606125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20subtypes%2C%20coercions%20and%20rw/near/262606125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw.html#262606125">(Nov 24 2021 at 15:54)</a>:</h4>
<p>Perhaps <code>leanproject rebase</code> should have some heavy warnings, since using it without understanding a <code>git rebase</code> that well gets you in this trap.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
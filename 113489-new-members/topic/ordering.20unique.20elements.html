---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/ordering.20unique.20elements.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ordering.20unique.20elements.html">ordering unique elements</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="273903348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ordering%20unique%20elements/near/273903348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Evan Lohn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ordering.20unique.20elements.html#273903348">(Mar 03 2022 at 00:40)</a>:</h4>
<p>I want to prove that some unique elements of <code>fin N</code> satisfying some property have an "ordered version" of those elements also each satisfying the property. Is this the best way to go about doing so? Would love any feedback (even on style)!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin.basic</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">N</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">not_lt_neq_gt</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span> <span class="n">fin</span> <span class="n">N</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span><span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">))</span> <span class="o">(</span><span class="n">h2</span><span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span><span class="o">):</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">not_lt</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">or.resolve_left</span> <span class="o">(</span><span class="n">eq_or_lt_of_le</span> <span class="n">h1</span><span class="o">)</span> <span class="o">(</span><span class="n">ne.symm</span> <span class="n">h2</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">find_ordered</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">:</span> <span class="n">fin</span> <span class="n">N</span><span class="o">}</span> <span class="o">{</span><span class="n">pred</span><span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="n">N</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">hab</span><span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hac</span><span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hbc</span><span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hprops</span><span class="o">:</span> <span class="n">pred</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">c</span><span class="o">):</span>
<span class="bp">∃</span> <span class="n">d</span> <span class="n">e</span> <span class="n">f</span><span class="o">,</span> <span class="n">d</span> <span class="bp">&lt;</span> <span class="n">e</span> <span class="bp">∧</span> <span class="n">e</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">d</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">e</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">haltb</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="bp">;</span> <span class="n">by_cases</span> <span class="n">hbltc</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">haltb</span><span class="o">,</span> <span class="n">hbltc</span><span class="o">,</span> <span class="n">hprops</span><span class="o">⟩,</span>
  <span class="n">by_cases</span> <span class="n">haltc</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">haltc</span><span class="o">,</span> <span class="n">not_lt_neq_gt</span> <span class="n">_</span> <span class="n">hbltc</span> <span class="n">hbc</span><span class="o">,</span> <span class="n">hprops.1</span><span class="o">,</span> <span class="n">hprops.2.2</span><span class="o">,</span> <span class="n">hprops.2.1</span><span class="o">⟩,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">not_lt_neq_gt</span> <span class="n">_</span> <span class="n">haltc</span> <span class="n">hac</span><span class="o">,</span> <span class="n">haltb</span><span class="o">,</span> <span class="n">hprops.2.2</span><span class="o">,</span> <span class="n">hprops.1</span><span class="o">,</span> <span class="n">hprops.2.1</span><span class="o">⟩,</span>
  <span class="n">by_cases</span> <span class="n">haltc</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">not_lt_neq_gt</span> <span class="n">_</span> <span class="n">haltb</span> <span class="n">hab</span><span class="o">,</span> <span class="n">haltc</span><span class="o">,</span> <span class="n">hprops.2.1</span><span class="o">,</span> <span class="n">hprops.1</span><span class="o">,</span> <span class="n">hprops.2.2</span><span class="o">⟩,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">hbltc</span><span class="o">,</span> <span class="n">not_lt_neq_gt</span> <span class="n">_</span> <span class="n">haltc</span> <span class="n">hac</span><span class="o">,</span> <span class="n">hprops.2.1</span><span class="o">,</span> <span class="n">hprops.2.2</span><span class="o">,</span> <span class="n">hprops.1</span><span class="o">⟩,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">not_lt_neq_gt</span> <span class="n">_</span> <span class="n">hbltc</span> <span class="n">hbc</span><span class="o">,</span> <span class="n">not_lt_neq_gt</span> <span class="n">_</span> <span class="n">haltb</span> <span class="n">hab</span><span class="o">,</span> <span class="n">hprops.2.2</span><span class="o">,</span> <span class="n">hprops.2.1</span><span class="o">,</span> <span class="n">hprops.1</span><span class="o">⟩,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="273909492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ordering%20unique%20elements/near/273909492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ordering.20unique.20elements.html#273909492">(Mar 03 2022 at 01:48)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin.basic</span>
<span class="kn">import</span> <span class="n">data.list.sort</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">N</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">find_ordered</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">:</span> <span class="n">fin</span> <span class="n">N</span><span class="o">}</span> <span class="o">{</span><span class="n">pred</span><span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="n">N</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">hab</span><span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hac</span><span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hbc</span><span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hprops</span><span class="o">:</span> <span class="n">pred</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">c</span><span class="o">):</span>
<span class="bp">∃</span> <span class="n">d</span> <span class="n">e</span> <span class="n">f</span><span class="o">,</span> <span class="n">d</span> <span class="bp">&lt;</span> <span class="n">e</span> <span class="bp">∧</span> <span class="n">e</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">d</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">e</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">set</span> <span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list.merge_sort</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">]</span> <span class="k">with</span> <span class="n">hl</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hperm</span> <span class="o">:</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">]</span> <span class="bp">~</span> <span class="n">l</span> <span class="o">:=</span> <span class="o">(</span><span class="n">list.perm_merge_sort</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hn</span> <span class="o">:</span> <span class="n">l.nodup</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">suffices</span> <span class="o">:</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">]</span><span class="bp">.</span><span class="n">nodup</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">hl</span><span class="o">,</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">hperm.nodup_iff</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">this</span> <span class="o">},</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hab</span><span class="o">,</span> <span class="n">hac</span><span class="o">,</span> <span class="n">hbc</span><span class="o">]</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">),</span> <span class="n">pred</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hperm.symm.mem_iff</span><span class="o">,</span> <span class="n">hprops</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">l.nth_le</span> <span class="mi">0</span> <span class="n">_</span><span class="o">,</span> <span class="n">l.nth_le</span> <span class="mi">1</span> <span class="n">_</span><span class="o">,</span> <span class="n">l.nth_le</span> <span class="mi">2</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">any_goals</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">any_goals</span> <span class="o">{</span> <span class="n">refine</span> <span class="n">lt_of_le_of_ne</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="n">list.sorted.rel_nth_le_of_lt</span> <span class="o">(</span><span class="n">list.sorted_merge_sort</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">ne.def</span><span class="o">,</span> <span class="n">hn.nth_le_inj_iff</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">any_goals</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">hp</span> <span class="n">_</span> <span class="o">(</span><span class="n">list.nth_le_mem</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="273909537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ordering%20unique%20elements/near/273909537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ordering.20unique.20elements.html#273909537">(Mar 03 2022 at 01:49)</a>:</h4>
<p>number of lines is more. but the logic is much simpler I think. I would also ask, why do you need to have three explicit elements as such? Why can't you work on the <code>{a, b, c} : finset (fin N)</code> or <code>[a, b, c]</code>?</p>



<a name="274005795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ordering%20unique%20elements/near/274005795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Evan Lohn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ordering.20unique.20elements.html#274005795">(Mar 03 2022 at 17:16)</a>:</h4>
<p>Thanks for your response! I wasn't  sure whether it was easier/better to use a finset or list, is that what people typically use for this type of thing? would that make the proof any simpler?</p>



<a name="274024645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ordering%20unique%20elements/near/274024645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ordering.20unique.20elements.html#274024645">(Mar 03 2022 at 19:21)</a>:</h4>
<p>Depending on what you're doing, you might consider holding onto the elements as a 3-element <code>finset</code>. There's a quick proof from your hypotheses that there's such a <code>finset</code>, and then it's possible to use that conclusion to obtain the conclusion of <code>find_ordered</code>, if you need it.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin.basic</span>
<span class="kn">import</span> <span class="n">data.finset</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">N</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">find_finset</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">N</span><span class="o">}</span> <span class="o">{</span><span class="n">pred</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">N</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hac</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hbc</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hprops</span> <span class="o">:</span> <span class="n">pred</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">N</span><span class="o">)),</span> <span class="n">s.card</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">pred</span> <span class="n">x</span> <span class="o">:=</span>
<span class="o">⟨{</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">},</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hab</span><span class="o">,</span> <span class="n">hac</span><span class="o">,</span> <span class="n">hbc</span><span class="o">,</span> <span class="n">hprops</span><span class="o">]⟩</span>

<span class="kd">lemma</span> <span class="n">find_ordered</span> <span class="o">{</span><span class="n">pred</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">N</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">N</span><span class="o">)),</span> <span class="n">s.card</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">pred</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">d</span> <span class="n">e</span> <span class="n">f</span><span class="o">,</span> <span class="n">d</span> <span class="bp">&lt;</span> <span class="n">e</span> <span class="bp">∧</span> <span class="n">e</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">d</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">e</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">hc</span><span class="o">,</span> <span class="n">hp</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">s.card</span> <span class="o">:=</span> <span class="n">finset.length_sort</span> <span class="o">(</span><span class="bp">≤</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">hsort</span> <span class="o">:=</span> <span class="n">s.sort_sorted</span> <span class="o">(</span><span class="bp">≤</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">hnd</span> <span class="o">:=</span> <span class="n">s.sort_nodup</span> <span class="o">(</span><span class="bp">≤</span><span class="o">),</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">finset.mem_sort</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span> <span class="n">at</span> <span class="n">hp</span><span class="o">,</span>
  <span class="n">generalize_hyp</span> <span class="n">hs</span> <span class="o">:</span> <span class="n">s.sort</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="bp">=</span> <span class="n">l</span> <span class="n">at</span> <span class="n">h</span> <span class="n">hp</span> <span class="n">hsort</span> <span class="n">hnd</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hc</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">l</span> <span class="k">with</span> <span class="n">d</span> <span class="n">l</span><span class="o">,</span> <span class="kd">by</span> <span class="n">norm_num</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">l</span> <span class="k">with</span> <span class="n">e</span> <span class="n">l</span><span class="o">,</span> <span class="kd">by</span> <span class="n">norm_num</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">l</span> <span class="k">with</span> <span class="n">f</span> <span class="n">l</span><span class="o">,</span> <span class="kd">by</span> <span class="n">norm_num</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">add_assoc</span><span class="o">,</span> <span class="n">list.length</span><span class="o">,</span> <span class="n">add_left_eq_self</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">replace</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">list.eq_nil_of_length_eq_zero</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">subst</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">not_or_distrib</span><span class="o">,</span> <span class="n">list.nodup_cons</span><span class="o">,</span> <span class="n">list.mem_cons_iff</span><span class="o">,</span> <span class="n">list.mem_singleton</span><span class="o">,</span>
    <span class="n">list.not_mem_nil</span><span class="o">,</span> <span class="n">not_false_iff</span><span class="o">,</span> <span class="n">list.nodup_nil</span><span class="o">,</span> <span class="n">and_true</span><span class="o">,</span> <span class="n">list.sorted_cons</span><span class="o">,</span> <span class="n">forall_eq_or_imp</span><span class="o">,</span>
    <span class="n">forall_eq</span><span class="o">,</span> <span class="n">list.sorted_singleton</span><span class="o">]</span> <span class="n">at</span> <span class="n">hsort</span> <span class="n">hnd</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="o">(</span><span class="n">ne.le_iff_lt</span> <span class="n">hnd.1.1</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hsort.1.1</span><span class="o">,</span> <span class="o">(</span><span class="n">ne.le_iff_lt</span> <span class="n">hnd.2</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hsort.2</span><span class="o">],</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">hp</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="274028046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ordering%20unique%20elements/near/274028046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ordering.20unique.20elements.html#274028046">(Mar 03 2022 at 19:43)</a>:</h4>
<p>Here's some style feedback in the form of a restyled version of your original code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin.basic</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">not_lt_neq_gt</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">or.resolve_left</span> <span class="o">(</span><span class="n">le_of_not_gt</span> <span class="n">h1</span><span class="o">)</span><span class="bp">.</span><span class="n">eq_or_lt</span> <span class="n">h2.symm</span>

<span class="kd">lemma</span> <span class="n">find_ordered</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">N</span><span class="o">}</span> <span class="o">{</span><span class="n">pred</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">N</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hac</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hbc</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">pred</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">pred</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">d</span> <span class="n">e</span> <span class="n">f</span><span class="o">,</span> <span class="n">d</span> <span class="bp">&lt;</span> <span class="n">e</span> <span class="bp">∧</span> <span class="n">e</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">d</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">e</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">haltb</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="bp">;</span> <span class="n">by_cases</span> <span class="n">hbltc</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">haltb</span><span class="o">,</span> <span class="n">hbltc</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">hc</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">by_cases</span> <span class="n">haltc</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">haltc</span><span class="o">,</span> <span class="n">not_lt_neq_gt</span> <span class="n">hbltc</span> <span class="n">hbc</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hc</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">not_lt_neq_gt</span> <span class="n">haltc</span> <span class="n">hac</span><span class="o">,</span> <span class="n">haltb</span><span class="o">,</span> <span class="n">hc</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">by_cases</span> <span class="n">haltc</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">not_lt_neq_gt</span> <span class="n">haltb</span> <span class="n">hab</span><span class="o">,</span> <span class="n">haltc</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hc</span><span class="o">⟩</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">hbltc</span><span class="o">,</span> <span class="n">not_lt_neq_gt</span> <span class="n">haltc</span> <span class="n">hac</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">hc</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">not_lt_neq_gt</span> <span class="n">hbltc</span> <span class="n">hbc</span><span class="o">,</span> <span class="n">not_lt_neq_gt</span> <span class="n">haltb</span> <span class="n">hab</span><span class="o">,</span> <span class="n">hc</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>If I remember all the changes:</p>
<ul>
<li>spaces before colons</li>
<li>using curly braces to show proof structure</li>
<li>split conjunctions when given as arguments</li>
<li>using dot notation in the first lemma (and turning it into a one-liner since it's "trivial")</li>
<li>indentation in the lemma statement</li>
</ul>



<a name="274029058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ordering%20unique%20elements/near/274029058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ordering.20unique.20elements.html#274029058">(Mar 03 2022 at 19:50)</a>:</h4>
<p>A somewhat less tedious version of the second lemma is this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">find_ordered</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">N</span><span class="o">}</span> <span class="o">{</span><span class="n">pred</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">N</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hac</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hbc</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">pred</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">pred</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">d</span> <span class="n">e</span> <span class="n">f</span><span class="o">,</span> <span class="n">d</span> <span class="bp">&lt;</span> <span class="n">e</span> <span class="bp">∧</span> <span class="n">e</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">d</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">e</span> <span class="bp">∧</span> <span class="n">pred</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">haltb</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="bp">;</span> <span class="n">by_cases</span> <span class="n">hbltc</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">use</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">],</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">by_cases</span> <span class="n">haltc</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">use</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">],</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">not_lt_neq_gt</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">use</span> <span class="o">[</span><span class="n">c</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">],</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">not_lt_neq_gt</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">by_cases</span> <span class="n">haltc</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">use</span> <span class="o">[</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">],</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">not_lt_neq_gt</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">use</span> <span class="o">[</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">a</span><span class="o">],</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">not_lt_neq_gt</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">use</span> <span class="o">[</span><span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">],</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">not_lt_neq_gt</span><span class="o">]</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>This way it makes it a bit clearer that you're implementing a sorting network, I think.</p>



<a name="274029413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ordering%20unique%20elements/near/274029413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ordering.20unique.20elements.html#274029413">(Mar 03 2022 at 19:52)</a>:</h4>
<p>can't <code>wlog</code> do this?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
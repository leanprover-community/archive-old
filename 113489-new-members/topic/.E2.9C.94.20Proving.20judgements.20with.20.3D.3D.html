---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html">✔ Proving judgements with ==</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="290296648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290296648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Earnest <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290296648">(Jul 20 2022 at 20:49)</a>:</h4>
<p>Hello all! I learned Lean from the Natural Number Game, and decided to try to define Catalan objects in Lean, and prove they satisfy the usual Catalan self similarity.  I think I am almost done with the proof; here is the current goal.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">t1</span> <span class="n">t2</span> <span class="o">:</span> <span class="n">binary_tree</span><span class="o">,</span>
<span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">fst</span> <span class="bp">+</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
<span class="n">h1</span> <span class="o">:</span> <span class="n">order</span> <span class="n">t1</span> <span class="bp">=</span> <span class="o">⟨(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">),</span> <span class="n">h</span><span class="o">⟩</span><span class="bp">.</span><span class="n">val.fst</span><span class="o">,</span>
<span class="n">h2</span> <span class="o">:</span> <span class="n">order</span> <span class="n">t2</span> <span class="bp">=</span> <span class="o">⟨(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">),</span> <span class="n">h</span><span class="o">⟩</span><span class="bp">.</span><span class="n">val.snd</span>
<span class="bp">⊢</span> <span class="o">(⟨</span><span class="n">t1</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">t2</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩)</span> <span class="bp">==</span> <span class="o">(⟨</span><span class="n">t1</span><span class="o">,</span> <span class="n">h1</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">t2</span><span class="o">,</span> <span class="n">h2</span><span class="o">⟩)</span>
</code></pre></div>
<p>I've never encountered proving something with a double equals sign. First of all, what does this mean? Second, how does one prove it? If it is not possible to prove, what kind of hypothesis would I need to add to prove it?</p>
<p>I am pretty sure that both sides of the <code>==</code> are ordered pairs, and the coordinates of each order pair are instances of subtype, meaning the first coordinate is the val, and the second coordinate is a <code>Prop</code> which proves that the val satisfies the subtype condition. On the left, the props are represented as underscores, and on the right they are explicitly written as <code>h1</code> and <code>h2</code>.  It would be easy for me to prove this goal if <code>==</code> was replaced with <code>=</code>, because there is a theorem in mathlib that two instances of a subtype are equal as long as their values are equal. I feel like I need to prove some sort of extensionality principle for the <code>binary_tree</code> type I defined, but I am not sure.</p>
<p>I hope this is enough context to answer my question. For more background, I defined <code>binary_tree</code> to be the inductive class with two constructors, <code>pt</code> with arity 0 and <code>join</code> with arity 2. Then, I inductively defined the <code>order</code> of a binary tree to be <code>0</code> in the case of <code>pt</code>, and one plus the sum of the orders of the two subtrees in the case of join. Finally, <code>catalan n</code> is defined to be the subtype of binary trees whose order is <code>n</code>, <code>catalan (n : \N) : Type  := {t : binary_tree // order t = n}</code>. The theorem I am trying to prove is that the type <code>catalan n</code> is equivalent to the type</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">sum</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">unit</span> <span class="bp">//</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">}</span>  <span class="o">(</span><span class="n">sigma</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">pair</span> <span class="o">:</span> <span class="o">{</span><span class="n">pair</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span> <span class="bp">//</span> <span class="n">pair.fst</span> <span class="bp">+</span> <span class="n">pair.snd</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">n</span><span class="o">},</span> <span class="n">catalan</span> <span class="n">pair.val.fst</span> <span class="bp">×</span> <span class="n">catalan</span> <span class="n">pair.val.snd</span><span class="o">))</span>
</code></pre></div>
<p>Basically, <code>catalan 0</code> is the unit type, while <code>n &gt; 0</code> implies <code>catalan n</code> is the disjoint union over pairs <code>(h, k)</code> for which <code>h + k + 1 = n</code> of <code>cat k \times cat h</code>. I have already defined the functions to and prove these types, and am now trying to prove they are inverses to each other.</p>



<a name="290297050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290297050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290297050">(Jul 20 2022 at 20:52)</a>:</h4>
<p>The term you're looking for is "heterogeneous equality", and that's about how much I know about it :)</p>



<a name="290297207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290297207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290297207">(Jul 20 2022 at 20:53)</a>:</h4>
<p><code>==</code> is <a href="https://leanprover-community.github.io/mathlib_docs/find/heq">docs#heq</a>, which is a fairly weak notion, where <code>a == b</code> means the types of <code>a</code> and <code>b</code> are equal, and if you carry <code>a</code> across that equality you get something equal to <code>b</code>. Usually what you need to do is to substitute some relevant things until the types aren't just equal, but definitionally equal, or better, figure out how you got into this mess <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>
<p>A <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> would help</p>



<a name="290297558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290297558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290297558">(Jul 20 2022 at 20:56)</a>:</h4>
<p>(<code>heq</code> is one of the levels of dependent type hell. It's not so bad, but it does take some getting used to.)</p>



<a name="290297774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290297774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290297774">(Jul 20 2022 at 20:57)</a>:</h4>
<p>Yeah generally the rule when faced with <code>==</code> is "go back to the tactic which caused it and try another one"</p>



<a name="290297805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290297805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290297805">(Jul 20 2022 at 20:57)</a>:</h4>
<p>But it's really hard to help without a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a></p>



<a name="290298806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290298806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Earnest <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290298806">(Jul 20 2022 at 21:04)</a>:</h4>
<p>Haha, the docs for <code>heq</code> say that if you encounter trying to prove something wtih <code>==</code>, then to ask yourself, or on zulip, if something went wrong, so I guess I did the right thing. Thank you all, I'll close this issue since it seems I need to back up and try a different route.</p>



<a name="290298825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290298825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290298825">(Jul 20 2022 at 21:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="515599">Michael Earnest</span> has marked this topic as resolved.</p>



<a name="290299014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290299014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290299014">(Jul 20 2022 at 21:06)</a>:</h4>
<p>Feel free to still give a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>, since we could still try to plow forward, since it looks like the goal might still be doable. (You should still also back up and try a different route.)</p>



<a name="290299686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290299686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290299686">(Jul 20 2022 at 21:12)</a>:</h4>
<p>My mental model for <code>a == b</code> is "<code>a</code> and <code>b</code> are equal, but the equality doesn't typecheck".</p>



<a name="290300591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290300591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290300591">(Jul 20 2022 at 21:20)</a>:</h4>
<p>The general way you prove a <code>==</code> goal is by rewriting carefully so that the statement still typechecks, until you get an equality of two things with definitionally equal types, at which point you can use <code>heq_of_eq</code> and get a normal equality.</p>



<a name="290300618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290300618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290300618">(Jul 20 2022 at 21:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="515599">Michael Earnest</span> has marked this topic as unresolved.</p>



<a name="290300677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290300677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Earnest <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290300677">(Jul 20 2022 at 21:21)</a>:</h4>
<p>Well, here's a link to a <a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic.linarith%0A%0Ainductive%20binary_tree%0A%7C%20%20%20%20pt%20%3A%20binary_tree%0A%7C%20%20join%20%3A%20binary_tree%20%E2%86%92%20binary_tree%20%E2%86%92%20binary_tree%0A%0Adef%20order%20%28t%20%3A%20binary_tree%29%20%3A%20%E2%84%95%20%3A%3D%20binary_tree.rec_on%20t%200%20%28%CE%BB%20left%20right%20x%20y%2C%20x%20%2B%20y%20%2B%201%29%0A%0Alemma%20order_sum%20%28L%20R%20%3A%20binary_tree%29%20%3A%20order%20%28binary_tree.join%20L%20R%29%20%3D%20order%20L%20%2B%20order%20R%20%2B%201%20%3A%3D%20begin%20refl%2C%20end%0A%0Adef%20catalan%20%28n%20%3A%20%E2%84%95%29%20%3A%20Type%20%3A%3D%20%7Bt%20%3A%20binary_tree%20%2F%2F%20order%20t%20%3D%20n%7D%0A%0Adef%20cat_split%20%7Bn%20%3A%20%E2%84%95%7D%20%28t%20%3A%20catalan%20n%29%20%3A%20--%20A%20catalan%20n%20object%0Asum%20--is%20either%20a%20unit%2C%20in%20the%20case%20n%20%3D%200%2C%20or%20a%20pair%20%28h%2Ck%29%20with%20h%2Bk%2B1%3Dn%2C%20and%20an%20ordered%20pair%20%28cat%20h%2C%20cat%20k%29%0A%7Bu%20%3A%20unit%20%2F%2F%20n%20%3D%200%7D%0A%28sigma%20%28%CE%BB%20pair%20%3A%20%7Bpair%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%2F%2F%20pair.fst%20%2B%20pair.snd%20%2B%201%20%3D%20n%7D%2C%20catalan%20pair.val.fst%20%C3%97%20catalan%20pair.val.snd%29%29%20%3A%3D%0Abegin%0A%20%20cases%20t%20with%20t%20pf%2C%0A%20%20cases%20t%20with%20t_left%20t_right%2C%0A%20%20left%2C%20use%28unit.star%29%2C%20rw%20%E2%86%90%20pf%2C%20refl%2C%0A%20%20right%2C%0A%20%20use%20%28order%20t_left%2C%20order%20t_right%29%2C%0A%20%20simp%20%5B%E2%86%90%20pf%2C%20order_sum%20t_left%20t_right%5D%2C%0A%20%20split%2C%0A%20%20use%20t_left%2C%0A%20%20use%20t_right%2C%0Aend%0A%0Adef%20cat_join%20%7Bn%20%3A%20%E2%84%95%7D%20%28input%20%3A%20sum%20%20%7Bk%20%3A%20unit%20%2F%2F%20n%20%3D%200%7D%20%0A%28sigma%20%28%CE%BB%20pair%20%3A%20%7Bpair%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%2F%2F%20pair.fst%20%2B%20pair.snd%20%2B%201%20%3D%20n%7D%2C%20catalan%20pair.val.fst%20%C3%97%20catalan%20pair.val.snd%29%29%29%0A%3A%20catalan%20n%20%3A%3D%20%0Abegin%0A%20%20cases%20input%2C%0A%20%20use%20binary_tree.pt%2C%0A%20%20rw%20input.prop%2C%20refl%2C%0A%20%20cases%20input%20with%20pair%20pair_of_trees%2C%20%20%20%20%20%20--%20There's%20a%20lot%20to%20unpack%20here...%0A%20%20cases%20pair_of_trees%20with%20t_left%20t_right%2C%20%20--%20%0A%20%20cases%20t_left%20with%20t_left%20pf_left%2C%20%20%20%20%20%20%20%20%20--%0A%20%20cases%20t_right%20with%20t_right%20pf_right%2C%20%20%20%20%20%20--%0A%20%20use%20%28binary_tree.join%20t_left%20t_right%29%2C%0A%20%20simp%20%5B%E2%86%90%20pair.prop%2C%20order_sum%20t_left%20t_right%2C%20pf_left%2C%20pf_right%5D%2C%0Aend%0A%0Adef%20cat_self_recurse%20%7Bn%20%3A%20%E2%84%95%7D%20%3A%0Aequiv%0A%20%20%28catalan%20n%29%0A%20%20%28sum%0A%20%20%20%20%7Bu%20%3A%20unit%20%2F%2F%20n%20%3D%200%7D%20%0A%20%20%20%20%28sigma%20%28%CE%BB%20pair%20%3A%20%7Bpair%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%2F%2F%20pair.fst%20%2B%20pair.snd%20%2B%201%20%3D%20n%7D%2C%20catalan%20pair.val.fst%20%C3%97%20catalan%20pair.val.snd%29%29%0A%20%20%29%0A%3A%3D%0Abegin%0A%20%20use%20cat_split%2C%20use%20cat_join%2C%0A%20%20intro%20t%2C%0A%20%20cases%20n%2C%0A%20%20%20%20cases%20t%20with%20t%20pf%2C%0A%20%20%20%20cases%20t%20with%20t_l%20t_r%2C%20refl%2C%0A%20%20%20%20rw%20order_sum%20at%20pf%2C%20contradiction%2C%0A%20%20%20%20cases%20t%20with%20t%20pf%2C%0A%20%20%20%20cases%20t%20with%20t_l%20t_r%2C%20contradiction%2C%0A%20%20%20%20unfold%20cat_split%2C%20simp%20%5Bcat_join%5D%2C%0A%20%20%20%20intro%20triv_or_pairtrees%2C%0A%20%20%20%20cases%20triv_or_pairtrees%2C%20simp%20%5Bcat_join%2C%20cat_split%5D%2C%0A%20%20%20%20cases%20triv_or_pairtrees%20with%20pair%20pair_of_trees%2C%0A%20%20%20%20cases%20pair_of_trees%20with%20t1%20t2%2C%0A%20%20%20%20cases%20t1%20with%20t1%20h1%2C%0A%20%20%20%20cases%20t2%20with%20t2%20h2%2C%0A%20%20%20%20cases%20pair%20with%20pair%20h%2C%0A%20%20%20%20cases%20pair%20with%20i%20j%2C%0A%20%20%20%20simp%20%5Bcat_join%2C%20cat_split%5D%2C%20--%20Here%20is%20where%20the%20%3D%3D%20goal%20gets%20introduced.%20%0A%20%20%20%20split%2C%0A%20%20%20%20simp%20%5Bh1%2C%20h2%5D%2C%0A%20%20%20%20sorry%2C%0Aend">working example</a>. I would not call it minimal, since I do not understand the problem well enough to pare it down to just that issue. I am trying to prove <code>cat_self_recurse</code>, and I included a comment the exact step which introduced the <code>==</code> goal. Basically, I had a complicated expression involving <code>cat_split</code> and <code>cat_join</code>, which are the inductively defined functions which are supposed to be inverses. I need to "unpack" these definitions in exactly right way, so I used <code>simp [cat_split, cat_join]</code>, but I guess lean couldn't prove both sides had the right types.</p>



<a name="290300731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290300731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290300731">(Jul 20 2022 at 21:21)</a>:</h4>
<p>Destructuring via <code>cases</code> or brute-force rewriting an equality using <code>subst</code> are usually most helpful. <code>congr</code> can usually make progress too.</p>



<a name="290302217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290302217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> FR <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290302217">(Jul 20 2022 at 21:33)</a>:</h4>
<p><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic.linarith%0A%0Ainductive%20binary_tree%0A%7C%20%20%20%20pt%20%3A%20binary_tree%0A%7C%20%20join%20%3A%20binary_tree%20%E2%86%92%20binary_tree%20%E2%86%92%20binary_tree%0A%0Adef%20order%20%28t%20%3A%20binary_tree%29%20%3A%20%E2%84%95%20%3A%3D%20binary_tree.rec_on%20t%200%20%28%CE%BB%20left%20right%20x%20y%2C%20x%20%2B%20y%20%2B%201%29%0A%0Alemma%20order_sum%20%28L%20R%20%3A%20binary_tree%29%20%3A%20order%20%28binary_tree.join%20L%20R%29%20%3D%20order%20L%20%2B%20order%20R%20%2B%201%20%3A%3D%20begin%20refl%2C%20end%0A%0Adef%20catalan%20%28n%20%3A%20%E2%84%95%29%20%3A%20Type%20%3A%3D%20%7Bt%20%3A%20binary_tree%20%2F%2F%20order%20t%20%3D%20n%7D%0A%0Adef%20cat_split%20%7Bn%20%3A%20%E2%84%95%7D%20%28t%20%3A%20catalan%20n%29%20%3A%20--%20A%20catalan%20n%20object%0Asum%20--is%20either%20a%20unit%2C%20in%20the%20case%20n%20%3D%200%2C%20or%20a%20pair%20%28h%2Ck%29%20with%20h%2Bk%2B1%3Dn%2C%20and%20an%20ordered%20pair%20%28cat%20h%2C%20cat%20k%29%0A%7Bu%20%3A%20unit%20%2F%2F%20n%20%3D%200%7D%0A%28sigma%20%28%CE%BB%20pair%20%3A%20%7Bpair%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%2F%2F%20pair.fst%20%2B%20pair.snd%20%2B%201%20%3D%20n%7D%2C%20catalan%20pair.val.fst%20%C3%97%20catalan%20pair.val.snd%29%29%20%3A%3D%0Abegin%0A%20%20cases%20t%20with%20t%20pf%2C%0A%20%20cases%20t%20with%20t_left%20t_right%2C%0A%20%20left%2C%20use%28unit.star%29%2C%20rw%20%E2%86%90%20pf%2C%20refl%2C%0A%20%20right%2C%0A%20%20use%20%28order%20t_left%2C%20order%20t_right%29%2C%0A%20%20simp%20%5B%E2%86%90%20pf%2C%20order_sum%20t_left%20t_right%5D%2C%0A%20%20split%2C%0A%20%20use%20t_left%2C%0A%20%20use%20t_right%2C%0Aend%0A%0Adef%20cat_join%20%7Bn%20%3A%20%E2%84%95%7D%20%28input%20%3A%20sum%20%20%7Bk%20%3A%20unit%20%2F%2F%20n%20%3D%200%7D%20%0A%28sigma%20%28%CE%BB%20pair%20%3A%20%7Bpair%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%2F%2F%20pair.fst%20%2B%20pair.snd%20%2B%201%20%3D%20n%7D%2C%20catalan%20pair.val.fst%20%C3%97%20catalan%20pair.val.snd%29%29%29%0A%3A%20catalan%20n%20%3A%3D%20%0Abegin%0A%20%20cases%20input%2C%0A%20%20use%20binary_tree.pt%2C%0A%20%20rw%20input.prop%2C%20refl%2C%0A%20%20cases%20input%20with%20pair%20pair_of_trees%2C%20%20%20%20%20%20--%20There's%20a%20lot%20to%20unpack%20here...%0A%20%20cases%20pair_of_trees%20with%20t_left%20t_right%2C%20%20--%20%0A%20%20cases%20t_left%20with%20t_left%20pf_left%2C%20%20%20%20%20%20%20%20%20--%0A%20%20cases%20t_right%20with%20t_right%20pf_right%2C%20%20%20%20%20%20--%0A%20%20use%20%28binary_tree.join%20t_left%20t_right%29%2C%0A%20%20simp%20%5B%E2%86%90%20pair.prop%2C%20order_sum%20t_left%20t_right%2C%20pf_left%2C%20pf_right%5D%2C%0Aend%0A%0Adef%20cat_self_recurse%20%7Bn%20%3A%20%E2%84%95%7D%20%3A%0Aequiv%0A%20%20%28catalan%20n%29%0A%20%20%28sum%0A%20%20%20%20%7Bu%20%3A%20unit%20%2F%2F%20n%20%3D%200%7D%20%0A%20%20%20%20%28sigma%20%28%CE%BB%20pair%20%3A%20%7Bpair%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%2F%2F%20pair.fst%20%2B%20pair.snd%20%2B%201%20%3D%20n%7D%2C%20catalan%20pair.val.fst%20%C3%97%20catalan%20pair.val.snd%29%29%0A%20%20%29%0A%3A%3D%0Abegin%0A%20%20use%20cat_split%2C%20use%20cat_join%2C%0A%20%20intro%20t%2C%0A%20%20cases%20n%2C%0A%20%20%20%20cases%20t%20with%20t%20pf%2C%0A%20%20%20%20cases%20t%20with%20t_l%20t_r%2C%20refl%2C%0A%20%20%20%20rw%20order_sum%20at%20pf%2C%20contradiction%2C%0A%20%20%20%20cases%20t%20with%20t%20pf%2C%0A%20%20%20%20cases%20t%20with%20t_l%20t_r%2C%20contradiction%2C%0A%20%20%20%20unfold%20cat_split%2C%20simp%20%5Bcat_join%5D%2C%0A%20%20%20%20intro%20triv_or_pairtrees%2C%0A%20%20%20%20cases%20triv_or_pairtrees%2C%20simp%20%5Bcat_join%2C%20cat_split%5D%2C%0A%20%20%20%20cases%20triv_or_pairtrees%20with%20pair%20pair_of_trees%2C%0A%20%20%20%20cases%20pair_of_trees%20with%20t1%20t2%2C%0A%20%20%20%20cases%20t1%20with%20t1%20h1%2C%0A%20%20%20%20cases%20t2%20with%20t2%20h2%2C%0A%20%20%20%20cases%20pair%20with%20pair%20h%2C%0A%20%20%20%20cases%20pair%20with%20i%20j%2C%0A%20%20%20%20simp%20%5Bcat_join%2C%20cat_split%5D%2C%20--%20Here%20is%20where%20the%20%3D%3D%20goal%20gets%20introduced.%20%0A%20%20%20%20split%2C%0A%20%20%20%20simp%20%5Bh1%2C%20h2%5D%2C%0A%20%20%20%20congr'%201%2C%0A%20%20%20%20simp%20%5Bh1%5D%2C%0A%20%20%20%20simp%20%5Bh2%5D%2C%0A%20%20%20%20congr'%201%2C%0A%20%20%20%20simp%20%5Bh1%5D%2C%0A%20%20%20%20congr'%201%2C%0A%20%20%20%20simp%20%5Bh2%5D%2C%0Aend">Here is my solution</a>.</p>



<a name="290303776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290303776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290303776">(Jul 20 2022 at 21:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="515599">Michael Earnest</span> has marked this topic as resolved.</p>



<a name="290303797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290303797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Earnest <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290303797">(Jul 20 2022 at 21:46)</a>:</h4>
<p><span class="user-mention" data-user-id="455791">@FR</span> , you are a beast, thank you!</p>



<a name="290304524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290304524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> FR <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290304524">(Jul 20 2022 at 21:53)</a>:</h4>
<p>Also <a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic.linarith%0A%0Ainductive%20binary_tree%0A%7C%20%20%20%20pt%20%3A%20binary_tree%0A%7C%20%20join%20%3A%20binary_tree%20%E2%86%92%20binary_tree%20%E2%86%92%20binary_tree%0A%0Adef%20order%20%28t%20%3A%20binary_tree%29%20%3A%20%E2%84%95%20%3A%3D%20binary_tree.rec_on%20t%200%20%28%CE%BB%20left%20right%20x%20y%2C%20x%20%2B%20y%20%2B%201%29%0A%0Alemma%20order_sum%20%28L%20R%20%3A%20binary_tree%29%20%3A%20order%20%28binary_tree.join%20L%20R%29%20%3D%20order%20L%20%2B%20order%20R%20%2B%201%20%3A%3D%20begin%20refl%2C%20end%0A%0Adef%20catalan%20%28n%20%3A%20%E2%84%95%29%20%3A%20Type%20%3A%3D%20%7Bt%20%3A%20binary_tree%20%2F%2F%20order%20t%20%3D%20n%7D%0A%0Adef%20cat_split%20%7Bn%20%3A%20%E2%84%95%7D%20%28t%20%3A%20catalan%20n%29%20%3A%20--%20A%20catalan%20n%20object%0Asum%20--is%20either%20a%20unit%2C%20in%20the%20case%20n%20%3D%200%2C%20or%20a%20pair%20%28h%2Ck%29%20with%20h%2Bk%2B1%3Dn%2C%20and%20an%20ordered%20pair%20%28cat%20h%2C%20cat%20k%29%0A%7Bu%20%3A%20unit%20%2F%2F%20n%20%3D%200%7D%0A%28sigma%20%28%CE%BB%20pair%20%3A%20%7Bpair%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%2F%2F%20pair.fst%20%2B%20pair.snd%20%2B%201%20%3D%20n%7D%2C%20catalan%20pair.val.fst%20%C3%97%20catalan%20pair.val.snd%29%29%20%3A%3D%0Abegin%0A%20%20cases%20t%20with%20t%20pf%2C%0A%20%20cases%20t%20with%20t_left%20t_right%2C%0A%20%20left%2C%20use%28unit.star%29%2C%20rw%20%E2%86%90%20pf%2C%20refl%2C%0A%20%20right%2C%0A%20%20use%20%28order%20t_left%2C%20order%20t_right%29%2C%0A%20%20simp%20%5B%E2%86%90%20pf%2C%20order_sum%20t_left%20t_right%5D%2C%0A%20%20split%2C%0A%20%20use%20t_left%2C%0A%20%20use%20t_right%2C%0Aend%0A%0Adef%20cat_join%20%7Bn%20%3A%20%E2%84%95%7D%20%28input%20%3A%20sum%20%20%7Bk%20%3A%20unit%20%2F%2F%20n%20%3D%200%7D%20%0A%28sigma%20%28%CE%BB%20pair%20%3A%20%7Bpair%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%2F%2F%20pair.fst%20%2B%20pair.snd%20%2B%201%20%3D%20n%7D%2C%20catalan%20pair.val.fst%20%C3%97%20catalan%20pair.val.snd%29%29%29%0A%3A%20catalan%20n%20%3A%3D%20%0Abegin%0A%20%20cases%20input%2C%0A%20%20use%20binary_tree.pt%2C%0A%20%20rw%20input.prop%2C%20refl%2C%0A%20%20cases%20input%20with%20pair%20pair_of_trees%2C%20%20%20%20%20%20--%20There's%20a%20lot%20to%20unpack%20here...%0A%20%20cases%20pair_of_trees%20with%20t_left%20t_right%2C%20%20--%20%0A%20%20cases%20t_left%20with%20t_left%20pf_left%2C%20%20%20%20%20%20%20%20%20--%0A%20%20cases%20t_right%20with%20t_right%20pf_right%2C%20%20%20%20%20%20--%0A%20%20use%20%28binary_tree.join%20t_left%20t_right%29%2C%0A%20%20simp%20%5B%E2%86%90%20pair.prop%2C%20order_sum%20t_left%20t_right%2C%20pf_left%2C%20pf_right%5D%2C%0Aend%0A%0Adef%20cat_self_recurse%20%7Bn%20%3A%20%E2%84%95%7D%20%3A%0Aequiv%0A%20%20%28catalan%20n%29%0A%20%20%28sum%0A%20%20%20%20%7Bu%20%3A%20unit%20%2F%2F%20n%20%3D%200%7D%20%0A%20%20%20%20%28sigma%20%28%CE%BB%20pair%20%3A%20%7Bpair%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%2F%2F%20pair.fst%20%2B%20pair.snd%20%2B%201%20%3D%20n%7D%2C%20catalan%20pair.val.fst%20%C3%97%20catalan%20pair.val.snd%29%29%0A%20%20%29%0A%3A%3D%0Abegin%0A%20%20use%20cat_split%2C%20use%20cat_join%2C%0A%20%20intro%20t%2C%0A%20%20cases%20n%2C%0A%20%20%20%20cases%20t%20with%20t%20pf%2C%0A%20%20%20%20cases%20t%20with%20t_l%20t_r%2C%20refl%2C%0A%20%20%20%20rw%20order_sum%20at%20pf%2C%20contradiction%2C%0A%20%20%20%20cases%20t%20with%20t%20pf%2C%0A%20%20%20%20cases%20t%20with%20t_l%20t_r%2C%20contradiction%2C%0A%20%20%20%20unfold%20cat_split%2C%20simp%20%5Bcat_join%5D%2C%0A%20%20%20%20intro%20triv_or_pairtrees%2C%0A%20%20%20%20cases%20triv_or_pairtrees%2C%20simp%20%5Bcat_join%2C%20cat_split%5D%2C%0A%20%20%20%20cases%20triv_or_pairtrees%20with%20pair%20pair_of_trees%2C%0A%20%20%20%20cases%20pair_of_trees%20with%20t1%20t2%2C%0A%20%20%20%20cases%20t1%20with%20t1%20h1%2C%0A%20%20%20%20cases%20t2%20with%20t2%20h2%2C%0A%20%20%20%20cases%20pair%20with%20pair%20h%2C%0A%20%20%20%20cases%20pair%20with%20i%20j%2C%0A%20%20%20%20simp%20%5Bcat_join%2C%20cat_split%5D%2C%20--%20Here%20is%20where%20the%20%3D%3D%20goal%20gets%20introduced.%20%0A%20%20%20%20split%2C%0A%20%20%20%20simp%20%5Bh1%2C%20h2%5D%2C%0A%20%20%20%20congr'%2C%0A%20%20%20%20simp%20%5Bh1%5D%2C%0A%20%20%20%20simp%20%5Bh2%5D%2C%0Aend">this</a> is shorter. Just merge <code>congr'</code>s into one.</p>



<a name="290306761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290306761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290306761">(Jul 20 2022 at 22:14)</a>:</h4>
<p><span class="user-mention" data-user-id="515599">@Michael Earnest</span> If you go back to just before the <code>simp</code> and instead simplify <code>h</code>, <code>h1</code>, and <code>h2</code> and then do <code>cases</code> on each of these (or, equivalent, doing <code>subst</code> on <code>n</code>, <code>i</code>, and <code>j</code>) then the <code>simp</code> completely handles the goal without introducing a <code>==</code>.</p>
<p>I also went ahead and switched your definitions to using the equation compiler, which lets you do pattern matching rather than lots of <code>cases</code> in a tactic block.</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.linarith</span>

<span class="kd">inductive</span> <span class="n">binary_tree</span>
<span class="bp">|</span>    <span class="n">pt</span> <span class="o">:</span> <span class="n">binary_tree</span>
<span class="bp">|</span>  <span class="n">join</span> <span class="o">:</span> <span class="n">binary_tree</span> <span class="bp">→</span> <span class="n">binary_tree</span> <span class="bp">→</span> <span class="n">binary_tree</span>

<span class="kd">def</span> <span class="n">order</span> <span class="o">:</span> <span class="n">binary_tree</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">binary_tree.pt</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">binary_tree.join</span> <span class="n">left</span> <span class="n">right</span><span class="o">)</span> <span class="o">:=</span> <span class="n">order</span> <span class="n">left</span> <span class="bp">+</span> <span class="n">order</span> <span class="n">right</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="c1">-- not needed, since this is one of the equations for `order`</span>
<span class="c1">--lemma order_sum (L R : binary_tree) : order (binary_tree.join L R) = order L + order R + 1 := begin refl, end</span>

<span class="kd">def</span> <span class="n">catalan</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">binary_tree</span> <span class="bp">//</span> <span class="n">order</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">n</span><span class="o">}</span>

<span class="sd">/--</span>
<span class="sd">A catalan n object is either a unit, in the case n = 0, or a pair (h,k) with h+k+1=n, and an ordered pair (cat h, cat k)</span>
<span class="sd">-/</span>
<span class="kd">def</span> <span class="n">cat_split</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">catalan</span> <span class="n">n</span> <span class="bp">→</span>
  <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">unit</span> <span class="bp">//</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">}</span> <span class="bp">⊕</span>
  <span class="bp">Σ</span> <span class="o">(</span><span class="n">pair</span> <span class="o">:</span> <span class="o">{</span><span class="n">pair</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span> <span class="bp">//</span> <span class="n">pair.fst</span> <span class="bp">+</span> <span class="n">pair.snd</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">n</span><span class="o">}),</span> <span class="n">catalan</span> <span class="n">pair.val.fst</span> <span class="bp">×</span> <span class="n">catalan</span> <span class="n">pair.val.snd</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">binary_tree.pt</span><span class="o">,</span> <span class="n">pf</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">sum.inl</span> <span class="o">⟨</span><span class="n">unit.star</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">pf</span><span class="o">,</span> <span class="n">refl</span> <span class="kd">end</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">binary_tree.join</span> <span class="n">left</span> <span class="n">right</span><span class="o">,</span> <span class="n">pf</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">sum.inr</span> <span class="o">⟨⟨(</span><span class="n">order</span> <span class="n">left</span><span class="o">,</span> <span class="n">order</span> <span class="n">right</span><span class="o">),</span> <span class="kd">begin</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span> <span class="n">pf</span><span class="o">,</span> <span class="n">order</span><span class="o">],</span> <span class="kd">end</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">left</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">right</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩⟩</span>

<span class="kd">def</span> <span class="n">cat_join</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">unit</span> <span class="bp">//</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">}</span> <span class="bp">⊕</span>
  <span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">pair</span> <span class="o">:</span> <span class="o">{</span><span class="n">pair</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span> <span class="bp">//</span> <span class="n">pair.fst</span> <span class="bp">+</span> <span class="n">pair.snd</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">n</span><span class="o">}),</span> <span class="n">catalan</span> <span class="n">pair.val.fst</span> <span class="bp">×</span> <span class="n">catalan</span> <span class="n">pair.val.snd</span><span class="o">)</span> <span class="bp">→</span>
  <span class="n">catalan</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">sum.inl</span> <span class="n">input</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">binary_tree.pt</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">rwa</span> <span class="n">input.prop</span><span class="o">,</span> <span class="n">refl</span> <span class="kd">end</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">sum.inr</span> <span class="o">⟨</span><span class="n">pair</span><span class="o">,</span> <span class="o">⟨</span><span class="n">t_left</span><span class="o">,</span> <span class="n">pf_left</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">t_right</span><span class="o">,</span> <span class="n">pf_right</span><span class="o">⟩⟩)</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="n">binary_tree.join</span> <span class="n">t_left</span> <span class="n">t_right</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span> <span class="n">pair.prop</span><span class="o">,</span> <span class="n">order</span><span class="o">,</span> <span class="n">pf_left</span><span class="o">,</span> <span class="n">pf_right</span><span class="o">]⟩</span>

<span class="kd">def</span> <span class="n">cat_self_recurse</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">catalan</span> <span class="n">n</span> <span class="bp">≃</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">unit</span> <span class="bp">//</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">}</span> <span class="bp">⊕</span>
  <span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">pair</span> <span class="o">:</span> <span class="o">{</span><span class="n">pair</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span> <span class="bp">//</span> <span class="n">pair.fst</span> <span class="bp">+</span> <span class="n">pair.snd</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">n</span><span class="o">}),</span> <span class="n">catalan</span> <span class="n">pair.val.fst</span> <span class="bp">×</span> <span class="n">catalan</span> <span class="n">pair.val.snd</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">cat_split</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">cat_join</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intro</span> <span class="n">t</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">t</span> <span class="k">with</span> <span class="n">t</span> <span class="n">pf</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">t</span> <span class="k">with</span> <span class="n">t_l</span> <span class="n">t_r</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">order</span><span class="o">]</span> <span class="n">at</span> <span class="n">pf</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">cat_split</span><span class="o">,</span> <span class="n">cat_join</span><span class="o">],</span> <span class="o">},</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intro</span> <span class="n">triv_or_pairtrees</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">triv_or_pairtrees</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">cat_join</span><span class="o">,</span> <span class="n">cat_split</span><span class="o">],</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">triv_or_pairtrees</span> <span class="k">with</span> <span class="n">pair</span> <span class="n">pair_of_trees</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">pair_of_trees</span> <span class="k">with</span> <span class="n">t1</span> <span class="n">t2</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">t1</span> <span class="k">with</span> <span class="n">t1</span> <span class="n">h1</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">t2</span> <span class="k">with</span> <span class="n">t2</span> <span class="n">h2</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">pair</span> <span class="k">with</span> <span class="n">pair</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">pair</span> <span class="k">with</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">at</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">h1</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">h2</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">cat_join</span><span class="o">,</span> <span class="n">cat_split</span><span class="o">],</span> <span class="o">},</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>
</div></div>



<a name="290306899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290306899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290306899">(Jul 20 2022 at 22:16)</a>:</h4>
<p>You can also simplify your sequences of <code>cases</code> using <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#rcases">tactic#rcases</a>, <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#obtain">tactic#obtain</a>, or <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#rintro">tactic#rintro</a>, which are all very convenient (though I didn't do this).</p>



<a name="290324591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Proving%20judgements%20with%20%3D%3D/near/290324591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Earnest <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Proving.20judgements.20with.20.3D.3D.html#290324591">(Jul 21 2022 at 02:18)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>  Hey Kyle, you went above and beyond with your reply. It teaches a lot about how to do things cleanly in lean.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
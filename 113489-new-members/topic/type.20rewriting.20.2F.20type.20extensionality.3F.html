---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html">type rewriting / type extensionality?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="198654784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198654784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198654784">(May 25 2020 at 10:34)</a>:</h4>
<p>I'm playing around with Pi types and I've come across something where I don't know how to tell lean what to do. </p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kn">instance</span> <span class="n">list_as_func</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">xs</span><span class="o">,</span> <span class="o">{</span><span class="n">i</span> <span class="bp">//</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">xs</span><span class="bp">.</span><span class="n">length</span><span class="o">}</span> <span class="bp">→</span> <span class="n">α</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">xs</span> <span class="n">i</span><span class="o">,</span> <span class="n">xs</span><span class="bp">.</span><span class="n">nth_le</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="n">i</span><span class="bp">.</span><span class="n">property</span><span class="bp">⟩</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="o">{</span><span class="n">i</span> <span class="bp">//</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="mi">2</span><span class="o">},</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="o">[</span><span class="bp">ℕ</span><span class="o">,</span> <span class="bp">ℕ</span><span class="o">]</span> <span class="n">i</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="k">let</span> <span class="n">xs</span> <span class="o">:=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">],</span>
    <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="o">{</span><span class="n">i</span> <span class="bp">//</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="mi">2</span><span class="o">},</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span>
        <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span><span class="o">,</span>
        <span class="n">cases</span> <span class="n">i</span><span class="o">,</span> <span class="n">exact</span> <span class="n">xs</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span><span class="o">,</span>
        <span class="n">cases</span> <span class="n">i</span><span class="o">,</span> <span class="n">exact</span> <span class="n">xs</span> <span class="bp">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">absurd</span> <span class="n">hi</span><span class="o">,</span>
        <span class="n">simp</span> <span class="o">[</span><span class="k">show</span> <span class="n">i</span><span class="bp">.</span><span class="n">succ</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">=</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="o">],</span>
    <span class="o">},</span>
    <span class="k">let</span> <span class="n">g</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="o">[</span><span class="bp">ℕ</span><span class="o">,</span> <span class="bp">ℕ</span><span class="o">]</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span>
        <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span><span class="o">,</span>
        <span class="n">cases</span> <span class="n">i</span><span class="o">,</span> <span class="n">exact</span> <span class="n">xs</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span><span class="o">,</span>
        <span class="n">cases</span> <span class="n">i</span><span class="o">,</span> <span class="n">exact</span> <span class="n">xs</span> <span class="bp">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">absurd</span> <span class="n">hi</span><span class="o">,</span>
        <span class="n">simp</span> <span class="o">[</span><span class="k">show</span> <span class="n">i</span><span class="bp">.</span><span class="n">succ</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">=</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="o">],</span>
    <span class="o">},</span>
    <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>


<p>How can I show that two Pi types are the same?</p>



<a name="198654804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198654804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198654804">(May 25 2020 at 10:35)</a>:</h4>
<p>you can't</p>



<a name="198654817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198654817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198654817">(May 25 2020 at 10:35)</a>:</h4>
<p>your theorem is nonsense</p>



<a name="198654998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198654998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198654998">(May 25 2020 at 10:38)</a>:</h4>
<p>sad HoTT noises</p>



<a name="198655002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655002">(May 25 2020 at 10:38)</a>:</h4>
<p>Actually, looking at it carefully I think this theorem might be true</p>



<a name="198655009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655009">(May 25 2020 at 10:38)</a>:</h4>
<p>the question is still nonsense though</p>



<a name="198655012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655012">(May 25 2020 at 10:38)</a>:</h4>
<p>But I have seen lean go ahead and simplify things in the type, too. Like for instance it does understand that <code>{ i // i &lt; [nat, nat] i}</code> is the same as <code>{i // i &lt; 0 + 1 + 1}</code>.</p>



<a name="198655020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655020">(May 25 2020 at 10:38)</a>:</h4>
<p>If it's true then the proof should be <code>rfl</code>, right?</p>



<a name="198655024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655024">(May 25 2020 at 10:38)</a>:</h4>
<p>yes</p>



<a name="198655042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655042">(May 25 2020 at 10:39)</a>:</h4>
<p>Rule of thumb: don't try to prove that types are equal. My understanding is that in Lean <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>=</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}=\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> is undecidable. Prove your types are <code>equiv</code> instead.</p>



<a name="198655049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655049">(May 25 2020 at 10:39)</a>:</h4>
<p>It is okay to prove types are equal by defeq, but if they aren't then you shouldn't be trying to prove an equality</p>



<a name="198655085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655085">(May 25 2020 at 10:39)</a>:</h4>
<p>This is definitely an <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> question though. What are you trying to do?</p>



<a name="198655124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655124">(May 25 2020 at 10:40)</a>:</h4>
<p>I think they're not equal because you need funext &amp; cases on <code>i</code> to prove it</p>



<a name="198655141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655141">(May 25 2020 at 10:40)</a>:</h4>
<p>oh hmm</p>



<a name="198655146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655146">(May 25 2020 at 10:40)</a>:</h4>
<p>The first components are defeq, the second are regular eq, so it's provable</p>



<a name="198655153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655153">(May 25 2020 at 10:40)</a>:</h4>
<p>In that case I guess maybe they are non-definitionally equal yes</p>



<a name="198655336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655336">(May 25 2020 at 10:43)</a>:</h4>
<p>I know that we can use a proof <code>x=y</code> to rewrite using <code>rw</code>, but that only works on the term level, not on the type level.</p>
<p>Is there a deep reason, why if I can prove something like <code>forall i, [nat, nat] i = nat</code>, I shouldn't be allowed to do a rewrite of the pi type?</p>



<a name="198655420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655420">(May 25 2020 at 10:45)</a>:</h4>
<p>I understand, that it would want a proof, of course, because it would have to go and apply a potentially large amount of unfolding and whatnot and it may not be decidable. But if I have the proof, shouldn't it be possible to do the rewrites?</p>



<a name="198655521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655521">(May 25 2020 at 10:46)</a>:</h4>
<p>mwe:</p>
<div class="codehilite"><pre><span></span><code><span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kn">theorem</span> <span class="n">pi_congr</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">g</span> <span class="n">i</span> <span class="o">:=</span>
<span class="n">sorry</span>
</code></pre></div>



<a name="198655524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655524">(May 25 2020 at 10:46)</a>:</h4>
<p>I have no clue how to do this</p>



<a name="198655561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655561">(May 25 2020 at 10:47)</a>:</h4>
<p>But the real question is why someone would want to do this. <code>=</code> is overrated. It's not the right concept anyway, for types. It's a random equivalence relation, which seems very different to the equivalence relations on mathematical objects which mathematicians carry around in their heads.</p>



<a name="198655565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655565">(May 25 2020 at 10:47)</a>:</h4>
<p>aha I know how to do this</p>



<a name="198655609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655609">(May 25 2020 at 10:48)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kn">theorem</span> <span class="n">pi_congr</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">g</span> <span class="n">i</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="k">show</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span><span class="o">,</span> <span class="k">from</span> <span class="n">funext</span> <span class="n">h</span>
</code></pre></div>



<a name="198655610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655610">(May 25 2020 at 10:48)</a>:</h4>
<p>boom</p>



<a name="198655614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655614">(May 25 2020 at 10:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F/near/198655042">said</a>:</p>
<blockquote>
<p>Rule of thumb: don't try to prove that types are equal. My understanding is that in Lean <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>=</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}=\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> is undecidable. Prove your types are <code>equiv</code> instead.</p>
</blockquote>
<p>Say I do this (in my case it would be easy to show the equivalence), what then? Can you use it to rewrite terms with it?</p>



<a name="198655622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655622">(May 25 2020 at 10:48)</a>:</h4>
<p>Maybe they'd want to do it because they're an UG in the summer with nothing better to do :-)</p>



<a name="198655626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655626">(May 25 2020 at 10:48)</a>:</h4>
<p>Yes <code>rw</code> works with <code>=</code>.</p>



<a name="198655637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655637">(May 25 2020 at 10:48)</a>:</h4>
<p>with = yes</p>



<a name="198655645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655645">(May 25 2020 at 10:48)</a>:</h4>
<p>but what about simeq</p>



<a name="198655655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655655">(May 25 2020 at 10:49)</a>:</h4>
<p>Then you need a tactic.</p>



<a name="198655680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655680">(May 25 2020 at 10:49)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="o">{</span><span class="n">i</span> <span class="bp">//</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="mi">2</span><span class="o">},</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="o">[</span><span class="bp">ℕ</span><span class="o">,</span> <span class="bp">ℕ</span><span class="o">]</span> <span class="n">i</span> <span class="o">:=</span>
<span class="n">suffices</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="o">{</span><span class="n">i</span> <span class="bp">//</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="mi">2</span><span class="o">},</span> <span class="bp">ℕ</span> <span class="bp">=</span> <span class="o">[</span><span class="bp">ℕ</span><span class="o">,</span> <span class="bp">ℕ</span><span class="o">]</span> <span class="n">i</span><span class="o">,</span>
<span class="k">from</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">f</span> <span class="o">:</span> <span class="o">{</span><span class="n">i</span> <span class="bp">//</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="mi">2</span><span class="o">}</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">,</span> <span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">funext</span> <span class="n">this</span><span class="o">),</span>
<span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">match</span> <span class="n">i</span> <span class="k">with</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">cases</span> <span class="n">not_le_of_lt</span> <span class="n">h</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_add_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span>
<span class="kn">end</span>
</code></pre></div>



<a name="198655759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655759">(May 25 2020 at 10:50)</a>:</h4>
<p>I think you are barking up the wrong tree. You probably don't need to rewrite across equivs either</p>



<a name="198655769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655769">(May 25 2020 at 10:51)</a>:</h4>
<p>Right. I was <em>very</em> surprised about this.</p>



<a name="198655867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655867">(May 25 2020 at 10:52)</a>:</h4>
<p>When I realised I couldn't prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>f</mi><mi>g</mi><mo stretchy="false">]</mo><mo>=</mo><mi>R</mi><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>f</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>g</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[1/fg]=R[1/f][1/g]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">]</span></span></span></span> in Lean (these are two rings which a mathematician would call equal, but if you put a gun to their head they might confess that they are merely canonically isomorphic) I instantly started banging on about an <code>equiv_rw</code> tactic being of utmost importance -- and Scott Morrison even <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#equiv_rw">made a start on one</a>.</p>



<a name="198655897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655897">(May 25 2020 at 10:53)</a>:</h4>
<p>The problem with these equalities of types isn't proving them, it's everything that comes after that.</p>



<a name="198655901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655901">(May 25 2020 at 10:53)</a>:</h4>
<p>But then when Ramon Fernandez Mir started work on schemes, he didn't need the tactic anyway, he just worked with the universal property instead</p>



<a name="198655914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655914">(May 25 2020 at 10:53)</a>:</h4>
<p>If you have a type <code>A</code> and you proved that <code>h : A = A'</code> and you want to rewrite along <code>h</code>, presumably you also have a value of type <code>A</code> and that value will not just come along for the ride.</p>



<a name="198655930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655930">(May 25 2020 at 10:53)</a>:</h4>
<p>The origin of this whole mess was this:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">prod_to_pi</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="o">[</span><span class="n">α</span><span class="o">,</span> <span class="n">β</span><span class="o">]</span> <span class="n">i</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span><span class="bp">_⟩</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="bp">⟨_</span><span class="o">,</span><span class="n">b</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="o">:=</span> <span class="n">b</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">⟨</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">norm_num</span> <span class="n">at</span> <span class="n">hi</span><span class="bp">;</span> <span class="n">linarith</span>
</code></pre></div>


<p>So it comes from choosing a crappy index type. Using boolean instead would simplify type.</p>



<a name="198655975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655975">(May 25 2020 at 10:54)</a>:</h4>
<p>but I just wanted to explore what can be done, really.</p>



<a name="198655993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655993">(May 25 2020 at 10:54)</a>:</h4>
<p>not proving anything too meaningful, but more like trying to figure out how to write things down so that the proofs are easy to deal with.</p>



<a name="198655999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198655999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198655999">(May 25 2020 at 10:54)</a>:</h4>
<p>that is properly an equiv, and you should use either <code>bool</code> or a bespoke inductive type for the index type</p>



<a name="198656025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198656025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198656025">(May 25 2020 at 10:55)</a>:</h4>
<p>To do that, I basically have to try things out and see where (and more importantly why) they fail.</p>



<a name="198656044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198656044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198656044">(May 25 2020 at 10:55)</a>:</h4>
<p>This is exactly how I got my understanding of <code>=</code> within my domain -- I just tried to make a bunch of pure mathematical objects and learnt a lot.</p>



<a name="198656196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198656196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198656196">(May 25 2020 at 10:58)</a>:</h4>
<p>So yes, sorry for the question being not meaningful for practical purposes. Now I basically learnt, that it's not really useful to talk about definitional equality of types.</p>
<p>I had an <code>exists ...</code> that I wanted to instantiate using my type. And it said it couldn't unify, precisely because it didn't know the types were the same. The expression was the same.</p>



<a name="198656210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198656210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198656210">(May 25 2020 at 10:58)</a>:</h4>
<p>Split by cases twice and then eliminate the 3rd case.</p>



<a name="198656245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198656245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198656245">(May 25 2020 at 10:59)</a>:</h4>
<p>Definitional equality of types is fine. Because if <code>A</code> is definitionally equal to <code>A'</code> and <code>a : A</code> then also <code>a : A'</code>.<br>
It's the non-definitional equality of types that is problematic.</p>



<a name="198656273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198656273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198656273">(May 25 2020 at 10:59)</a>:</h4>
<p>Even when you can prove it, you probably shouldn't.</p>



<a name="198656367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198656367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198656367">(May 25 2020 at 11:00)</a>:</h4>
<p>The problem is that as a mathematician I don't want to think about "the" definition of an object -- I only care about the specification of the object, and its implementation is a matter for the CS people. I never quite know how much weight to put on definitional equality.</p>



<a name="198656386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198656386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198656386">(May 25 2020 at 11:01)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">index</span> <span class="bp">|</span> <span class="n">left</span> <span class="bp">|</span> <span class="n">right</span>

<span class="n">def</span> <span class="n">index</span><span class="bp">.</span><span class="n">elim</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">index</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">index</span><span class="bp">.</span><span class="n">left</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">index</span><span class="bp">.</span><span class="n">right</span> <span class="o">:=</span> <span class="n">b</span>

<span class="n">def</span> <span class="n">prod_to_pi</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">index</span><span class="bp">.</span><span class="n">elim</span> <span class="n">α</span> <span class="n">β</span> <span class="n">i</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="n">index</span><span class="bp">.</span><span class="n">left</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">b</span><span class="bp">⟩</span> <span class="n">index</span><span class="bp">.</span><span class="n">right</span> <span class="o">:=</span> <span class="n">b</span>

<span class="n">def</span> <span class="n">pi_to_prod</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">index</span><span class="bp">.</span><span class="n">elim</span> <span class="n">α</span> <span class="n">β</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span> <span class="n">index</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span> <span class="n">f</span> <span class="n">index</span><span class="bp">.</span><span class="n">right</span><span class="o">)</span>

<span class="n">def</span> <span class="n">prod_equiv_pi</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="err">≃</span> <span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">index</span><span class="bp">.</span><span class="n">elim</span> <span class="n">α</span> <span class="n">β</span> <span class="n">i</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">prod_to_pi</span><span class="o">,</span> <span class="n">pi_to_prod</span><span class="o">,</span> <span class="k">by</span> <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="bp">⟩;</span> <span class="n">refl</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="k">by</span> <span class="n">ext</span> <span class="o">(</span><span class="bp">_|_</span><span class="o">)</span><span class="bp">;</span> <span class="n">refl</span><span class="bp">⟩</span>
</code></pre></div>



<a name="198656592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198656592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198656592">(May 25 2020 at 11:04)</a>:</h4>
<p>yes, clearly having my own DU is the right way to go. And I knew that the moment, I realised that <code>{i // i &lt; 2}</code> is NOT a type consisting of two elements, but rather <code>nat</code> with a proof of <code>i &lt; 2</code>.</p>



<a name="198656607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198656607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198656607">(May 25 2020 at 11:05)</a>:</h4>
<p>So any pattern matching requires me to prove the impossible case.</p>



<a name="198656654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198656654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198656654">(May 25 2020 at 11:05)</a>:</h4>
<p>The Pi extensionality, if you will, was more like a curiosity after that.</p>



<a name="198656713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198656713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198656713">(May 25 2020 at 11:06)</a>:</h4>
<p>I mean, it <em>is</em> a type with two elements, you can prove that, but when it comes to equations in types you really want things to be defeq and that means using inductive types and recursive definitions such that everything evaluates smoothly</p>



<a name="198656832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20rewriting%20/%20type%20extensionality%3F/near/198656832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20rewriting.20.2F.20type.20extensionality.3F.html#198656832">(May 25 2020 at 11:08)</a>:</h4>
<p>makes a lot of sense.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
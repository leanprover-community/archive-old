---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Nodup.20Indices.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html">Nodup Indices</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="224658275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224658275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224658275">(Jan 31 2021 at 18:41)</a>:</h4>
<p>How would you prove this lemma?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.indexes</span>
<span class="kn">import</span> <span class="n">data.list.nodup</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">l.find_indexes</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">nodup</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">list.find_indexes_eq_map_indexes_values</span><span class="o">,</span>
  <span class="k">suffices</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">list.indexes_values</span> <span class="n">p</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">nodup</span><span class="o">,</span> <span class="k">from</span> <span class="n">list.nodup_map</span> <span class="gr">sorry</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">list.indexes_values_eq_filter_enum</span><span class="o">,</span>
  <span class="k">suffices</span> <span class="n">h</span> <span class="o">:</span> <span class="n">l.enum.nodup</span><span class="o">,</span> <span class="k">from</span> <span class="n">list.nodup_filter</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span>
  <span class="c1">-- ...?</span>
<span class="kd">end</span>
</code></pre></div>
<p>I've been able to reduce it to showing that <code>l.enum.nodup</code>, but I don't know how to continue from here. And also I feel like there must be some easier way to show this result.<br>
Is there anything I'm missing?<br>
Thanks</p>



<a name="224658519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224658519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224658519">(Jan 31 2021 at 18:46)</a>:</h4>
<p>Why is this true? If the list has duplicates and <code>p</code> is always true...</p>



<a name="224658610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224658610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224658610">(Jan 31 2021 at 18:48)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span><span class="bp">.</span><span class="n">find_indexes</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="c1">-- [0, 1, 2, 3]</span>
</code></pre></div>



<a name="224658635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224658635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224658635">(Jan 31 2021 at 18:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/113489-new-members/topic/Nodup.20Indices/near/224658519">said</a>:</p>
<blockquote>
<p>Why is this true? If the list has duplicates and <code>p</code> is always true...</p>
</blockquote>
<p>I was assuming that <code>list.find_indexes</code> would return the indices of all those elements in the list that satisfy some predicate. So any given index would show up at most once, making the list <code>nodup</code>.</p>



<a name="224658708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224658708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224658708">(Jan 31 2021 at 18:51)</a>:</h4>
<p>Ah sure, it finds the <em>indexes</em>, not the elements! Sorry, my fault</p>



<a name="224658874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224658874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224658874">(Jan 31 2021 at 18:55)</a>:</h4>
<p>I would prove that the list this function produces is strictly increasing as a separate lemma, and go from there.</p>



<a name="224660503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224660503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224660503">(Jan 31 2021 at 19:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Nodup.20Indices/near/224658874">said</a>:</p>
<blockquote>
<p>I would prove that the list this function produces is strictly increasing as a separate lemma, and go from there.</p>
</blockquote>
<p>I've separated this subproof out into its own lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.enum_cons_mem</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">hd</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">tl</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)}</span> <span class="o">:</span>
  <span class="n">l.enum</span> <span class="bp">=</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="bp">→</span> <span class="n">hd</span> <span class="bp">∉</span> <span class="n">tl</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span>
</code></pre></div>
<p>But I'm failing at actually applying it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.find_indexes_nodup</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">l.find_indexes</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">nodup</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">rw</span> <span class="n">list.find_indexes_eq_map_indexes_values</span><span class="o">,</span>
    <span class="k">suffices</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">list.indexes_values</span> <span class="n">p</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">nodup</span><span class="o">,</span> <span class="k">from</span> <span class="n">list.nodup_map</span> <span class="gr">sorry</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">list.indexes_values_eq_filter_enum</span><span class="o">,</span>
    <span class="k">suffices</span> <span class="n">h</span> <span class="o">:</span> <span class="n">l.enum.nodup</span><span class="o">,</span> <span class="k">from</span> <span class="n">list.nodup_filter</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">l.enum</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">ih</span><span class="o">,</span>
      <span class="n">case</span> <span class="n">list.nil</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
      <span class="n">case</span> <span class="n">list.cons</span> <span class="o">{</span>
        <span class="n">apply</span> <span class="n">list.nodup_cons.mpr</span><span class="o">,</span>
        <span class="k">suffices</span> <span class="n">h</span> <span class="o">:</span> <span class="n">hd</span> <span class="bp">∉</span> <span class="n">tl</span><span class="o">,</span> <span class="k">from</span> <span class="n">and.intro</span> <span class="n">h</span> <span class="n">ih</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">l.enum</span> <span class="bp">=</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span><span class="o">,</span> <span class="k">from</span> <span class="gr">sorry</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">list.enum_cons_mem</span> <span class="n">h</span>
      <span class="o">}</span>
  <span class="kd">end</span>
</code></pre></div>
<p>I don't know how to fix the second <code>sorry</code>. I thought a <code>refl</code> would work, but it seems that the fact that <code>l.enum = hd :: tl</code> isn't being propagated into the induction.</p>



<a name="224661412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224661412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224661412">(Jan 31 2021 at 19:56)</a>:</h4>
<p><span class="user-mention" data-user-id="372804">@Marcus Rossel</span> What I had in mind is splitting up as follows. <br>
I bet mathlib already has something like this <code>to_func</code> thing...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.basic</span>
<span class="kn">import</span> <span class="n">data.list.indexes</span>
<span class="kn">import</span> <span class="n">data.list.nodup</span>

<span class="kd">def</span> <span class="n">list.to_func</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">l.length</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">l.nth_le</span> <span class="n">i.1</span> <span class="n">i.2</span>

<span class="kd">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span> <span class="n">strict_mono</span> <span class="o">(</span><span class="n">l.find_indexes</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">to_func</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">bar</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">strict_mono</span> <span class="n">l.to_func</span> <span class="bp">→</span> <span class="n">l.nodup</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">l.find_indexes</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">nodup</span> <span class="o">:=</span> <span class="n">bar</span> <span class="bp">$</span> <span class="n">foo</span> <span class="n">_</span> <span class="n">_</span>
</code></pre></div>



<a name="224661731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224661731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224661731">(Jan 31 2021 at 20:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="372804">Marcus Rossel</span> <a href="#narrow/stream/113489-new-members/topic/Nodup.20Indices/near/224660503">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Nodup.20Indices/near/224658874">said</a>:</p>
<blockquote>
<p>I would prove that the list this function produces is strictly increasing as a separate lemma, and go from there.</p>
</blockquote>
<p>I've separated this subproof out into its own lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.enum_cons_mem</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">hd</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">tl</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)}</span> <span class="o">:</span>
  <span class="n">l.enum</span> <span class="bp">=</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="bp">→</span> <span class="n">hd</span> <span class="bp">∉</span> <span class="n">tl</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span>
</code></pre></div>
<p>But I'm failing at actually applying it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.find_indexes_nodup</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">l.find_indexes</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">nodup</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">rw</span> <span class="n">list.find_indexes_eq_map_indexes_values</span><span class="o">,</span>
    <span class="k">suffices</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">list.indexes_values</span> <span class="n">p</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">nodup</span><span class="o">,</span> <span class="k">from</span> <span class="n">list.nodup_map</span> <span class="gr">sorry</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">list.indexes_values_eq_filter_enum</span><span class="o">,</span>
    <span class="k">suffices</span> <span class="n">h</span> <span class="o">:</span> <span class="n">l.enum.nodup</span><span class="o">,</span> <span class="k">from</span> <span class="n">list.nodup_filter</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">l.enum</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">ih</span><span class="o">,</span>
      <span class="n">case</span> <span class="n">list.nil</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
      <span class="n">case</span> <span class="n">list.cons</span> <span class="o">{</span>
        <span class="n">apply</span> <span class="n">list.nodup_cons.mpr</span><span class="o">,</span>
        <span class="k">suffices</span> <span class="n">h</span> <span class="o">:</span> <span class="n">hd</span> <span class="bp">∉</span> <span class="n">tl</span><span class="o">,</span> <span class="k">from</span> <span class="n">and.intro</span> <span class="n">h</span> <span class="n">ih</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">l.enum</span> <span class="bp">=</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span><span class="o">,</span> <span class="k">from</span> <span class="gr">sorry</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">list.enum_cons_mem</span> <span class="n">h</span>
      <span class="o">}</span>
  <span class="kd">end</span>
</code></pre></div>
<p>I don't know how to fix the second <code>sorry</code>. I thought a <code>refl</code> would work, but it seems that the fact that <code>l.enum = hd :: tl</code> isn't being propagated into the induction.</p>
</blockquote>
<p>It looks like to me you're trying to prove something false in the induction</p>



<a name="224661743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224661743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224661743">(Jan 31 2021 at 20:03)</a>:</h4>
<p>Maybe I may be wrong but doing induction on <code>l.enum</code> is like: take an arbitrary list and prove what I want I think</p>



<a name="224661805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224661805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224661805">(Jan 31 2021 at 20:04)</a>:</h4>
<p>If you do it on <code>l</code>, it might work, as you will prove <code>(0, hd) notin enum_from 1 tl and (enum_from 1 tl).nodup</code></p>



<a name="224661902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224661902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224661902">(Jan 31 2021 at 20:06)</a>:</h4>
<p>And the first is provable because you can show the first component of <code>enum_from 1 tl</code> is greater or equal than 1, thus <code>(0, something)</code> cannot be there, and the second is just the fact that applying an injective function to a nodup list won't change its nodup property, and you just translate the first component of the induction hypothesis, there might be a lot better way to do it though</p>



<a name="224662398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224662398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224662398">(Jan 31 2021 at 20:16)</a>:</h4>
<p>Though, indeed, this is a bit strange</p>



<a name="224669319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224669319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224669319">(Jan 31 2021 at 22:18)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nodup_zip_of_left</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nodup</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">nodup</span> <span class="o">(</span><span class="n">l.zip</span> <span class="n">l'</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span> <span class="n">generalizing</span> <span class="n">l'</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">l'</span> <span class="k">with</span> <span class="n">hd'</span> <span class="n">tl'</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nodup_cons</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">zip_cons_cons</span><span class="o">,</span> <span class="n">nodup_cons</span><span class="o">],</span>
      <span class="n">exact</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">H</span><span class="o">,</span> <span class="n">h.left</span> <span class="o">(</span><span class="n">mem_zip</span> <span class="n">H</span><span class="o">)</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span> <span class="n">hl</span> <span class="n">h.right</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">nodup_zip_of_right</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nodup</span> <span class="n">l</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">nodup</span> <span class="o">(</span><span class="n">l.zip</span> <span class="n">l'</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">l'</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span> <span class="n">generalizing</span> <span class="n">l</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">l</span> <span class="k">with</span> <span class="n">hd'</span> <span class="n">tl'</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nodup_cons</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">zip_cons_cons</span><span class="o">,</span> <span class="n">nodup_cons</span><span class="o">],</span>
      <span class="n">exact</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">H</span><span class="o">,</span> <span class="n">h.left</span> <span class="o">(</span><span class="n">mem_zip</span> <span class="n">H</span><span class="o">)</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span> <span class="n">hl</span> <span class="n">_</span> <span class="n">h.right</span><span class="o">⟩</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">nodup_enum</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">nodup</span> <span class="n">l.enum</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">enum_eq_zip_range</span><span class="o">,</span> <span class="n">exact</span> <span class="n">nodup_zip_of_left</span> <span class="o">(</span><span class="n">nodup_range</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span> <span class="o">}</span>
</code></pre></div>



<a name="224669325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224669325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224669325">(Jan 31 2021 at 22:18)</a>:</h4>
<p>You said you needed <code>l.enum.nodup</code> -- there you go.</p>



<a name="224669328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224669328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224669328">(Jan 31 2021 at 22:18)</a>:</h4>
<p>That's after <code>import list.range</code></p>



<a name="224669345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224669345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224669345">(Jan 31 2021 at 22:19)</a>:</h4>
<p><span class="user-mention" data-user-id="372804">@Marcus Rossel</span></p>



<a name="224703719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224703719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224703719">(Feb 01 2021 at 09:44)</a>:</h4>
<p>Wow, thanks! <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> <br>
I feel like some of this should make its way into Mathlib, since IMHO <code>find_indexes</code> being <code>nodup</code> should be easily available and not require 4 lemmata. Does anyone know how I could get the ball rolling on that?</p>



<a name="224704492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224704492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224704492">(Feb 01 2021 at 09:53)</a>:</h4>
<p>If you have a github account then announce what it is and ask the maintainers for push access to non-master branches of mathlib, and then put the lemmas in an appropriate place on a branch of mathlib and then make a PR</p>



<a name="224728956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224728956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224728956">(Feb 01 2021 at 13:59)</a>:</h4>
<p>The initial premise that <code>find_indexes</code> is <code>nodup</code> is faulty (using your proof strategy), as you can tell by the fact that you have to <code>sorry</code> the proof that <code>prod.fst</code> is injective. Because it isn't.</p>



<a name="224749989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Nodup%20Indices/near/224749989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Nodup.20Indices.html#224749989">(Feb 01 2021 at 16:16)</a>:</h4>
<p>Here you go:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.indexes</span>
<span class="kn">import</span> <span class="n">data.list.range</span>

<span class="kn">open</span> <span class="n">list</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">δ</span> <span class="n">ε</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">foldr_with_index_nil</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">foldr_with_index</span> <span class="n">f</span> <span class="n">b</span> <span class="n">nil</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">foldr_with_index_singleton</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">foldr_with_index</span> <span class="n">f</span> <span class="n">b</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="bp">=</span> <span class="n">f</span> <span class="mi">0</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">function.uncurry_comp_prod_map_id_left</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">δ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">function.uncurry</span> <span class="n">f</span> <span class="bp">∘</span> <span class="n">prod.map</span> <span class="n">g</span> <span class="n">id</span> <span class="bp">=</span> <span class="n">function.uncurry</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">g</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="o">⟨</span><span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">⟩,</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">foldr_with_index_cons</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">foldr_with_index</span> <span class="n">f</span> <span class="n">b</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="mi">0</span> <span class="n">a</span> <span class="o">(</span><span class="n">foldr_with_index</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">nat.succ</span><span class="o">)</span> <span class="n">b</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">foldr_with_index_eq_foldr_enum</span><span class="o">,</span> <span class="n">enum_eq_zip_range</span><span class="o">,</span> <span class="n">range_succ_eq_map</span><span class="o">,</span> <span class="n">zip_map_left</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">find_indexes_nil</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span> <span class="n">find_indexes</span> <span class="n">p</span> <span class="n">nil</span> <span class="bp">=</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">find_indexes_cons_true</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">find_indexes</span> <span class="n">p</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">::</span> <span class="o">(</span><span class="n">find_indexes</span> <span class="n">p</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">nat.succ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">map</span> <span class="o">(</span><span class="n">prod.fst</span> <span class="bp">∘</span> <span class="n">prod.map</span> <span class="n">nat.succ</span> <span class="n">id</span><span class="o">)</span> <span class="o">(</span><span class="n">filter</span> <span class="o">((</span><span class="n">p</span> <span class="bp">∘</span> <span class="n">prod.snd</span><span class="o">)</span> <span class="bp">∘</span> <span class="n">prod.map</span> <span class="n">nat.succ</span> <span class="n">id</span><span class="o">)</span>
    <span class="o">((</span><span class="n">range</span> <span class="n">l.length</span><span class="o">)</span><span class="bp">.</span><span class="n">zip</span> <span class="n">l</span><span class="o">))</span> <span class="bp">=</span> <span class="n">map</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="bp">∘</span> <span class="n">prod.fst</span><span class="o">)</span>
      <span class="o">(</span><span class="n">filter</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∘</span> <span class="n">prod.snd</span><span class="o">)</span> <span class="o">((</span><span class="n">range</span> <span class="n">l.length</span><span class="o">)</span><span class="bp">.</span><span class="n">zip</span> <span class="n">l</span><span class="o">)),</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">find_indexes_eq_map_indexes_values</span><span class="o">,</span> <span class="n">indexes_values_eq_filter_enum</span><span class="o">,</span> <span class="n">enum_eq_zip_range</span><span class="o">,</span>
             <span class="n">range_succ_eq_map</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">filter</span><span class="o">,</span> <span class="n">zip_map_left</span><span class="o">,</span> <span class="n">filter_of_map</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">congr</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">find_indexes_cons_false</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">find_indexes</span> <span class="n">p</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">find_indexes</span> <span class="n">p</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">nat.succ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">map</span> <span class="o">(</span><span class="n">prod.fst</span> <span class="bp">∘</span> <span class="n">prod.map</span> <span class="n">nat.succ</span> <span class="n">id</span><span class="o">)</span> <span class="o">(</span><span class="n">filter</span> <span class="o">((</span><span class="n">p</span> <span class="bp">∘</span> <span class="n">prod.snd</span><span class="o">)</span> <span class="bp">∘</span> <span class="n">prod.map</span> <span class="n">nat.succ</span> <span class="n">id</span><span class="o">)</span>
    <span class="o">((</span><span class="n">range</span> <span class="n">l.length</span><span class="o">)</span><span class="bp">.</span><span class="n">zip</span> <span class="n">l</span><span class="o">))</span> <span class="bp">=</span> <span class="n">map</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="bp">∘</span> <span class="n">prod.fst</span><span class="o">)</span>
      <span class="o">(</span><span class="n">filter</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∘</span> <span class="n">prod.snd</span><span class="o">)</span> <span class="o">((</span><span class="n">range</span> <span class="n">l.length</span><span class="o">)</span><span class="bp">.</span><span class="n">zip</span> <span class="n">l</span><span class="o">)),</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">find_indexes_eq_map_indexes_values</span><span class="o">,</span> <span class="n">indexes_values_eq_filter_enum</span><span class="o">,</span> <span class="n">enum_eq_zip_range</span><span class="o">,</span>
             <span class="n">range_succ_eq_map</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">filter</span><span class="o">,</span> <span class="n">zip_map_left</span><span class="o">,</span> <span class="n">filter_of_map</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">congr</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">nodup_find_indexes</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">l.find_indexes</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">nodup</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">hd</span><span class="bp">;</span>
    <span class="n">simpa</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">nat.succ_ne_zero</span><span class="o">]</span> <span class="n">using</span> <span class="n">nodup_map</span> <span class="n">nat.succ_injective</span> <span class="n">hl</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
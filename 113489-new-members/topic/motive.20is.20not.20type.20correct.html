---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html">motive is not type correct</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="215677895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215677895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chase Norman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215677895">(Nov 05 2020 at 07:25)</a>:</h4>
<p>I have a goal of type <code>l.nth_le (l.length - 2).succ bound = l.nth_le i i_bound</code> and a hypothesis <code>z</code> of type <code>i=0</code>. When I use the tactic <code>rw z</code>, I get the following error <code>rewrite tactic failed, motive is not type correct
  λ (_a : ℕ),
    l.nth_le (l.length - 2).succ bound = l.nth_le i i_bound = (l.nth_le (l.length - 2).succ bound = l.nth_le _a i_bound)</code>. </p>
<p><code>change</code> fails to recognize it too. I also can't get <code>set</code> or <code>congr</code> to work. Any ideas?</p>



<a name="215678130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215678130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215678130">(Nov 05 2020 at 07:30)</a>:</h4>
<p>What about <code>simp_rw [z]</code>?</p>



<a name="215678202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215678202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215678202">(Nov 05 2020 at 07:32)</a>:</h4>
<p>But why do you have a goal that is the equality of equalities? Did you <code>congr</code> too deep? Or as the result of a <code>convert</code>?</p>



<a name="215678224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215678224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chase Norman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215678224">(Nov 05 2020 at 07:32)</a>:</h4>
<p>This worked! Thanks a bunch. I'm not sure what you mean by equality of equalities.</p>



<a name="215678232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215678232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chase Norman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215678232">(Nov 05 2020 at 07:33)</a>:</h4>
<p>I'm trying to show that two elements of a list are equal.</p>



<a name="215678261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215678261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chase Norman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215678261">(Nov 05 2020 at 07:33)</a>:</h4>
<p>Is there something I'm missing as far as how you came up with simp_rw? Is it just a general catch-all for these types of errors?</p>



<a name="215678369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215678369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215678369">(Nov 05 2020 at 07:36)</a>:</h4>
<p>Hmm maybe it's just the error that has the <code>_ = _ = (_ = _)</code> structure</p>



<a name="215678404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215678404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215678404">(Nov 05 2020 at 07:36)</a>:</h4>
<p>I've seen these motive errors a lot when working with lists or vectors with some length constraint. And that experience has taught me  that <code>simp_rw</code> or just <code>simp [...]</code> works. In fact, <code>simp_rw</code> is just a wrapper around <code>simp only [...]</code> iirc.</p>



<a name="215678420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215678420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215678420">(Nov 05 2020 at 07:37)</a>:</h4>
<p><code>simp</code> is able to see through more layers than <code>rw</code>. There is some work going on to have a better, dependent-equality cognization <code>dep_rw</code>, but in the meantime, <code>simp</code> related tools will work.</p>



<a name="215678433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215678433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215678433">(Nov 05 2020 at 07:37)</a>:</h4>
<p>Careful though, you can get some weird loops if you do <code>simp_rw [&lt;- vector.cons_head_tail v]</code> for example.</p>



<a name="215685443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215685443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215685443">(Nov 05 2020 at 09:04)</a>:</h4>
<p>The error _means_ that your goal contains a proof of something involving <code>i</code>, and when you try to change i to 0 with a rewrite it didn't change the proof, so the proof still mentioned i but it was now supposed to be a proof about 0, and Lean gets confused. It "didn't rewrite enough", in some sense. <code>simp_rw</code> tries harder to rewrite.</p>



<a name="215685644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215685644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215685644">(Nov 05 2020 at 09:06)</a>:</h4>
<p>"Motive is not type correct" just means something like "this thing is supposed to be a pair (i,P) where P is a proof of something involving i, but you just presented me with (0,P) with P a proof of something involving i instead of 0, so (0,P) is not an object with a well-defined type as far as I can see"</p>



<a name="215686730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215686730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chase Norman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215686730">(Nov 05 2020 at 09:17)</a>:</h4>
<p>I'm surprised that the <code>i = 0</code> is not enough for Lean to determine that proofs involving <code>i</code> also work for <code>0</code></p>



<a name="215687451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215687451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215687451">(Nov 05 2020 at 09:25)</a>:</h4>
<p>It is... as you just noticed by using <code>simp_rw</code></p>



<a name="215687503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215687503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215687503">(Nov 05 2020 at 09:26)</a>:</h4>
<p>It's just that <code>rw</code> is being "silly"</p>



<a name="215688145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215688145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215688145">(Nov 05 2020 at 09:32)</a>:</h4>
<p>Every tactic has some (often quite well-understood, and also often quite well-defined) domain where it works effectively, and outside this domain it might fail, and the reason for failure isn't because the tactic is stupid, it's because the tactic was not designed to work here.</p>



<a name="215688368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215688368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215688368">(Nov 05 2020 at 09:34)</a>:</h4>
<p>You can see <code>linarith</code> failing on goals where to a mathematician it "should obviously work" but it doesn't work because it didn't use the hypothesis "x &lt; 37" because it was part of a bigger hypothesis "x &lt; 37 and y &lt; 42". So you say "why didn't linarith just extract the hypothesis x&lt;37 from the "and" hypothesis?" and the answer is "linarith doesn't do "and"". And you say "well doesn't that mean "linarith" is stupid?" and they basically reply "no, it means that splitting up "and" clauses is not linarith's job, and if we made it linarith's job then tomorrow you would ask it to start doing some other basic logic too. "</p>



<a name="215688429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215688429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chase Norman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215688429">(Nov 05 2020 at 09:35)</a>:</h4>
<p>I now realize how silly that made me sound.</p>



<a name="215688446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215688446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215688446">(Nov 05 2020 at 09:35)</a>:</h4>
<p>actually I think linarith might do this</p>



<a name="215688498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215688498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215688498">(Nov 05 2020 at 09:35)</a>:</h4>
<p>but you can see the point I'm making. The idea is that tactics do one job, and when they fail it's often because they were asked to do a job which they weren't designed to do.</p>



<a name="215688595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215688595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215688595">(Nov 05 2020 at 09:36)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">37</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">37</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">38</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">linarith</span> <span class="c1">-- fails</span>
<span class="kd">end</span>
</code></pre></div>



<a name="215688640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215688640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215688640">(Nov 05 2020 at 09:37)</a>:</h4>
<p>obviously "the general theory of inequalities" should solve this goal, but <code>linarith</code> doesn't because it won't do the cases on the "or".</p>



<a name="215688666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215688666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215688666">(Nov 05 2020 at 09:37)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">37</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">37</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">38</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">h</span><span class="bp">;</span>
  <span class="n">linarith</span> <span class="c1">-- works</span>
<span class="kd">end</span>
</code></pre></div>



<a name="215688769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215688769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215688769">(Nov 05 2020 at 09:38)</a>:</h4>
<p>There is a more primitive version of rewrite called <code>▸</code> and that fails in even more cases.</p>



<a name="215760046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215760046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chase Norman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215760046">(Nov 05 2020 at 19:11)</a>:</h4>
<p>I have another issue that is similar. The case seems simpler, but it's even more resistant to these tactics. My goal is <code>int.of_nat {v : V | P.P v x y}.to_finset.card - int.of_nat {v : V | P.P v y x}.to_finset.card &gt; 0</code> and I have <code>int.of_nat {v : V | P.P v y x}.to_finset.card = 0</code>. I hope to be able to achieve <code>int.of_nat {v : V | P.P v x y}.to_finset.card - 0 &gt; 0</code>. </p>
<p><code>rw</code>, <code>congr'</code>, <code>simp_rw</code> all failing me.</p>



<a name="215775656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215775656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215775656">(Nov 05 2020 at 21:19)</a>:</h4>
<p>Do you have an <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>?</p>



<a name="215775771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/215775771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#215775771">(Nov 05 2020 at 21:20)</a>:</h4>
<p>There can be different issues with hidden (implicit and typeclass) arguments.</p>



<a name="223067036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/223067036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#223067036">(Jan 17 2021 at 22:26)</a>:</h4>
<p>At the last step here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.rat.basic</span>
<span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">data.num.prime</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">tactic.slim_check</span>
<span class="kn">open</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">rat</span>
<span class="kn">open</span> <span class="n">nat</span>

<span class="kd">lemma</span> <span class="n">mul_injective</span>
        <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">}</span>
        <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
        <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a.denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span>
        <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b.denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">):</span>
        <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">ha</span> <span class="n">at</span> <span class="n">a_cop</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hb</span> <span class="n">at</span> <span class="n">b_cop</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">ha</span><span class="o">,</span> <span class="c1">-- error</span>
<span class="kd">end</span>
</code></pre></div>
<p>the tactic state is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">a_num</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span>
<span class="n">a_denom</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">a_pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a_denom</span><span class="o">,</span>
<span class="n">a_cop</span> <span class="o">:</span> <span class="n">a_num.nat_abs.coprime</span> <span class="n">a_denom</span><span class="o">,</span>
<span class="n">b_num</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span>
<span class="n">b_denom</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">b_pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">b_denom</span><span class="o">,</span>
<span class="n">b_cop</span> <span class="o">:</span> <span class="n">b_num.nat_abs.coprime</span> <span class="n">b_denom</span><span class="o">,</span>
<span class="n">ha</span> <span class="o">:</span> <span class="n">a_denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">,</span>
<span class="n">hb</span> <span class="o">:</span> <span class="n">b_denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">,</span>
<span class="n">a_cop</span> <span class="o">:</span> <span class="n">a_num.nat_abs.coprime</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">),</span>
<span class="n">b_cop</span> <span class="o">:</span> <span class="n">b_num.nat_abs.coprime</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">m</span><span class="o">)</span>
<span class="bp">⊢</span> <span class="o">({</span><span class="n">num</span> <span class="o">:=</span> <span class="n">a_num</span><span class="o">,</span> <span class="n">denom</span> <span class="o">:=</span> <span class="n">a_denom</span><span class="o">,</span> <span class="n">pos</span> <span class="o">:=</span> <span class="n">a_pos</span><span class="o">,</span> <span class="n">cop</span> <span class="o">:=</span> <span class="n">a_cop</span><span class="o">}</span> <span class="bp">*</span>
       <span class="o">{</span><span class="n">num</span> <span class="o">:=</span> <span class="n">b_num</span><span class="o">,</span> <span class="n">denom</span> <span class="o">:=</span> <span class="n">b_denom</span><span class="o">,</span> <span class="n">pos</span> <span class="o">:=</span> <span class="n">b_pos</span><span class="o">,</span> <span class="n">cop</span> <span class="o">:=</span> <span class="n">b_cop</span><span class="o">})</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span>
    <span class="mi">2</span> <span class="bp">^</span> <span class="bp">?</span><span class="n">m_1</span>
</code></pre></div>
<p>I want to substitute <code>2^n</code> for <code>a_denom</code> in the goal.  Lean throws error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rewrite</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">motive</span> <span class="n">is</span> <span class="n">not</span> <span class="n">type</span> <span class="n">correct</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">_a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span>
    <span class="o">({</span><span class="n">num</span> <span class="o">:=</span> <span class="n">a_num</span><span class="o">,</span> <span class="n">denom</span> <span class="o">:=</span> <span class="n">a_denom</span><span class="o">,</span> <span class="n">pos</span> <span class="o">:=</span> <span class="n">a_pos</span><span class="o">,</span> <span class="n">cop</span> <span class="o">:=</span> <span class="n">a_cop</span><span class="o">}</span> <span class="bp">*</span>
           <span class="o">{</span><span class="n">num</span> <span class="o">:=</span> <span class="n">b_num</span><span class="o">,</span> <span class="n">denom</span> <span class="o">:=</span> <span class="n">b_denom</span><span class="o">,</span> <span class="n">pos</span> <span class="o">:=</span> <span class="n">b_pos</span><span class="o">,</span> <span class="n">cop</span> <span class="o">:=</span> <span class="n">b_cop</span><span class="o">})</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span>
        <span class="mi">2</span> <span class="bp">^</span> <span class="bp">?</span><span class="n">m_1</span> <span class="bp">=</span>
      <span class="o">(({</span><span class="n">num</span> <span class="o">:=</span> <span class="n">a_num</span><span class="o">,</span> <span class="n">denom</span> <span class="o">:=</span> <span class="n">_a</span><span class="o">,</span> <span class="n">pos</span> <span class="o">:=</span> <span class="n">a_pos</span><span class="o">,</span> <span class="n">cop</span> <span class="o">:=</span> <span class="n">a_cop</span><span class="o">}</span> <span class="bp">*</span>
            <span class="o">{</span><span class="n">num</span> <span class="o">:=</span> <span class="n">b_num</span><span class="o">,</span> <span class="n">denom</span> <span class="o">:=</span> <span class="n">b_denom</span><span class="o">,</span> <span class="n">pos</span> <span class="o">:=</span> <span class="n">b_pos</span><span class="o">,</span> <span class="n">cop</span> <span class="o">:=</span> <span class="n">b_cop</span><span class="o">})</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span>
         <span class="mi">2</span> <span class="bp">^</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">)</span>
</code></pre></div>
<p>How do I get this rewrite to work?   </p>
<p>How do I get the multiplication to be performed/expanded out in the goal so that I get a single <code>{}</code> structure instead of <code>{} * {}</code>?</p>
<p>Once I have a single <code>{}</code> in the goal, how can I rewrite that into either multiple goals or make an assertion that the resulting structure is a rational?</p>



<a name="223069222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/223069222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#223069222">(Jan 17 2021 at 23:23)</a>:</h4>
<p>Try <code>simp_rw</code> instead of <code>rw</code>?</p>



<a name="223069813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/motive%20is%20not%20type%20correct/near/223069813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/motive.20is.20not.20type.20correct.html#223069813">(Jan 17 2021 at 23:39)</a>:</h4>
<p>When you want do do a dependent rewrite of a variable (like <code>ha : a_denom = 2 ^ n</code>) something that tends to work is <code>subst a_denom</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
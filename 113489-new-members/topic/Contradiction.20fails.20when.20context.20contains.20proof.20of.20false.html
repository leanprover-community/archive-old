---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html">Contradiction fails when context contains proof of false</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="302190439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contradiction%20fails%20when%20context%20contains%20proof%20of%20false/near/302190439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Josiah Eldon Bills <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html#302190439">(Oct 04 2022 at 04:59)</a>:</h4>
<p>I am working on a fairly complex proof where in part of the proof I get a contradiction by simplifying  using <code>x=a</code> at a hypothesis <code>not (a = x)</code>, thus yielding a term of type <code>false</code>. Normally I can just close the current goal with <code>contradiction</code>, but in this case I get an error. Below you can see my context, my goal, and the (quite unhelpful) error I get:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">contradiction</span> <span class="n">tactic</span> <span class="n">failed</span>
<span class="n">state</span><span class="o">:</span>
<span class="mi">4</span> <span class="n">goals</span>
<span class="n">case</span> <span class="n">or.inl</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">α</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">this</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)),</span> <span class="n">l.length</span> <span class="bp">&gt;</span> <span class="mi">1</span> <span class="bp">→</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="bp">.</span><span class="n">intercalate</span> <span class="o">[</span><span class="n">l.head</span><span class="o">,</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="bp">.</span><span class="n">intercalate</span> <span class="n">l.tail</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="bp">.</span><span class="n">intercalate</span> <span class="n">l</span><span class="o">,</span>
<span class="n">hd</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">tl</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span>
<span class="n">ih</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">),</span>
    <span class="n">a</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="o">(</span><span class="k">let</span> <span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">list.split_on_first</span> <span class="n">a</span> <span class="n">l</span> <span class="k">in</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">tl</span> <span class="bp">→</span> <span class="o">(</span><span class="n">list.split_on</span> <span class="n">a</span> <span class="n">tl</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">&gt;</span> <span class="mi">1</span><span class="o">),</span>
<span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span>
<span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">list.split_on_first</span> <span class="n">a</span> <span class="n">l</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span><span class="o">,</span>
<span class="n">list_contains</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span><span class="o">,</span>
<span class="n">or</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">hd</span><span class="o">,</span>
<span class="n">h_1</span> <span class="o">:</span> <span class="n">false</span>
<span class="bp">⊢</span> <span class="o">(</span><span class="k">let</span> <span class="n">or</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">hd</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">tl</span> <span class="o">:=</span> <span class="n">list.eq_or_mem_of_mem_cons</span> <span class="n">list_contains</span> <span class="k">in</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">tl</span><span class="o">)</span> <span class="o">(</span><span class="n">_root_.or.inl</span> <span class="n">or</span><span class="o">)</span>
</code></pre></div>
<p>I can post the full context if need be, but it is quite long.</p>



<a name="302191377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contradiction%20fails%20when%20context%20contains%20proof%20of%20false/near/302191377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html#302191377">(Oct 04 2022 at 05:12)</a>:</h4>
<p>Does <code>exact h_1.elim</code> work at that point?</p>



<a name="302191521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contradiction%20fails%20when%20context%20contains%20proof%20of%20false/near/302191521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html#302191521">(Oct 04 2022 at 05:14)</a>:</h4>
<p>(At least for me, a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>, even if not too minimized), would be helpful.)</p>



<a name="302191750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contradiction%20fails%20when%20context%20contains%20proof%20of%20false/near/302191750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Josiah Eldon Bills <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html#302191750">(Oct 04 2022 at 05:18)</a>:</h4>
<p>I get the following error when I try that. Similarly, if I try to use <code>exact absurd</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">infer</span> <span class="n">type</span> <span class="n">failed</span><span class="o">,</span> <span class="n">function</span> <span class="n">expected</span> <span class="n">at</span>
  <span class="o">(</span><span class="k">let</span> <span class="n">or</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">hd</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">tl</span> <span class="o">:=</span> <span class="n">list.eq_or_mem_of_mem_cons</span> <span class="n">list_contains</span> <span class="k">in</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">tl</span><span class="o">)</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">hypothesis</span><span class="o">)</span>
<span class="n">term</span>
  <span class="k">let</span> <span class="n">or</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">hd</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">tl</span> <span class="o">:=</span> <span class="n">_</span>
  <span class="k">in</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">tl</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="kt">Prop</span>
</code></pre></div>



<a name="302191930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contradiction%20fails%20when%20context%20contains%20proof%20of%20false/near/302191930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html#302191930">(Oct 04 2022 at 05:21)</a>:</h4>
<p>and also <code>refine false.elim _, </code> gives an error?</p>



<a name="302191949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contradiction%20fails%20when%20context%20contains%20proof%20of%20false/near/302191949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html#302191949">(Oct 04 2022 at 05:21)</a>:</h4>
<p>or <code>apply false.elim,</code>?</p>



<a name="302192085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contradiction%20fails%20when%20context%20contains%20proof%20of%20false/near/302192085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Josiah Eldon Bills <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html#302192085">(Oct 04 2022 at 05:23)</a>:</h4>
<p>The former gives </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">infer</span> <span class="n">type</span> <span class="n">failed</span><span class="o">,</span> <span class="n">function</span> <span class="n">expected</span> <span class="n">at</span>
  <span class="o">(</span><span class="k">let</span> <span class="n">or</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">hd</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">tl</span> <span class="o">:=</span> <span class="n">list.eq_or_mem_of_mem_cons</span> <span class="n">list_contains</span> <span class="k">in</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">tl</span><span class="o">)</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">hypothesis</span><span class="o">)</span>
<span class="n">term</span>
  <span class="k">let</span> <span class="n">or</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">hd</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">tl</span> <span class="o">:=</span> <span class="n">_</span>
  <span class="k">in</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">tl</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="kt">Prop</span>
</code></pre></div>
<p>again, while the latter gives</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">apply</span> <span class="n">tactic</span><span class="o">,</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">unify</span>
  <span class="o">(</span><span class="k">let</span> <span class="n">or</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">hd</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">tl</span> <span class="o">:=</span> <span class="n">list.eq_or_mem_of_mem_cons</span> <span class="n">list_contains</span> <span class="k">in</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">tl</span><span class="o">)</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">hypothesis</span><span class="o">)</span>
<span class="k">with</span>
  <span class="bp">?</span><span class="n">m_1</span>
</code></pre></div>



<a name="302192224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contradiction%20fails%20when%20context%20contains%20proof%20of%20false/near/302192224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Josiah Eldon Bills <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html#302192224">(Oct 04 2022 at 05:25)</a>:</h4>
<p>Here is the theorem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">list.split_on_first</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">l.split_on</span> <span class="n">a</span> <span class="k">in</span>
  <span class="o">(</span><span class="n">s.head</span><span class="o">,</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="bp">.</span><span class="n">intercalate</span> <span class="n">s.tail</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">list.split_on_first.infix</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">list.split_on_first</span> <span class="n">a</span> <span class="n">l</span> <span class="k">in</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">s.1</span> <span class="bp">++</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="bp">++</span> <span class="n">s.2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">list_contains</span> <span class="n">s</span><span class="o">,</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="bp">.</span><span class="n">intercalate</span> <span class="o">[</span><span class="n">s.1</span><span class="o">,</span> <span class="n">s.2</span><span class="o">]</span> <span class="bp">=</span> <span class="n">l</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="k">let</span> <span class="n">intercalate_append</span> <span class="o">:</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="bp">.</span><span class="n">intercalate</span> <span class="o">[</span><span class="n">s.1</span><span class="o">,</span> <span class="n">s.2</span><span class="o">]</span> <span class="bp">=</span> <span class="n">s.1</span> <span class="bp">++</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="bp">++</span> <span class="n">s.2</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">list.intercalate</span><span class="o">],</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">intercalate_append</span><span class="o">,</span>
    <span class="n">symmetry</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">this</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">),</span> <span class="n">l.length</span> <span class="bp">&gt;</span> <span class="mi">1</span> <span class="bp">→</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="bp">.</span><span class="n">intercalate</span> <span class="o">[</span><span class="n">l.head</span><span class="o">,</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="bp">.</span><span class="n">intercalate</span> <span class="n">l.tail</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="bp">.</span><span class="n">intercalate</span> <span class="n">l</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="k">suffices</span> <span class="n">split_len</span> <span class="o">:</span> <span class="o">(</span><span class="n">list.split_on</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">&gt;</span> <span class="mi">1</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">specialize</span> <span class="n">this</span> <span class="o">(</span><span class="n">list.split_on</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="n">split_len</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">list.intercalate_split_on</span> <span class="n">l</span> <span class="n">a</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">this</span>
    <span class="o">},</span>

    <span class="n">induction</span> <span class="n">h</span><span class="o">:</span> <span class="n">l</span> <span class="n">generalizing</span> <span class="n">l</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="n">at</span> <span class="n">list_contains</span><span class="o">,</span>
    <span class="n">contradiction</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.split_on</span><span class="o">,</span> <span class="n">list.split_on_p_cons</span><span class="o">],</span>
    <span class="n">split_ifs</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">list.split_on_p_ne_nil</span><span class="o">],</span>
      <span class="n">cases</span> <span class="n">th</span><span class="o">:</span> <span class="n">list.split_on_p</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">_x</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="n">tl</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">list.split_on_p_ne_nil</span><span class="o">]</span> <span class="n">at</span> <span class="n">th</span><span class="o">,</span>
      <span class="n">contradiction</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">th</span><span class="o">]</span>
    <span class="o">},</span>
    <span class="n">rw</span> <span class="n">h</span> <span class="n">at</span> <span class="n">list_contains</span><span class="o">,</span>
    <span class="k">let</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">tl</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="k">let</span> <span class="n">or</span> <span class="o">:=</span> <span class="n">list.eq_or_mem_of_mem_cons</span> <span class="n">list_contains</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">or</span> <span class="k">with</span> <span class="n">hypothesis</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">hypothesis</span><span class="o">]</span> <span class="n">at</span> <span class="n">h_1</span><span class="o">,</span>
      <span class="n">contradiction</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">h_2</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="k">let</span> <span class="n">induction</span> <span class="o">:=</span> <span class="n">ih</span> <span class="n">tl</span> <span class="n">this</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">list.split_on</span><span class="o">,</span>
    <span class="n">cases</span> <span class="o">(</span><span class="n">list.split_on</span> <span class="n">a</span> <span class="n">tl</span><span class="o">),</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="n">induction</span><span class="o">,</span>
    <span class="n">contradiction</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="n">induction</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">induction</span><span class="o">],</span>
  <span class="o">},</span>
  <span class="n">intros</span> <span class="n">lol</span> <span class="n">lol_size_2</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">lol</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">lol_size_2</span><span class="o">,</span>
  <span class="n">contradiction</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">lol_tl</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">lol_size_2</span><span class="o">,</span>
  <span class="n">contradiction</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">list.intercalate</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>
<p>The error occurs in the proof of <code>let : a ∈ tl,</code>.</p>



<a name="302192361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contradiction%20fails%20when%20context%20contains%20proof%20of%20false/near/302192361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Josiah Eldon Bills <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html#302192361">(Oct 04 2022 at 05:27)</a>:</h4>
<p>I found that if you use <code>cases dont_care: or with hypothesis,</code> then this works just fine.</p>



<a name="302192459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contradiction%20fails%20when%20context%20contains%20proof%20of%20false/near/302192459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Josiah Eldon Bills <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html#302192459">(Oct 04 2022 at 05:28)</a>:</h4>
<p>If you do this then the goal remains <code>a ∈ tl</code>, while if you don't then the goal gets a whole bunch of garbage thrown in it.</p>



<a name="302192541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contradiction%20fails%20when%20context%20contains%20proof%20of%20false/near/302192541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html#302192541">(Oct 04 2022 at 05:29)</a>:</h4>
<p>what happens if you type <code>intros</code> first?</p>



<a name="302192773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contradiction%20fails%20when%20context%20contains%20proof%20of%20false/near/302192773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html#302192773">(Oct 04 2022 at 05:32)</a>:</h4>
<p>This works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="o">{</span>
      <span class="k">have</span> <span class="n">or</span> <span class="o">:=</span> <span class="n">list.eq_or_mem_of_mem_cons</span> <span class="n">list_contains</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">or</span> <span class="k">with</span> <span class="n">hypothesis</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">hypothesis</span><span class="o">]</span> <span class="n">at</span> <span class="n">h_1</span><span class="o">,</span>
      <span class="n">contradiction</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">or</span><span class="o">,</span>
    <span class="o">},</span>
</code></pre></div>
<p>I used <code>have</code> instead of <code>let</code>.</p>



<a name="302192880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contradiction%20fails%20when%20context%20contains%20proof%20of%20false/near/302192880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html#302192880">(Oct 04 2022 at 05:33)</a>:</h4>
<p>Even though this does not seem to be causing problems, I am very skeptical about calling a variable with the name of an existing function such as <code>or</code>...</p>



<a name="302193082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contradiction%20fails%20when%20context%20contains%20proof%20of%20false/near/302193082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html#302193082">(Oct 04 2022 at 05:35)</a>:</h4>
<p>Briefly, <code>let</code> is for introducing "shorthand" notation for something, while <code>have</code> is for introducing extra hypotheses.  In your situation, I think that you used <code>let</code> to mean "let us call <code>or</code> the hypothesis <code>a = hd ∨ a ∈ tl</code>".  In Lean, this is done by using <code>have</code>, not <code>let</code>.</p>



<a name="302193224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contradiction%20fails%20when%20context%20contains%20proof%20of%20false/near/302193224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Josiah Eldon Bills <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html#302193224">(Oct 04 2022 at 05:37)</a>:</h4>
<p>The name point is well made, I will change it. It isn't the cause of the issue though. Why does this bubble down to cause issues in <code>cases</code>?</p>



<a name="302194162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contradiction%20fails%20when%20context%20contains%20proof%20of%20false/near/302194162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html#302194162">(Oct 04 2022 at 05:48)</a>:</h4>
<p>I do not know, but the <code>cases</code> on the <code>let</code> mangles the type of the target.  I am actually not sure about what the precise effect is, but Lean is not very happy with it either.</p>



<a name="302198593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contradiction%20fails%20when%20context%20contains%20proof%20of%20false/near/302198593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html#302198593">(Oct 04 2022 at 06:37)</a>:</h4>
<p>When you use <code>let</code> you are informing Lean that you will use <code>or</code> to mean whatever you say it is.  At this stage, I suspect that lean thinks that <code>or</code> is the Prop that it displays, not its proof.</p>
<p>I imagine that, to Lean, what you wrote was not very different than <code>let or := A ∨ B</code>, with <code>A B : Prop</code> completely arbitrary, with no indication that actually at least one of them is true.</p>



<a name="302205300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contradiction%20fails%20when%20context%20contains%20proof%20of%20false/near/302205300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html#302205300">(Oct 04 2022 at 07:36)</a>:</h4>
<p><code>let</code> changes the goal. It's not the correct tactic to use when defining a proof, <code>have</code> is.</p>



<a name="302206517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contradiction%20fails%20when%20context%20contains%20proof%20of%20false/near/302206517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contradiction.20fails.20when.20context.20contains.20proof.20of.20false.html#302206517">(Oct 04 2022 at 07:45)</a>:</h4>
<p>Indeed, here is a smaller version of the same issue as above:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">logic.basic</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">or1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">em</span> <span class="n">p</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">or1</span><span class="o">,</span>
  <span class="n">trivial</span><span class="o">,</span>  <span class="c1">-- fails</span>
<span class="kd">end</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/image_bUnion.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html">image_bUnion</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="222207315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222207315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222207315">(Jan 10 2021 at 05:33)</a>:</h4>
<p>Dear All,</p>
<p>I am not completely sure what <code>bUnion</code> refers to exactly, but I found myself needing the lemma below.</p>
<p>Is it already in mathlib?  I could not find it.<br>
Is the name reasonable?  I am under the impression that <code>bUnion</code> means that it is a union over elements in a type with a condition that these elements should belong to a subset of the Type, but I could be wrong!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">image_bUnion</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">f</span> <span class="bp">''</span> <span class="o">((</span><span class="bp">⋃</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="o">{</span><span class="n">i</span><span class="o">})</span> <span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">⋃</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="bp">''</span> <span class="o">{</span><span class="n">i</span><span class="o">})</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">ext</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩),</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">t</span><span class="o">,</span> <span class="o">⟨⟨</span><span class="n">bs</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">ta</span><span class="o">⟩⟩,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="n">mem_Union.mpr</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">image_singleton</span><span class="o">,</span> <span class="n">mem_Union</span><span class="o">,</span> <span class="n">mem_singleton_iff.mp</span> <span class="n">ta</span><span class="o">],</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">bs</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">d</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">b</span><span class="o">,</span> <span class="o">⟨</span><span class="n">ba</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩⟩,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">mem_singleton_iff.mp</span> <span class="n">ba</span><span class="o">,</span> <span class="n">mem_image</span><span class="o">,</span> <span class="n">bUnion_of_singleton</span><span class="o">],</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="222207410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222207410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222207410">(Jan 10 2021 at 05:36)</a>:</h4>
<p><code>bUnion</code> is "big Union", or the union of indexed sets. It would be over all the sets of a Type, if that type is <code>fintype</code>, or some <code>set</code> describing the indices. This is as far as I understand.</p>



<a name="222207464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222207464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222207464">(Jan 10 2021 at 05:38)</a>:</h4>
<p>Your lemma is about the union of singletons of elements in <code>s</code>, right?</p>



<a name="222207467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222207467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222207467">(Jan 10 2021 at 05:38)</a>:</h4>
<p>Isn't that just <code>s</code>?</p>



<a name="222207545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222207545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222207545">(Jan 10 2021 at 05:41)</a>:</h4>
<p>Thanks for the explanation on the name!  I thought that it was "bound Union", implying a restriction on the indexing variable!</p>
<p>I realize that the lemma above is not exactly what I need, either.   So, I will try to make <code>s</code> work above and to produce the lemma that I actually want!</p>
<p>Thanks for the help!</p>



<a name="222207606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222207606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222207606">(Jan 10 2021 at 05:43)</a>:</h4>
<p>Btw,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">image_bUnion</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">f</span> <span class="bp">''</span> <span class="o">((</span><span class="bp">⋃</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="o">{</span><span class="n">i</span><span class="o">})</span> <span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">⋃</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="bp">''</span> <span class="o">{</span><span class="n">i</span><span class="o">})</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">]</span>
</code></pre></div>



<a name="222207719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222207719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222207719">(Jan 10 2021 at 05:46)</a>:</h4>
<p>Your proof is much better!  I had found my proof by cleaning up after <code>tidy</code>!   For some reason, I do not like to use <code>simp</code> in my final versions, but in this case, the shortening is so significant, that it makes sense!</p>



<a name="222207784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222207784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222207784">(Jan 10 2021 at 05:48)</a>:</h4>
<p>The advice I got from PR comments was that the more "API" or "foundational" lemmas are totally OK to have proofs like "ext; simp" because there isn't much insight into the proof bodies</p>



<a name="222207788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222207788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222207788">(Jan 10 2021 at 05:49)</a>:</h4>
<p>That is, proofs that on paper or in person are like "oh that's obvious" can also have proof bodies that are like that. That way scrolling through a file, it's easy to notice that this isn't a significant result, but is truly a "lemma".</p>



<a name="222207790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222207790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222207790">(Jan 10 2021 at 05:49)</a>:</h4>
<p>Ok, I had not realized this and it does seem like a good guiding principle!  I am slowly getting the hang of what API means...</p>



<a name="222207832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222207832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222207832">(Jan 10 2021 at 05:50)</a>:</h4>
<p>Back to figuring out exactly what lemma I need and then I will look for it in mathlib!  Otherwise, I will extend this thread!</p>



<a name="222207841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222207841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222207841">(Jan 10 2021 at 05:51)</a>:</h4>
<p>Note, I found the proof by first doing <code>simp</code>, and that didn't do much, so, how do we show equality of unions? By equality of the elements, so <code>ext</code>. Then <code>ext, simp</code>. That was almost right, but in the <code>exists</code> statement in the RHS of the iff, one of the equalities was flipped compared to the LHS. So I just included <code>eq_comm</code> in the simp set here.</p>



<a name="222208003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222208003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222208003">(Jan 10 2021 at 05:56)</a>:</h4>
<p>Thanks for the details on how you found the proof!  My strategy is also to start with <code>simp</code>, try <code>tidy</code> otherwise, finish the proof (if I can!), and finally clean up to leave no inbetween <code>simp</code>.  I am still not too much onboard on giving hints to <code>simp</code>: I will try to remember about this!</p>



<a name="222209193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222209193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222209193">(Jan 10 2021 at 06:39)</a>:</h4>
<p>After the discussion, it turns out that the lemma below actually does finish my proof.  I thought that some lemma around <code>Union_of_singleton</code> could have worked, but I did not find it.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">setext</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">s</span> <span class="bp">=</span> <span class="bp">⋃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">s</span><span class="o">),</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span>
</code></pre></div>
<p>In case you want the more verbose proof, here it is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">setext</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">s</span> <span class="bp">=</span> <span class="bp">⋃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">s</span><span class="o">),</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">ext</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">xs</span><span class="o">,</span> <span class="n">mem_Union.mpr</span> <span class="o">⟨⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">⟩,</span> <span class="n">mem_singleton</span> <span class="n">x</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">⟩),</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="bp">-</span><span class="o">,</span> <span class="o">⟨⟨</span><span class="bp">-</span><span class="o">,</span> <span class="n">xs</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="o">⟨⟩⟩,</span>
  <span class="n">exact</span> <span class="n">xs</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="222209525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222209525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222209525">(Jan 10 2021 at 06:49)</a>:</h4>
<p>git grep of <code>⋃ i :</code> gives very few results</p>



<a name="222209568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222209568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222209568">(Jan 10 2021 at 06:50)</a>:</h4>
<p>So your firstlemma would be good simp lemma! You might call it this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">set.bUnion_of_singleton_of_coe</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">s</span><span class="o">),</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span>
</code></pre></div>



<a name="222209621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222209621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222209621">(Jan 10 2021 at 06:52)</a>:</h4>
<p>but this might now be no longer a <code>bUnion</code> but a <code>Union</code> instead.</p>



<a name="222209632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222209632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222209632">(Jan 10 2021 at 06:53)</a>:</h4>
<p>as one can see by the simp lemmas used in the proof, they only mention <code>Union</code>, not <code>bUnion</code>.</p>



<a name="222212939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222212939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222212939">(Jan 10 2021 at 08:49)</a>:</h4>
<p>Damiano, <code>bUnion</code> does stand for "bounded union". Did you read the <a href="https://leanprover-community.github.io/mathematics_in_lean/sets_functions_and_relations.html#sets">relevant section of MIL</a>?</p>



<a name="222213102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222213102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222213102">(Jan 10 2021 at 08:55)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span>, why the <code>of_coe</code>? What coercion is happening there?</p>



<a name="222213142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222213142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222213142">(Jan 10 2021 at 08:56)</a>:</h4>
<p>Sorry for the mistake re "bounded Union" vs "big Union", correcting up top.</p>



<a name="222213147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222213147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222213147">(Jan 10 2021 at 08:56)</a>:</h4>
<p>There is a coercion from <code>set s</code> to <code>set R</code>.</p>



<a name="222213588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222213588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222213588">(Jan 10 2021 at 09:11)</a>:</h4>
<p>Is there a lemma to convert from a union over a subtype to a union over a condition?</p>



<a name="222213643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222213643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222213643">(Jan 10 2021 at 09:12)</a>:</h4>
<p>I can't help feeling that Damiano posted a very similar problem before</p>



<a name="222215058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222215058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222215058">(Jan 10 2021 at 09:57)</a>:</h4>
<p>(deleted)</p>



<a name="222215904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222215904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222215904">(Jan 10 2021 at 10:25)</a>:</h4>
<p>Patrick, I probably had read that section, but at a time where it made much less sense than it might now.  I will brush up on it again!</p>
<p>Eric, you are right that I struggle often with sets/subtype/coercions.  I do not know if it is only me, or it is a common difficulty.</p>



<a name="222215970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222215970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222215970">(Jan 10 2021 at 10:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/image_bUnion/near/222213588">said</a>:</p>
<blockquote>
<p>Is there a lemma to convert from a union over a subtype to a union over a condition?</p>
</blockquote>
<p>Of course there is. Did you try <code>library_search</code>?</p>



<a name="222217010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222217010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222217010">(Jan 10 2021 at 10:57)</a>:</h4>
<p>No, I was sending that from mobile without access to a shell</p>



<a name="222217067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222217067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222217067">(Jan 10 2021 at 10:58)</a>:</h4>
<p>Damiano, my point was that I think a previous thread might have concluded "here is a lemma that ought to be in mathlib", but the lemma never made it.</p>



<a name="222227953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222227953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222227953">(Jan 10 2021 at 15:50)</a>:</h4>
<p>Eric, you may be right, since I have been struggling with coercions and sets also for the strand with the discrete_topology stuff and with the Liouville PR.  In any case, I have now created PR <a href="https://github.com/leanprover-community/mathlib/issues/5691">#5691</a>, which adds this <code>simp</code> lemma.  In maintaining the style of the previous result in the file, I changed the proof from</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span>
</code></pre></div>
<p>to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">ext</span> <span class="bp">$</span> <span class="kd">by</span> <span class="n">simp</span>
</code></pre></div>



<a name="222227973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222227973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222227973">(Jan 10 2021 at 15:51)</a>:</h4>
<p>I also discovered that the result <code>bUnion_of_singleton</code> (without <code>_coe</code>) exists in mathlib and is not a proof of this lemma.  However, I am not entirely sure why the two statements are not equivalent.</p>



<a name="222229633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222229633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222229633">(Jan 10 2021 at 16:32)</a>:</h4>
<p>In a similar spirit, I also created PR <a href="https://github.com/leanprover-community/mathlib/issues/5692">#5692</a>, adding another <code>bUnion</code> lemma, this time for <code>zero_loci</code>!</p>
<p>I am trying to get as much as possible of what I have on <code>is_open_map comap C</code> into mathlib, before I will have to devote more time to teaching!</p>



<a name="222281774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222281774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222281774">(Jan 11 2021 at 10:46)</a>:</h4>
<p>Here's the old thread: <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/name-hunt.3A.20Union_of_singleton.3F">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/name-hunt.3A.20Union_of_singleton.3F</a></p>



<a name="222282024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222282024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222282024">(Jan 11 2021 at 10:49)</a>:</h4>
<p>Eric: thank you very much for finding this!  It was indeed the same issue: I had forgotten that I had asked about it already!</p>
<p>How did you find it?  I feel that I am not so good at using the search feature on Zulip...</p>



<a name="222282550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/image_bUnion/near/222282550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/image_bUnion.html#222282550">(Jan 11 2021 at 10:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/image_bUnion/near/222215970">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/image_bUnion/near/222213588">said</a>:</p>
<blockquote>
<p>Is there a lemma to convert from a union over a subtype to a union over a condition?</p>
</blockquote>
<p>Of course there is. Did you try <code>library_search</code>?</p>
</blockquote>
<p>Library search found <a href="https://leanprover-community.github.io/mathlib_docs/find/set.bUnion_eq_Union">docs#set.bUnion_eq_Union</a>, which solves:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">set.Union_subtype</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⋃</span> <span class="o">(</span><span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">set.bUnion_eq_Union</span> <span class="n">s</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">_</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
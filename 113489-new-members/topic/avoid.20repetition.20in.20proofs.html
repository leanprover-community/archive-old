---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/avoid.20repetition.20in.20proofs.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/avoid.20repetition.20in.20proofs.html">avoid repetition in proofs</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="267219338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/avoid%20repetition%20in%20proofs/near/267219338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/avoid.20repetition.20in.20proofs.html#267219338">(Jan 07 2022 at 17:48)</a>:</h4>
<p>Is there an easy way to avoid repetition in the proof below? I often end up repeating myself when proving biconditionals, I wonder if there is a technique or tactic that can be used in such cases.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">noncomputable theory</span>

<span class="kd">axiom</span> <span class="n">Set</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kd">axiom</span> <span class="n">mem</span> <span class="o">:</span> <span class="n">Set</span> <span class="bp">→</span> <span class="n">Set</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">Set</span> <span class="n">Set</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">mem</span><span class="o">⟩</span>

<span class="kd">@[ext]</span> <span class="kd">axiom</span> <span class="n">extensionality</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Set</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span>
<span class="kd">axiom</span> <span class="n">pairing</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Set</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">P</span> <span class="o">:</span> <span class="n">Set</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">b</span>

<span class="kd">lemma</span> <span class="n">fst_eq_fst_of_pair_eq_pair</span> <span class="o">{</span><span class="n">a₁</span> <span class="n">a₂</span> <span class="n">b₁</span> <span class="n">b₂</span> <span class="o">:</span> <span class="n">Set</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="o">:</span> <span class="n">Set</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">w</span><span class="o">,</span> <span class="n">w</span> <span class="bp">∈</span> <span class="n">z</span> <span class="bp">↔</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">a₁</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">w</span><span class="o">,</span> <span class="n">w</span> <span class="bp">∈</span> <span class="n">z</span> <span class="bp">↔</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">a₁</span> <span class="bp">∨</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">b₁</span><span class="o">)</span> <span class="bp">↔</span>
                  <span class="o">(</span><span class="bp">∀</span> <span class="n">w</span><span class="o">,</span> <span class="n">w</span> <span class="bp">∈</span> <span class="n">z</span> <span class="bp">↔</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">a₂</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">w</span><span class="o">,</span> <span class="n">w</span> <span class="bp">∈</span> <span class="n">z</span> <span class="bp">↔</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">a₂</span> <span class="bp">∨</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">b₂</span><span class="o">))</span> <span class="o">:</span> <span class="n">a₁</span> <span class="bp">=</span> <span class="n">a₂</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">hx</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">P</span><span class="o">,</span> <span class="n">hP</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">pairing</span> <span class="n">a₂</span> <span class="n">a₂</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">or_self</span><span class="o">]</span> <span class="n">at</span> <span class="n">hP</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">h₁</span><span class="o">,</span> <span class="n">h₂</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">P</span><span class="o">,</span>
    <span class="n">clear</span> <span class="n">h</span> <span class="n">h₁</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hP</span><span class="o">]</span> <span class="n">at</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rwa</span> <span class="n">h₂</span> <span class="o">},</span>
    <span class="o">{</span> <span class="k">have</span> <span class="o">:=</span> <span class="n">h₂</span> <span class="n">a₁</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">specialize</span> <span class="n">h₂</span> <span class="n">a₂</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">at</span> <span class="n">h₂</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">h₂</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">rwa</span> <span class="n">h₂</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">substs</span> <span class="n">h₂</span><span class="o">,</span>
        <span class="n">rwa</span> <span class="bp">←</span><span class="n">this</span> <span class="o">}</span> <span class="o">}</span> <span class="o">},</span>
  <span class="c1">-- Basically the same as above...</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">P</span><span class="o">,</span> <span class="n">hP</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">pairing</span> <span class="n">a₁</span> <span class="n">a₁</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">or_self</span><span class="o">]</span> <span class="n">at</span> <span class="n">hP</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">h₁</span><span class="o">,</span> <span class="n">h₂</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">P</span><span class="o">,</span>
    <span class="n">clear</span> <span class="n">h</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hP</span><span class="o">]</span> <span class="n">at</span> <span class="n">h₁</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h₁</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rwa</span> <span class="n">h₁</span> <span class="o">},</span>
    <span class="o">{</span> <span class="k">have</span> <span class="o">:=</span> <span class="n">h₁</span> <span class="n">a₂</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">specialize</span> <span class="n">h₁</span> <span class="n">a₁</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">at</span> <span class="n">h₁</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">h₁</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">rwa</span> <span class="n">h₁</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">substs</span> <span class="n">h₁</span><span class="o">,</span>
        <span class="n">rwa</span> <span class="bp">←</span><span class="n">this</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="267221338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/avoid%20repetition%20in%20proofs/near/267221338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/avoid.20repetition.20in.20proofs.html#267221338">(Jan 07 2022 at 18:04)</a>:</h4>
<p>One thing you could try is to prove a general statement of the principle you’re using as <code>have aux_lemma : …</code> and then apply that in each of the two cases.</p>



<a name="267225952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/avoid%20repetition%20in%20proofs/near/267225952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/avoid.20repetition.20in.20proofs.html#267225952">(Jan 07 2022 at 18:43)</a>:</h4>
<p>Taking Stuart's thought a little further. If you want to avoid repeating yourself it's quite often possible the same way as we do in regular programming, if we have a function and notice we are repeating ourselves just pull out stuff into an additional function. And since proof=function this applies here as well.</p>
<p>Alternatively you could look into proof combinators such as e.g. <code>;</code> which repeats a tactic on all subgoals create by another statement (there are many more) or more heavily automated proofs.</p>



<a name="267226624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/avoid%20repetition%20in%20proofs/near/267226624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/avoid.20repetition.20in.20proofs.html#267226624">(Jan 07 2022 at 18:47)</a>:</h4>
<p>The right way to do it would be to write another lemma and cover the differences between the cases by the lemma parameters. There is also <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.wlog">docs#tactic.wlog</a> that reduces multiple subgoals to just one, if you prove that the generality is not lost.</p>
<p>BTW, in this particular case, <code>finish</code> seems to be smart enough to prove it automatically:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">fst_eq_fst_of_pair_eq_pair</span> <span class="o">{</span><span class="n">a₁</span> <span class="n">a₂</span> <span class="n">b₁</span> <span class="n">b₂</span> <span class="o">:</span> <span class="n">Set</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="o">:</span> <span class="n">Set</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">w</span><span class="o">,</span> <span class="n">w</span> <span class="bp">∈</span> <span class="n">z</span> <span class="bp">↔</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">a₁</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">w</span><span class="o">,</span> <span class="n">w</span> <span class="bp">∈</span> <span class="n">z</span> <span class="bp">↔</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">a₁</span> <span class="bp">∨</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">b₁</span><span class="o">)</span> <span class="bp">↔</span>
                  <span class="o">(</span><span class="bp">∀</span> <span class="n">w</span><span class="o">,</span> <span class="n">w</span> <span class="bp">∈</span> <span class="n">z</span> <span class="bp">↔</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">a₂</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">w</span><span class="o">,</span> <span class="n">w</span> <span class="bp">∈</span> <span class="n">z</span> <span class="bp">↔</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">a₂</span> <span class="bp">∨</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">b₂</span><span class="o">))</span> <span class="o">:</span> <span class="n">a₁</span> <span class="bp">=</span> <span class="n">a₂</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">s₁</span><span class="o">,</span> <span class="n">h₁</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">pairing</span> <span class="n">a₁</span> <span class="n">a₁</span><span class="o">,</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">s₂</span><span class="o">,</span> <span class="n">h₂</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">pairing</span> <span class="n">a₂</span> <span class="n">a₂</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₃</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">s₁</span><span class="o">,</span> <span class="k">have</span> <span class="n">h₄</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">s₂</span><span class="o">,</span> <span class="n">finish</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="267227924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/avoid%20repetition%20in%20proofs/near/267227924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/avoid.20repetition.20in.20proofs.html#267227924">(Jan 07 2022 at 18:57)</a>:</h4>
<p>Sometimes it makes sense to pull out a separate lemma, but if you're planning to PR something to mathlib you should consider whether that lemma is something that will be used more generally or if it's only of interest for this one specific proof.  In the latter case you should perhaps just inline it.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
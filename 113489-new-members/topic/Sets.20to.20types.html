---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Sets.20to.20types.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html">Sets to types</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="197717390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197717390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197717390">(May 15 2020 at 16:32)</a>:</h4>
<p>I'm struggling to translate basic set theory constructs into type theory. I'm trying to define <code>disjoint</code> but I believe in type theory all terms only belong to a single type, so generically if I have two types A and B, every a : A is not a term of B, hence they are disjoint in some sort of trivial way.  I guess I want to define disjoint using equality? disjoint A B is true if  forall a : A, there does not exist  b : B such that a = b ?</p>



<a name="197717530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197717530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197717530">(May 15 2020 at 16:32)</a>:</h4>
<p>disjoint doesn't make sense as a concept in types</p>



<a name="197717648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197717648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197717648">(May 15 2020 at 16:33)</a>:</h4>
<p>when this happens you should <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> analyze the question</p>



<a name="197717762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197717762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197717762">(May 15 2020 at 16:34)</a>:</h4>
<p>what caused you to want the ability to say this?</p>



<a name="197717963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197717963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197717963">(May 15 2020 at 16:35)</a>:</h4>
<p>I'm just trying to do basic set theory stuff in Lean but was told to not use the set  type but now I dont know how to proceed</p>



<a name="197718052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197718052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197718052">(May 15 2020 at 16:35)</a>:</h4>
<p>that's not <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> enough. What are you trying to do and why</p>



<a name="197718218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197718218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197718218">(May 15 2020 at 16:36)</a>:</h4>
<p>if it's just set theory for the sake of set theory, first see whether <code>set A</code> is a better setting, and then ask whether it is needed at all</p>



<a name="197718701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197718701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197718701">(May 15 2020 at 16:39)</a>:</h4>
<p><a href="#narrow/stream/236446-Type-theory/topic/Math.20on.20lists/near/197718432">https://leanprover.zulipchat.com/#narrow/stream/236446-Type-theory/topic/Math.20on.20lists/near/197718432</a></p>



<a name="197718709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197718709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197718709">(May 15 2020 at 16:39)</a>:</h4>
<p>I guess I just need to skip these pages. I think I can understand how an equivalence relation can be defined type theoretically quite analogously to the set way. But since things like disjointedness dont make sense, I just shouldnt think in those terms. I can move on and get to defining a group</p>



<a name="197718844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197718844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197718844">(May 15 2020 at 16:40)</a>:</h4>
<p>A bare type behaves exactly in the same way as a set, except that its "elements" are terms (not types, so they don't have elements themselves).</p>



<a name="197718991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197718991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197718991">(May 15 2020 at 16:41)</a>:</h4>
<p>My goal was to do this exercise in Algebra: Chapter 0: Prove that if <code>~</code> is an equivalence relation on a set <code>S</code>, then the corresponding set of equivalence classes is a partition of the set <code>S</code>, i.e. that its elements are nonempty, disjoint and their union is <code>S</code></p>



<a name="197719072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197719072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197719072">(May 15 2020 at 16:42)</a>:</h4>
<p>So in fact when you learnt equivalence relations in set theory, you took elements <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">a,b\in X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> and asked if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∼</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\sim b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>. But you never asked what <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∩</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\cap b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> was, even though this strictly speaking makes sense because at the end of the day, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> <em>are actually sets</em>. Because you never used this extra setty functionality for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> and instead just treated them like "atoms" or "terms", this is why it all goes through immediately in type theory.</p>



<a name="197719098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197719098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197719098">(May 15 2020 at 16:42)</a>:</h4>
<p>A relation on a set S is a function S -&gt; S -&gt; Prop. It is not a type</p>



<a name="197719143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197719143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197719143">(May 15 2020 at 16:43)</a>:</h4>
<p>That exercise is a joy to do in Lean. Shall we just do it now together?</p>



<a name="197719180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197719180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197719180">(May 15 2020 at 16:43)</a>:</h4>
<p>Hah yes please</p>



<a name="197719182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197719182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197719182">(May 15 2020 at 16:43)</a>:</h4>
<p>It is therefore meaningful to talk about disjointness of equivalence classes (which are S -&gt; Prop, aka <code>set S</code>)</p>



<a name="197719259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197719259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197719259">(May 15 2020 at 16:43)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span>

<span class="c">/-</span><span class="cm"></span>

<span class="cm">data.equiv.basic  is the import which gives you the type `equiv X Y`, the type of</span>
<span class="cm">bijections from X to Y.</span>

<span class="cm">Here&#39;s the definition of equiv from that file.</span>

<span class="cm">structure equiv (α : Sort*) (β : Sort*) :=</span>
<span class="cm">(to_fun    : α → β)</span>
<span class="cm">(inv_fun   : β → α)</span>
<span class="cm">(left_inv  : left_inverse inv_fun to_fun)</span>
<span class="cm">(right_inv : right_inverse inv_fun to_fun)</span>

<span class="cm">To make a term of type `equiv α β` you have to supply a function α → β,</span>
<span class="cm">a function β → α, and proofs that both composites are the identity function.</span>

<span class="cm">Let&#39;s see how to create the bijection ℤ → ℤ sending x to -x.</span>
<span class="cm">-/</span>
<span class="c1">-- let&#39;s prove that x ↦ -x can be extended to</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">equiv</span> <span class="bp">ℤ</span> <span class="bp">ℤ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">-</span><span class="n">x</span><span class="o">,</span> <span class="c1">-- this is data</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">-</span><span class="n">x</span><span class="o">,</span>  <span class="c1">-- this is data</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="k">begin</span> <span class="c1">-- this is a proof</span>
    <span class="n">change</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="bp">-</span> <span class="bp">-</span><span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span> <span class="c1">-- that&#39;s the question</span>
    <span class="n">exact</span> <span class="n">neg_neg</span><span class="o">,</span> <span class="c1">-- note: I guessed what this function was called.</span>
                   <span class="c1">-- If it had been called &quot;lemma 12&quot; I would not have been able to guess</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="n">neg_neg</span> <span class="c1">-- another proof, this time in term mode</span>
<span class="o">}</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Q1 Define the type of partitions of a type.</span>
<span class="cm">A partition of X is a set of subsets of X with the property that each subset</span>
<span class="cm">is non-empty and each element of X is in precisely one of the subsets.</span>
<span class="cm">NB : this is one of the harder questions here.</span>
<span class="cm">-/</span>

<span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span><span class="bp">.</span> <span class="c1">-- remove `.`  and fill in -- look at def of equiv above</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Equivalence relations are in core Lean -- we don&#39;t need any imports.</span>
<span class="cm">Here&#39;s an example: I&#39;ll prove that the &quot;always true&quot; relation on a set is</span>
<span class="cm">an equivalence relation.</span>

<span class="cm">-/</span>

<span class="n">def</span> <span class="n">always_true</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">true</span>

<span class="c1">-- and now here&#39;s the proof that it&#39;s an equivalence relation.</span>

<span class="kn">theorem</span> <span class="n">always_true_refl</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">reflexive</span> <span class="o">(</span><span class="n">always_true</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">trivial</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">always_true_symm</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="o">(</span><span class="n">always_true</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">trivial</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">always_true_trans</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">transitive</span> <span class="o">(</span><span class="n">always_true</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">Hab</span> <span class="n">Hbc</span><span class="o">,</span>
  <span class="n">trivial</span>
<span class="kn">end</span>

<span class="c1">-- note pointy brackets to make a term of type &quot;A ∧ B ∧ C&quot;</span>
<span class="kn">theorem</span> <span class="n">always_true_equiv</span> <span class="o">(</span><span class="n">X</span><span class="o">):</span> <span class="n">equivalence</span> <span class="o">(</span><span class="n">always_true</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">always_true_refl</span> <span class="n">X</span><span class="o">,</span> <span class="n">always_true_symm</span> <span class="n">X</span><span class="o">,</span> <span class="n">always_true_trans</span> <span class="n">X</span><span class="bp">⟩</span>
<span class="c1">-- autocomplete made that proof really easy to type. It&#39;s really</span>
<span class="c1">-- lucky that I didn&#39;t call these lemmas lemma 12, lemma 13 and lemma 14.</span>

<span class="c1">-- if X is a type, then `setoid X` is is the type of equivalence relations on X.</span>
<span class="c1">-- I&#39;ll now make a term of type `setoid X` corresponding to that equivalence</span>
<span class="c1">-- relation above.</span>

<span class="c1">-- note squiggly brackets and commas at the end of each definition to make a structure</span>
<span class="n">def</span> <span class="n">always_true_setoid</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">always_true</span> <span class="n">X</span><span class="o">,</span>
  <span class="n">iseqv</span> <span class="o">:=</span> <span class="n">always_true_equiv</span> <span class="n">X</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Q2 : If X is a type then `setoid X` is the type of equivalence relations on X,</span>
<span class="cm">and `partitions X` is the type of partitions of X. These two concepts are in</span>
<span class="cm">some sort of &quot;canonical&quot; bijection with each other (interesting exercise: make</span>
<span class="cm">this statement mathematically meaningful -- I know we all say it, but what</span>
<span class="cm">does it *mean*?).</span>

<span class="cm">Let&#39;s prove that these sets biject with each other by defining</span>
<span class="cm">a term of type equiv (setoid X) (partitions X)</span>
<span class="cm">-/</span>

<span class="kn">variable</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="n">def</span> <span class="n">F</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Q3 : now define a map the other way</span>
<span class="cm">-/</span>

<span class="n">def</span> <span class="n">G</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Q4 : now finally prove that the composite of maps in both directions</span>
<span class="cm">is the identity</span>
<span class="cm">-/</span>

<span class="kn">theorem</span> <span class="n">FG_eq_id</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span> <span class="o">(</span><span class="n">G</span> <span class="n">P</span><span class="o">)</span> <span class="bp">=</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">theorem</span> <span class="n">GF_eq_id</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">G</span> <span class="o">(</span><span class="n">F</span> <span class="n">S</span><span class="o">)</span> <span class="bp">=</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Q5 : now finally construct the term we seek.</span>
<span class="cm">-/</span>

<span class="n">def</span> <span class="n">partitions_biject_with_equivalence_relations</span> <span class="o">:</span>
  <span class="n">equiv</span> <span class="o">(</span><span class="n">setoid</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">partition</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="197719319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197719319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197719319">(May 15 2020 at 16:44)</a>:</h4>
<p>Your move <span class="user-mention" data-user-id="243102">@Brandon Brown</span></p>



<a name="197719418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197719418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197719418">(May 15 2020 at 16:45)</a>:</h4>
<p>Kevin it seems you have played this game before</p>



<a name="197719692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197719692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197719692">(May 15 2020 at 16:47)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">ℱ</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">))</span>
<span class="o">(</span><span class="n">disjoint</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℱ</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">A</span> <span class="err">∩</span> <span class="n">B</span> <span class="bp">=</span> <span class="err">∅</span><span class="o">)</span>
<span class="o">(</span><span class="n">cover</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℱ</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">A</span><span class="o">)</span>
<span class="o">(</span><span class="n">nonempty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℱ</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="err">∅</span><span class="o">)</span>
</code></pre></div>



<a name="197720245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197720245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197720245">(May 15 2020 at 16:51)</a>:</h4>
<p><code>set</code> is a function from <code>Type u \to Type u</code>, that's what someone was telling me earlier that <code>set</code> is a subset?</p>



<a name="197720324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197720324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197720324">(May 15 2020 at 16:51)</a>:</h4>
<p><code>set X</code> is the type of subsets of <code>X</code>.</p>



<a name="197720358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197720358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197720358">(May 15 2020 at 16:51)</a>:</h4>
<p>A term of type <code>set X</code> should be thought of as a subset of <code>X</code>.</p>



<a name="197720401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197720401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197720401">(May 15 2020 at 16:52)</a>:</h4>
<p>Don't worry about how it's implemented.</p>



<a name="197720449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197720449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197720449">(May 15 2020 at 16:52)</a>:</h4>
<p>ok</p>



<a name="197720491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197720491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197720491">(May 15 2020 at 16:52)</a>:</h4>
<p>If <code>x : X</code> and <code>S : set X</code> then <code>x ∈ S</code> makes sense and is a Proposition, i.e. a true/false statement.</p>



<a name="197720561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197720561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197720561">(May 15 2020 at 16:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/Sets.20to.20types/near/197719418">said</a>:</p>
<blockquote>
<p>Kevin it seems you have played this game before</p>
</blockquote>
<p>It's some partly-written teaching material.</p>



<a name="197721799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197721799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197721799">(May 15 2020 at 17:02)</a>:</h4>
<p>Why is <code>def F (S : setoid X) : partition X := sorry</code> giving me an error of "type expected at partition X".  An equivalence relation on X implies a partition on X. The def makes sense in english</p>



<a name="197722675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197722675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197722675">(May 15 2020 at 17:09)</a>:</h4>
<p>It makes sense to me too, so it must be for some reason we cannot see.</p>



<a name="197723162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197723162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197723162">(May 15 2020 at 17:13)</a>:</h4>
<p>I'm reviewing how structures work</p>



<a name="197723806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197723806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197723806">(May 15 2020 at 17:18)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span>

<span class="c">/-</span><span class="cm"></span>

<span class="cm">data.equiv.basic  is the import which gives you the type `equiv X Y`, the type of</span>
<span class="cm">bijections from X to Y.</span>

<span class="cm">Here&#39;s the definition of equiv from that file.</span>

<span class="cm">structure equiv (α : Sort*) (β : Sort*) :=</span>
<span class="cm">(to_fun    : α → β)</span>
<span class="cm">(inv_fun   : β → α)</span>
<span class="cm">(left_inv  : left_inverse inv_fun to_fun)</span>
<span class="cm">(right_inv : right_inverse inv_fun to_fun)</span>

<span class="cm">To make a term of type `equiv α β` you have to supply a function α → β,</span>
<span class="cm">a function β → α, and proofs that both composites are the identity function.</span>

<span class="cm">Let&#39;s see how to create the bijection ℤ → ℤ sending x to -x.</span>
<span class="cm">-/</span>
<span class="c1">-- let&#39;s prove that x ↦ -x can be extended to</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">equiv</span> <span class="bp">ℤ</span> <span class="bp">ℤ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">-</span><span class="n">x</span><span class="o">,</span> <span class="c1">-- this is data</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">-</span><span class="n">x</span><span class="o">,</span>  <span class="c1">-- this is data</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="k">begin</span> <span class="c1">-- this is a proof</span>
    <span class="n">change</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="bp">-</span> <span class="bp">-</span><span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span> <span class="c1">-- that&#39;s the question</span>
    <span class="n">exact</span> <span class="n">neg_neg</span><span class="o">,</span> <span class="c1">-- note: I guessed what this function was called.</span>
                   <span class="c1">-- If it had been called &quot;lemma 12&quot; I would not have been able to guess</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="n">neg_neg</span> <span class="c1">-- another proof, this time in term mode</span>
<span class="o">}</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Q1 Define the type of partitions of a type.</span>
<span class="cm">A partition of X is a set of subsets of X with the property that each subset</span>
<span class="cm">is non-empty and each element of X is in precisely one of the subsets.</span>
<span class="cm">NB : this is one of the harder questions here.</span>
<span class="cm">-/</span>

<span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">ℱ</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">))</span>
<span class="o">(</span><span class="n">disjoint</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℱ</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">A</span> <span class="err">∩</span> <span class="n">B</span> <span class="bp">=</span> <span class="err">∅</span><span class="o">)</span>
<span class="o">(</span><span class="n">cover</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℱ</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">A</span><span class="o">)</span>
<span class="o">(</span><span class="n">nonempty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℱ</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="err">∅</span><span class="o">)</span>


<span class="c">/-</span><span class="cm"></span>
<span class="cm">Equivalence relations are in core Lean -- we don&#39;t need any imports.</span>
<span class="cm">Here&#39;s an example: I&#39;ll prove that the &quot;always true&quot; relation on a set is</span>
<span class="cm">an equivalence relation.</span>

<span class="cm">-/</span>

<span class="n">def</span> <span class="n">always_true</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">true</span>

<span class="c1">-- and now here&#39;s the proof that it&#39;s an equivalence relation.</span>

<span class="kn">theorem</span> <span class="n">always_true_refl</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">reflexive</span> <span class="o">(</span><span class="n">always_true</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">trivial</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">always_true_symm</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="o">(</span><span class="n">always_true</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">trivial</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">always_true_trans</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">transitive</span> <span class="o">(</span><span class="n">always_true</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">Hab</span> <span class="n">Hbc</span><span class="o">,</span>
  <span class="n">trivial</span>
<span class="kn">end</span>

<span class="c1">-- note pointy brackets to make a term of type &quot;A ∧ B ∧ C&quot;</span>
<span class="kn">theorem</span> <span class="n">always_true_equiv</span> <span class="o">(</span><span class="n">X</span><span class="o">):</span> <span class="n">equivalence</span> <span class="o">(</span><span class="n">always_true</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">always_true_refl</span> <span class="n">X</span><span class="o">,</span> <span class="n">always_true_symm</span> <span class="n">X</span><span class="o">,</span> <span class="n">always_true_trans</span> <span class="n">X</span><span class="bp">⟩</span>
<span class="c1">-- autocomplete made that proof really easy to type. It&#39;s really</span>
<span class="c1">-- lucky that I didn&#39;t call these lemmas lemma 12, lemma 13 and lemma 14.</span>

<span class="c1">-- if X is a type, then `setoid X` is is the type of equivalence relations on X.</span>
<span class="c1">-- I&#39;ll now make a term of type `setoid X` corresponding to that equivalence</span>
<span class="c1">-- relation above.</span>

<span class="c1">-- note squiggly brackets and commas at the end of each definition to make a structure</span>
<span class="n">def</span> <span class="n">always_true_setoid</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">always_true</span> <span class="n">X</span><span class="o">,</span>
  <span class="n">iseqv</span> <span class="o">:=</span> <span class="n">always_true_equiv</span> <span class="n">X</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Q2 : If X is a type then `setoid X` is the type of equivalence relations on X,</span>
<span class="cm">and `partitions X` is the type of partitions of X. These two concepts are in</span>
<span class="cm">some sort of &quot;canonical&quot; bijection with each other (interesting exercise: make</span>
<span class="cm">this statement mathematically meaningful -- I know we all say it, but what</span>
<span class="cm">does it *mean*?).</span>

<span class="cm">Let&#39;s prove that these sets biject with each other by defining</span>
<span class="cm">a term of type equiv (setoid X) (partitions X)</span>
<span class="cm">-/</span>

<span class="kn">variable</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="n">def</span> <span class="n">F</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Q3 : now define a map the other way</span>
<span class="cm">-/</span>

<span class="n">def</span> <span class="n">G</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Q4 : now finally prove that the composite of maps in both directions</span>
<span class="cm">is the identity</span>
<span class="cm">-/</span>

<span class="kn">theorem</span> <span class="n">FG_eq_id</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span> <span class="o">(</span><span class="n">G</span> <span class="n">P</span><span class="o">)</span> <span class="bp">=</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">theorem</span> <span class="n">GF_eq_id</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">G</span> <span class="o">(</span><span class="n">F</span> <span class="n">S</span><span class="o">)</span> <span class="bp">=</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Q5 : now finally construct the term we seek.</span>
<span class="cm">-/</span>

<span class="n">def</span> <span class="n">partitions_biject_with_equivalence_relations</span> <span class="o">:</span>
  <span class="n">equiv</span> <span class="o">(</span><span class="n">setoid</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">partition</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>


<p>This file works for me.</p>



<a name="197724104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197724104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197724104">(May 15 2020 at 17:20)</a>:</h4>
<p>If that exact file is giving you errors then update your Lean and mathlib.</p>



<a name="197724266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197724266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197724266">(May 15 2020 at 17:22)</a>:</h4>
<p>Okay it's working now. I must have accidentally messed something up</p>



<a name="197724348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197724348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197724348">(May 15 2020 at 17:22)</a>:</h4>
<p>Feel free to write the official solutions; I don't seem to have written them down.</p>



<a name="197724582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/197724582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#197724582">(May 15 2020 at 17:24)</a>:</h4>
<p>I have official solutions for a completely different teaching file on the same material, with far fewer comments. If you've played the natural number game and you know how to make a term whose type is a structure (hint: write <code>:= {! !}</code> and then click on the light bulb and select the bottom but one option, assuming some mathlib is imported).</p>



<a name="199301305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/199301305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#199301305">(May 31 2020 at 10:58)</a>:</h4>
<p>I had to go through the natural number game first before attempting this. I have some unsightly proofs of G and F. Still working on proving they compose to identity.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">setoid</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">open</span> <span class="n">set</span>
<span class="kn">open</span> <span class="n">setoid</span>

<span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">))</span>
<span class="o">(</span><span class="n">disjoint</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">F</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">A</span> <span class="err">∩</span> <span class="n">B</span> <span class="bp">=</span> <span class="err">∅</span><span class="o">)</span>
<span class="o">(</span><span class="n">cover</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">F</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">A</span><span class="o">)</span>
<span class="o">(</span><span class="n">nonempty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">F</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="err">∅</span><span class="o">)</span>

<span class="n">def</span> <span class="n">F</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">X</span> <span class="o">:=</span>
<span class="n">partition</span><span class="bp">.</span><span class="n">mk</span>
<span class="o">(</span>
     <span class="n">classes</span> <span class="n">S</span>
<span class="o">)</span>
<span class="o">(</span> <span class="c1">-- ⊢ (disjoint : ∀ A B ∈ ℱ, A ≠ B → A ∩ B = ∅)</span>
  <span class="k">begin</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">eq_of_subset_of_subset</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">intros</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mem_empty_eq</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">a_1</span><span class="o">,</span>
      <span class="c1">--have F : set (set X), from classes S,</span>
      <span class="n">apply</span> <span class="n">eq_of_mem_classes</span><span class="o">,</span>
      <span class="n">repeat</span> <span class="o">{</span><span class="n">assumption</span><span class="o">},</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">apply</span> <span class="n">set</span><span class="bp">.</span><span class="n">empty_subset</span><span class="o">,</span>
    <span class="o">}</span>
  <span class="kn">end</span>
<span class="o">)</span>
<span class="o">(</span> <span class="c1">-- ⊢ (cover : ∀ x : X, ∃ A ∈ ℱ, x ∈ A)</span>
  <span class="k">begin</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="kn">end</span>
<span class="o">)</span>
<span class="o">(</span> <span class="c1">-- ⊢ (nonempty : ∀ A ∈ ℱ, A ≠ ∅)</span>
  <span class="k">begin</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">aqn</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">empty_not_mem_classes</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="err">←</span> <span class="n">aqn</span><span class="o">,</span>
  <span class="kn">end</span>
<span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">F</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Q3 : now define a map the other way</span>
<span class="cm">-/</span>

<span class="n">def</span> <span class="n">G</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">X</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">setoid</span><span class="bp">.</span><span class="n">setoid_of_disjoint_union</span><span class="o">,</span>
    <span class="n">swap</span> <span class="mi">3</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">P</span><span class="bp">.</span><span class="n">F</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">eq_of_subset_of_subset</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">p1</span><span class="o">,</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">trivial</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">p1</span><span class="o">,</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">P</span><span class="bp">.</span><span class="n">cover</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">set</span><span class="bp">.</span><span class="n">pairwise_disjoint</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">set</span><span class="bp">.</span><span class="n">pairwise_on</span><span class="o">,</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">disjoint</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">z</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∩</span> <span class="n">y</span> <span class="bp">=</span> <span class="err">∅</span><span class="o">,</span> <span class="n">apply</span> <span class="n">P</span><span class="bp">.</span><span class="n">disjoint</span><span class="o">,</span>
    <span class="n">repeat</span> <span class="o">{</span><span class="n">assumption</span><span class="o">},</span>
    <span class="n">finish</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="199312262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/199312262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#199312262">(May 31 2020 at 16:38)</a>:</h4>
<p>Oh thanks! You'll need two proofs of course, one for each round trip. Then you're done</p>



<a name="199312275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/199312275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#199312275">(May 31 2020 at 16:39)</a>:</h4>
<p>You should probably be using structure notation to make these structures though. I am busy with real life right now unfortunately</p>



<a name="200744431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/200744431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#200744431">(Jun 13 2020 at 02:18)</a>:</h4>
<p>You made a partition structure as follows</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">))</span>
<span class="o">(</span><span class="n">disjoint</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">F</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">A</span> <span class="err">∩</span> <span class="n">B</span> <span class="bp">=</span> <span class="err">∅</span><span class="o">)</span>
<span class="o">(</span><span class="n">cover</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">F</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">A</span><span class="o">)</span>
<span class="o">(</span><span class="n">nonempty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">F</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="err">∅</span><span class="o">)</span>
</code></pre></div>


<p>To prove two partitions are equal, I assume I have to make my own <code>.ext</code> definition?</p>



<a name="200744468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/200744468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#200744468">(Jun 13 2020 at 02:19)</a>:</h4>
<p>It'll be a lemma, but yeah.</p>



<a name="200745239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/200745239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#200745239">(Jun 13 2020 at 02:41)</a>:</h4>
<p>Back in 2018, I wrote some code on partitions (with a lot of help from folks here, especially Simon Hudon, see e.g. <a href="#narrow/stream/113488-general/topic/tutorial">this thread</a>) in a "tutorials" branch: <a href="https://github.com/leanprover-fork/mathlib-backup/blob/tutorials/tutorials/partitions.lean">https://github.com/leanprover-fork/mathlib-backup/blob/tutorials/tutorials/partitions.lean</a></p>
<p>I think some of the code eventually made it in to <code>data.setoid.partition</code> but not the <code>partition</code> structure. The code was written when I knew a lot less about Lean, so there are probably lots of things which are done poorly. Nonetheless, I tried to write a lot of comments, so you might find it interesting.</p>
<p>It's based on a very old version of mathlib (using the now-ancient Lean 3.4.1!) but <code>leanproject</code> and <code>elan</code> should make it fairly easy to get it up and running (modulo some compiling time):</p>
<div class="codehilite"><pre><span></span><code>leanproject get https://github.com/leanprover-fork/mathlib-backup:tutorials
<span class="nb">cd</span> mathlib-backup_tutorials
<span class="c1"># this is a version of mathlib from before we started uploading oleans to the cloud,</span>
<span class="c1"># so unfortunately you&#39;ll have to do some compiling yourself</span>
lean --make tutorials/partitions.lean
</code></pre></div>


<p>Then you can open up <code>mathlib-backup_tutorials/</code> in VS Code and then look at <code>tutorials/partitions.lean</code>.</p>



<a name="200745472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/200745472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#200745472">(Jun 13 2020 at 02:48)</a>:</h4>
<p>very helpful, thank you!</p>



<a name="200749228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sets%20to%20types/near/200749228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sets.20to.20types.html#200749228">(Jun 13 2020 at 04:49)</a>:</h4>
<p>Actually, you can just write <code>@[ext]</code> immediately before the structure, and you'll get an automatically generated <code>ext</code> lemma. It may not be the one you actually want.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
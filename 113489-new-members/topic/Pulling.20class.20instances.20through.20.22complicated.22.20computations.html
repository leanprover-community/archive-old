---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html">Pulling class instances through "complicated" computations</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="172748298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172748298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Spencer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172748298">(Aug 08 2019 at 08:43)</a>:</h4>
<p>Good morning all.</p>
<p>I wonder if anyone could help me understand how best to tackle the following.  In a nutshell, I am performing some computations on types (taking quotients of submodules) and lean is struggling to find an instance I need for the result (that a quotient of a submodule is indeed a module).</p>
<p>Here is my minimal code.  Mathematically I am defining a filtration of a module, and then finding its subquotients.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">list</span>

<span class="n">universes</span> <span class="n">U₁</span> <span class="n">U₂</span>

<span class="kn">namespace</span> <span class="n">list</span>
  <span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">U₁</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">U₂</span><span class="o">}</span>
  <span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span>

  <span class="c1">-- Much like head,</span>
  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">head&#39;&#39;</span><span class="o">:</span> <span class="bp">Π</span>  <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">),</span> <span class="n">L</span> <span class="bp">≠</span> <span class="o">[]</span> <span class="bp">→</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="o">[]</span>        <span class="n">h</span> <span class="o">:=</span> <span class="n">absurd</span> <span class="n">rfl</span> <span class="n">h</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="bp">::</span> <span class="n">xs</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">x</span>

  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
  <span class="kn">lemma</span> <span class="n">chain&#39;_desc_left</span> <span class="o">:</span> <span class="n">chain&#39;</span> <span class="n">R</span> <span class="o">(</span><span class="n">x</span> <span class="bp">::</span> <span class="n">L</span><span class="o">)</span> <span class="bp">→</span> <span class="n">chain&#39;</span> <span class="n">R</span> <span class="n">L</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">cases</span> <span class="n">L</span><span class="bp">;</span> <span class="n">simp</span><span class="o">[</span><span class="n">chain&#39;</span><span class="o">]</span>

  <span class="n">def</span> <span class="n">chain&#39;_apply_between</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span><span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="n">R</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">),</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;</span> <span class="n">R</span> <span class="n">L</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">β</span>
  <span class="bp">|</span> <span class="o">[]</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="bp">::</span> <span class="n">y</span> <span class="bp">::</span> <span class="n">xs</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">(</span><span class="n">rel_of_chain_cons</span> <span class="n">h</span><span class="o">))</span> <span class="bp">::</span>
                       <span class="o">(</span><span class="n">chain&#39;_apply_between</span> <span class="o">(</span><span class="n">y</span> <span class="bp">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="n">chain&#39;_desc_left</span> <span class="n">h</span><span class="o">)</span> <span class="o">)</span>

<span class="kn">end</span> <span class="n">list</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="n">class</span> <span class="n">filtration</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">mods</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span>
  <span class="o">(</span><span class="n">is_fil</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;</span> <span class="o">(</span><span class="n">has_le</span><span class="bp">.</span><span class="n">le</span><span class="o">)</span> <span class="n">mods</span><span class="o">)</span>

<span class="n">def</span> <span class="n">mk_quotient</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">))</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">≤</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="n">submodule</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">((</span><span class="n">submodule</span><span class="bp">.</span><span class="n">map_subtype</span><span class="bp">.</span><span class="n">order_iso</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">l</span><span class="bp">⟩</span><span class="o">)</span>


<span class="n">def</span> <span class="n">factors</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filtration</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;_apply_between</span> <span class="o">(</span><span class="n">mk_quotient</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="n">F</span><span class="bp">.</span><span class="n">mods</span> <span class="n">F</span><span class="bp">.</span><span class="n">is_fil</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filtration</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span> <span class="bp">≠</span> <span class="o">[])</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">M</span>                                          <span class="c">/-</span><span class="cm"> M : Type -/</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">((</span><span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">head&#39;&#39;</span> <span class="n">h</span><span class="o">)</span>                 <span class="c">/-</span><span class="cm"> list.head&#39;&#39; (factors R M F) h : Type -/</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">neg_smul</span> <span class="n">R</span> <span class="n">M</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span>                        <span class="c">/-</span><span class="cm"> neg_smul : ∀ (r : R) (x : M), -r • x = -(r • x) -/</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">neg_smul</span> <span class="n">R</span> <span class="o">((</span><span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">head&#39;&#39;</span> <span class="n">h</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span>
</pre></div>


<p>The last line fails, </p>
<div class="codehilite"><pre><span></span>failed to synthesize type class instance for
R : Type,
_inst_1 : ring R,
M : Type,
_inst_2 : add_comm_group M,
_inst_3 : module R M,
F : filtration R M,
h : factors R M F ≠ list.nil
⊢ add_comm_group (list.head&#39;&#39; (factors R M F) h)
</pre></div>


<p>Now, there is an instance defined in mathlib for <code>instance : add_comm_group (quotient p) </code>, which, once you unpack <code>head''</code> and <code>chain'_apply_between</code> is really what we are looking at.</p>
<p>How would be the best way to help lean find this instance?  I have two ideas: either a bunch of lemmas that carry the instances over each step or bundling the type with its instance data (in a similar manner to <code>submodule</code>) so that it is all in one place.  Are either of these good lean practice?</p>
<p>Hope I am not missing something obvious and stupid!</p>



<a name="172749428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172749428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172749428">(Aug 08 2019 at 09:03)</a>:</h4>
<p>I would first point out that your use of <code>list Type</code> is rather unidiomatic and can lead to this kind of issues</p>



<a name="172749499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172749499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172749499">(Aug 08 2019 at 09:04)</a>:</h4>
<p>It's almost useless to have a <code>list Type</code> because you don't know where the types came from so you don't know what structure they carry (like add_comm_group structure here)</p>



<a name="172749538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172749538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172749538">(Aug 08 2019 at 09:05)</a>:</h4>
<p>and you can't use the usual list lemmas because that leads to an equality of types which is problematic (aka "evil")</p>



<a name="172750025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172750025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172750025">(Aug 08 2019 at 09:14)</a>:</h4>
<p>One possibility is to use <code>fin n -&gt; Type</code> instead, which has better characteristics. But you need to know <code>n</code>, which here is something like <code>mods.length - 1</code> which is not so nice, especially in a rigid position like the <code>n</code> in <code>fin n</code>. You can remove the dependency by extending the list by some suitable default value past the end, for example if <code>modn n := if h : n &lt; mods.length then mods.nth_le n h else \top</code>, then you can prove <code>is_filn n : modn n &lt;= modn (n+1)</code> and then write <code>factors n := mk_quotient (is_filn n)</code> and now everything unfolds nicely.</p>



<a name="172751046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172751046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Spencer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172751046">(Aug 08 2019 at 09:36)</a>:</h4>
<p>I understand that <code>list Type</code> is a problem, exactly for the reasons stated.</p>
<p>I had thought that <code>fin n -&gt; A</code> was almost interchangeable with <code>list A</code>, as there are suitable coercions between them (I think).  As you say, though, <code>fin n</code> requires you to know <code>n</code>.  This is not the end of the world for me I don't think.  I'd much rather not extend the filtration past the top, as I would like to distinguish between <code>0 &lt; U_1 &lt; U_2 &lt; M</code> and <code>0 &lt; U_1 &lt; U_2 &lt; M &lt; M</code> as filtrations.</p>
<p>This problem completely goes away if we have a <code>list (submodule R M)</code> for example because <code>submodule R M</code> is itself a structure and carries instances associated to that structure.  In an earlier draft of this I redefined a <code>modules</code> structure along the lines of</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">modules</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">add_comm_group</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">carrier</span><span class="o">)</span>
  <span class="o">(</span><span class="n">module</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">carrier</span><span class="o">)</span>
</pre></div>


<p>and then defined suitable coercions to <code>Type</code>, and instances of <code>add_comm_group</code> on that coercion etc. etc.  This felt very dirty though, and not at all in the spirit of lean, but did let me have a <code>list (modules R)</code> very easily.</p>



<a name="172751056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172751056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172751056">(Aug 08 2019 at 09:36)</a>:</h4>
<p>The problem seems to be that each of the subquotients has type <code>Type</code>, but type class inference isn't smart enough to spot that it can put a module structure on the subquotients. I suspect this problem could be solved by bundling. If you had a type whose terms were R-modules, rather than the current set-up where M is a parameter for the R-module set-up, then perhaps things would go better.</p>



<a name="172751218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172751218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Spencer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172751218">(Aug 08 2019 at 09:39)</a>:</h4>
<p>"Bundling" such as the above <code>structure</code>?</p>



<a name="172751295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172751295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172751295">(Aug 08 2019 at 09:41)</a>:</h4>
<p>At the minute you have terms of type <code>Type</code> and it's not generally true that a random term of this type is a module, so Lean's typeclass system can't deal with what you are trying to do. I guess another possibility would be to make your own structure consisting of a list and an R-module structure of each element of the list, and then work with these structures.</p>



<a name="172751402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172751402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172751402">(Aug 08 2019 at 09:43)</a>:</h4>
<p>Sorry, I'm on the London underground and I only have sporadic reception [messages are being sent before I see earlier messages you sent]. Yes, you're making the bundled category of R-modules. I am sure <span class="user-mention" data-user-id="110087">@Scott Morrison</span> would thoroughly approve and would argue that it was, or perhaps should be, in the spirit of Lean. Different people seem to have different opinions on the matter.</p>



<a name="172751651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172751651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172751651">(Aug 08 2019 at 09:49)</a>:</h4>
<p>Currently people believe that submodules of a given module should be a type, but that rings should not be a type (R should be a type and then the ring structure should be handled by the typeclass systems). Modules over a given ring are somewhere in the middle. Currently we're letting the typeclass system try and handle them -- but it's not clear to me whether this is "right" -- there will be advantages and disadvantages to each approach I guess. I will remark that we had real problems trying to make the typeclass system work with modules, there were a couple of failed attempts. The mathlib code</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">module</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">semimodule</span> <span class="n">α</span> <span class="n">β</span>

<span class="kn">structure</span> <span class="n">module</span><span class="bp">.</span><span class="n">core</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">has_scalar</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">smul_add</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">r</span> <span class="err">•</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">r</span> <span class="err">•</span> <span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_smul</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="o">(</span><span class="n">r</span> <span class="bp">+</span> <span class="n">s</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">s</span> <span class="err">•</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_smul</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="o">(</span><span class="n">r</span> <span class="bp">*</span> <span class="n">s</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">s</span> <span class="err">•</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">one_smul</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>

<span class="n">def</span> <span class="n">module</span><span class="bp">.</span><span class="n">of_core</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">module</span><span class="bp">.</span><span class="n">core</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">module</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">letI</span> <span class="o">:=</span> <span class="n">M</span><span class="bp">.</span><span class="n">to_has_scalar</span><span class="bp">;</span> <span class="n">exact</span>
<span class="o">{</span> <span class="n">zero_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">M</span><span class="bp">.</span><span class="n">add_smul</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span>
    <span class="n">add_left_cancel</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">r</span> <span class="err">•</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="n">β</span><span class="o">)</span> <span class="bp">+</span> <span class="n">r</span> <span class="err">•</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="mi">0</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">M</span><span class="bp">.</span><span class="n">smul_add</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span>
    <span class="n">add_left_cancel</span> <span class="n">this</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">M</span> <span class="o">}</span>
</pre></div>


<p>already seems to indicate that something funny is going on.</p>



<a name="172752428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172752428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172752428">(Aug 08 2019 at 10:06)</a>:</h4>
<p>The best way would be to stick to submodules in your list, and then only quotient by them at the end. A <code>fin n -&gt; Type</code> would also be better, because you can easily get the instance, by just unfolding the function, and you will have the right definitional equalities.</p>



<a name="172753704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172753704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172753704">(Aug 08 2019 at 10:34)</a>:</h4>
<p>But if the entire R-module structure is bundled then he can just use lists, right? There is a category of R-modules. Was this ever created? Do these help to solve the problem?</p>



<a name="172755365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172755365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Spencer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172755365">(Aug 08 2019 at 11:07)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span>  Not quite understanding what you mean by "only quotient by them at the end".  If you mean that <code>(U : submodule R M)</code> encodes the same information as <code>M / U</code>, then this is true, but I'd have to have a list where each member is a submodule of the next, which seems messy.</p>



<a name="172756279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172756279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172756279">(Aug 08 2019 at 11:24)</a>:</h4>
<p>Something like this (not sure if this Type checks, but hopefully you get the idea)</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">mk_quotient</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">))</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">≤</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">submodule</span><span class="bp">.</span><span class="n">map_subtype</span><span class="bp">.</span><span class="n">order_iso</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">l</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">factors</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filtration</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;_apply_between</span> <span class="o">(</span><span class="n">mk_quotient</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="n">F</span><span class="bp">.</span><span class="n">mods</span> <span class="n">F</span><span class="bp">.</span><span class="n">is_fil</span>

<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">neg_smul</span> <span class="n">R</span> <span class="o">(</span><span class="n">submodule</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">((</span><span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">head&#39;&#39;</span> <span class="n">h</span><span class="o">))</span> <span class="bp">_</span> <span class="bp">_</span>
</pre></div>



<a name="172757374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172757374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Spencer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172757374">(Aug 08 2019 at 11:44)</a>:</h4>
<p>Hmm.  So if, for example, I wanted to check some filtration were a composition series I'd have to do</p>
<div class="codehilite"><pre><span></span><span class="bp">∀</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">map</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">(</span><span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span><span class="o">)),</span> <span class="n">is_simple</span> <span class="n">N</span>
</pre></div>


<p>I feel like it would be neater if I could write</p>
<div class="codehilite"><pre><span></span><span class="o">(</span><span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span><span class="o">)</span> <span class="err">⊆</span> <span class="o">{</span> <span class="n">N</span> <span class="bp">//</span> <span class="n">is_simple</span> <span class="n">N</span> <span class="o">}</span>
</pre></div>


<p>which I think I could get with a bundled object.</p>
<p>Is the consensus that this is currently a stylistic choice: bundle or not?</p>



<a name="172757990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172757990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172757990">(Aug 08 2019 at 11:57)</a>:</h4>
<p>Chris and Mario have suggested sticking with unbundled modules, and they have written a lot more Lean code than I have. But submodules are bundled and subgroups are not bundled, which in my mind is evidence that the community is still learning what the best way to go about things is. I don't see anything wrong with bundling modules. Perhaps if you try it you'll see the problems which I cannot.</p>



<a name="172758044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172758044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172758044">(Aug 08 2019 at 11:58)</a>:</h4>
<p>You can still write</p>
<div class="codehilite"><pre><span></span><span class="o">(</span><span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span><span class="o">)</span> <span class="err">⊆</span> <span class="o">{</span> <span class="n">N</span> <span class="bp">|</span> <span class="n">is_simple</span> <span class="o">(</span><span class="n">submodule</span><span class="bp">.</span><span class="n">quotient</span> <span class="n">N</span><span class="o">)</span> <span class="o">}</span>
</pre></div>


<p>(you'd have to coerce the list into a set for this to work)</p>



<a name="172758170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172758170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172758170">(Aug 08 2019 at 12:00)</a>:</h4>
<p>This is nicer from a category theoretic perspective, because if your objects are submodules, your category is small. This might be useful at some point.</p>



<a name="172758288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172758288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172758288">(Aug 08 2019 at 12:02)</a>:</h4>
<p>The problem with using <code>submodule</code> is that if you are taking subquotients of a chain of submodules then everything is a submodule of everything above it and there is not one canonical module for which the submodules are the answer.</p>
<p>Perhaps another approach is bundled subquotients of a module. I think this would be a very interesting way of going about things. You carry around A and B, submodules of some fixed module M, with A a subset of B, and this represents the quotient module B/A. You'd have to write an API for this but if the community think that submodules are worth bundling, surely bundling subquotients is also a natural idea.</p>



<a name="172758336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172758336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172758336">(Aug 08 2019 at 12:03)</a>:</h4>
<p>Assia Mahboubi wrote a paper called "the rooster and the butterfly" where she talks about subquotients of groups in Coq. This might have some relevant ideas. The more CS-minded people in this conversation seem to be against the idea of bundling modules, but perhaps they would be more open to the idea of bundling subquotients of a given module.</p>



<a name="172760072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760072">(Aug 08 2019 at 12:32)</a>:</h4>
<p>I'm open to the idea of bundling subquotients, but first I would like to know what that is exactly. It doesn't quite line up with our current definitions; is there a single set of all subquotients of a module?</p>



<a name="172760092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760092">(Aug 08 2019 at 12:32)</a>:</h4>
<p>Yes. A subquotient of a module <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> is just <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi mathvariant="normal">/</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">B/A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord mathdefault">A</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi><mo>⊆</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">A\subseteq B\subseteq M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> are submodules.</p>



<a name="172760112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760112">(Aug 08 2019 at 12:33)</a>:</h4>
<p>A subquotient of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> is equivalently a subset of a quotient of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>, or a quotient of a subset of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>.</p>



<a name="172760114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760114">(Aug 08 2019 at 12:33)</a>:</h4>
<p>but you have to equate isomorphic subquotients I assume?</p>



<a name="172760118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760118">(Aug 08 2019 at 12:33)</a>:</h4>
<p>I think it's better than that.</p>



<a name="172760131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760131">(Aug 08 2019 at 12:34)</a>:</h4>
<p>If you're dealing with subquotients then you can literally keep track of just the two submodules.</p>



<a name="172760177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760177">(Aug 08 2019 at 12:34)</a>:</h4>
<p>Is the set simply a subset of the product of subquotients then?</p>



<a name="172760181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760181">(Aug 08 2019 at 12:34)</a>:</h4>
<p>Quotienting <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi mathvariant="normal">/</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">B/A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord mathdefault">A</span></span></span></span> is just making <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> bigger, and submoduling it is making <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> smaller.</p>



<a name="172760186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760186">(Aug 08 2019 at 12:34)</a>:</h4>
<p>You mean a product of submodules I suspect. Yes.</p>



<a name="172760195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760195">(Aug 08 2019 at 12:34)</a>:</h4>
<p>I mean a subquotient is encoded as a pair of submodules</p>



<a name="172760200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760200">(Aug 08 2019 at 12:34)</a>:</h4>
<p>Right.</p>



<a name="172760215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760215">(Aug 08 2019 at 12:35)</a>:</h4>
<p>It's not obvious to me that this has nice algebraic properties like submodules do though</p>



<a name="172760239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760239">(Aug 08 2019 at 12:35)</a>:</h4>
<p>That is, the collection of submodules is a "space", not just a "set"</p>



<a name="172760243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760243">(Aug 08 2019 at 12:35)</a>:</h4>
<p>There is such a thing as a simple subquotient -- a subquotient which is simple as a module. A simple module is a module which has precisely two submoules, bot and top.</p>



<a name="172760348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760348">(Aug 08 2019 at 12:37)</a>:</h4>
<p>That, to me, is the compelling justification for bundling. If we are only claiming that subquotients are determined by this data (a pair A &lt;= B), then you could just as well do that with a function <code>mk_quotient (A B) (h: A &lt;= B): Type</code></p>



<a name="172760357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760357">(Aug 08 2019 at 12:37)</a>:</h4>
<p>Simple modules are the analogue of prime numbers. Every positive integer is a uniquely a product of primes. For modules life isn't so simple. Recall that a <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>-module is just the same as an abelian group. The <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>-module <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><mn>4</mn><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}/4\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mord">/</span><span class="mord">4</span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> is not simple, and even worse, it's not even isomorphic to a product of simple modules.</p>



<a name="172760458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760458">(Aug 08 2019 at 12:38)</a>:</h4>
<p>However given a module with certain finiteness properties (e.g. a finite abelian group) one can produce a "saturated chain" of submodules <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>=</mo><msub><mi>M</mi><mn>0</mn></msub><mo>⊂</mo><msub><mi>M</mi><mn>1</mn></msub><mo>⊂</mo><msub><mi>M</mi><mn>2</mn></msub><mo>⊂</mo><mo>⋯</mo><mo>⊂</mo><msub><mi>M</mi><mi>n</mi></msub><mo>=</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">0=M_0\subset M_1\subset M_2\subset\cdots\subset M_n=M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>, with each subquotient <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">/</mi><msub><mi>M</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">M_{i+1}/M_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> simple.</p>



<a name="172760472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760472">(Aug 08 2019 at 12:38)</a>:</h4>
<p>And the theorem is that the multiset of isomorphism classes of simple factors is an invariant of the module.</p>



<a name="172760494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760494">(Aug 08 2019 at 12:39)</a>:</h4>
<blockquote>
<p>I understand that <code>list Type</code> is a problem, exactly for the reasons stated.</p>
<p>I had thought that <code>fin n -&gt; A</code> was almost interchangeable with <code>list A</code>, as there are suitable coercions between them (I think).  As you say, though, <code>fin n</code> requires you to know <code>n</code>.  This is not the end of the world for me I don't think.  I'd much rather not extend the filtration past the top, as I would like to distinguish between <code>0 &lt; U_1 &lt; U_2 &lt; M</code> and <code>0 &lt; U_1 &lt; U_2 &lt; M &lt; M</code> as filtrations.</p>
</blockquote>
<p>To be clear, I'm not saying that the filtration actually extends past the top. This is only an encoding trick - the <code>list (submodule R M)</code> is still just as it was</p>



<a name="172760592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760592">(Aug 08 2019 at 12:40)</a>:</h4>
<p>For example, for the cyclic groups <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">C_4</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub><mo>×</mo><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2\times C_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> the multisets are <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> with multiplicity 2 (in both cases), so you can't reconstruct a module from its irreducible subquotients. However the multiset is still useful -- for example in algebraic geometry one often does induction on the size of the multiset (with the inductive step typically being straightforward and the base case being the interesting one).</p>



<a name="172760761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760761">(Aug 08 2019 at 12:42)</a>:</h4>
<p>That is, the filtrations <code>0 &lt; U_1 &lt; U_2 &lt; M</code> and <code>0 &lt; U_1 &lt; U_2 &lt; M &lt; M</code> are distinct, but the function <code>factors F : nat -&gt; Type</code> is the same for both filtrations. You just remember that they have different lengths and the function is "garbage" past the end</p>



<a name="172760890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760890">(Aug 08 2019 at 12:44)</a>:</h4>
<blockquote>
<p>That is, the collection of submodules is a "space", not just a "set"</p>
</blockquote>
<p>I find it hard to imagine a definition of "space" where the submodules form a space and the subquotients do not. The subquotients are a subspace of the product of two copies of the space of submodules.</p>



<a name="172760951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172760951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172760951">(Aug 08 2019 at 12:45)</a>:</h4>
<p>My question is mostly directed at whether that encoding is reflecting some real structure that we care about or if it's just the usual "a group is a 4-tuple" business</p>



<a name="172761007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172761007">(Aug 08 2019 at 12:46)</a>:</h4>
<p>In some cases (for example subspaces of a finite-dimensional real vector space) the "space" of submodules really do naturally form a topological space, with one connected component for each dimension. But similarly the subquotients do too, they're a topological space with one connected component for each pair (dim A, dim B).</p>



<a name="172761060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172761060">(Aug 08 2019 at 12:47)</a>:</h4>
<p>Are they a lattice?</p>



<a name="172761121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172761121">(Aug 08 2019 at 12:48)</a>:</h4>
<p>Or at least, is there an ordering</p>



<a name="172761195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172761195">(Aug 08 2019 at 12:49)</a>:</h4>
<p>You can visualise the space of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>-dimensional submodules of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> as a quotient <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><msub><mi>L</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi mathvariant="double-struck">R</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">GL_n(\mathbb{R})/P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathbb">R</span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> is a subgroup of "block upper triangular matrices" consisting of a <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>×</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">d\times d</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> block at the top and an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>d</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n-d)\times (n-d)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span> block at the bottom. You can get more general subquotients (or even chains of submodules) by using other choices of "parabolic subgroup" P with more blocks on the diagonal.</p>



<a name="172761270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172761270">(Aug 08 2019 at 12:50)</a>:</h4>
<p>I don't think I can intersect two subquotients, but I am more confident about an ordering. I think I would suggest that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi mathvariant="normal">/</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">B/A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord mathdefault">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>B</mi><mo mathvariant="normal">′</mo></msup><mi mathvariant="normal">/</mi><msup><mi>A</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">B'/A'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> were incomparable unless <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><msup><mi>A</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">A=A'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> in which case it goes on the subset ordering on the $$B$$s.</p>



<a name="172761307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172761307">(Aug 08 2019 at 12:51)</a>:</h4>
<p>One could risk <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>B</mi><mo>∩</mo><msup><mi>B</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>A</mi><mo>∩</mo><msup><mi>A</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(B\cap B')/(A\cap A')</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> but it might not be a great idea. It looks a bit odd to me in the sense that I've not seen it before.</p>



<a name="172761344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172761344">(Aug 08 2019 at 12:51)</a>:</h4>
<p>Oh, I was going to guess <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mn>1</mn></msub><mi mathvariant="normal">/</mi><msub><mi>A</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>B</mi><mn>2</mn></msub><mi mathvariant="normal">/</mi><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">B_1/A_1 \le B_2/A_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> iff <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>B</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">B_1\le B_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>2</mn></msub><mo>≤</mo><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_2\le A_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>



<a name="172761345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172761345">(Aug 08 2019 at 12:51)</a>:</h4>
<p>It might work but not be useful, or it might work and be a really cool way of thinking about things, or it might just not work.</p>



<a name="172761442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172761442">(Aug 08 2019 at 12:52)</a>:</h4>
<p>One could I guess also say <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mn>1</mn></msub><mi mathvariant="normal">/</mi><msub><mi>A</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>B</mi><mn>2</mn></msub><mi mathvariant="normal">/</mi><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">B_1/A_1\leq B_2/A_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> iff there was a "natural map" from one to the other, like for submodules.</p>



<a name="172761503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172761503">(Aug 08 2019 at 12:53)</a>:</h4>
<p>If you did that you'd get <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>⊆</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">A_1\subseteq A_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mn>1</mn></msub><mo>⊆</mo><msub><mi>B</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">B_1\subseteq B_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>



<a name="172761537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172761537">(Aug 08 2019 at 12:53)</a>:</h4>
<p>Your point about considering subquotients as generalizations of submodules by inserting an additional block, and filtrations as a further generalization to multiple blocks, suggests a way to encode this as an inductive type, which might work out nicer</p>



<a name="172761633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172761633">(Aug 08 2019 at 12:54)</a>:</h4>
<p>Grassmannians are the topological spaces which one gets by considering filtrations on a finite-dimensional vector space. Because they can be computed as quotients of general linear groups by subgroups there is also a purely algebraic way of thinking about them, where your base field is now arbitrary and the quotients are (non-affine) schemes.</p>



<a name="172761868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172761868">(Aug 08 2019 at 12:58)</a>:</h4>
<p>Projective 1-space is the space of 1-dimensional subspaces of a 2-dimensional vector space. These are the first natural examples of non-affine schemes. <span class="user-mention" data-user-id="110064">@Kenny Lau</span> how is gluing?</p>



<a name="172761879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172761879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172761879">(Aug 08 2019 at 12:59)</a>:</h4>
<p>Do we have Grassmannians yet? ;-)</p>



<a name="172762157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172762157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172762157">(Aug 08 2019 at 13:03)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>
<span class="kn">open</span> <span class="n">lattice</span>
<span class="kn">inductive</span> <span class="n">transit</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">one</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">transit</span> <span class="n">a</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">trans</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">transit</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">transit</span> <span class="n">b</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">transit</span> <span class="n">a</span> <span class="n">c</span>

<span class="n">def</span> <span class="n">filtration</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">bounded_lattice</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span> <span class="n">transit</span> <span class="o">(</span><span class="err">⊥</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="err">⊤</span>
</pre></div>


<p>The downside of this encoding is that it distinguishes reassociated sequences, i.e. <code>0 &lt; (A &lt; (B &lt; M))</code> vs <code>(0 &lt; A) &lt; (B &lt; M)</code></p>



<a name="172764341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172764341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172764341">(Aug 08 2019 at 13:28)</a>:</h4>
<p>Here's how you can say that a filtration is simple:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">open</span> <span class="n">lattice</span>
<span class="kn">inductive</span> <span class="n">transit</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">one</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">transit</span> <span class="n">a</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">trans</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">transit</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">transit</span> <span class="n">b</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">transit</span> <span class="n">a</span> <span class="n">c</span>

<span class="n">def</span> <span class="n">filtration</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">bounded_lattice</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span> <span class="n">transit</span> <span class="o">(</span><span class="err">⊥</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="err">⊤</span>

<span class="kn">structure</span> <span class="n">le_pair</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a_le_b</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span>

<span class="n">def</span> <span class="n">transit</span><span class="bp">.</span><span class="n">factors</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">transit</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">le_pair</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">transit</span><span class="bp">.</span><span class="n">one</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[</span><span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span><span class="o">]</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">transit</span><span class="bp">.</span><span class="n">trans</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">t1</span> <span class="n">t2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">t1</span><span class="bp">.</span><span class="n">factors</span> <span class="bp">++</span> <span class="n">t2</span><span class="bp">.</span><span class="n">factors</span>

<span class="n">def</span> <span class="n">subquotient</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">le_pair</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">α</span> <span class="n">β</span><span class="o">))</span> <span class="o">:=</span> <span class="o">(</span><span class="n">submodule</span><span class="bp">.</span><span class="n">comap</span> <span class="n">p</span><span class="bp">.</span><span class="n">b</span><span class="bp">.</span><span class="n">subtype</span> <span class="n">p</span><span class="bp">.</span><span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">quotient</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">le_pair</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">α</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">subquotient</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">quotient</span><span class="bp">.</span><span class="n">add_comm_group</span> <span class="bp">_</span>
<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">le_pair</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">α</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">module</span> <span class="n">α</span> <span class="o">(</span><span class="n">subquotient</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">quotient</span><span class="bp">.</span><span class="n">module</span> <span class="bp">_</span>

<span class="n">def</span> <span class="n">module</span><span class="bp">.</span><span class="n">is_simple</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="n">def</span> <span class="n">filtration</span><span class="bp">.</span><span class="n">is_simple</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filtration</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">α</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">F</span><span class="bp">.</span><span class="n">factors</span><span class="o">,</span> <span class="n">module</span><span class="bp">.</span><span class="n">is_simple</span> <span class="n">α</span> <span class="o">(</span><span class="n">subquotient</span> <span class="n">p</span><span class="o">)</span>
</pre></div>



<a name="172774026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172774026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Spencer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172774026">(Aug 08 2019 at 15:14)</a>:</h4>
<p>I'll have to take some time to look at that solution and wrap my head around it, and how <code>transit</code> is really different from a <code>list</code> with a <code>chain'</code> (in particular, I think one could replace <code>transit.factors</code> with some sort of <code>chain'_factors (l : list \a) [chain' &lt;= l] : list (le_pair \a)</code> and get a similar result.</p>



<a name="172774041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172774041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Spencer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172774041">(Aug 08 2019 at 15:14)</a>:</h4>
<p>Thanks for the pointers though</p>



<a name="172774122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172774122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Spencer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172774122">(Aug 08 2019 at 15:15)</a>:</h4>
<p>I think for now I'll just treat sub quotients as these <code>le_pairs</code> until something better comes around</p>



<a name="172776682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172776682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172776682">(Aug 08 2019 at 15:46)</a>:</h4>
<p>You can still use list and chain; the key point here is that you don't put types in a list, you put the data from which you generate the types</p>



<a name="172776791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172776791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172776791">(Aug 08 2019 at 15:47)</a>:</h4>
<p>But I think it would be better to use structures that encode the relevant invariants, so that for example it's not possible to have an empty factors list, rather than having a predicate on the side to assert this</p>



<a name="172776951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172776951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172776951">(Aug 08 2019 at 15:49)</a>:</h4>
<p>You can also avoid the reassociation problem by structuring the inductive type a little differently so that it's all associated one way (this is basically what the <code>list</code> representation gives you), but this has different defeq simplifications and introduces a bias for one kind of association over the other. Whether this matters one way or another depends on details of the application</p>



<a name="172779143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172779143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Spencer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172779143">(Aug 08 2019 at 16:15)</a>:</h4>
<p>When I said use a list I meant something more along the lines of</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">open</span> <span class="n">lattice</span>

<span class="n">class</span> <span class="n">filtration</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span> <span class="o">(</span><span class="n">modules</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="n">modules</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">le_pair</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a_le_b</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">L</span> <span class="n">L₁</span> <span class="n">L₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span>
<span class="kn">lemma</span> <span class="n">chain&#39;_of_first_two</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;</span> <span class="n">R</span> <span class="o">(</span><span class="n">x</span> <span class="bp">::</span> <span class="n">y</span> <span class="bp">::</span> <span class="n">L</span><span class="o">)</span> <span class="bp">→</span> <span class="n">R</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">dunfold</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;</span><span class="bp">;</span> <span class="n">simp</span><span class="bp">;</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span>
<span class="kn">lemma</span> <span class="n">chain&#39;_desc_left</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;</span> <span class="n">R</span> <span class="o">(</span><span class="n">x</span> <span class="bp">::</span> <span class="n">L</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;</span> <span class="n">R</span> <span class="n">L</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">cases</span> <span class="n">L</span><span class="bp">;</span> <span class="n">simp</span><span class="o">[</span><span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;</span><span class="o">]</span>

<span class="n">def</span> <span class="n">filtration</span><span class="bp">.</span><span class="n">factors</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">bounded_lattice</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">filtration</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">le_pair</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">⟨</span> <span class="o">[],</span>       <span class="bp">_</span> <span class="bp">⟩</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="bp">⟨</span> <span class="o">[</span><span class="n">x</span><span class="o">],</span>      <span class="bp">_</span> <span class="bp">⟩</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="bp">⟨</span> <span class="o">(</span><span class="n">x</span><span class="bp">::</span><span class="n">y</span><span class="bp">::</span><span class="n">l</span><span class="o">),</span><span class="n">h</span> <span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">,</span> <span class="n">chain&#39;_of_first_two</span> <span class="n">h</span><span class="bp">⟩</span> <span class="bp">::</span> <span class="o">(</span><span class="n">filtration</span><span class="bp">.</span><span class="n">factors</span> <span class="bp">⟨</span> <span class="o">(</span><span class="n">y</span><span class="bp">::</span><span class="n">l</span><span class="o">),</span> <span class="o">(</span><span class="n">chain&#39;_desc_left</span> <span class="n">h</span><span class="o">)</span><span class="bp">⟩</span> <span class="o">)</span>

<span class="n">def</span> <span class="n">subquotient</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">le_pair</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">α</span> <span class="n">β</span><span class="o">))</span> <span class="o">:=</span> <span class="o">(</span><span class="n">submodule</span><span class="bp">.</span><span class="n">comap</span> <span class="n">p</span><span class="bp">.</span><span class="n">b</span><span class="bp">.</span><span class="n">subtype</span> <span class="n">p</span><span class="bp">.</span><span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">quotient</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">le_pair</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">α</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">subquotient</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">quotient</span><span class="bp">.</span><span class="n">add_comm_group</span> <span class="bp">_</span>
<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">le_pair</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">α</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">module</span> <span class="n">α</span> <span class="o">(</span><span class="n">subquotient</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">quotient</span><span class="bp">.</span><span class="n">module</span> <span class="bp">_</span>

<span class="n">def</span> <span class="n">module</span><span class="bp">.</span><span class="n">is_simple</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="n">def</span> <span class="n">filtration</span><span class="bp">.</span><span class="n">is_simple</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filtration</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">α</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">F</span><span class="bp">.</span><span class="n">factors</span><span class="o">,</span> <span class="n">module</span><span class="bp">.</span><span class="n">is_simple</span> <span class="n">α</span> <span class="o">(</span><span class="n">subquotient</span> <span class="n">p</span><span class="o">)</span>
</pre></div>


<p>which I am pretty sure never has a list of types?</p>



<a name="172830800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172830800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Spencer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172830800">(Aug 09 2019 at 07:15)</a>:</h4>
<p>To return to the bundling issue, am I going to  run into problems when I try to define equivalence classes of modules?  From a (very brief) reading of <code>setoid</code> and <code>quot</code>, you aren't allowed to tack classes onto the types.  In particular this</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">function</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">module</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">N</span><span class="o">]</span>

<span class="n">def</span> <span class="n">are_isomorphic</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">N</span><span class="o">),</span> <span class="n">function</span><span class="bp">.</span><span class="n">bijective</span> <span class="n">f</span> <span class="bp">∧</span> <span class="bp">...</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">quot</span> <span class="n">are_isomorphic</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="bp">⟨</span> <span class="n">are_isomorphic</span><span class="o">,</span> <span class="n">sorry</span> <span class="bp">⟩</span> <span class="o">:</span> <span class="n">setoid</span> <span class="kt">Type</span><span class="o">)</span>
</pre></div>


<p>gives errors, and I feel very dirty defining <code>setoid Type</code></p>



<a name="172831578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172831578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172831578">(Aug 09 2019 at 07:33)</a>:</h4>
<p>If you want to deal with isomorphism classes of R-modules then this is another argument that says you should be bundling them. Independent of this, the usual way in Lean to express that two objects are isomorphic is not to ask for a bijection between them but to ask for functions in each direction whose composite is the identity -- see e.g. data.equiv.basic (which also provides notation \equiv)</p>



<a name="172831735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172831735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172831735">(Aug 09 2019 at 07:36)</a>:</h4>
<p>The more you talk about the sort of things you are interested in, the more I am convinced you should just be working with a type representing the category of R-modules. I still don't know if such a type is in Lean (I was hoping that Scott would have chimed in by now) but even if it doesn't exist I would suspect that it wouldn't be too much trouble to make. Then you have all the category machinery available to you and in particular the notion of isomorphism would be available to you already together with all standard theorems you'll need about it (transitivity etc).</p>



<a name="172834433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172834433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Spencer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172834433">(Aug 09 2019 at 08:36)</a>:</h4>
<blockquote>
<p>the usual way in Lean to express that two objects are isomorphic is not to ask for a bijection between them but to ask for functions in each direction whose composite is the identity -- see e.g. data.equiv.basic (which also provides notation \equiv)</p>
</blockquote>
<p>yes, I think I've seen this, but wanted to throw together a MWE above.</p>



<a name="172834456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172834456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Spencer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172834456">(Aug 09 2019 at 08:37)</a>:</h4>
<p>I know next-to-nothing about categories in lean.  Is there any documentation or sample code I could peruse?</p>



<a name="172834693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172834693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172834693">(Aug 09 2019 at 08:42)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/master/docs/tutorial/category_theory/calculating_colimits_in_Top.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/tutorial/category_theory/calculating_colimits_in_Top.lean">https://github.com/leanprover-community/mathlib/blob/master/docs/tutorial/category_theory/calculating_colimits_in_Top.lean</a></p>



<a name="172834802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172834802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172834802">(Aug 09 2019 at 08:44)</a>:</h4>
<p>But another alternative is just to write the stuff yourself without categories. It will be a pleasant, but long, exercise. I don't know which will be easier. You bundle modules like earlier in the thread, bundle linear maps, and you can make your own kernels and cokernels. I'm really sorry -- it's the kind of thing I would just spend a couple of hours doing because I like that kind of thing, but I am really snowed under at the minute.</p>



<a name="172835047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172835047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Spencer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172835047">(Aug 09 2019 at 08:48)</a>:</h4>
<p>Ok.  I'll take a look.  I'm not so keen on the idea (in general) of writing custom bundlings for every algebraic structure (once modules are done, what about bimodules, comodules etc. etc.) so I'll look into categories first.</p>



<a name="172835801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172835801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172835801">(Aug 09 2019 at 09:01)</a>:</h4>
<p>This has been Scott's argument too. In mathlib we are still figuring out the right way to do things, and several approaches have been tried (and I am partly to blame for this) . I am working with two summer students on group theory and we have been using unbundled groups but bundled subgroups and isomorphisms, so we're having to write our own theorems such as if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>≅</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">G\cong H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>≅</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">H\cong K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>≅</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">G\cong K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>, and are introducing new notation for each kind of isomorphism. With the category theory approach we get all these for free.</p>



<a name="172921112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172921112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Spencer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172921112">(Aug 10 2019 at 11:22)</a>:</h4>
<p>Ok, I think I have a (very ugly) first pass at this, culminating in the line</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">Module</span> <span class="n">R</span><span class="o">)</span>

<span class="kn">variable</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filtration</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span>

<span class="n">def</span> <span class="n">filtration</span><span class="bp">.</span><span class="n">is_composition_series</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">F</span><span class="bp">.</span><span class="n">factors</span><span class="o">,</span> <span class="n">is_simple</span> <span class="o">(</span><span class="n">subquotient&#39;</span> <span class="n">R</span> <span class="n">M</span> <span class="n">p</span><span class="o">)</span>
</pre></div>


<p>There are many ugly bits, mostly due to my ignorance (e.g. stating a object in a category is isomorphic to another), but it works.  At last.  I think.<br>
<a href="https://github.com/rspencer01/lean_representation_theory/tree/master/src" target="_blank" title="https://github.com/rspencer01/lean_representation_theory/tree/master/src">https://github.com/rspencer01/lean_representation_theory/tree/master/src</a></p>



<a name="172922487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172922487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172922487">(Aug 10 2019 at 12:08)</a>:</h4>
<p>What's up with the remark on <code>submodule</code> not inferring <code>add_comm_group</code>?</p>



<a name="172922495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172922495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172922495">(Aug 10 2019 at 12:09)</a>:</h4>
<p>I think the issue might be in the definition of <code>Module</code></p>



<a name="172922553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172922553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172922553">(Aug 10 2019 at 12:10)</a>:</h4>
<p><code>r_mod</code> is a bad idea</p>



<a name="172922610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172922610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Spencer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172922610">(Aug 10 2019 at 12:12)</a>:</h4>
<p>I'm very happy to suggestions/corrections.  I defined <code>r_mod</code> because <code>bundled</code> only works on a single class.</p>



<a name="172922611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172922611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172922611">(Aug 10 2019 at 12:12)</a>:</h4>
<p>You should probably define <code>Module</code> directly rather than using <code>bundled</code></p>



<a name="172922621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172922621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172922621">(Aug 10 2019 at 12:13)</a>:</h4>
<p>I don't think it's actually saving you that much work, you still have to associate the right category structure</p>



<a name="172922625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172922625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172922625">(Aug 10 2019 at 12:13)</a>:</h4>
<p>and don't make it <code>reducible</code></p>



<a name="172922668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172922668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Spencer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172922668">(Aug 10 2019 at 12:14)</a>:</h4>
<p>Ah.</p>
<p>I was basically copying <code>mathlib</code>'s <code>group_theory.category</code></p>



<a name="172922869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172922869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Spencer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172922869">(Aug 10 2019 at 12:21)</a>:</h4>
<p>I still am not certain what is up with <code>submodule</code> and <code>add_comm_group</code>.  Here is an example:</p>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">filtration</span><span class="bp">.</span><span class="n">le_pair</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">p</span><span class="bp">.</span><span class="n">b</span>
<span class="c">/-</span><span class="cm"> p.b : submodule R ↥M -/</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">submodule</span><span class="bp">.</span><span class="n">comap</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">submodule</span><span class="bp">.</span><span class="n">add_comm_group</span> <span class="n">p</span><span class="bp">.</span><span class="n">b</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">p</span><span class="bp">.</span><span class="n">b</span><span class="bp">.</span><span class="n">subtype</span> <span class="n">p</span><span class="bp">.</span><span class="n">a</span>
<span class="c">/-</span><span class="cm"> submodule.comap (submodule.subtype (p.b)) (p.a) : submodule R ↥(p.b) -/</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">submodule</span><span class="bp">.</span><span class="n">comap</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span>                              <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">p</span><span class="bp">.</span><span class="n">b</span><span class="bp">.</span><span class="n">subtype</span> <span class="n">p</span><span class="bp">.</span><span class="n">a</span>
<span class="c">/-</span><span class="cm"> maximum class-instance resolution depth has been reached (the limit can be increased by setting option &#39;class.instance_max_depth&#39;) (the class-instance resolution trace can be visualized by setting option &#39;trace.class_instances&#39;)-/</span>
</pre></div>


<p>which seems to indicate that it can't find an instance of <code>add_comm_group</code> for <code>p.b</code>, an honest <code>submodule R ↥M</code>.</p>
<p>To me this feels like a problem in <code>submodule</code>, rather than <code>Module</code>.</p>



<a name="172923102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172923102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Spencer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172923102">(Aug 10 2019 at 12:29)</a>:</h4>
<p>In fact, the same happens if I replace <code>M : Module R</code> with <code>(N : Type) [add_comm_group N] [module R N]</code></p>



<a name="172923578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172923578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Spencer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Pulling.20class.20instances.20through.20.22complicated.22.20computations.html#172923578">(Aug 10 2019 at 12:45)</a>:</h4>
<p>Whoops.  Nevermind.  I retract that.  Its only a problem when I <code>import Module</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
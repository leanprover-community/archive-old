---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html">1 is not equal to zero?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="266505582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266505582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266505582">(Dec 31 2021 at 14:12)</a>:</h4>
<p>I seem to have backed myself into a corner and cannot for the life of me figure out how to prove that 1 is not = to zero.  Any hints?</p>



<a name="266505722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266505722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266505722">(Dec 31 2021 at 14:15)</a>:</h4>
<p>some variation of <a href="https://leanprover-community.github.io/mathlib_docs/find/one_ne_zero">docs#one_ne_zero</a>; what type is <code>1</code>?</p>



<a name="266505968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266505968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266505968">(Dec 31 2021 at 14:20)</a>:</h4>
<p>just a natural number.</p>



<a name="266505970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266505970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266505970">(Dec 31 2021 at 14:20)</a>:</h4>
<p>For natural numbers, it can be proved using <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.succ_ne_zero">docs#nat.succ_ne_zero</a>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">succ_ne_zero</span> <span class="mi">0</span>
</code></pre></div>
<p>But it is not true in general:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">T</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">T</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">T</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">T.mk</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="n">T</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">T.mk</span><span class="o">⟩</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="266506010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266506010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266506010">(Dec 31 2021 at 14:21)</a>:</h4>
<p>If you omit the type signature, you can't prove it.</p>



<a name="266506100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266506100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266506100">(Dec 31 2021 at 14:23)</a>:</h4>
<p>fun fact: this is also a valid proof of <code>1 ≠ 0</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">one_ne_zero</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span><span class="bp">.</span>
</code></pre></div>
<p>(you can <code>#print</code> it to see what magic is going on here, and Kevin has a <a href="https://xenaproject.wordpress.com/2018/03/24/no-confusion-over-no_confusion/">blog post on it</a>)</p>



<a name="266506178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266506178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266506178">(Dec 31 2021 at 14:25)</a>:</h4>
<p>The actual situation I'm in is the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">1</span> <span class="n">goal</span>
<span class="n">h</span><span class="o">:</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span>
<span class="bp">⊢</span> <span class="n">false</span>
</code></pre></div>
<p>So I really want to prove 1 not = to 2.  More generally I am experimenting with proving very concrete things like </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">one_list</span> <span class="o">:=</span> <span class="n">list.nil.cons</span> <span class="mi">1</span>
<span class="kd">lemma</span> <span class="n">two</span><span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">one_list</span> <span class="bp">=</span> <span class="o">(</span><span class="n">one_list.cons</span> <span class="mi">2</span><span class="o">))</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>and finding it surprisingly complicated.</p>



<a name="266506189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266506189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266506189">(Dec 31 2021 at 14:25)</a>:</h4>
<p>The <code>.</code> is the most mystifying proof I've ever seen. I love it <span aria-label="stuck out tongue closed eyes" class="emoji emoji-1f61d" role="img" title="stuck out tongue closed eyes">:stuck_out_tongue_closed_eyes:</span></p>



<a name="266506251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266506251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266506251">(Dec 31 2021 at 14:27)</a>:</h4>
<p>Does <code>norm_num</code> help Jeremy? Or <code>dec_trivial(!)</code>?</p>



<a name="266506344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266506344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266506344">(Dec 31 2021 at 14:29)</a>:</h4>
<p>Or <code>cases h</code></p>



<a name="266506518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266506518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266506518">(Dec 31 2021 at 14:33)</a>:</h4>
<p><code>cases h</code> works like magic, but what did it do?</p>



<a name="266506760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266506760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266506760">(Dec 31 2021 at 14:38)</a>:</h4>
<p>It gave you n goals, where n was the number of constructors of <code>eq</code> which could possibly have made such a proof.</p>



<a name="266506859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266506859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266506859">(Dec 31 2021 at 14:40)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">one_list</span> <span class="o">:=</span> <span class="n">list.nil.cons</span> <span class="mi">1</span>
<span class="kd">def</span> <span class="n">one_list'</span> <span class="o">:=</span> <span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="c1">-- why not just use the notation for this?</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">one_list</span> <span class="bp">=</span> <span class="n">one_list'</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">two</span><span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">one_list</span> <span class="bp">=</span> <span class="o">(</span><span class="n">one_list.cons</span> <span class="mi">2</span><span class="o">))</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
</code></pre></div>



<a name="266507033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266507033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266507033">(Dec 31 2021 at 14:45)</a>:</h4>
<p>When <code>nat</code> is constructed, Lean's elaborator knows that it can assume that constructors are injective and that distinct constructors give different terms. If you do <code>cases h</code> when <code>h : 1 = 2</code> then Lean thinks "well the only constructor for <code>eq</code> is <code>eq.refl x : x = x</code> so both <code>1</code> and <code>2</code> have to be equal to <code>x</code>. Now <code>1 := succ zero</code> and <code>2 := succ (succ zero)</code> so for <code>x</code> to exist, <code>succ (succ zero)</code> and <code>succ zero</code> have to be equal, but I know that succ is injective so this means <code>succ zero</code> has to equal <code>zero</code> but again I know this can't be true because zero isn't succ of anything, so this case can't happen"</p>



<a name="266507051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266507051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266507051">(Dec 31 2021 at 14:46)</a>:</h4>
<p>Under the hood, there are these auto-generated <code>no_confusion</code> declarations that give you (or the <code>cases</code> tactic) lower level access to the fact that constructors are injective and disjoint.</p>



<a name="266507095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266507095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266507095">(Dec 31 2021 at 14:46)</a>:</h4>
<p>Is it the elaborator doing this when the <code>cases</code> tactic is run?</p>



<a name="266507112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266507112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266507112">(Dec 31 2021 at 14:47)</a>:</h4>
<p>In Lean 4 it is, there might be c++ magic in Lean 3.</p>



<a name="266507185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266507185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266507185">(Dec 31 2021 at 14:48)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="bp">@</span><span class="n">nat.no_confusion</span>
</code></pre></div>
<p>gives some statement which is hard to understand (it involves another type called <code>nat.no_confusion_type</code> -- it was only when Chris Hughes and I sat down to figure out what was going on that I began to understand it and then wrote the blog post linked to above). If you right click on it, you might be surprised where you end up: the point is that this lemma is generated automatically by Lean when <code>nat</code> is defined.</p>



<a name="266507325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266507325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266507325">(Dec 31 2021 at 14:50)</a>:</h4>
<p>It does look like <code>cases</code> farms out to <code>no_confusion</code> in lean 3 as well.</p>



<a name="266507499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266507499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266507499">(Dec 31 2021 at 14:54)</a>:</h4>
<p>I guess I didn't realize that "constructors are injective" and that "distinct constructors give different terms" were built in.  So in the<br>
inductive definition of the natural numbers, the injectivity of <code>succ</code> is automatic? </p>
<p>Is there a section of TPIL I can read to understand more about the process you describe below?</p>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F/near/266507033">said</a>:</p>
<blockquote>
<p>When <code>nat</code> is constructed, Lean's elaborator knows that it can assume that constructors are injective and that distinct constructors give different terms. If you do <code>cases h</code> when <code>h : 1 = 2</code> then Lean thinks "well the only constructor for <code>eq</code> is <code>eq.refl x : x = x</code> so both <code>1</code> and <code>2</code> have to be equal to <code>x</code>. Now <code>1 := succ zero</code> and <code>2 := succ (succ zero)</code> so for <code>x</code> to exist, <code>succ (succ zero)</code> and <code>succ zero</code> have to be equal, but I know that succ is injective so this means <code>succ zero</code> has to equal <code>zero</code> but again I know this can't be true because zero isn't succ of anything, so this case can't happen"</p>
</blockquote>



<a name="266507523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266507523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266507523">(Dec 31 2021 at 14:54)</a>:</h4>
<p>They're not built in per se, they're proved automatically and added. You can <code>#print nat.no_confusion</code> to see the proof that Lean automatically generated.</p>



<a name="266507553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266507553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266507553">(Dec 31 2021 at 14:55)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">foo</span>
<span class="bp">|</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">foo</span>
<span class="bp">|</span> <span class="n">baz</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">foo</span>

<span class="k">#print</span> <span class="n">foo.no_confusion</span> <span class="c1">-- you can see the term proof</span>
<span class="k">#print</span> <span class="kd">prefix</span> <span class="n">foo</span> <span class="c1">-- all the other goodies</span>
</code></pre></div>



<a name="266507606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266507606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266507606">(Dec 31 2021 at 14:56)</a>:</h4>
<p><code>#print prefix foo</code> shows you all the things Lean makes automatically when the user builds the inductive type <code>foo</code>. The only things in that list without a definition are <code>foo</code>, <code>foo.bar</code>, <code>foo.baz</code> and <code>foo.rec</code>.</p>



<a name="266507897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266507897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266507897">(Dec 31 2021 at 15:01)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">foo</span>
<span class="bp">|</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">foo</span>
<span class="bp">|</span> <span class="n">baz</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">foo</span>

<span class="kn">namespace</span> <span class="n">foo</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">bar</span> <span class="bp">=</span> <span class="n">baz</span> <span class="n">x</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">foo.no_confusion</span> <span class="n">h</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">bar</span> <span class="bp">=</span> <span class="n">baz</span> <span class="n">x.</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span> <span class="o">:</span> <span class="n">baz</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">baz</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">foo.no_confusion</span> <span class="n">h</span> <span class="n">id</span>

<span class="kd">end</span> <span class="n">foo</span>
</code></pre></div>



<a name="266508068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266508068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266508068">(Dec 31 2021 at 15:05)</a>:</h4>
<p>The dot thing is just an Easter egg, it's rarely useful in practice to mathematicians. It's all well and good having this fabulous equation compiler, but the equation compiler is a tool which works wonders on inductive types with more than one constructor, and we in practice hardly ever use these. Things like <code>group G</code>, the type of group structures on a type <code>G</code>, are strictly speaking inductive types, but they only have one constructor (the only way to make a group structure on G is to give the multiplication, identity, inverse, and proofs of the axioms). So you don't ever see this <code>no_confusion</code> stuff in practice when you're e.g. in <a class="stream" data-stream-id="304774" href="/#narrow/stream/304774-FLT-regular">#FLT regular</a> trying to prove FLT for regular primes.</p>



<a name="266508310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266508310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266508310">(Dec 31 2021 at 15:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="462625">Jeremy Teitelbaum</span> <a href="#narrow/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F/near/266507499">said</a>:</p>
<blockquote>
<p>I guess I didn't realize that "constructors are injective" and that "distinct constructors give different terms" were built in.  So in the<br>
inductive definition of the natural numbers, the injectivity of <code>succ</code> is automatic? </p>
<p>Is there a section of TPIL I can read to understand more about the process you describe below?</p>
</blockquote>
<p>The type signature for <code>no_confusion_type</code>is intimidating, but the underlying idea is pretty intuitive. You tell it some <code>p</code> that you want, and give it a proof <code>h : a = b</code>, and it looks at what <code>a</code> and <code>b</code> are. <br>
For <code>0 = 0</code>, you get nothing, since it's a trivial proof. For <code>S x  = 0</code> and <code>0 = S y</code>, you immediately get a witness of <code>p</code>, since your <code>h</code> is a proof of false. For <code>S x = S y</code>, you get back a term that will give you <code>p</code> if it can be derived from <code>x = y</code>.</p>



<a name="266509172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/1%20is%20not%20equal%20to%20zero%3F/near/266509172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/1.20is.20not.20equal.20to.20zero.3F.html#266509172">(Dec 31 2021 at 15:24)</a>:</h4>
<blockquote>
<p>Is there a section of TPIL I can read to understand more about the process you describe below?</p>
</blockquote>
<p>I just picked it up by asking questions on here. I don't need a detailed understanding of this phenomenon to do the kind of mathematics I want to do so I didn't understand the details any more carefully. Someone like <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> will be able to tell you how everything works in Lean 3.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/set.20notation.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html">set notation</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="212929970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212929970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212929970">(Oct 10 2020 at 19:00)</a>:</h4>
<p>Could someone point me to or tell me what the underlying definition of <code>{}</code> is? For instance, the singleton set <code>{x}</code>. I haven't been able to find it in mathlib.</p>



<a name="212930173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212930173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212930173">(Oct 10 2020 at 19:05)</a>:</h4>
<p>Nevermind, I guess VIsual Code says it is singleton.</p>



<a name="212930311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212930311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212930311">(Oct 10 2020 at 19:08)</a>:</h4>
<p>Hmm, but then set.singleton uses the same notation.</p>



<a name="212930434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212930434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212930434">(Oct 10 2020 at 19:11)</a>:</h4>
<p>(deleted, Pedro gave a better answer)</p>



<a name="212930566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212930566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212930566">(Oct 10 2020 at 19:14)</a>:</h4>
<p><code>{}</code> is an empty "set comprehension," like <code>{1, 2, 3}</code> but with zero elements.</p>



<a name="212930594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212930594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212930594">(Oct 10 2020 at 19:14)</a>:</h4>
<p>Look at <a href="https://leanprover-community.github.io/mathlib_docs/find/is_lawful_singleton">docs#is_lawful_singleton</a>, it should give you an idea of what is happening behind the scenes.</p>



<a name="212930596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212930596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212930596">(Oct 10 2020 at 19:15)</a>:</h4>
<p>Is there any underlying definition somewhere for set comprehension?</p>



<a name="212930660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212930660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212930660">(Oct 10 2020 at 19:16)</a>:</h4>
<p>So it appears that a set is just a predicate?</p>



<a name="212930661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212930661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212930661">(Oct 10 2020 at 19:16)</a>:</h4>
<p>The notation <code>{1, 2, 3}</code> folds <code>has_insert.insert</code> with <code>has_emptyc.emptyc</code>.</p>



<a name="212930666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212930666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212930666">(Oct 10 2020 at 19:16)</a>:</h4>
<p>Yes, a set is just a predicate.</p>



<a name="212930689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212930689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212930689">(Oct 10 2020 at 19:17)</a>:</h4>
<p><code>{}</code> is equal to <code>∅</code>, which is equivalent to <code>λ _, false</code>.</p>



<a name="212930770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212930770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212930770">(Oct 10 2020 at 19:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="298376">Pedro Minicz</span> <a href="#narrow/stream/113489-new-members/topic/set.20notation/near/212930661">said</a>:</p>
<blockquote>
<p>The notation <code>{1, 2, 3}</code> folds <code>has_insert.insert</code> with <code>has_emptyc.emptyc</code>.</p>
</blockquote>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> is that correct? I can't seem to find a <code>notation</code> definition for <code> `{` l:(foldr `, ` (x xs, insert x xs) ∅ `}`)</code>. Is it defined internally in C++?</p>



<a name="212930821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212930821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212930821">(Oct 10 2020 at 19:20)</a>:</h4>
<p>Does the following represent the proposition that <code>a</code> is a member of <code>set s</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">mem</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">s</span> <span class="n">a</span>
</code></pre></div>



<a name="212930887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212930887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212930887">(Oct 10 2020 at 19:22)</a>:</h4>
<p>Yes. Since sets are predicates (<code>α → Prop</code>) and <code>a : α</code>, <code>s a : Prop</code>, which is <code>true</code> or <code>false</code> depending on whether <code>a</code> "is in" <code>s</code>.</p>



<a name="212930966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212930966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212930966">(Oct 10 2020 at 19:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="298376">Pedro Minicz</span> <a href="#narrow/stream/113489-new-members/topic/set.20notation/near/212930770">said</a>:</p>
<blockquote>
<p>I can't seem to find a <code>notation</code> definition for <code> `{` l:(foldr `, ` (x xs, insert x xs) ∅ `}`)</code>. Is it defined internally in C++?</p>
</blockquote>
<p>I think it's defined here: <a href="https://github.com/leanprover-community/lean/blob/master/src/frontends/lean/brackets.cpp">https://github.com/leanprover-community/lean/blob/master/src/frontends/lean/brackets.cpp</a></p>



<a name="212931070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212931070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212931070">(Oct 10 2020 at 19:27)</a>:</h4>
<p>Ah, yes, this looks like it.</p>



<a name="212931317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212931317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212931317">(Oct 10 2020 at 19:33)</a>:</h4>
<p>Would this be an equivalent definition: <code>def singleton (α : Type) (a : α) (s : set α) := ∀ b : α, (set.mem b s) → b = a</code>?</p>



<a name="212931394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212931394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212931394">(Oct 10 2020 at 19:35)</a>:</h4>
<p>Doesn't insert itself use the <code>{}</code> notation?</p>



<a name="212932874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212932874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212932874">(Oct 10 2020 at 20:16)</a>:</h4>
<p><code>set.insert</code> uses <code>{ ... | ... }</code> notation, which is different from <code>{.., ..., ...}</code>.</p>



<a name="212932899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212932899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212932899">(Oct 10 2020 at 20:17)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">pp.notation</span> <span class="n">false</span>
<span class="k">#print</span> <span class="n">set.insert</span> <span class="c1">-- λ {α : Type u} (a : α) (s : set α), set_of (λ (b : α), or (eq b a) (has_mem.mem b s))</span>
</code></pre></div>

<p>If you disable notations when printing, you can see the definition of <code>set.insert</code>.</p>



<a name="212932935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212932935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212932935">(Oct 10 2020 at 20:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/set.20notation/near/212931317">said</a>:</p>
<blockquote>
<p>Would this be an equivalent definition: <code>def singleton (α : Type) (a : α) (s : set α) := ∀ b : α, (set.mem b s) → b = a</code>?</p>
</blockquote>
<p>This is a predicate <em>on sets</em>. It says that the set <code>s</code> contains only one element.</p>



<a name="212933034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212933034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212933034">(Oct 10 2020 at 20:21)</a>:</h4>
<p>Sets are predicates <em>on a type</em>. Consider <code>def singleton' (a : α) : set α := λ x, x = a</code>, <code>singleton' a</code> is a set of <code>α</code>, that is, a predicate on <code>α</code>. While with your definition <code>singleton a s</code> says that <code>s</code> is a set that only contains <code>a</code>.</p>



<a name="212933174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212933174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212933174">(Oct 10 2020 at 20:25)</a>:</h4>
<p>That is what I was intending.</p>



<a name="212933225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212933225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212933225">(Oct 10 2020 at 20:26)</a>:</h4>
<p>That it was an equivalent definition to <code>{a}</code>.</p>



<a name="212933948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212933948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212933948">(Oct 10 2020 at 20:48)</a>:</h4>
<p>Wait, are you saying that singleton' is a set of alpha that only contains a?</p>



<a name="212934038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212934038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212934038">(Oct 10 2020 at 20:51)</a>:</h4>
<p>Yes, <code>singleton' a</code> is a set that only contains <code>a</code>.</p>



<a name="212935158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212935158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212935158">(Oct 10 2020 at 21:23)</a>:</h4>
<p>I guess I don't understand the difference between my <code>def singleton (α : Type) (a : α) (s : set α) := ∀ b : α, (set.mem b s) → b = a</code> and your <code>def singleton' (a : α) : set α := λ x, x = a</code>.</p>



<a name="212935164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212935164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212935164">(Oct 10 2020 at 21:24)</a>:</h4>
<p>Is it just that mine takes a set as a parameter?</p>



<a name="212935562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212935562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212935562">(Oct 10 2020 at 21:34)</a>:</h4>
<p>Observe the types of both definitions:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">sing</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">sing'</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span>
<span class="c1">-- Remember that `set α = α → Prop`.</span>
<span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">sing</span> <span class="n">a</span> <span class="c1">-- `set α → Prop`, that is, a predicate on `set α`.</span>
<span class="k">#check</span> <span class="n">sing'</span> <span class="n">a</span> <span class="c1">-- `set α`, that is, a predicate on `α`.</span>
</code></pre></div>



<a name="212935634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212935634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212935634">(Oct 10 2020 at 21:36)</a>:</h4>
<p>I see. Thank you.</p>



<a name="212935642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212935642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212935642">(Oct 10 2020 at 21:36)</a>:</h4>
<p>Your predicate talks about sets. It is true if and only if the set in question is a singleton set. My <code>singleton'</code> <em>creates</em> a set, that is, given an <code>a : α</code> it creates a predicate <code>α → Prop</code>.</p>



<a name="212935923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212935923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212935923">(Oct 10 2020 at 21:43)</a>:</h4>
<p>So...?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">union</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">set.mem</span> <span class="n">x</span> <span class="n">s</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">set.mem</span> <span class="n">x</span> <span class="n">t</span><span class="o">)</span>
</code></pre></div>



<a name="212936011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212936011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212936011">(Oct 10 2020 at 21:45)</a>:</h4>
<p>Yes! That is exactly it!</p>



<a name="212936065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212936065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212936065">(Oct 10 2020 at 21:46)</a>:</h4>
<p>Cool. Thank you!</p>



<a name="212936070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212936070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212936070">(Oct 10 2020 at 21:46)</a>:</h4>
<p>I'd recommend using <code>x ∈ s</code> as it is a bit easier to read than <code>set.mem</code>.</p>



<a name="212936086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212936086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212936086">(Oct 10 2020 at 21:47)</a>:</h4>
<p>Ok.</p>



<a name="212936089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212936089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212936089">(Oct 10 2020 at 21:47)</a>:</h4>
<p>Also, since sets are predicates and predicates are functions, you can write <code>λ x, s x ∨ t x</code> to make what is happening under the hood explicit.</p>



<a name="212936152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/212936152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#212936152">(Oct 10 2020 at 21:48)</a>:</h4>
<p>Cool.</p>



<a name="220528900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/220528900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lúcás Meier <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#220528900">(Dec 20 2020 at 17:33)</a>:</h4>
<p>So, I've seen that Lean has a kind of set notation: <code>{a : nat | a &gt;= 3}</code> (modulo unicode syntax). Is this hard-coded into the language, or could you define a similar kind of notation for other things?</p>



<a name="220528909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/220528909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#220528909">(Dec 20 2020 at 17:33)</a>:</h4>
<p>It's hardcoded.</p>



<a name="220529030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/220529030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#220529030">(Dec 20 2020 at 17:36)</a>:</h4>
<p>but you can define similar notation, as long as you don't start with <code>{</code></p>



<a name="246392984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/246392984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#246392984">(Jul 18 2021 at 18:59)</a>:</h4>
<p>Does lean recognise any kind of  "dot notation" for sets?<br>
<code>def S (n: ℕ) :set ℕ:= {1,2,...,n}</code></p>



<a name="246393273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/246393273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#246393273">(Jul 18 2021 at 19:05)</a>:</h4>
<p><span class="user-mention" data-user-id="408694">@Alex Zhang</span> No, not as far as I've seen.  That set happens to be called <code>set.Icc 1 n</code>, though.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">S</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">{</span><span class="n">i</span> <span class="bp">|</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">i</span> <span class="bp">∧</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">}</span>
<span class="kd">def</span> <span class="n">S'</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">set.Icc</span> <span class="mi">1</span> <span class="n">n</span>
<span class="kd">def</span> <span class="n">S''</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">''</span> <span class="n">set.univ</span>
</code></pre></div>



<a name="246394113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/246394113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#246394113">(Jul 18 2021 at 19:24)</a>:</h4>
<p>If I have a finite field F with card p (odd and large) say,<br>
then is it possible to define a set to be say {0 , 1, ... (p-1)/2} :<code>set F</code>?</p>



<a name="246394122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/246394122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#246394122">(Jul 18 2021 at 19:24)</a>:</h4>
<p>by defining to be the image of some function perhaps? any convenient way?</p>



<a name="246394265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/246394265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#246394265">(Jul 18 2021 at 19:29)</a>:</h4>
<p><span class="user-mention" data-user-id="408694">@Alex Zhang</span> There's a natural map from natural numbers to a ring, which is given as a coercion instance, and you can take the image of <code>set.Icc</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">S</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">F</span> <span class="o">:=</span> <span class="n">coe</span> <span class="bp">''</span> <span class="n">set.Icc</span> <span class="mi">0</span> <span class="n">n</span>
</code></pre></div>
<p>It's up to you to pass in the upper bound you want.</p>



<a name="246394273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/246394273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#246394273">(Jul 18 2021 at 19:29)</a>:</h4>
<p>More generally,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">S</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">coe</span> <span class="bp">''</span> <span class="n">set.Icc</span> <span class="mi">0</span> <span class="n">n</span>
</code></pre></div>



<a name="246394427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/246394427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#246394427">(Jul 18 2021 at 19:32)</a>:</h4>
<p>Very helpful, Kyle!</p>



<a name="246394689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/set%20notation/near/246394689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/set.20notation.html#246394689">(Jul 18 2021 at 19:39)</a>:</h4>
<p>Will you be taking sums over these? There is also <code>finset.Ico</code>, and soon we will also have <code>finset.Icc</code> and all the other variants.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
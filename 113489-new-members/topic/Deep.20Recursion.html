---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Deep.20Recursion.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Deep.20Recursion.html">Deep Recursion</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="219388528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Deep%20Recursion/near/219388528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Saroj N <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Deep.20Recursion.html#219388528">(Dec 09 2020 at 19:48)</a>:</h4>
<p>I am not sure why this code says there is an issue of deep recursion: <br>
theorem ok {c : char} :<br>
    c = '∧' →  c ≠ '∨' :=<br>
begin finish end<br>
When I replace  '∧'  and  '∨' with 'a' and 'b', there is no error though. Thanks!</p>



<a name="219389307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Deep%20Recursion/near/219389307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Deep.20Recursion.html#219389307">(Dec 09 2020 at 19:55)</a>:</h4>
<p>It's because the unicode character for  '∧' will correspond to a number like 37 gazillion, and <code>finish</code> is not adapted to dealing with large numbers.</p>



<a name="219389839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Deep%20Recursion/near/219389839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Deep.20Recursion.html#219389839">(Dec 09 2020 at 20:00)</a>:</h4>
<div class="codehilite" data-code-language="Python"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">'∧'</span><span class="p">)</span>
<span class="mi">8743</span>
</code></pre></div>



<a name="219389908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Deep%20Recursion/near/219389908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Deep.20Recursion.html#219389908">(Dec 09 2020 at 20:00)</a>:</h4>
<p><del>Which amazingly, has 37 as a divisor, making "a gazillion" exactly 236</del></p>



<a name="219390040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Deep%20Recursion/near/219390040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Deep.20Recursion.html#219390040">(Dec 09 2020 at 20:01)</a>:</h4>
<p>&lt;never mind&gt;</p>



<a name="219390043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Deep%20Recursion/near/219390043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Deep.20Recursion.html#219390043">(Dec 09 2020 at 20:01)</a>:</h4>
<p>Where's the <code>gazillion</code> emoji?</p>



<a name="219390133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Deep%20Recursion/near/219390133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Deep.20Recursion.html#219390133">(Dec 09 2020 at 20:02)</a>:</h4>
<p>well, <code>chr(236)</code> is <code>ì</code>...</p>



<a name="219390226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Deep%20Recursion/near/219390226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Deep.20Recursion.html#219390226">(Dec 09 2020 at 20:03)</a>:</h4>
<p>I don't know much python but I'm a bit skeptical about the claim that 37*236=8743</p>



<a name="219390293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Deep%20Recursion/near/219390293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Deep.20Recursion.html#219390293">(Dec 09 2020 at 20:03)</a>:</h4>
<p>It turns out that the human brain isn't reliable as a clipboard. I typed <code>8732</code> by accident</p>



<a name="219390312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Deep%20Recursion/near/219390312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Deep.20Recursion.html#219390312">(Dec 09 2020 at 20:03)</a>:</h4>
<p>unless we're talking about nat.div in which case I'm totally on board</p>



<a name="219390368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Deep%20Recursion/near/219390368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Deep.20Recursion.html#219390368">(Dec 09 2020 at 20:04)</a>:</h4>
<p>It's 236.29729....</p>



<a name="219390396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Deep%20Recursion/near/219390396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Deep.20Recursion.html#219390396">(Dec 09 2020 at 20:04)</a>:</h4>
<p>this works though: <code>lemma foo (c : ℕ) : c = 88888 → c ≠ 99999 := by finish</code></p>



<a name="219390419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Deep%20Recursion/near/219390419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Deep.20Recursion.html#219390419">(Dec 09 2020 at 20:04)</a>:</h4>
<p>maybe the issue is that char does something crazy, this has come up before</p>



<a name="219390533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Deep%20Recursion/near/219390533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Deep.20Recursion.html#219390533">(Dec 09 2020 at 20:06)</a>:</h4>
<p>chars are somehow unusable in Lean 3</p>



<a name="219390918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Deep%20Recursion/near/219390918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Deep.20Recursion.html#219390918">(Dec 09 2020 at 20:09)</a>:</h4>
<p>The problem is something to do with this code in core:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[reducible]</span> <span class="kd">def</span> <span class="n">is_valid_char</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">0xd800</span> <span class="bp">∨</span> <span class="o">(</span><span class="mi">0xdfff</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">0x110000</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">is_valid_char_range_1</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">0xd800</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_valid_char</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">or.inl</span> <span class="n">h</span>

<span class="kd">lemma</span> <span class="n">is_valid_char_range_2</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="mi">0xdfff</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">0x110000</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_valid_char</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">or.inr</span> <span class="o">⟨</span><span class="n">h₁</span><span class="o">,</span> <span class="n">h₂</span><span class="o">⟩</span>

<span class="sd">/-- The `char` type represents an unicode scalar value.</span>
<span class="sd">    See http://www.unicode.org/glossary/#unicode_scalar_value). -/</span>
<span class="kd">structure</span> <span class="n">char</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">valid</span> <span class="o">:</span> <span class="n">is_valid_char</span> <span class="n">val</span><span class="o">)</span>
</code></pre></div>
<p>Checking that you're in the right range is really painful.</p>



<a name="219391059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Deep%20Recursion/near/219391059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Deep.20Recursion.html#219391059">(Dec 09 2020 at 20:10)</a>:</h4>
<p>You just need the right lemmas and to use the tool for the job:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">char.of_nat_inj</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">is_valid_char</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">is_valid_char</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">char.of_nat</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">char.of_nat</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">char.of_nat</span><span class="o">,</span> <span class="bp">*</span><span class="o">]</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">e</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">char.veq_of_eq</span> <span class="n">e</span>

<span class="kd">theorem</span> <span class="n">ok</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">char</span><span class="o">}</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">=</span> <span class="sc">'∧'</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">≠</span> <span class="sc">'∨'</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">mt</span> <span class="o">(</span><span class="n">char.of_nat_inj</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span><span class="bp">;</span> <span class="n">norm_num</span> <span class="o">[</span><span class="n">is_valid_char</span><span class="o">]</span>
<span class="kd">end</span>
</code></pre></div>



<a name="220494397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Deep%20Recursion/near/220494397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Deep.20Recursion.html#220494397">(Dec 20 2020 at 00:14)</a>:</h4>
<p>Here's a ridiculous solution: replace <code>∧</code> and <code>∨</code> by ASCII characters <code>.</code> and <code>v</code> and do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.basic</span>

<span class="k">#eval</span> <span class="sc">'v'</span><span class="bp">.</span><span class="n">val</span>
<span class="k">#eval</span> <span class="sc">'.'</span><span class="bp">.</span><span class="n">val</span>

<span class="kd">lemma</span> <span class="n">ok</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">char</span><span class="o">}</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">=</span> <span class="sc">'.'</span> <span class="bp">→</span>  <span class="n">c</span> <span class="bp">≠</span> <span class="sc">'v'</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">dot</span><span class="o">:</span> <span class="n">c</span> <span class="bp">=</span> <span class="sc">'.'</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">vee</span><span class="o">:</span> <span class="n">c</span> <span class="bp">=</span> <span class="sc">'v'</span><span class="o">,</span>
    <span class="k">have</span> <span class="mi">118</span> <span class="bp">=</span> <span class="mi">46</span><span class="o">,</span> <span class="k">from</span> <span class="k">calc</span> <span class="mi">118</span> <span class="bp">=</span> <span class="sc">'v'</span><span class="bp">.</span><span class="n">val</span> <span class="o">:</span> <span class="n">refl</span> <span class="o">(</span><span class="sc">'v'</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span>
                             <span class="bp">...</span> <span class="bp">=</span>   <span class="n">c.val</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">vee</span>
                             <span class="bp">...</span> <span class="bp">=</span> <span class="sc">'.'</span><span class="bp">.</span><span class="n">val</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">dot</span>
                             <span class="bp">...</span> <span class="bp">=</span>      <span class="mi">46</span> <span class="o">:</span> <span class="n">refl</span> <span class="o">(</span><span class="sc">'.'</span><span class="bp">.</span><span class="n">val</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">same_num</span><span class="o">:</span> <span class="mi">72</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="k">from</span> <span class="kd">by</span> <span class="n">tidy</span><span class="o">,</span>

    <span class="n">nat.succ_ne_zero</span> <span class="mi">71</span> <span class="o">(</span><span class="n">eq.trans</span> <span class="o">(</span><span class="n">refl</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="mi">71</span><span class="o">))</span> <span class="n">same_num</span><span class="o">)</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
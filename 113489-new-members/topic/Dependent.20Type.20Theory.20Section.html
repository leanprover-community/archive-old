---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html">Dependent Type Theory Section</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="267315377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267315377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267315377">(Jan 08 2022 at 21:03)</a>:</h4>
<p>Hi I'm reading said section from the book "Theorem Proving in Lean", and I'm having a few questions hopefully I can get some help:</p>
<p><a href="/user_uploads/3121/eHeLuxCKvVr_1JOPPEpT3P_E/image.png">image.png</a> </p>
<div class="message_inline_image"><a href="/user_uploads/3121/eHeLuxCKvVr_1JOPPEpT3P_E/image.png" title="image.png"><img src="/user_uploads/3121/eHeLuxCKvVr_1JOPPEpT3P_E/image.png"></a></div><p>Here' I'm experimenting with universe variables but I don't get why it says <code>u_1</code> instead of just <code>u</code> also <code>u</code> is representing some natural number right?</p>



<a name="267315859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267315859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267315859">(Jan 08 2022 at 21:08)</a>:</h4>
<p>yes <code>u</code> is representing a natural number...the reason it's saying <code>u_1</code> is that what you see on the right hand side does not directly correspond to what you see on the left, the right hand side (aka the infoview) is autogenerated from your file + your current position using another information provided by the compiler and it appears there is a minor cosmetic bug here in this case</p>



<a name="267316157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267316157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267316157">(Jan 08 2022 at 21:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267315859">said</a>:</p>
<blockquote>
<p>yes <code>u</code> is representing a natural number...the reason it's saying <code>u_1</code> is that what you see on the right hand side does not directly correspond to what you see on the left, the right hand side (aka the infoview) is autogenerated from your file + your current position using another information provided by the compiler and it appears there is a minor cosmetic bug here in this case</p>
</blockquote>
<p>Ok, so in reality the info view should be saying <code>alpha: Type u</code> right?</p>



<a name="267316207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267316207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267316207">(Jan 08 2022 at 21:11)</a>:</h4>
<p>Yes, I think its just a cosmetic bug, I also would expect the infoview to at least be self consistent so it will most likely use the u_1 identifier in every spot where <code>u</code> should appear</p>



<a name="267316585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267316585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267316585">(Jan 08 2022 at 21:20)</a>:</h4>
<p>If I wrote <code>#check λ (α β : Type*) (b : β) (x : α), x</code> Then alpha and beta are two arbitrary types right? Now if I type <code>#check λ (α β : Type) (b : β) (x : α), x</code> (notice the asterisk is gone), then it makes alpha and beta both have type <code>Type</code> ?</p>



<a name="267316690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267316690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267316690">(Jan 08 2022 at 21:22)</a>:</h4>
<p>Yeap, and you can do things like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">(</span><span class="n">χ</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">χ</span> <span class="c1">-- χ : Type</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">χ</span> <span class="bp">→</span> <span class="n">χ</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="k">#check</span> <span class="n">foo</span> <span class="c1">-- foo : Π (χ : Type), χ → χ</span>
</code></pre></div>



<a name="267316691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267316691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267316691">(Jan 08 2022 at 21:22)</a>:</h4>
<p>Yes, also note that <code>Type*</code> actually works in a way such that in the first case alpha and beta are in fact so arbitrary that they are not necessarily in the same type universe as evident by:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="k">#check</span> <span class="n">α</span>
<span class="k">#check</span> <span class="n">β</span>
</code></pre></div>



<a name="267316722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267316722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267316722">(Jan 08 2022 at 21:24)</a>:</h4>
<p>Just to give some more context here for why Lean doesn't return the exact universe variables you wrote back at you, in the following example both <code>a</code> and <code>b</code> are in type <code>Type u</code>, but <code>u</code> is a variable here, so when they interact the type may depend on two universe variables <code>u_1 u_2</code>, despite the fact that they both live in <code>Type u</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>
<span class="kd">constant</span> <span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="kd">constant</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>

<span class="k">#check</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">b</span> <span class="c1">-- Type (max u_1 u_2)</span>
</code></pre></div>



<a name="267316870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267316870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267316870">(Jan 08 2022 at 21:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267316722">said</a>:</p>
<blockquote>
<p>Just to give some more context here for why Lean doesn't return the exact universe variables you wrote back at you, in the following example both <code>a</code> and <code>b</code> are in type <code>Type u</code>, but <code>u</code> is a variable here, so when they interact the type may depend on two universe variables <code>u_1 u_2</code>, despite the fact that they both live in <code>Type u</code></p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>
<span class="kd">constant</span> <span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="kd">constant</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>

<span class="k">#check</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">b</span> <span class="c1">-- Type (max u_1 u_2)</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Is <code>a → b</code> the same thing as <code>f: a → b</code> ?</p>



<a name="267316949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267316949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267316949">(Jan 08 2022 at 21:29)</a>:</h4>
<p>It is the type of all possible functions from alpha to beta</p>



<a name="267316998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267316998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267316998">(Jan 08 2022 at 21:30)</a>:</h4>
<p>And <code>f: a -&gt; b</code> would just be one of the possible elements of that set?</p>



<a name="267317003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267317003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267317003">(Jan 08 2022 at 21:30)</a>:</h4>
<p>Yeah exactly</p>



<a name="267317004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267317004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267317004">(Jan 08 2022 at 21:30)</a>:</h4>
<p>I know it's not sets now though right? How could I rephrase my question I just asked in terms of type theory</p>



<a name="267317027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267317027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267317027">(Jan 08 2022 at 21:31)</a>:</h4>
<p>Maybe "one possible term of that type"</p>



<a name="267317030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267317030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267317030">(Jan 08 2022 at 21:31)</a>:</h4>
<p>Right, but its not a bad mental model to start with.<br>
You can still use the terminology elements of a type, some people say terms of a type, but elements is totally fine</p>



<a name="267317080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267317080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267317080">(Jan 08 2022 at 21:32)</a>:</h4>
<p>Ok thanks for explaining that</p>



<a name="267317086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267317086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267317086">(Jan 08 2022 at 21:32)</a>:</h4>
<p>I just tried out <code>#check λ (α β γ : Type*) (g : β → γ) (f : α → β) (x : α), g (f x)</code> in a  lean file, the infoview says this: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">λ</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_3</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_3</span><span class="o">),</span> <span class="o">(</span><span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">γ</span>
</code></pre></div>
<p>What does the part after the Π mean?</p>



<a name="267317113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267317113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267317113">(Jan 08 2022 at 21:33)</a>:</h4>
<p>I think that <code>λ (α : Type u_1) (β : Type u_2) (γ : Type u_3) (g : β → γ) (f : α → β) (x : α), g (f x)</code> describes a function which takes in <code>alpha</code> of type <code>u_</code>,  <code>beta</code> of type <code>u_2</code>, <code>gamma</code> of type <code>u_3</code> two functions and x, and outputs the composition</p>



<a name="267317184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267317184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267317184">(Jan 08 2022 at 21:35)</a>:</h4>
<p>Have you learned what the capital pi means in general yet? If not you can keep going until you do and try to ignore it for now, it's on of the fundamental concepts of dependent type theory.</p>



<a name="267317185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267317185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267317185">(Jan 08 2022 at 21:35)</a>:</h4>
<p>Maybe this book can help you with these questions: <a href="https://homotopytypetheory.org/book/">https://homotopytypetheory.org/book/</a><br>
It certainly helped me (and still does)</p>
<p>And you don't need to go super super deep into it. The chapter 1 is highly insightful already</p>



<a name="267317257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267317257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267317257">(Jan 08 2022 at 21:36)</a>:</h4>
<p><a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a> is also a good reference here <a href="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#dependent-types">https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#dependent-types</a></p>



<a name="267317426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267317426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267317426">(Jan 08 2022 at 21:40)</a>:</h4>
<p>These videos are very good too:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=TeY5niDR8yE">https://www.youtube.com/watch?v=TeY5niDR8yE</a><div class="youtube-video message_inline_image"><a data-id="TeY5niDR8yE" href="https://www.youtube.com/watch?v=TeY5niDR8yE"><img src="https://uploads.zulipusercontent.net/100b1ba69a7c5cb668e0dd4708270dc32f852b2f/68747470733a2f2f692e7974696d672e636f6d2f76692f546559356e6944523879452f64656661756c742e6a7067"></a></div></li>
<li><a href="https://www.youtube.com/watch?v=9cR2Day-4Bk">https://www.youtube.com/watch?v=9cR2Day-4Bk</a><div class="youtube-video message_inline_image"><a data-id="9cR2Day-4Bk" href="https://www.youtube.com/watch?v=9cR2Day-4Bk"><img src="https://uploads.zulipusercontent.net/7716d13534969edec01f9a92b9a7d413c36ce769/68747470733a2f2f692e7974696d672e636f6d2f76692f396352324461792d34426b2f64656661756c742e6a7067"></a></div></li>
</ul>



<a name="267317438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267317438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267317438">(Jan 08 2022 at 21:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267317257">said</a>:</p>
<blockquote>
<p><a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a> is also a good reference here <a href="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#dependent-types">https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#dependent-types</a></p>
</blockquote>
<p>I'm in section 2.3 rn, I guess I'll get there soon</p>



<a name="267317446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267317446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267317446">(Jan 08 2022 at 21:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267317426">said</a>:</p>
<blockquote>
<p>These videos are very good too:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=TeY5niDR8yE">https://www.youtube.com/watch?v=TeY5niDR8yE</a></li>
<li><a href="https://www.youtube.com/watch?v=9cR2Day-4Bk">https://www.youtube.com/watch?v=9cR2Day-4Bk</a></li>
</ul>
</blockquote>
<p>checking it out</p>



<a name="267327847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267327847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267327847">(Jan 09 2022 at 01:36)</a>:</h4>
<p>Ok, so I'm trying to figure out why bar doesn't work whereas foo does work: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="k">let</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">nat</span>  <span class="k">in</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">2</span>

<span class="kd">def</span> <span class="n">bar</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="n">nat</span>
</code></pre></div>



<a name="267327896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267327896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267327896">(Jan 09 2022 at 01:37)</a>:</h4>
<p>I think it has to do with the order of how things are evaluated.</p>
<p>Would it be correct to say that bar doesn't work because first lean looks at <code>(λ a, λ x : a, x + 2)</code> but that doesn't make sense because we don't know what <code>x</code> is? in the case for foo, I think they must "sub" the <code>nat</code> in before it does the type check?</p>



<a name="267328420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267328420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267328420">(Jan 09 2022 at 01:47)</a>:</h4>
<p>You'd have to be able to do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">bar'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">2</span>
<span class="kd">def</span> <span class="n">bar</span> <span class="o">:=</span> <span class="n">bar'</span> <span class="n">nat</span>
</code></pre></div>
<p>Notice that <code>bar'</code> breaks for the same reason. Maybe this way you can understand it better</p>



<a name="267328556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267328556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267328556">(Jan 09 2022 at 01:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267328420">said</a>:</p>
<blockquote>
<p>You'd have to be able to do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">bar'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">2</span>
<span class="kd">def</span> <span class="n">bar</span> <span class="o">:=</span> <span class="n">bar'</span> <span class="n">nat</span>
</code></pre></div>
<p>Notice that <code>bar'</code> breaks for the same reason. Maybe this way you can understand it better</p>
</blockquote>
<p>So that one is breaking because it doesn't know what type x has right?</p>



<a name="267328751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267328751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267328751">(Jan 09 2022 at 01:52)</a>:</h4>
<p>Wait nvm it doesn't know what a is</p>



<a name="267329981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267329981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267329981">(Jan 09 2022 at 02:19)</a>:</h4>
<p>Ok, so I think it's a problem because it can't infer what type a should be</p>



<a name="267331122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267331122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267331122">(Jan 09 2022 at 02:44)</a>:</h4>
<p>The problem is that Lean can't just assume that addition is available for <code>x</code>. That is, Lean can't assure that addition is defined for type <code>a</code></p>



<a name="267331713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267331713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267331713">(Jan 09 2022 at 02:58)</a>:</h4>
<p>This works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">bar'</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">a</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">a</span><span class="o">]</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">2</span>

<span class="k">#check</span> <span class="n">bar'</span> <span class="c1">-- bar' : ?M_1 → ?M_1</span>

<span class="kd">def</span> <span class="n">bar</span> <span class="o">:=</span> <span class="n">bar'</span> <span class="mi">3</span>

<span class="k">#check</span> <span class="n">bar</span> <span class="c1">-- bar : ℕ (Lean inferred ℕ because I applied bar' to 3)</span>
</code></pre></div>



<a name="267332207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267332207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267332207">(Jan 09 2022 at 03:09)</a>:</h4>
<p>And this is a bit exotic, but is more aligned with what you tried to do:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">bar'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">a</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">a</span><span class="o">],</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span>
<span class="kd">begin</span>
  <span class="n">tactic.unfreeze_local_instances</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">2</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">bar</span> <span class="o">:=</span> <span class="n">bar'</span> <span class="n">nat</span>

<span class="k">#check</span> <span class="n">bar</span> <span class="c1">-- bar : ℕ → ℕ</span>
</code></pre></div>



<a name="267332279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267332279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267332279">(Jan 09 2022 at 03:11)</a>:</h4>
<p>If someone knows how to tell lean to use <code>_inst_1: has_add a</code> and <code>_inst_2: has_one a</code> directly (without relying on <code>tactic.unfreeze_local_instances</code>), please let us know <span aria-label="pray" class="emoji emoji-1f64f" role="img" title="pray">:pray:</span></p>



<a name="267332398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267332398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267332398">(Jan 09 2022 at 03:14)</a>:</h4>
<p>It's still tactic mode, but the usual way is <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#exactI">tactic#exactI</a></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">bar'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">a</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">a</span><span class="o">],</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="kd">by</span> <span class="n">exactI</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">2</span>

<span class="kd">def</span> <span class="n">bar</span> <span class="o">:=</span> <span class="n">bar'</span> <span class="n">nat</span>

<span class="k">#check</span> <span class="n">bar</span> <span class="c1">-- bar : ℕ → ℕ</span>
</code></pre></div>



<a name="267332440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267332440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267332440">(Jan 09 2022 at 03:16)</a>:</h4>
<p>Much better!</p>



<a name="267332550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267332550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267332550">(Jan 09 2022 at 03:18)</a>:</h4>
<p>(I'd never looked at the definition of <code>exactI</code> until now. It just does <code>tactic.unfreeze_local_instances</code> then <code>tactic.freeze_local_instances</code> for you before doing <code>exact</code>, so it's essentially equivalent to what you'd written, but fewer keystrokes.)</p>



<a name="267338921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267338921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267338921">(Jan 09 2022 at 06:09)</a>:</h4>
<p><span class="user-mention" data-user-id="367659">@ccn</span> One thing about the original question that no one seems to have pointed out is that when you write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>
<span class="kd">constant</span> <span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
</code></pre></div>
<p>you are really defining a parametric family of constants, denoted <code>a.{u}</code>. It's not like <code>a</code> exists in some particular universe <code>u</code>, rather there is a different <code>a</code> at each universe: <code>a.{0} : Type 0</code>, <code>a.{1} : Type 1</code> and so on. This is the same way that the <code>variables</code> command works: every definition is implicitly universally quantified over <code>variable</code> declarations in scope, and when you use the definition later you can supply different values for the variables.</p>
<p>Universe parameters are usually implicit, so when you write <code>#check a</code> what it really means is <code>#check a.{_}</code>. Lean has to pick some universe variable to fill the <code>_</code>, and it makes up <code>u_1</code> as a universe variable name. So the output is saying <code>a.{u_1} : Type u_1</code>, although the <code>.{u_1}</code> part is hidden unless you set <code>set_option pp.universes true</code>.</p>



<a name="267368306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267368306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuri de Wit <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267368306">(Jan 09 2022 at 17:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267317257">said</a>:</p>
<blockquote>
<p><a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a> is also a good reference here <a href="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#dependent-types">https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#dependent-types</a></p>
</blockquote>
<p>I guess this is the relevant part?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">This</span> <span class="n">is</span> <span class="n">an</span> <span class="kd">instance</span> <span class="n">of</span> <span class="n">a</span> <span class="k">Pi</span> <span class="n">type</span><span class="o">,</span> <span class="n">or</span> <span class="n">dependent</span> <span class="n">function</span> <span class="n">type.</span> <span class="n">Given</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">and</span> <span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">,</span> <span class="n">think</span> <span class="n">of</span> <span class="n">β</span> <span class="n">as</span> <span class="n">a</span> <span class="n">family</span> <span class="n">of</span> <span class="n">types</span> <span class="n">over</span> <span class="n">α</span><span class="o">,</span> <span class="n">that</span> <span class="n">is</span><span class="o">,</span> <span class="n">a</span> <span class="n">type</span> <span class="n">β</span> <span class="n">a</span> <span class="n">for</span> <span class="n">each</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α.</span> <span class="n">In</span> <span class="n">that</span> <span class="n">case</span><span class="o">,</span> <span class="n">the</span> <span class="n">type</span> <span class="bp">Π</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">β</span> <span class="n">x</span> <span class="n">denotes</span> <span class="n">the</span> <span class="n">type</span> <span class="n">of</span> <span class="n">functions</span> <span class="n">f</span> <span class="k">with</span> <span class="n">the</span> <span class="n">property</span> <span class="n">that</span><span class="o">,</span> <span class="n">for</span> <span class="n">each</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="n">is</span> <span class="n">an</span> <span class="n">element</span> <span class="n">of</span> <span class="n">β</span> <span class="n">a.</span> <span class="n">In</span> <span class="n">other</span> <span class="n">words</span><span class="o">,</span> <span class="n">the</span> <span class="n">type</span> <span class="n">of</span> <span class="n">the</span> <span class="n">value</span> <span class="n">returned</span> <span class="kd">by</span> <span class="n">f</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">its</span> <span class="n">input.</span>
</code></pre></div>



<a name="267370587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267370587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267370587">(Jan 09 2022 at 18:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267331713">said</a>:</p>
<blockquote>
<p>This works:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">bar'</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">a</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">a</span><span class="o">]</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">2</span>

<span class="k">#check</span> <span class="n">bar'</span> <span class="c1">-- bar' : ?M_1 → ?M_1</span>

<span class="kd">def</span> <span class="n">bar</span> <span class="o">:=</span> <span class="n">bar'</span> <span class="mi">3</span>

<span class="k">#check</span> <span class="n">bar</span> <span class="c1">-- bar : ℕ (Lean inferred ℕ because I applied bar' to 3)</span>
</code></pre></div><br>
</p>
</blockquote>
<p>what does <code>has_one</code> mean here? Is it connected to the one in the type of it? <code>bar' : ?M_1 → ?M_1</code>, what do those question marks mean?</p>



<a name="267370729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267370729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267370729">(Jan 09 2022 at 18:28)</a>:</h4>
<p><code>has_one</code> is a typeclass, its what lets us type <code>1 : a</code> and have lean know what that means, nat already has a <code>has_one</code> typeclass built in so you don't notice it. Given <code>has_one</code> and <code>has_add</code> lean knows what 2 and 3, etc. mean for a given type</p>



<a name="267370739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267370739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267370739">(Jan 09 2022 at 18:28)</a>:</h4>
<p>The questionmarked variables are metavariables</p>



<a name="267371026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267371026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267371026">(Jan 09 2022 at 18:35)</a>:</h4>
<p>Yeah, you can read <code>bar' : ?M_1 → ?M_1</code> as "<code>bar'</code> is a function that, given a term of a type, returns a term of that same type, whatever that type is"</p>
<p>And Lean differentiates "whatever types" by saying <code>?M_1</code>, <code>?M_2</code>...</p>



<a name="267372156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267372156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267372156">(Jan 09 2022 at 19:01)</a>:</h4>
<p>Ok, so I'm trying to get this into my head, so if I have <code>Π x : α, β</code> this represents  <code>α → β</code> which is the type of functions from alpha to beta. </p>
<p>When we have something like this: <code>Π x : α, β x</code> then what it saying is that this is the type of functions so where for any such function f and element a in α, then f a is an element of β a.</p>
<p>So if α consists of the points a_0, a_1, a_2, ... then <code>Π x : α, β x</code> is the type of functions  <code>α→ Union over a_i β a_i</code> ?</p>



<a name="267372260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267372260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267372260">(Jan 09 2022 at 19:03)</a>:</h4>
<p>You could think of them as functions of that type such that for each input <code>i</code>, the output value belongs to <code>β i</code></p>



<a name="267372343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267372343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267372343">(Jan 09 2022 at 19:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267372260">said</a>:</p>
<blockquote>
<p>You could think of them as functions of that type such that for each input <code>i</code>, the output value belongs to <code>β i</code></p>
</blockquote>
<p>So it means that the co-domain of any one of those functions  has to at least contain { β i :  i in α}, but could be a super set of that?</p>



<a name="267372407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267372407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267372407">(Jan 09 2022 at 19:06)</a>:</h4>
<p>Well, now you're mixing type theory and set theory terminology in a way that's probably making things more confusing</p>



<a name="267372448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267372448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267372448">(Jan 09 2022 at 19:07)</a>:</h4>
<p>A dependent function in type theory doesn't really have <strong>a</strong> codomain because the result type depends on the input value</p>



<a name="267372489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267372489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267372489">(Jan 09 2022 at 19:08)</a>:</h4>
<p>so maybe it is best to just avoid this language</p>



<a name="267372523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267372523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267372523">(Jan 09 2022 at 19:09)</a>:</h4>
<p>Ok I will. I watched this video: <a href="https://youtu.be/TeY5niDR8yE?t=757">https://youtu.be/TeY5niDR8yE?t=757</a> so is it ok to think about types as space and then the terms of a type as the points of the space?</p>
<div class="youtube-video message_inline_image"><a data-id="TeY5niDR8yE" href="https://youtu.be/TeY5niDR8yE?t=757"><img src="https://uploads.zulipusercontent.net/100b1ba69a7c5cb668e0dd4708270dc32f852b2f/68747470733a2f2f692e7974696d672e636f6d2f76692f546559356e6944523879452f64656661756c742e6a7067"></a></div>



<a name="267372726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267372726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267372726">(Jan 09 2022 at 19:14)</a>:</h4>
<p>This is from TPIL</p>
<blockquote>
<p>Suppose we wish to write a function cons which inserts a new element at the head of a list. What type should cons have? Such a function is polymorphic: we expect the cons function for ℕ, bool, or an arbitrary type α to behave the same way. So it makes sense to take the type to be the first argument to cons, so that for any type, α, cons α is the insertion function for lists of type α. In other words, for every α, cons α is the function that takes an element a : α and a list l : list α, and returns a new list, so we have cons α a l : list α.</p>
<p>It is clear that cons α should have type α → list α → list α. But what type should cons have? A first guess might be Type → α → list α → list α, but, on reflection, this does not make sense: the α in this expression does not refer to anything, whereas it should refer to the argument of type Type. In other words, assuming α : Type is the first argument to the function, the type of the next two elements are α and list α. These types vary depending on the first argument, α.</p>
</blockquote>
<p>Couldn't cons be of the the type <code>Type -&gt; type Type -&gt; list Type -&gt; list Type</code> ?</p>



<a name="267372907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267372907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267372907">(Jan 09 2022 at 19:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267372523">said</a>:</p>
<blockquote>
<p>is it ok to think about types as space and then the terms of a type as the points of the space?</p>
</blockquote>
<p>You can, although in Lean the "spaces" are more specifically discrete spaces, i.e., just sets.</p>



<a name="267372912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267372912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267372912">(Jan 09 2022 at 19:18)</a>:</h4>
<p><span class="user-mention" data-user-id="367659">@ccn</span>  Reid's right that there's not really a codomain, but you can transform dependent functions into non-dependent ones by creating "the" codomain using a sigma type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">to_total</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">β</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">β</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">sigma.mk</span> <span class="n">x</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>Using the space analogy, this sigma type is the total space of a fiber bundle, where above each <code>y</code> lies the fiber <code>β y</code>. Then the original <code>f</code> here "is" a section of this fiber bundle.</p>



<a name="267372945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267372945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267372945">(Jan 09 2022 at 19:19)</a>:</h4>
<p>(The sigma type is basically a disjoint union.)</p>



<a name="267373774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267373774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267373774">(Jan 09 2022 at 19:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267372523">said</a>:</p>
<blockquote>
<p>Ok I will. I watched this video. so is it ok to think about types as space and then the terms of a type as the points of the space?</p>
</blockquote>
<p>Watching video about some foundations they are related to the foundations used by Lean but different will very likely bring you a <em>lot</em> of confusion.</p>



<a name="267374451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267374451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267374451">(Jan 09 2022 at 19:55)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kd">variable</span> <span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="kd">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">variable</span> <span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="n">a</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>            <span class="c1">-- (a, b) : α × β a</span>
<span class="k">#check</span> <span class="n">sigma.mk</span> <span class="n">a</span> <span class="n">b</span>      <span class="c1">-- Σ (a : α), β a</span>
</code></pre></div>
<p>I'm having some trouble differentiating these two objects, can anyone enlighten me?</p>



<a name="267374835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267374835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267374835">(Jan 09 2022 at 20:02)</a>:</h4>
<p><span class="user-mention" data-user-id="367659">@ccn</span> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kd">variable</span> <span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">a</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="kd">variable</span> <span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="n">a</span>
<span class="kd">variable</span> <span class="n">b'</span> <span class="o">:</span> <span class="n">β</span> <span class="n">a'</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>            <span class="c1">-- (a, b) : α × β a</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">a'</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>           <span class="c1">-- (a', b) : α × β a</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">sigma.mk</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">β</span> <span class="n">x</span><span class="o">)</span>      <span class="c1">-- Σ (a : α), β a</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">sigma.mk</span> <span class="n">a'</span> <span class="n">b'</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">β</span> <span class="n">x</span><span class="o">)</span>    <span class="c1">-- Σ (a : α), β a</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">sigma.mk</span> <span class="n">a</span> <span class="n">b'</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">β</span> <span class="n">x</span><span class="o">)</span>     <span class="c1">-- error</span>
</code></pre></div>
<p>The first are non-dependent pairs, so the second element does not depend on the value of the first. The last example shows that sigmas need the second element to have a type determined by the first element.</p>



<a name="267374870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267374870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267374870">(Jan 09 2022 at 20:02)</a>:</h4>
<p><code>(a, b)</code> is another way of calling the constructor of <code>prod</code>, which is <code>prod.mk</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kd">variable</span> <span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="kd">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">variable</span> <span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="n">a</span>

<span class="k">#check</span> <span class="n">prod.mk</span> <span class="n">a</span> <span class="n">b</span>       <span class="c1">-- (a, b) : α × β a</span>
<span class="k">#check</span> <span class="n">sigma.mk</span> <span class="n">a</span> <span class="n">b</span>      <span class="c1">-- Σ (a : α), β a</span>
</code></pre></div>
<p>They (<code>prod</code> and <code>sigma</code>) are different structures, you can ctrl+click on them to see their definitions</p>



<a name="267374896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267374896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267374896">(Jan 09 2022 at 20:03)</a>:</h4>
<p>In principle, the non-dependent pair (the cartesian product) is a sigma type where the second argument does not depend on the first argument, in exactly the same way that the function arrow is a pi type.  However, in Lean <code>prod</code> and <code>sigma</code> are actually different so this is only an analogy.</p>



<a name="267374955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267374955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267374955">(Jan 09 2022 at 20:04)</a>:</h4>
<p>Products could have been defined this way:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">myprod</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">β</span>
</code></pre></div>



<a name="267375168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267375168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267375168">(Jan 09 2022 at 20:07)</a>:</h4>
<p>Ok, so is <code>prod.mk</code>a dependent type too, since you can pass in a second argument which depends on the first?</p>



<a name="267375213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267375213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267375213">(Jan 09 2022 at 20:08)</a>:</h4>
<p><code>prod.mk</code> is a term, not a type</p>



<a name="267375234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267375234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267375234">(Jan 09 2022 at 20:08)</a>:</h4>
<p>Should I have said the type of the term produced by <code>prod.mk a b</code>?</p>



<a name="267375327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267375327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267375327">(Jan 09 2022 at 20:10)</a>:</h4>
<p><code>prod.mk</code> <strong>is</strong> a dependent function</p>



<a name="267375471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267375471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267375471">(Jan 09 2022 at 20:13)</a>:</h4>
<p>Tada:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="bp">@</span><span class="n">prod.mk</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">prod.mk : Π {α : Type u_4} {β : Type u_5}, α → β → α × β</span>
<span class="cm">-/</span>
</code></pre></div>
<p>It's dependent in a very weak way (it's the kind of dependent function that Haskell 98 has, which is type polymorphism).</p>



<a name="267375561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267375561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267375561">(Jan 09 2022 at 20:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267375234">said</a>:</p>
<blockquote>
<p>Should I have said the type of the term produced by <code>prod.mk a b</code>?</p>
</blockquote>
<p>Probably not, since the type of the term produced by <code>prod.mk a b</code> doesn't depend on anything. (Assuming that <code>a</code> and <code>b</code> are some fixed terms.) Also, the second argument does not depend on the first -- notice that the type of <code>prod.mk</code> has independent types <code>α</code> and <code>β</code> for its two explicit arguments.</p>



<a name="267375743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267375743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267375743">(Jan 09 2022 at 20:19)</a>:</h4>
<p>(What I was trying to point out with <code>#check (a', b)</code> earlier is how <code>#check (a, b)</code> is misleading.)</p>



<a name="267376149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267376149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267376149">(Jan 09 2022 at 20:28)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>
<span class="kd">def</span> <span class="n">ident</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x</span>

<span class="kd">variables</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">ident</span>      <span class="c1">-- ?M_1 → ?M_1</span>
<span class="k">#check</span> <span class="n">ident</span> <span class="n">a</span>    <span class="c1">-- α</span>
<span class="k">#check</span> <span class="n">ident</span> <span class="n">b</span>    <span class="c1">-- β</span>

<span class="kd">def</span> <span class="n">ident_v2</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x</span>

<span class="k">#check</span> <span class="n">ident_v2</span>
<span class="k">#check</span> <span class="n">ident_v2</span> <span class="n">a</span>
</code></pre></div>
<p>Why does <code>ident_v2 a</code> cause this problem: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">ident_v2</span> <span class="n">a</span>
<span class="n">term</span>
  <span class="n">a</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="kt">Type</span> <span class="bp">?</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="bp">?+</span><span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>Shouldn't it be ok since <code>a</code> is of the type <code>α</code>?</p>



<a name="267376484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267376484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267376484">(Jan 09 2022 at 20:36)</a>:</h4>
<p>What was the output of <code>#check ident_v2</code>?</p>



<a name="267376490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267376490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267376490">(Jan 09 2022 at 20:36)</a>:</h4>
<p>The first parameter that <code>ident_v2</code> expects is the type of the second parameter</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="n">ident_v2</span> <span class="n">α</span> <span class="n">a</span> <span class="c1">-- ident_v2 α a : α</span>
</code></pre></div>
<p>You can see it here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="n">ident_v2</span> <span class="c1">-- def ident_v2 : Π (α : Type u), α → α := λ (α : Type u) (x : α), x</span>
</code></pre></div>



<a name="267376518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267376518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267376518">(Jan 09 2022 at 20:37)</a>:</h4>
<p>This should fix it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
</code></pre></div>
<p>That way alpha will be an implicit argument.</p>



<a name="267376586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267376586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267376586">(Jan 09 2022 at 20:38)</a>:</h4>
<p><code>variables</code> aren't fixed, they turn into extra arguments of definitions. In this case, the argument is explicit because of the way <code>α</code> was declared. So you need to pass it explicitly to use <code>ident_v2</code>.</p>



<a name="267818203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267818203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267818203">(Jan 13 2022 at 03:07)</a>:</h4>
<p>Can anyone provide a concrete example of when a Pi type is used? I'm still having some trouble grasping it. Thanks!</p>



<a name="267818569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267818569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267818569">(Jan 13 2022 at 03:12)</a>:</h4>
<p>Ok, here's an example of one: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">modus_ponens</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="n">Proof</span> <span class="o">(</span><span class="n">implies</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span>  <span class="n">Proof</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">Proof</span> <span class="n">q</span>
</code></pre></div>
<p>So would this be the type of functions f where giving the arguments p and q, then then <code>f p q</code> has the type <code> Proof (implies p q) →  Proof p → Proof q</code></p>
<p>Does it mean pretty much that this is a "template" where if you give two propositions, you get a proof of modeus_ponens for those specific <code>Props</code> p and q ?</p>



<a name="267835123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267835123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267835123">(Jan 13 2022 at 08:05)</a>:</h4>
<p>The statement of Fermat's Last Theorem is a pi type.</p>



<a name="267835145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267835145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267835145">(Jan 13 2022 at 08:05)</a>:</h4>
<p>Because the equation depends on the input variables</p>



<a name="267835824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267835824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267835824">(Jan 13 2022 at 08:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">ccn</span> <a href="#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267818569">said</a>:</p>
<blockquote>
<p>Does it mean pretty much that this is a "template" where if you give two propositions, you get a proof of modeus_ponens for those specific <code>Props</code> p and q ?</p>
</blockquote>
<p>I'm not sure if thinking about them as "templates" is really helpful. <br>
The parameters <code>p</code> and <code>q</code> are just "normal" parameters, too. The only difference is that all the other parameters (after the comma) are allowed to reference <code>p</code> and <code>q</code>.<br>
Perhaps this example motivates this better:</p>
<p><code>array</code> is a type of fixed length arrays (like a list, but with an additional parameter in the type that constrains the size of the array):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="n">array</span> <span class="c1">--  ℕ → Type u → Type u</span>
<span class="k">#check</span> <span class="n">array</span> <span class="mi">10</span> <span class="n">nat</span> <span class="c1">-- Type u</span>

<span class="c1">-- for comparison:</span>
<span class="k">#check</span> <span class="n">list</span> <span class="c1">--  Type u → Type u</span>
<span class="k">#check</span> <span class="n">list</span> <span class="n">nat</span> <span class="c1">-- Type u</span>
</code></pre></div>
<p>Let's say you want to define a function that returns the last item in a given array of integers of length 10:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">array.last</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">array</span> <span class="mi">10</span> <span class="n">int</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span> <span class="o">:=</span>
  <span class="n">a.read</span> <span class="mi">9</span>
</code></pre></div>
<p>Obviously it would would be nice to write this function more generically for all lengths. So we add a parameter <code>n</code> for the length:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">array.last</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">array</span> <span class="n">n</span> <span class="n">int</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span> <span class="o">:=</span>
  <span class="n">a.read</span> <span class="n">n</span><span class="bp">-</span><span class="mi">1</span> <span class="c1">-- this wouldn't actually work exactly like this, but for the example it's ok</span>
</code></pre></div>
<p>This is now a dependent function, as the type of <code>a</code> depends on the value <code>n</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="n">array.last</span> <span class="c1">-- Π (n : ℕ), array n int → int</span>
</code></pre></div>
<p>But as you can see <code>n</code> is still just a regular parameter. In fact, we use it in the body of the function.</p>



<a name="267841814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20Type%20Theory%20Section/near/267841814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section.html#267841814">(Jan 13 2022 at 09:16)</a>:</h4>
<p>(it's irrelevant for the example, but you want <code>a.read (n-1)</code> instead of <code>a.read n-1</code>)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
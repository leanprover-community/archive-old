---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/TPIL.20Chapter.207.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html">TPIL Chapter 7</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="190544119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190544119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rocky Kamen-Rubio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190544119">(Mar 13 2020 at 19:20)</a>:</h4>
<ol>
<li>I'm running into type issues with inductively defined types that Lean already has defined. For example, when I try running the code from the book below, I get an error in add_zero that n is of type N but type nat is expected. </li>
</ol>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">nat</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span>

<span class="kn">namespace</span> <span class="n">nat</span>
<span class="n">def</span> <span class="n">add</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span> <span class="n">m</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">add_m_n</span><span class="o">,</span> <span class="n">succ</span> <span class="n">add_m_n</span><span class="o">)</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">add</span> <span class="o">(</span><span class="n">succ</span> <span class="n">zero</span><span class="o">)</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="n">zero</span><span class="o">))</span>


<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">has_zero</span><span class="bp">.</span><span class="n">mk</span> <span class="n">zero</span> <span class="c1">--instance is explained in ch 10</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">has_add</span><span class="bp">.</span><span class="n">mk</span> <span class="n">add</span>

<span class="kn">theorem</span> <span class="n">add_zero</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">theorem</span> <span class="n">add_succ</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">--this is how we defined addition</span>


<span class="kn">theorem</span> <span class="n">zero_add</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span>
  <span class="o">(</span><span class="k">show</span> <span class="mi">0</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">)</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">ih</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">show</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span>
      <span class="k">calc</span>
        <span class="mi">0</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
          <span class="bp">...</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">n</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">ih</span><span class="o">)</span>


<span class="kn">end</span> <span class="n">nat</span>
</pre></div>


<p>Similarly, when I define <code>bool</code>I get the same error when I do <code>bool.cases_on</code></p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">empty</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kn">inductive</span> <span class="n">unit</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">:</span> <span class="n">unit</span>
<span class="kn">inductive</span> <span class="n">bool</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">ff</span> <span class="o">:</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">tt</span> <span class="o">:</span> <span class="n">bool</span>

<span class="c1">--EXERCISE: Define band bor bnot on this new bool type</span>

<span class="n">def</span> <span class="n">band</span> <span class="o">(</span><span class="n">b1</span> <span class="n">b2</span> <span class="o">:</span> <span class="n">hidden</span><span class="bp">.</span><span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">hidden</span><span class="bp">.</span><span class="n">bool</span> <span class="o">:=</span>
<span class="n">bool</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">b1</span> <span class="n">ff</span> <span class="n">b2</span>

<span class="n">def</span> <span class="n">bor</span> <span class="o">(</span><span class="n">b1</span> <span class="n">b2</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span>
<span class="n">bool</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">b1</span> <span class="n">b2</span> <span class="n">tt</span>

<span class="n">def</span> <span class="n">bnot</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span>
<span class="n">bool</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">b</span> <span class="n">tt</span> <span class="n">ff</span>
</pre></div>


<p>The same issue comes up when I do <code>sum</code> and <code>prod</code> from the book. I've been copying over the text from the book, and have imported <code>data.nat.basic</code> and <code>tactic</code></p>



<a name="190544304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190544304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190544304">(Mar 13 2020 at 19:21)</a>:</h4>
<p>Try adding <code>namespace mydefs</code> before your code and <code>end mydefs</code> after your code. That should help Lean disambiguate the names.</p>



<a name="190544418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190544418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190544418">(Mar 13 2020 at 19:22)</a>:</h4>
<p>Choosing different names is also a very efficient way to disambiguate.</p>



<a name="190544936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190544936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190544936">(Mar 13 2020 at 19:27)</a>:</h4>
<p>Note that in <code>zero_add</code>, <code>ℕ</code> is notation for the built-in <code>nat</code> (<code>_root_.nat</code>), so it fails.</p>



<a name="190545113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190545113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190545113">(Mar 13 2020 at 19:29)</a>:</h4>
<p>Not sure why the <code>show</code> fails, but this works:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">zero_add</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span>
  <span class="o">(</span><span class="n">rfl</span><span class="o">)</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">ih</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">show</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">=</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span><span class="o">,</span> <span class="k">from</span>
      <span class="k">calc</span>
        <span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:</span> <span class="n">rfl</span>
          <span class="bp">...</span> <span class="bp">=</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">ih</span><span class="o">)</span>
</pre></div>



<a name="190545956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190545956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rocky Kamen-Rubio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190545956">(Mar 13 2020 at 19:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190544936" title="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190544936">said</a>:</p>
<blockquote>
<p>Note that in <code>zero_add</code>, <code>ℕ</code> is notation for the built-in <code>nat</code> (<code>_root_.nat</code>), so it fails.</p>
</blockquote>
<p>Interesting, yeah I'm also getting that it fails when I use show but not when I just use <code>(rfl)</code> like you are.</p>



<a name="190546755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190546755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rocky Kamen-Rubio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190546755">(Mar 13 2020 at 19:44)</a>:</h4>
<p>I'm also getting an error on the <code>#check</code> term at the end when I try to do </p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">list</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="bp">→</span> <span class="n">list</span>

<span class="kn">namespace</span> <span class="n">list</span>
<span class="kn">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
<span class="kn">notation</span> <span class="n">h</span> <span class="bp">::</span> <span class="n">t</span>  <span class="o">:=</span> <span class="n">cons</span> <span class="n">h</span> <span class="n">t</span>
<span class="n">def</span> <span class="n">append</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">list</span><span class="bp">.</span><span class="n">rec</span> <span class="n">t</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">l</span> <span class="n">u</span><span class="o">,</span> <span class="n">x</span><span class="bp">::</span><span class="n">u</span><span class="o">)</span> <span class="n">s</span>
<span class="kn">notation</span> <span class="n">s</span> <span class="bp">++</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">append</span> <span class="n">s</span> <span class="n">t</span>
<span class="kn">theorem</span> <span class="n">nil_append</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">nil</span> <span class="bp">++</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">theorem</span> <span class="n">cons_append</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span><span class="bp">::</span><span class="n">s</span> <span class="bp">++</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">::</span><span class="o">(</span><span class="n">s</span> <span class="bp">++</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">notation</span> <span class="err">&#39;</span><span class="o">[</span><span class="err">&#39;</span> <span class="n">l</span><span class="o">:(</span><span class="n">foldr</span> <span class="err">&#39;</span><span class="o">,</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">h</span> <span class="n">t</span><span class="o">,</span> <span class="n">cons</span> <span class="n">h</span> <span class="n">t</span><span class="o">)</span> <span class="n">nil</span><span class="o">)</span> <span class="err">&#39;</span><span class="o">]</span><span class="err">&#39;</span> <span class="o">:=</span> <span class="n">l</span>

<span class="bp">#</span><span class="kn">check</span> <span class="o">([</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">)</span>

<span class="c1">--EDIT: It only happens when I open a new section like this</span>
<span class="kn">section</span>
    <span class="kn">open</span> <span class="n">nat</span>
    <span class="bp">#</span><span class="kn">check</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
    <span class="bp">#</span><span class="kn">check</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℤ</span>
<span class="kn">end</span>
</pre></div>



<a name="190799779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190799779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rocky Kamen-Rubio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190799779">(Mar 17 2020 at 01:23)</a>:</h4>
<p>I'm very confused by the exercises suggested at the end of section 7.2. They read</p>
<div class="codehilite"><pre><span></span><span class="n">As</span> <span class="n">exercises</span><span class="o">,</span> <span class="n">we</span> <span class="n">encourage</span> <span class="n">you</span> <span class="n">to</span> <span class="n">develop</span> <span class="n">a</span> <span class="n">notion</span> <span class="n">of</span> <span class="n">composition</span> <span class="n">for</span> <span class="n">partial</span> <span class="n">functions</span> <span class="k">from</span> <span class="n">α</span> <span class="n">to</span> <span class="n">β</span> <span class="n">and</span> <span class="n">β</span> <span class="n">to</span> <span class="n">γ</span><span class="o">,</span> <span class="n">and</span> <span class="k">show</span> <span class="n">that</span> <span class="n">it</span> <span class="n">behaves</span> <span class="n">as</span> <span class="n">expected</span><span class="bp">.</span> <span class="n">We</span> <span class="n">also</span> <span class="n">encourage</span> <span class="n">you</span> <span class="n">to</span> <span class="k">show</span> <span class="n">that</span> <span class="n">bool</span> <span class="n">and</span> <span class="n">nat</span> <span class="n">are</span> <span class="n">inhabited</span><span class="o">,</span> <span class="n">that</span> <span class="n">the</span> <span class="n">product</span> <span class="n">of</span> <span class="n">two</span> <span class="n">inhabited</span> <span class="n">types</span> <span class="n">is</span> <span class="n">inhabited</span><span class="o">,</span> <span class="n">and</span> <span class="n">that</span> <span class="n">the</span> <span class="n">type</span> <span class="n">of</span> <span class="n">functions</span> <span class="n">to</span> <span class="n">an</span> <span class="n">inhabited</span> <span class="n">type</span> <span class="n">is</span> <span class="n">inhabited</span><span class="bp">.</span>

<span class="kn">inductive</span> <span class="n">option</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">none</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">option</span>
<span class="bp">|</span> <span class="n">some</span>    <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span>

<span class="kn">inductive</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">inhabited</span>
</pre></div>


<p>For the inhabited type, I understand conceptually that given an example of an instance of a type, we could generate an object that says this type is inhabited. I'm at a loss for how to actually do something like <code>define inhabited_example ...</code> the we the book does for sum and prod. </p>
<p>For option, I'm substantially more confused. It seems like option would go from a given element of the domain to either none or to a defined function, not the other way around. I feel like I'm misunderstanding something about what it means to have a recursively defined type.</p>



<a name="190801100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190801100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190801100">(Mar 17 2020 at 01:50)</a>:</h4>
<p><code>option A</code> is a type which has one more element than <code>A</code>. The extra element is called <code>none : option A</code>, and the function that maps <code>A</code> into <code>option A</code> is called <code>some : A -&gt; option A</code>.</p>



<a name="190801192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190801192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190801192">(Mar 17 2020 at 01:53)</a>:</h4>
<p>Can you prove</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>



<a name="190802208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190802208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rocky Kamen-Rubio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190802208">(Mar 17 2020 at 02:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190801192" title="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190801192">said</a>:</p>
<blockquote>
<p>Can you prove</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


</blockquote>
<p>I'm not sure... If we have proofs that A and B and inhabited, it makes sense me that <code>A x B</code> would be inhabited. My intuition is to apply <code>inhabited.mk</code> to the product of the two instances we have, but that gives me a type error (understandably). Is there a way to extract the actual instance from an <code>inhabited</code> object so we can use it to make a new one?</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">inhabited</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">h1</span> <span class="bp">×</span> <span class="n">h2</span><span class="o">)</span>
</pre></div>



<a name="190802713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190802713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190802713">(Mar 17 2020 at 02:34)</a>:</h4>
<p>(deleted, I was using Lean's definition of inhabited, not the one given by TPiL...)</p>



<a name="190803827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190803827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190803827">(Mar 17 2020 at 03:03)</a>:</h4>
<p>One way is to use the <code>match ... with ... end</code> syntax:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">h1</span><span class="o">,</span> <span class="n">h2</span> <span class="k">with</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">inhabited</span><span class="bp">.</span><span class="n">mk</span> <span class="n">a</span><span class="o">),</span> <span class="o">(</span><span class="n">inhabited</span><span class="bp">.</span><span class="n">mk</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">mk</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="bp">⟩</span>
<span class="kn">end</span>
</pre></div>


<p>This syntax "pattern matches" on <code>h1</code> and <code>h2</code> to pull out <code>a : A</code> and <code>b : B</code>.</p>
<p>You can also use angle brackets in place of the constructors like this:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">h1</span><span class="o">,</span> <span class="n">h2</span> <span class="k">with</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">a</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">b</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="bp">⟩⟩</span>
<span class="kn">end</span>
</pre></div>



<a name="190803999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190803999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190803999">(Mar 17 2020 at 03:07)</a>:</h4>
<p>Compare also:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="bp">⟨</span><span class="n">a</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">h1</span> <span class="k">in</span>
<span class="k">let</span> <span class="bp">⟨</span><span class="n">b</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">h2</span> <span class="k">in</span>
<span class="bp">⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="bp">⟩⟩</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">inhabited</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">a</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">b</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="bp">⟩⟩</span>
</pre></div>



<a name="190805054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190805054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190805054">(Mar 17 2020 at 03:29)</a>:</h4>
<p>Oh, pattern-matching is introduced in chapter 8, so I guess you're meant  to use <code>inhabited.cases_on</code> instead. Here's a hint:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">inhabited</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">h1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">h2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="bp">_</span><span class="o">))</span>
</pre></div>


<p>[I was hoping this would work with dot notation (so I could write <code>h1.cases_on</code> and <code>h2.cases_on</code> instead of <code>inhabited.cases_on h1</code>, etc.) but it looks like that's too much for the elaborator...]</p>



<a name="190939609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190939609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rocky Kamen-Rubio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190939609">(Mar 18 2020 at 05:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190805054" title="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190805054">said</a>:</p>
<blockquote>
<p>Oh, pattern-matching is introduced in chapter 8, so I guess you're meant  to use <code>inhabited.cases_on</code> instead. Here's a hint:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">inhabited</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">h1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">h2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="bp">_</span><span class="o">))</span>
</pre></div>


<p>[I was hoping this would work with dot notation (so I could write <code>h1.cases_on</code> and <code>h2.cases_on</code> instead of <code>inhabited.cases_on h1</code>, etc.) but it looks like that's too much for the elaborator...]</p>
</blockquote>
<p>Thanks for your detailed answer! I'm getting a "don't know how to synthesize placeholder<br>
context:" error on the wildecard. Is there something I need to import somewhere? I'm also still a little confused conceptually by how this works but maybe that'll be cleared up after reading chapter 8.</p>



<a name="190939723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190939723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rocky Kamen-Rubio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190939723">(Mar 18 2020 at 05:07)</a>:</h4>
<p>I think part of my confusion comes from the fact that all the solutions you gave rely on implicit notation using either brackets or wildcards. Is there an explicit way to show a type is inhabited, or is that not the way I should be thinking about this problem?</p>



<a name="190939865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190939865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190939865">(Mar 18 2020 at 05:12)</a>:</h4>
<blockquote>
<p>I'm getting a "don't know how to synthesize placeholder context:" error on the wildecard.</p>
</blockquote>
<p>That's right, the underscore was left for you to fill in. <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span> </p>
<blockquote>
<p>Is there something I need to import somewhere?</p>
</blockquote>
<p>No imports necessary!</p>
<blockquote>
<p>Is there an explicit way to show a type is inhabited</p>
</blockquote>
<p>Yep, in this context, <code>⟨⟨a, b⟩⟩</code> is just shorthand for to <code>inhabited.mk (prod.mk a b)</code>.</p>



<a name="190939929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190939929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rocky Kamen-Rubio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190939929">(Mar 18 2020 at 05:14)</a>:</h4>
<p>Oh, that makes sense haha. I thought you were intentionally leaving it as a wildcard. This is very helpful, thank you!</p>



<a name="190941372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rocky Kamen-Rubio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190941372">(Mar 18 2020 at 05:56)</a>:</h4>
<p>Ok I'm still a little confused about how <code>option</code> works. I'm trying to define a simple function that is the identity on 0 and 1, and undefined everywhere else. I'm getting a type mismatch error on all three <code>:=</code> signs when I do the following. Any thoughts?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">partial</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">option</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">some</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">some</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">none</span>
</pre></div>



<a name="190941519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190941519">(Mar 18 2020 at 06:01)</a>:</h4>
<p>it does not give any error for me.</p>



<a name="190941706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190941706">(Mar 18 2020 at 06:06)</a>:</h4>
<p>Rocky's using the <code>option</code> defined in TPiL, so the full code is something like this:</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">blah</span>
<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">inductive</span> <span class="n">option</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">none</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">option</span>
<span class="bp">|</span> <span class="n">some</span>    <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span>


<span class="n">def</span> <span class="n">partial</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">option</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">some</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">some</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">none</span>

<span class="kn">end</span> <span class="n">blah</span>
</pre></div>



<a name="190941716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190941716">(Mar 18 2020 at 06:06)</a>:</h4>
<p><del>The solution is to add <code>open option</code> before <code>def partial</code>.</del></p>
<p>This works:</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">blah</span>
<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">inductive</span> <span class="n">option</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">none</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">option</span>
<span class="bp">|</span> <span class="n">some</span>    <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span>

<span class="n">def</span> <span class="n">partial</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">option</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">some</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">some</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">none</span>

<span class="kn">end</span> <span class="n">blah</span>
</pre></div>



<a name="190941794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rocky Kamen-Rubio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190941794">(Mar 18 2020 at 06:08)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span>  for catching that! Adding <code>open option</code> doesn't seem to resolve this issue. Leaving the namespace and using lean's default <code>option</code> does work though. I thought the two definitions were the same here... is that not the case?</p>



<a name="190941805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rocky Kamen-Rubio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190941805">(Mar 18 2020 at 06:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190941716" title="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190941716">said</a>:</p>
<blockquote>
<p><del>The solution is to add <code>open option</code> before <code>def partial</code>.</del></p>
<p>This works:</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">blah</span>
<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">inductive</span> <span class="n">option</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">none</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">option</span>
<span class="bp">|</span> <span class="n">some</span>    <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span>

<span class="n">def</span> <span class="n">partial</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">option</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">some</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">some</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">none</span>

<span class="kn">end</span> <span class="n">blah</span>
</pre></div>


</blockquote>
<p>That did the trick. Thank you!</p>



<a name="190941884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190941884">(Mar 18 2020 at 06:11)</a>:</h4>
<p>Yeah, it wasn't <code>open option</code> that worked but rather surrounding <code>def partial</code> with <code>namespace option</code> and <code>end option</code> (or writing the names out fully as I did above).</p>



<a name="190941932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190941932">(Mar 18 2020 at 06:12)</a>:</h4>
<p>The <code>option</code> provided by Lean's core library is equivalent, but you can't use it when Lean is expecting your <code>option</code>.</p>



<a name="190941986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rocky Kamen-Rubio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190941986">(Mar 18 2020 at 06:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190941932" title="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190941932">said</a>:</p>
<blockquote>
<p>The <code>option</code> provided by Lean's core library is equivalent, but you can't use it when Lean is expecting your <code>option</code>.</p>
</blockquote>
<p>Makes sense. This has come up before when TPIL makes you define types that are built in and I've forgotten that the interactions are a little different. Thanks!</p>



<a name="190941987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rocky Kamen-Rubio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190941987">(Mar 18 2020 at 06:14)</a>:</h4>
<p>Another question: I'm trying to define the composite of partial functions also discussed in this section. I have this so far, and am (understandably) running into an error when I try to apply <code>g</code> to <code>(f a)</code> because it is an element of <code>option β</code> rather than <code>β</code>. Is there an easy way to convert back from an option type to the element of the regular type?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">compose_partials</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span>  <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">option</span><span class="bp">.</span><span class="n">cases_on</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)))</span> <span class="o">(</span><span class="n">none</span><span class="o">)</span>
</pre></div>



<a name="190942392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190942392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190942392">(Mar 18 2020 at 06:27)</a>:</h4>
<p><del>I think you might need a helper function like this:</del></p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">helper</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">option</span> <span class="n">α</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">option</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">))</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">x</span>
<span class="bp">|</span> <span class="bp">_</span>               <span class="o">:=</span> <span class="n">none</span>
</pre></div>


<p><del>I don't think there is a way to have a function where<code>f : option a -&gt; a</code> in Lean, since <code>f none</code> would require you to be able to make a value of type <code>a</code> for all <code>a</code>.</del></p>
<p><del>In other languages (Haskell, etc.) there is what you're looking for, but they crash on the case <code>f none</code>.</del></p>
<p>Nevermind.</p>



<a name="190942608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190942608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190942608">(Mar 18 2020 at 06:31)</a>:</h4>
<p>This works:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">compose_partials</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">option</span><span class="bp">.</span><span class="n">cases_on</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="n">none</span> <span class="n">g</span>
</pre></div>


<p>I think maybe you were thrown off by having <code>none</code> in the wrong slot.</p>



<a name="190946023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190946023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#190946023">(Mar 18 2020 at 07:38)</a>:</h4>
<p>I think this is called <code>bind</code> and it's basically the proof that <code>option</code> is a monad</p>



<a name="191068324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191068324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rocky Kamen-Rubio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#191068324">(Mar 19 2020 at 03:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190942608" title="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190942608">said</a>:</p>
<blockquote>
<p>This works:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">compose_partials</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">option</span><span class="bp">.</span><span class="n">cases_on</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="n">none</span> <span class="n">g</span>
</pre></div>


<p>I think maybe you were thrown off by having <code>none</code> in the wrong slot.</p>
</blockquote>
<p>Wouldn't this just give us the function g in the case that a is in the domain of f, and not the element that g maps (f a) to? Or am I missing something?</p>



<a name="191068428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191068428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rocky Kamen-Rubio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#191068428">(Mar 19 2020 at 03:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="266440">Shing Tak Lam</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190942392" title="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190942392">said</a>:</p>
<blockquote>
<p><del>I think you might need a helper function like this:</del></p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">helper</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">option</span> <span class="n">α</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">option</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">))</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">x</span>
<span class="bp">|</span> <span class="bp">_</span>               <span class="o">:=</span> <span class="n">none</span>
</pre></div>


<p><del>I don't think there is a way to have a function where<code>f : option a -&gt; a</code> in Lean, since <code>f none</code> would require you to be able to make a value of type <code>a</code> for all <code>a</code>.</del></p>
<p><del>In other languages (Haskell, etc.) there is what you're looking for, but they crash on the case <code>f none</code>.</del></p>
<p>Nevermind.</p>
</blockquote>
<p>That makes sense. The notation for more abstract recursive types like this still makes my head hurt a little, but I feel like that will probably get better with time.</p>



<a name="191068759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191068759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#191068759">(Mar 19 2020 at 03:26)</a>:</h4>
<p>It might help to see the definition expanded as <code>λ a : α, option.cases_on (f a) none (λ b, g b)</code></p>



<a name="191068857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191068857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rocky Kamen-Rubio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#191068857">(Mar 19 2020 at 03:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/191068759" title="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/191068759">said</a>:</p>
<blockquote>
<p>It might help to see the definition expanded as <code>λ a : α, option.cases_on (f a) none (λ b, g b)</code></p>
</blockquote>
<p>Using a helper function and reversing the order of the arguments to <code>option (f a) _ _</code> I still get two errors. </p>
<p>That makes sense to me. Does <code>cases_on</code> do that automatically with the notation <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span>  gave?</p>



<a name="191068929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191068929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#191068929">(Mar 19 2020 at 03:30)</a>:</h4>
<p>I don't understand your question. But <code>g</code> equals <code>λ b, g b</code>.</p>



<a name="191069073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191069073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rocky Kamen-Rubio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#191069073">(Mar 19 2020 at 03:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/191068929" title="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/191068929">said</a>:</p>
<blockquote>
<p>I don't understand your question. But <code>g</code> equals <code>λ b, g b</code>.</p>
</blockquote>
<p>Oh duh, yeah I was just getting a little lost in what was taking in what and going where with <code>cases_on</code>. Yeah that makes sense now. </p>
<p><span class="user-mention" data-user-id="266440">@Shing Tak Lam</span>  I tried doing something like this and got rid of the return type error but I'm getting type mismatches in my helper function and at <code>option.cases_on</code></p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">helper</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">input</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">):</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">some</span> <span class="n">x</span>
<span class="bp">|</span> <span class="n">some</span> <span class="n">x</span> <span class="o">:</span> <span class="n">x</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:</span> <span class="n">none</span>

<span class="n">def</span> <span class="n">compose_partials</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span>  <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">option</span><span class="bp">.</span><span class="n">cases_on</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="n">none</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">helper</span> <span class="o">(</span><span class="n">g</span> <span class="n">b</span><span class="o">))</span>
</pre></div>



<a name="191070850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191070850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#191070850">(Mar 19 2020 at 04:25)</a>:</h4>
<p><span class="user-mention" data-user-id="260106">@Rocky Kamen-Rubio</span> </p>
<p>Nevermind what I said previously. I didn't look at it properly. (I never did TPIL). So I did it with <code>option.map</code> instead of <code>option.cases_on</code>.</p>
<p>Sorry for any confusion</p>



<a name="191079092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191079092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#191079092">(Mar 19 2020 at 07:48)</a>:</h4>
<p><span class="user-mention" data-user-id="261068">@ROCKY KAMEN-RUBIO</span> your helper definition does not look good to me. What is the type of x supposed to be in some (some x)? You say you're getting type mismatches but if you just read them carefully they will tell you by themselves the errors you made</p>



<a name="191079147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191079147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#191079147">(Mar 19 2020 at 07:49)</a>:</h4>
<p>You do understand that alpha and option alpha are completely different types, right?</p>



<a name="191079217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191079217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#191079217">(Mar 19 2020 at 07:50)</a>:</h4>
<p>There is no natural helper map of the kind you're trying to define because where is none going to go? Alpha could be empty</p>



<a name="191079327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191079327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#191079327">(Mar 19 2020 at 07:52)</a>:</h4>
<p>Maybe you should take a look at learnyouahaskell? This taught me a lot about functional programming</p>



<a name="191079798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191079798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#191079798">(Mar 19 2020 at 07:58)</a>:</h4>
<p>Given the type of <code>compose_partials</code>, it looks like the right thing to put in the location of <code>helper</code> is the identity function</p>



<a name="191082205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191082205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#191082205">(Mar 19 2020 at 08:31)</a>:</h4>
<p><span class="user-mention" data-user-id="260106">@Rocky Kamen-Rubio</span> </p>
<p>The <code>helper</code> function I posted is</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">helper</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">option</span> <span class="n">α</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">option</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">))</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">x</span>
<span class="bp">|</span> <span class="bp">_</span>               <span class="o">:=</span> <span class="n">none</span>
</pre></div>


<p>The one you posted is below</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">helper</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">input</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">):</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">some</span> <span class="n">x</span>
<span class="bp">|</span> <span class="n">some</span> <span class="n">x</span> <span class="o">:</span> <span class="n">x</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:</span> <span class="n">none</span>
</pre></div>


<p>Notice how mine is <code>option (option α) -&gt; option α</code>, while yours is <code>option α -&gt; α</code>. That is why the first case from mine <code>(some (some x)) := some x</code> doesn't apply for you, as the left hand side <code>(some (some x))</code> has the type <code>option (option α)</code>, not <code>option α</code>. Also, the parenthesis matter here, as when used to pattern match, <code>(some (some x))</code> and <code>some (some x)</code> are different.</p>
<p>Additionally, there is a syntax error there, it should be <code>:=</code> in the cases.</p>
<p>Also notice the types of your cases do not match, as the first one is <code>option (option α) -&gt; option α</code>, the second one is <code>option α -&gt; α</code>, the last one is <code>option α -&gt; option ???</code>. So lean complains that all of them have different types.</p>
<p>The helper function was when I solved it with <code>option.map</code>, and <code>option.cases_on</code> expects a different function, so that's why you're getting an error there. <code>option.map</code> would produce a <code>option (option α)</code>, which is why I needed the <code>helper</code> function, as for this example, <code>some (none)</code> is pragmatically the same as <code>none</code>, so I use <code>_</code> to catch both cases.</p>
<p>Sorry for any confusion caused</p>



<a name="254179407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/254179407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Teixeira <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#254179407">(Sep 21 2021 at 09:39)</a>:</h4>
<p>I'm having a some issues understanding how the book's definition of natural number addition works.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kd">inductive</span> <span class="n">myNat</span> <span class="o">:</span> <span class="kt">Type</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">myNat</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">myNat</span> <span class="bp">→</span> <span class="n">myNat</span>

<span class="kd">def</span> <span class="n">add</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span><span class="o">:</span> <span class="n">myNat</span><span class="o">)</span> <span class="o">:</span> <span class="n">myNat</span> <span class="o">:=</span>
  <span class="n">myNat.rec_on</span> <span class="n">m</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">add_m_n</span><span class="o">,</span> <span class="n">myNat.succ</span> <span class="n">add_m_n</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">hidden</span>
</code></pre></div>
<p>My understanding of addition in peano arithmetic is the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">=</span> <span class="n">n</span>
<span class="o">(</span><span class="n">m</span><span class="bp">++</span><span class="o">)</span> <span class="bp">+</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span><span class="bp">++</span>
</code></pre></div>
<p>I 'm a little confused on the mechanics of rec_on and how add_m_n is evaluated as m + n</p>



<a name="254180832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/254180832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Teixeira <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#254180832">(Sep 21 2021 at 09:51)</a>:</h4>
<p>Also, this type reading</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="bp">@</span><span class="n">nat.rec_on</span>

<span class="bp">Π</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
  <span class="n">C</span> <span class="n">nat.zero</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">a</span><span class="o">))</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">n</span>
</code></pre></div>
<p>is completely opaque to me</p>



<a name="254181207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/254181207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#254181207">(Sep 21 2021 at 09:54)</a>:</h4>
<p>This is exactly what this definition is doing. <code>myNat.rec_on</code> takes in</p>
<ul>
<li>The variable to recurse on: <code>m</code></li>
<li>The value you want to output when the variable is <code>0</code>: <code>n</code> because <code>0 + n = n</code></li>
<li>The value you want to output when the variable is <code>succ a</code> given the value for <code>a</code>:  <code>succ (a + n)</code> because <code>succ a + n = succ (a + n)</code>.</li>
</ul>



<a name="254181289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/254181289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#254181289">(Sep 21 2021 at 09:55)</a>:</h4>
<p>Maybe it's a bit clearer if you write it</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">myNat</span> <span class="o">:</span> <span class="kt">Type</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">myNat</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">myNat</span> <span class="bp">→</span> <span class="n">myNat</span>

<span class="kd">def</span> <span class="n">add</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span><span class="o">:</span> <span class="n">myNat</span><span class="o">)</span> <span class="o">:</span> <span class="n">myNat</span> <span class="o">:=</span>
  <span class="n">myNat.rec_on</span> <span class="n">m</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">add_a_n</span><span class="o">,</span> <span class="n">myNat.succ</span> <span class="n">add_a_n</span><span class="o">)</span>
</code></pre></div>
<p>to make clear those two <code>m</code> don't have the same meaning.</p>



<a name="254182182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/254182182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#254182182">(Sep 21 2021 at 10:02)</a>:</h4>
<p>The point of a recursor of an inductive type <code>α</code> is to define a function <code>α → β</code>. To define a function from <code>α</code>, you only need to define that function for every constructor of <code>α</code>. <code>nat</code> has two constructors: <code>zero</code> and<code>succ</code>, so to define <code>C : nat → Type*</code> you only need to define <code>C 0</code> and <code>C a → C (nat.succ a)</code>  for all <code>a</code>. This is exactly what <code>nat.rec_on</code> does:<br>
<code>Π {C : nat → Type*} (n : nat), C nat.zero → (Π (a : nat), C a → C (nat.succ a)) → C n</code><br>
(<code>Π</code> is a synonym of <code>∀</code> used when you're defining data, but they're the same in practice)<br>
"For all function <code>C</code> from <code>nat</code> to anything,<br>
if I know <code>C 0</code><br>
and if for all <code>a : nat</code> I know <code>C (succ a)</code> from <code>C a</code>,<br>
then I know <code>C n</code> for all <code>n : nat</code>."</p>



<a name="254182293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/254182293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#254182293">(Sep 21 2021 at 10:03)</a>:</h4>
<p>Note that <code>n</code> is bound earlier than in my translation. That's the (only) difference between <code>nat.rec</code> and <code>nat.rec_on</code>: the order of the arguments.</p>



<a name="254184030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/254184030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Teixeira <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#254184030">(Sep 21 2021 at 10:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/254182182">said</a>:</p>
<p>So in the case of add, would <code>add_a_n</code> be the <code>C a</code> in <code>Π {C : nat → Type*} (n : nat), C nat.zero → (Π (a : nat), C a → C (nat.succ a)) → C n</code> ??</p>



<a name="254184466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/254184466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#254184466">(Sep 21 2021 at 10:23)</a>:</h4>
<p>Exactly! It corresponds to the value you already assigned to <code>a + n</code>.</p>



<a name="254187515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/254187515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Teixeira <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#254187515">(Sep 21 2021 at 10:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span><br>
This is starting to make a lot more sense now.</p>
<p>But I'm still a little lost for when exactly I assigned the value of <code>a + n</code>. The type signature seems to take it as an assumption. </p>
<p>I know I assigned <code>zero</code>.<br>
And I know if we recurse on any <code>n ≠ zero</code> we'll eventually hit zero.  <br>
And I understand that since <code>C: myNat → myNat</code> and <code>succ : myNat → myNat</code> <code>C succ</code> doesn't type check and we're required to use <code>C (nat.succ a)</code> where <code>a : myNat</code> and to define this we'd have to know <code>C a</code> for all <code>a</code>.</p>
<p>But I don't see where the proof for <code>C a</code> is actually constructed. Is this the part of a recursive definition where we are defining something in terms of itself?</p>



<a name="254192471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/254192471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#254192471">(Sep 21 2021 at 11:38)</a>:</h4>
<p>Your question boils down to "Where is the <code>n</code> in <code>succ n</code> coming from?". The answer is that <code>succ : nat → nat</code>, so you're given <code>n : nat</code> to get <code>succ n : nat</code>. With <code>C</code>, precisely the same thing happens. You're given <code>a : nat</code> and <code>C a</code> and you must produce <code>C (succ a)</code>.</p>



<a name="254193227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/254193227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#254193227">(Sep 21 2021 at 11:46)</a>:</h4>
<p>You can think of <code>h0 : C 0</code> and <code>hsucc : Π (a : nat), C a → C (succ a)</code> as <em>instructions</em> to compute <code>C</code>.  If I want to compute <code>C 3 = C (succ (succ (succ 0)))</code>, then it will be <code>hsucc 2 (hsucc 1 (hsucc 0 h0)))</code>.</p>



<a name="254197119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/254197119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Teixeira <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#254197119">(Sep 21 2021 at 12:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span><br>
Okay, I think I'm getting it now.</p>
<p>So for the purposes of demonstration let's say that <code>n: nat</code> and <code>n': nat</code></p>
<p>The <code>a</code> in <code>C a</code> in <code>(Π (a : nat), C a → C (nat.succ a))</code> by definition of <code>nat</code> is either <code>zero</code> or <code>succ n': nat</code>. This means that <code>nat.succ a</code> is either <code>nat.succ zero</code> or <code>nat.succ (nat.succ n')</code> respectively.</p>



<a name="254197602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/254197602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#254197602">(Sep 21 2021 at 12:22)</a>:</h4>
<p>I'm not sure that observation is interesting or helpful to your confusion, but it is correct</p>



<a name="255724474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255724474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255724474">(Oct 01 2021 at 10:50)</a>:</h4>
<p>I am trying to understand this more and more, and I am realising that the definition</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="bp">@</span><span class="n">nat.rec_on</span>

<span class="bp">Π</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
  <span class="n">C</span> <span class="n">nat.zero</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">a</span><span class="o">))</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">n</span>
</code></pre></div>
<p>is actually defining a <em>family</em> of types indexed by <code>nat</code>, one <code>C n : Type*</code> for each <code>n : nat</code>(actually, on my pc I see <code>C : nat  → Sort</code>, but this makes no difference for my question). Yet then when I try to understand what goes beyond the following</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">nat.rec_on</span> <span class="n">n</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">nat</span><span class="o">))</span>
</code></pre></div>
<p>(which I intuitively view as the constant function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> defined inductively on <code>n</code>), I am perplexed: how is it possible that Lean accepts  <code>(zero : nat)</code> for the type <code>C zero</code>? I am happy to see types as being terms of <code>Type1</code> but is it also the case that every term like <code>zero : nat </code> is a Type?</p>



<a name="255724724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255724724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255724724">(Oct 01 2021 at 10:52)</a>:</h4>
<p>Welcome! <span aria-label="wave" class="emoji emoji-1f44b" role="img" title="wave">:wave:</span></p>



<a name="255724757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255724757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255724757">(Oct 01 2021 at 10:53)</a>:</h4>
<p>In the case of usual induction <code>C n</code> is of type <code>Prop</code> everywhere. That's how I understand it.</p>



<a name="255724792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255724792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255724792">(Oct 01 2021 at 10:53)</a>:</h4>
<p>I think it's a bit clearer what's going on you write it out with <code>@</code>:</p>
<p><code>def foo (n : nat) : nat := @nat.rec_on (λ _, nat) n (zero : nat) (λ n m, (zero : nat))</code></p>



<a name="255724895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255724895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255724895">(Oct 01 2021 at 10:54)</a>:</h4>
<p>Note that <code>(zero : nat)</code> is not <code>C 0</code>, it's a value of type <code>C 0</code>, i.e., a value of type <code>nat</code></p>



<a name="255725044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255725044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255725044">(Oct 01 2021 at 10:55)</a>:</h4>
<p>(This code also breaks my brain, fwiw)</p>



<a name="255725327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255725327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255725327">(Oct 01 2021 at 10:58)</a>:</h4>
<p>Well, but if <code>C</code> takes values in <code>Type*</code> it cannot take values in <code>nat</code>, right?</p>



<a name="255725357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255725357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255725357">(Oct 01 2021 at 10:58)</a>:</h4>
<p>C is the type of what you're making, so C 0 = nat</p>



<a name="255725391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255725391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255725391">(Oct 01 2021 at 10:58)</a>:</h4>
<p>and <code>nat : Type</code></p>



<a name="255725411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255725411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255725411">(Oct 01 2021 at 10:59)</a>:</h4>
<p>Do you mean <code>C</code> or the value of <code>C</code> at some <code>n : nat</code> is the type of what I am making?</p>



<a name="255725437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255725437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255725437">(Oct 01 2021 at 10:59)</a>:</h4>
<p><code>C</code> is a function that takes a natural number to a type (* Sort)</p>



<a name="255725452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255725452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255725452">(Oct 01 2021 at 10:59)</a>:</h4>
<p>So <code>C 0</code> is a type</p>



<a name="255725470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255725470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255725470">(Oct 01 2021 at 10:59)</a>:</h4>
<p>Ah, ok, and it is <code>nat</code>.</p>



<a name="255725471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255725471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255725471">(Oct 01 2021 at 10:59)</a>:</h4>
<p>Induction in this generality starts with a function C : nat -&gt; Type or C : nat -&gt; Prop, and then proceeds to construct elements of <code>C n</code> for all n from the usual 0 and succ hypotheses</p>



<a name="255725553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255725553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255725553">(Oct 01 2021 at 11:00)</a>:</h4>
<p>In your case, <code>C := λ n, ℕ</code>.</p>



<a name="255725621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255725621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255725621">(Oct 01 2021 at 11:00)</a>:</h4>
<p>Oh, yes, exactly, thanks!</p>



<a name="255725647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255725647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255725647">(Oct 01 2021 at 11:00)</a>:</h4>
<p>If you're constructing data, C is often constant. If you're doing induction then C is never constant, e.g. <code>C n</code> can be the <em>statement</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>i</mi><mo>=</mo><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\sum_{i=1}^ni=n(n+1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span></p>



<a name="255725648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255725648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255725648">(Oct 01 2021 at 11:00)</a>:</h4>
<p>You don't actually need recursion in your case. That may have obscured the situation.</p>



<a name="255725721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255725721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255725721">(Oct 01 2021 at 11:01)</a>:</h4>
<p>Well, no: my point was not to understand how to construct the constant function, but to understand subtleties about <code>rec_on</code>...</p>



<a name="255725796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255725796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255725796">(Oct 01 2021 at 11:02)</a>:</h4>
<p>A case with a non-constant <code>C</code> that I found easier to wrap my head around is <code>vector T n</code>, the lists of length <code>n</code></p>



<a name="255725829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255725829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255725829">(Oct 01 2021 at 11:02)</a>:</h4>
<p>What is your question, based on your revised understanding of <code>C</code>?</p>



<a name="255725905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255725905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255725905">(Oct 01 2021 at 11:03)</a>:</h4>
<p>Well, none any more: I was looking for a revised understanding of <code>C</code> and I got it. So I am happy. Does it count as a question?</p>



<a name="255725960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255725960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255725960">(Oct 01 2021 at 11:03)</a>:</h4>
<p>What makes you happy?</p>



<a name="255725967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255725967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255725967">(Oct 01 2021 at 11:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="307953">Ruben Van de Velde</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/255725796">said</a>:</p>
<blockquote>
<p>A case with a non-constant <code>C</code> that I found easier to wrap my head around is <code>vector T n</code>, the lists of length <code>n</code></p>
</blockquote>
<p>Thanks, I'll think about it.</p>



<a name="255726041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255726041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255726041">(Oct 01 2021 at 11:04)</a>:</h4>
<p>The <code>Sort*</code> thing means "either Prop or Type" i.e. one function which does both induction and recursion</p>



<a name="255726084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255726084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255726084">(Oct 01 2021 at 11:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/255725960">said</a>:</p>
<blockquote>
<p>What makes you happy?</p>
</blockquote>
<p>Basically that I understood my mistake, no? I had not been able to figure out that <code>C := λ n, ℕ</code>.</p>



<a name="255726161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255726161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255726161">(Oct 01 2021 at 11:05)</a>:</h4>
<p>I apologize if my satisfaction is a low hanging fruit... <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="255726270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255726270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255726270">(Oct 01 2021 at 11:06)</a>:</h4>
<p>I also remember being super-confused about all this</p>



<a name="255726340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255726340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255726340">(Oct 01 2021 at 11:06)</a>:</h4>
<p>What is happiness?</p>



<a name="255726530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255726530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255726530">(Oct 01 2021 at 11:08)</a>:</h4>
<p>Well, I don't know if this counts as happiness, but I have tried to insert your suggestion in the code and I got <em>very</em> happy:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="bp">@</span><span class="n">nat.rec_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat</span><span class="o">)</span>
</code></pre></div>
<p>gives</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">nat.rec_on</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">nat</span><span class="o">)</span> <span class="n">zero</span> <span class="bp">→</span>
    <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">ᾰ</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">nat</span><span class="o">)</span> <span class="n">ᾰ</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">nat</span><span class="o">)</span> <span class="n">ᾰ.succ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">nat</span><span class="o">)</span> <span class="n">n</span>
</code></pre></div>



<a name="255726543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255726543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255726543">(Oct 01 2021 at 11:08)</a>:</h4>
<p>And I find it very much clear!</p>



<a name="255726824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255726824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255726824">(Oct 01 2021 at 11:11)</a>:</h4>
<p>No, really: I was always a bit perplexed of the syntax of the second term of an inductively defined gadget, which goes as <code>(λ n m, (zero : nat))</code> whereas I would have thought that <code>(λ m, (zero : nat))</code> to mean "if <code>n = succ m</code>, then send it to <code>zero</code>" would have been more reasonable. But with the above code it is clear that the lambda expression must also contain <code>n</code>.</p>



<a name="255730562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255730562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255730562">(Oct 01 2021 at 11:47)</a>:</h4>
<p>You can also do:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">type_of</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">α</span>
<span class="k">#reduce</span> <span class="n">type_of</span> <span class="o">(</span><span class="bp">@</span><span class="n">nat.rec_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat</span><span class="o">))</span>  <span class="c1">-- `ℕ → ℕ → (ℕ → ℕ → ℕ) → ℕ`</span>
</code></pre></div>
<p>but the problem with non-dependent binders is that you lose all the names!</p>



<a name="255732469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/255732469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#255732469">(Oct 01 2021 at 12:03)</a>:</h4>
<p>Thanks! I agree that one loses all names, but it is at any rate useful to have a clear picture of what goes on. <span aria-label="pray" class="emoji emoji-1f64f" role="img" title="pray">:pray:</span></p>



<a name="280856670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/280856670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ayush Agrawal <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#280856670">(May 02 2022 at 10:30)</a>:</h4>
<p>I defined <code>len</code> of the <code>list</code> definition as follows:<br>
<code>def len {α : Type*} (n : list2 α ) : ℕ :=
list2.rec_on n 0 (λ x l leni, leni+1)</code><br>
However, I am not able to prove a basic statement :<br>
<code>theorem list_len_one {α : Type*} (x : α ) (g : list2 α ) : len (x::g) = 1 + len g := </code><br>
Can someone help me to prove this? thanks!</p>



<a name="280856703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/280856703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#280856703">(May 02 2022 at 10:31)</a>:</h4>
<p>Does <code>add_comm _ _</code> work as a proof?</p>



<a name="280857413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/280857413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ayush Agrawal <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#280857413">(May 02 2022 at 10:40)</a>:</h4>
<p>Oh I see now, thanks <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> ,<br>
<code>theorem list_len_one {α : Type*} (x : α ) (g : list2 α ) : len (x::g) = 1 + len g := 
begin
  rw nat.add_comm _ _,
  apply rfl,
end</code><br>
this now works!</p>



<a name="280857456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/280857456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#280857456">(May 02 2022 at 10:41)</a>:</h4>
<p>Yes, because you wrote <code>leni+1</code>, not <code>1+leni</code> <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="280857860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/280857860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#280857860">(May 02 2022 at 10:46)</a>:</h4>
<p>This is very easy to do if you're coming into this area with a mathematical background, because a+b=b+a feels like it should be true by definition and before you start formalising you treat these two terms as the same.</p>



<a name="280858017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/280858017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/TPIL.20Chapter.207.html#280858017">(May 02 2022 at 10:48)</a>:</h4>
<p>In maths we don't think twice about going from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo>×</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_n (a_n\times C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0017em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mo>∑</mo><mi>n</mi></msub><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">C\sum_n a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0017em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> but in Lean this is two commuting steps: take the factor out the sum, and rearrange.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
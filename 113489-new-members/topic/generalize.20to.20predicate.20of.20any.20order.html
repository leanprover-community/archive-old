---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html">generalize to predicate of any order</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="211380758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211380758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211380758">(Sep 26 2020 at 20:14)</a>:</h4>
<p>Is there a way to generalize something like this to predicates <code>P</code> and <code>Q</code> of any order?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">Q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">Q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">Q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">x'</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">P</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">a1</span> <span class="n">x'</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">P</span> <span class="n">x'</span> <span class="bp">→</span> <span class="n">Q</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">x'</span><span class="o">,</span>
<span class="n">s2</span> <span class="n">s1</span>
</code></pre></div>



<a name="211382681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211382681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211382681">(Sep 26 2020 at 21:05)</a>:</h4>
<p>That is combine these and the rest in the pattern into one theorem and proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">Q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">Q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="211430350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211430350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211430350">(Sep 27 2020 at 19:23)</a>:</h4>
<p>Would creating a tactic be necessary to accomplish something like this?</p>



<a name="211430420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211430420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211430420">(Sep 27 2020 at 19:24)</a>:</h4>
<p><code>finish</code> kills both these goals</p>



<a name="211430444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211430444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211430444">(Sep 27 2020 at 19:25)</a>:</h4>
<p>I know. I'm wondering more for my understanding of what is possible and necessary.</p>



<a name="211430523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211430523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211430523">(Sep 27 2020 at 19:27)</a>:</h4>
<p>That is, is there a way to generalize it without tactics?</p>



<a name="211430539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211430539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211430539">(Sep 27 2020 at 19:27)</a>:</h4>
<p>I'm guessing no?</p>



<a name="211430590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211430590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211430590">(Sep 27 2020 at 19:28)</a>:</h4>
<p>Which is fine, I'm just curious.</p>



<a name="211430591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211430591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211430591">(Sep 27 2020 at 19:28)</a>:</h4>
<p>Your question is very imprecise.</p>



<a name="211430602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211430602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211430602">(Sep 27 2020 at 19:28)</a>:</h4>
<p>How can I clarify it?</p>



<a name="211430680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211430680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211430680">(Sep 27 2020 at 19:30)</a>:</h4>
<p>You asked if it's possible to "combine" infinitely many examples into "one theorem and proof". I don't know what it means to combine two terms in Lean. One tactic solves your examples. Is there another well-formed question which can be asked here?</p>



<a name="211430695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211430695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211430695">(Sep 27 2020 at 19:31)</a>:</h4>
<p>I think the question is about doing reasoning under a collection of universal quantifiers.  I've been thinking about something similar, and I think this is an example of what's known as a "reader monad" in Haskell.  (The full monad isn't necessary here, I don't think.  Maybe just the applicative part?)  But, this is only for one layer of quantifiers; you'd still have to nest monads.</p>



<a name="211430787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211430787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211430787">(Sep 27 2020 at 19:33)</a>:</h4>
<p>Interesting.</p>



<a name="211430837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211430837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211430837">(Sep 27 2020 at 19:34)</a>:</h4>
<p>There's a tactic I was working on for entering a shared context, but it only lives in this Zulip thread right now: <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Automatic.20intro.2Fcases.2Fspecialize.2Fuse.20dance/near/203767478">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Automatic.20intro.2Fcases.2Fspecialize.2Fuse.20dance/near/203767478</a></p>



<a name="211431557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211431557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211431557">(Sep 27 2020 at 19:50)</a>:</h4>
<p>Does shared context mean everything after the prefixed quantifiers?</p>



<a name="211431674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211431674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211431674">(Sep 27 2020 at 19:53)</a>:</h4>
<p>Yeah, and that the quantified variables are assumed to have the same values.</p>



<a name="211431729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211431729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211431729">(Sep 27 2020 at 19:54)</a>:</h4>
<p>Anyway, I did an experiment, and it looks like it's possible to create an ultra modus ponens using typeclasses:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">has_mp</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mp</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">mp</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mp</span> <span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">γ</span> <span class="o">:=</span> <span class="n">has_mp.mp</span> <span class="n">f</span> <span class="n">x</span>

<span class="kd">instance</span> <span class="n">regular_mp</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_mp</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mp</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">ultra_mp</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">has_mp</span> <span class="o">(</span><span class="n">γ</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="n">x</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">has_mp</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">γ</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">α</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">β</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mp</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f'</span> <span class="n">x'</span> <span class="n">y</span><span class="o">,</span> <span class="n">mp</span> <span class="o">(</span><span class="n">f'</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">x'</span> <span class="n">y</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">Q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">Q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">mp</span> <span class="n">h</span> <span class="n">z</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">mp</span> <span class="n">h</span> <span class="n">z</span>
</code></pre></div>



<a name="211431814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211431814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211431814">(Sep 27 2020 at 19:56)</a>:</h4>
<p>I'm sort of surprised it actually worked!  This should let you apply functions underneath any number of foralls/pis</p>



<a name="211431935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211431935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211431935">(Sep 27 2020 at 19:58)</a>:</h4>
<p>Cool!</p>



<a name="211431940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211431940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211431940">(Sep 27 2020 at 19:58)</a>:</h4>
<p>Thank you!</p>



<a name="211432033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211432033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211432033">(Sep 27 2020 at 20:00)</a>:</h4>
<p>Yep, it works for at least one more layer of foralls:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">γ</span><span class="o">),</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">γ</span><span class="o">),</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">γ</span><span class="o">),</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">mp</span> <span class="n">h</span> <span class="n">z</span>
</code></pre></div>



<a name="211432208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/generalize%20to%20predicate%20of%20any%20order/near/211432208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/generalize.20to.20predicate.20of.20any.20order.html#211432208">(Sep 27 2020 at 20:05)</a>:</h4>
<p>(Caveat: I'm not sure any of this is a good idea in practice, but it's cool that it seems to work at least in these basic examples.)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
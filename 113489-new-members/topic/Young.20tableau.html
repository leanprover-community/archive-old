---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Young.20tableau.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Young.20tableau.html">Young tableau</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="222817232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Young%20tableau/near/222817232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Young.20tableau.html#222817232">(Jan 15 2021 at 03:52)</a>:</h4>
<p>I'm trying to define Young tableau in terms of partitions and finsets of <code>ℕ × ℕ</code>. First I turn a partition, which is implemented over a multiset, into a indexed function <code>fin k → ℕ</code>. The point being that I want to sort a partition <code>{7, 2, 1, 5, 1, 6}</code> into <code>[1, 1, 2, 5, 6, 7]</code>. To make a Young Tableau, the plan is to induce a finset of <code>ℕ × ℕ</code> which corresponds to the partition, along with a filling from that finset to <code>ℕ</code>. Here's my attempt to do it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.nat.choose.basic</span>
<span class="kn">import</span> <span class="n">combinatorics.partition</span>

<span class="kn">open</span> <span class="n">nat</span> <span class="n">fin</span> <span class="n">multiset</span>
<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kn">namespace</span> <span class="n">partition</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">length</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">multiset.card</span> <span class="o">(</span><span class="n">p.parts</span><span class="o">)</span>

<span class="c1">-- for example, sort a partition `{7, 2, 1, 5, 1, 6}` into `[7, 6, 5, 2, 1, 1]`</span>
<span class="kd">def</span> <span class="n">to_index</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">p.length</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">list.index_of</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">sort</span> <span class="n">has_le.le</span> <span class="n">p.parts</span><span class="o">)</span>

<span class="c1">-- for example, given a partition [2, 1], output the subset {(0, 0), (0, 1), (1, 0)}</span>
<span class="kd">def</span> <span class="n">to_grid</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>

<span class="c1">--  define a young_tableau with shape `p` as a filling of the subset of `ℕ × ℕ` induced by `p`</span>
<span class="kd">structure</span> <span class="n">young_tableau</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">))</span>
<span class="o">(</span><span class="n">proof_that_partition_induces_carrier</span> <span class="o">:</span> <span class="n">carrier</span> <span class="bp">=</span> <span class="n">p.to_grid</span><span class="o">)</span>
<span class="o">(</span><span class="n">filling</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">carrier</span><span class="o">}</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="c1">-- a tableau is standard if `syt.filling` is a bijection</span>
<span class="c1">-- from `{x : (ℕ × ℕ) // x ∈ carrier} ` to `range n`</span>
<span class="c1">-- but how do I say that?</span>
<span class="kd">def</span> <span class="n">is_standard</span> <span class="o">(</span><span class="n">syt</span> <span class="o">:</span> <span class="n">young_tableau</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>

<span class="kd">end</span> <span class="n">partition</span>
</code></pre></div>
<p>But I'm getting stuck on trying to define a standard tableau, because it's hard to reason while carrying <code>{x : (ℕ × ℕ) // x ∈ carrier}</code>everywhere. But I also don't want to drop it, since that would mean I have to say <code>filling : ℕ × ℕ → ℕ</code> along with something that restricts the function to only the carrier.<br>
Or is there a better way to do all this?</p>



<a name="222829584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Young%20tableau/near/222829584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Young.20tableau.html#222829584">(Jan 15 2021 at 08:12)</a>:</h4>
<p><span class="user-mention" data-user-id="355764">@Hanting Zhang</span> Oh, I see you've deleted your message in the meantime.  In case you're still wondering about formulating Young tableaux, here's something that might work.  The design is set up to make it so that transposing a tableau is easy.  Then, you can get the partition from a tableau by taking the supremum index from each row and forming a multiset of these indices.  At the very end, <code>young_tableau_of p</code> is the subtype of all Young tableau with a particular partition <code>p</code>.</p>
<p>The <code>young_tableau</code> type is designed so that equality of Young tableau corresponds to equality of <code>young_tableau</code> terms.  The notion of a standard tableau is <code>young_tableau.is_standard</code>, and it just writes out the two axioms of injectivity and surjectivity.</p>
<p>This can all definitely be better organized and simplified!  I'm also not sure how awkward it would be working with <code>young_tableau_of p</code>, which unfortunately uses <code>eq.rec_on</code>...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.nat.choose.basic</span>
<span class="kn">import</span> <span class="n">combinatorics.partition</span>

<span class="kn">open</span> <span class="n">nat</span> <span class="n">fin</span> <span class="n">multiset</span>
<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kn">namespace</span> <span class="n">partition</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">young_tableau</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">filling</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">))</span>
<span class="o">(</span><span class="n">is_carrier</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span><span class="o">,</span> <span class="n">filling</span> <span class="n">s</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">↔</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">carrier</span><span class="o">)</span>
<span class="o">(</span><span class="n">left_closed</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">filling</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">j'</span><span class="o">,</span> <span class="n">j'</span> <span class="bp">≤</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">filling</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j'</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">up_closed</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">filling</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">i'</span><span class="o">,</span> <span class="n">i'</span> <span class="bp">≤</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">filling</span> <span class="o">(</span><span class="n">i'</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">young_tableau</span>

<span class="kd">lemma</span> <span class="n">left_closed'</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">young_tableau</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">t.carrier</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">j'</span><span class="o">,</span> <span class="n">j'</span> <span class="bp">≤</span> <span class="n">j</span> <span class="bp">→</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j'</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">t.carrier</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">t.left_closed</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">t.is_carrier</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">up_closed'</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">young_tableau</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">t.carrier</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">i'</span><span class="o">,</span> <span class="n">i'</span> <span class="bp">≤</span> <span class="n">i</span> <span class="bp">→</span> <span class="o">(</span><span class="n">i'</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">t.carrier</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">t.up_closed</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">t.is_carrier</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">}</span>

<span class="sd">/-- The number of nonzero entries in the Young tableau. -/</span>
<span class="kd">def</span> <span class="n">size</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">young_tableau</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">t.carrier.card</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">transpose</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">young_tableau</span><span class="o">)</span> <span class="o">:</span> <span class="n">young_tableau</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">filling</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">t.filling</span> <span class="n">s.swap</span><span class="o">,</span>
  <span class="n">carrier</span> <span class="o">:=</span> <span class="n">t.carrier.map</span> <span class="o">(</span><span class="n">equiv.prod_comm</span> <span class="n">ℕ</span> <span class="n">ℕ</span><span class="o">)</span><span class="bp">.</span><span class="n">to_embedding</span><span class="o">,</span>
  <span class="n">is_carrier</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">rw</span> <span class="n">t.is_carrier</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">exists_prop</span><span class="o">,</span> <span class="n">equiv.to_embedding_apply</span><span class="o">,</span> <span class="n">finset.mem_map</span><span class="o">,</span> <span class="n">prod.mk.inj_iff</span><span class="o">,</span>
               <span class="n">equiv.prod_comm_apply</span><span class="o">,</span> <span class="n">prod.swap_prod_mk</span><span class="o">,</span> <span class="n">prod.exists</span><span class="o">],</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">s.2</span><span class="o">,</span> <span class="n">s.1</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">prod.mk.eta</span><span class="o">⟩,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">up_closed</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">j</span> <span class="n">i</span><span class="o">,</span> <span class="n">t.left_closed</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span>
  <span class="n">left_closed</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">j</span> <span class="n">i</span><span class="o">,</span> <span class="n">t.up_closed</span> <span class="n">i</span> <span class="n">j</span> <span class="o">}</span>

<span class="sd">/-- `t.filling` is a bijection from `t.carrier` to the interval `[1, t.size]`. -/</span>
<span class="kd">structure</span> <span class="n">is_standard</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">young_tableau</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">filling_inj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="n">s'</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">t.carrier</span> <span class="bp">→</span> <span class="n">s'</span> <span class="bp">∈</span> <span class="n">t.carrier</span> <span class="bp">→</span> <span class="n">t.filling</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">t.filling</span> <span class="n">s'</span> <span class="bp">→</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">s'</span><span class="o">)</span>
<span class="o">(</span><span class="n">filling_surj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">t.carrier</span> <span class="bp">→</span> <span class="n">t.filling</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t.size</span><span class="o">)</span>

<span class="sd">/-- Get the smallest `j'` such that `(i,j) ∈ t.carrier` implies `j &lt; j'` -/</span>
<span class="kd">def</span> <span class="n">width_at</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">young_tableau</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t.carrier.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">s.1</span> <span class="bp">=</span> <span class="n">i</span><span class="o">))</span><span class="bp">.</span><span class="n">sup</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s.2</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="sd">/-- Get the smallest `i'` such that `(i,0) ∈ t.carrier` implies `i &lt; i'`  -/</span>
<span class="kd">def</span> <span class="n">height</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">young_tableau</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t.carrier.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">s.2</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">))</span><span class="bp">.</span><span class="n">sup</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s.1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">widths</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">young_tableau</span><span class="o">)</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">range</span> <span class="n">t.height</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">t.width_at</span> <span class="n">i</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">mem_sup</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hne</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">s.sup</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">finset.induction_on</span> <span class="n">s</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">s'</span> <span class="n">hs'</span> <span class="n">ih</span> <span class="n">hine'</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="n">hne</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hne'</span> <span class="o">:</span> <span class="n">s'.nonempty</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">hne'</span><span class="o">,</span>
    <span class="n">subst</span> <span class="n">s'</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">a</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">ih</span> <span class="n">hne'</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">hfb</span><span class="o">⟩,</span>
    <span class="n">by_cases</span> <span class="n">hm</span> <span class="o">:</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">f</span> <span class="n">b</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">use</span> <span class="n">b</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hb</span><span class="o">,</span> <span class="n">hfb</span><span class="o">,</span> <span class="n">hm</span><span class="o">],</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">not_le</span> <span class="n">at</span> <span class="n">hm</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.sup_insert</span><span class="o">,</span> <span class="n">hfb</span><span class="o">],</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">le_of_lt</span> <span class="n">hm</span><span class="o">],</span> <span class="o">},</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">carrier_eq_bind</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">young_tableau</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">t.carrier</span> <span class="bp">=</span> <span class="o">(</span><span class="n">finset.range</span> <span class="n">t.height</span><span class="o">)</span><span class="bp">.</span><span class="n">bind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">finset.range</span> <span class="o">(</span><span class="n">t.width_at</span> <span class="n">i</span><span class="o">))</span><span class="bp">.</span><span class="n">image</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">x</span> <span class="k">with</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">height</span><span class="o">,</span> <span class="n">width_at</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">finset.mem_bind</span><span class="o">,</span> <span class="n">finset.mem_image</span><span class="o">,</span> <span class="n">finset.mem_range</span><span class="o">,</span>
             <span class="n">prod.mk.inj_iff</span><span class="o">],</span>
  <span class="n">by_cases</span> <span class="n">hne</span> <span class="o">:</span> <span class="n">t.carrier.nonempty</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finset.not_nonempty_iff_eq_empty</span><span class="o">]</span> <span class="n">at</span> <span class="n">hne</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hne</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">hij</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">true_and</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">exists_eq_right</span><span class="o">],</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">by_contra</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">finset.sup_le_iff</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">specialize</span> <span class="n">h</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
      <span class="k">have</span> <span class="n">hi0</span> <span class="o">:</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">t.carrier</span> <span class="o">:=</span> <span class="n">t.left_closed'</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hij</span> <span class="n">_</span> <span class="o">(</span><span class="n">nat.zero_le</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">hi0</span><span class="o">,</span> <span class="n">forall_prop_of_true</span><span class="o">,</span> <span class="n">add_le_iff_nonpos_right</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span>
                 <span class="n">one_ne_zero</span><span class="o">,</span> <span class="n">and_self</span><span class="o">,</span> <span class="n">finset.mem_filter</span><span class="o">,</span> <span class="n">nonpos_iff_eq_zero</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">assumption</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">by_contra</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">finset.sup_le_iff</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">specialize</span> <span class="n">h</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">),</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">hij</span><span class="o">,</span> <span class="n">forall_prop_of_true</span><span class="o">,</span> <span class="n">add_le_iff_nonpos_right</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span>
                 <span class="n">one_ne_zero</span><span class="o">,</span> <span class="n">and_self</span><span class="o">,</span> <span class="n">finset.mem_filter</span><span class="o">,</span> <span class="n">nonpos_iff_eq_zero</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">assumption</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">hj</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="k">have</span> <span class="n">hh</span> <span class="o">:=</span> <span class="n">mem_sup</span> <span class="o">(</span><span class="n">t.carrier.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s.snd</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">))</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">s.fst</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
    <span class="n">swap</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rcases</span> <span class="n">hne</span> <span class="k">with</span> <span class="o">⟨⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">⟩,</span> <span class="n">hs</span><span class="o">⟩,</span>
      <span class="n">use</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="n">simp</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">t.up_closed'</span> <span class="n">i</span> <span class="mi">0</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">nat.zero_le</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">apply</span> <span class="n">t.left_closed'</span> <span class="n">i</span> <span class="n">j</span> <span class="n">hs</span> <span class="n">_</span> <span class="o">(</span><span class="n">nat.zero_le</span> <span class="n">_</span><span class="o">),</span> <span class="o">},</span>
    <span class="n">rcases</span> <span class="n">hh</span> <span class="k">with</span> <span class="o">⟨⟨</span><span class="n">i'</span><span class="o">,</span> <span class="n">j'</span><span class="o">⟩,</span> <span class="n">hh</span><span class="o">,</span> <span class="n">hh'</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.mem_filter</span><span class="o">]</span> <span class="n">at</span> <span class="n">hh</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hh</span> <span class="k">with</span> <span class="n">hh</span> <span class="n">hj'</span><span class="o">,</span>
    <span class="n">subst</span> <span class="n">j'</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">hh'</span><span class="o">]</span> <span class="n">at</span> <span class="n">hi</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hh''</span> <span class="o">:=</span> <span class="n">mem_sup</span> <span class="o">(</span><span class="n">t.carrier.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">s.fst</span> <span class="bp">=</span> <span class="n">i</span><span class="o">))</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">s.snd</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
    <span class="n">swap</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">use</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
      <span class="n">simp</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">lt_succ_iff</span> <span class="n">at</span> <span class="n">hi</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">t.up_closed'</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hh</span> <span class="n">_</span> <span class="n">hi</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">rcases</span> <span class="n">hh''</span> <span class="k">with</span> <span class="o">⟨⟨</span><span class="n">i''</span><span class="o">,</span> <span class="n">j''</span><span class="o">⟩,</span> <span class="n">hh''</span><span class="o">,</span> <span class="n">hh'''</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.mem_filter</span><span class="o">]</span> <span class="n">at</span> <span class="n">hh''</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hh''</span> <span class="k">with</span> <span class="n">hh''</span> <span class="n">hi''</span><span class="o">,</span>
    <span class="n">subst</span> <span class="n">i''</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">hh'''</span><span class="o">]</span> <span class="n">at</span> <span class="n">hj</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">lt_succ_iff</span> <span class="n">at</span> <span class="n">hj</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">t.left_closed'</span> <span class="n">i</span> <span class="n">j''</span> <span class="n">hh''</span> <span class="n">_</span> <span class="n">hj</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">size_eq</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">young_tableau</span><span class="o">)</span> <span class="o">:</span> <span class="n">t.size</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">t.height</span><span class="o">,</span> <span class="n">t.width_at</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert_to</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">s</span> <span class="k">in</span> <span class="n">t.carrier</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">carrier_eq_bind</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">finset.sum_bind</span><span class="o">],</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">finset.sum_image</span><span class="o">],</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">i</span> <span class="n">hi</span> <span class="n">j</span> <span class="n">hj</span> <span class="n">hij</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset.disjoint_iff_ne</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">ai</span><span class="o">,</span> <span class="n">aj</span><span class="o">⟩</span> <span class="n">ha</span> <span class="o">⟨</span><span class="n">bi</span><span class="o">,</span> <span class="n">bj</span><span class="o">⟩</span> <span class="n">hb</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">ha</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">rcases</span> <span class="n">hb</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hij</span> <span class="n">h.1</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">sum_widths_eq_size</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">young_tableau</span><span class="o">)</span> <span class="o">:</span> <span class="n">t.widths.sum</span> <span class="bp">=</span> <span class="n">t.size</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert_to</span> <span class="o">(</span><span class="n">finset.range</span> <span class="n">t.height</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="n">t.width_at</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">size_eq</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">partition</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">young_tableau</span><span class="o">)</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">t.size</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">parts</span> <span class="o">:=</span> <span class="n">t.widths</span><span class="o">,</span>
  <span class="n">parts_pos</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">j</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">widths</span><span class="o">,</span> <span class="n">width_at</span><span class="o">,</span> <span class="n">height</span><span class="o">,</span> <span class="n">mem_range</span><span class="o">,</span> <span class="n">mem_map</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">by_cases</span> <span class="n">hne</span> <span class="o">:</span> <span class="n">t.carrier.nonempty</span><span class="o">,</span>
    <span class="n">swap</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finset.not_nonempty_iff_eq_empty</span><span class="o">]</span> <span class="n">at</span> <span class="n">hne</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">hne</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">exfalso</span><span class="o">,</span>
      <span class="n">rcases</span> <span class="n">h.1</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩,</span>
      <span class="n">exact</span> <span class="n">not_lt_zero</span> <span class="n">_</span> <span class="n">hx</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">rcases</span> <span class="n">hne</span> <span class="k">with</span> <span class="o">⟨⟨</span><span class="n">xi</span><span class="o">,</span> <span class="n">xj</span><span class="o">⟩,</span> <span class="n">hx</span><span class="o">⟩,</span>
    <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">i'</span><span class="o">,</span> <span class="n">hi'</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="k">have</span> <span class="n">h1</span> <span class="o">:=</span> <span class="n">mem_sup</span> <span class="o">(</span><span class="n">t.carrier.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">s.snd</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">))</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">s.fst</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
    <span class="n">swap</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">use</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="n">simp</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">t.up_closed'</span> <span class="n">xi</span> <span class="mi">0</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">nat.zero_le</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">apply</span> <span class="n">t.left_closed'</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hx</span> <span class="n">_</span> <span class="o">(</span><span class="n">nat.zero_le</span> <span class="n">_</span><span class="o">),</span> <span class="o">},</span>
    <span class="n">rcases</span> <span class="n">h1</span> <span class="k">with</span> <span class="o">⟨⟨</span><span class="n">ai</span><span class="o">,</span> <span class="n">aj</span><span class="o">⟩,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">h1</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">ha</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">ha</span><span class="o">,</span> <span class="n">haj</span><span class="o">⟩,</span>
    <span class="n">subst</span> <span class="n">aj</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">h1</span><span class="o">]</span> <span class="n">at</span> <span class="n">hi'</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h2</span> <span class="o">:=</span> <span class="n">mem_sup</span> <span class="o">(</span><span class="n">t.carrier.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">s.fst</span> <span class="bp">=</span> <span class="n">i'</span><span class="o">))</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">s.snd</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
    <span class="n">swap</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">use</span> <span class="o">(</span><span class="n">i'</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
      <span class="n">simp</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">lt_succ_iff</span> <span class="n">at</span> <span class="n">hi'</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">t.up_closed'</span> <span class="n">_</span> <span class="n">_</span> <span class="n">ha</span> <span class="n">_</span> <span class="n">hi'</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">rcases</span> <span class="n">h2</span> <span class="k">with</span> <span class="o">⟨⟨</span><span class="n">bi</span><span class="o">,</span> <span class="n">bj</span><span class="o">⟩,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">h2</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">h2</span><span class="o">],</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">parts_sum</span> <span class="o">:=</span> <span class="n">t.sum_widths_eq_size</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">young_tableau</span>

<span class="sd">/-- Whether or not a tableau has a particular partition.  Needs `eq.rec_on` to rewrite</span>
<span class="sd">the `n` in the partition to `t.size` when they are equal. -/</span>
<span class="kd">def</span> <span class="n">young_tableau.has_partition</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">young_tableau</span><span class="o">)</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">t.size</span><span class="o">),</span> <span class="n">t.partition</span> <span class="bp">=</span> <span class="n">eq.rec_on</span> <span class="n">h</span> <span class="n">p</span>

<span class="sd">/-- All the young tableau with a partition of a particular type. -/</span>
<span class="kd">def</span> <span class="n">young_tableau_of</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">young_tableau</span> <span class="bp">//</span> <span class="n">t.has_partition</span> <span class="n">p</span><span class="o">}</span>

<span class="kd">end</span> <span class="n">partition</span>
</code></pre></div>



<a name="222830204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Young%20tableau/near/222830204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Young.20tableau.html#222830204">(Jan 15 2021 at 08:18)</a>:</h4>
<p>In retrospect, it would probably be better to have defined</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">young_tableau</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">filling</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">))</span>
<span class="o">(</span><span class="n">size_eq</span> <span class="o">:</span> <span class="n">carrier.card</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_carrier</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span><span class="o">,</span> <span class="n">filling</span> <span class="n">s</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">↔</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">carrier</span><span class="o">)</span>
<span class="o">(</span><span class="n">left_closed</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">filling</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">j'</span><span class="o">,</span> <span class="n">j'</span> <span class="bp">≤</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">filling</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j'</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">up_closed</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">filling</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">i'</span><span class="o">,</span> <span class="n">i'</span> <span class="bp">≤</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">filling</span> <span class="o">(</span><span class="n">i'</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div>
<p>for the Young tableaux with <code>n</code> filled squares.  This avoids the <code>eq.rec_on</code>.</p>



<a name="222830774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Young%20tableau/near/222830774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Young.20tableau.html#222830774">(Jan 15 2021 at 08:26)</a>:</h4>
<p>Fields 1,2, and 4 are collectively just a <code>finsupp (\N \times \N) \N</code></p>



<a name="222842991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Young%20tableau/near/222842991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Young.20tableau.html#222842991">(Jan 15 2021 at 10:54)</a>:</h4>
<p>With the above, I made it so that a square is filled iff it wasn't <code>0</code>, so then a standard tableau has 1,2,...,n, but it's probably better if it's 0,1,...,n-1.  (Unfortunately that means it wouldn't just be <code>finsupp</code>.)</p>
<p>Also, it's probably better to split off Young diagrams from Young tableaux.  The diagram is the <code>finset</code> of squares, and the tableau is a filling.  The following is an experiment with this (mostly things regarding transpositions), and it has the beginnings of constructing a Young diagram from a partition (<code>young_diagram.of_row_partition</code>).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.nat.choose.basic</span>
<span class="kn">import</span> <span class="n">combinatorics.partition</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kn">namespace</span> <span class="n">partition</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">young_diagram</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">squares</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">))</span>
<span class="o">(</span><span class="n">left_closed</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">squares</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">j'</span><span class="o">,</span> <span class="n">j'</span> <span class="bp">≤</span> <span class="n">j</span> <span class="bp">→</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j'</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">squares</span><span class="o">)</span>
<span class="o">(</span><span class="n">up_closed</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">squares</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">i'</span><span class="o">,</span> <span class="n">i'</span> <span class="bp">≤</span> <span class="n">i</span> <span class="bp">→</span> <span class="o">(</span><span class="n">i'</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">squares</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">young_diagram</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">mem_image_swap</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">s.image</span> <span class="n">prod.swap</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">exists_prop</span><span class="o">,</span> <span class="n">prod.mk.inj_iff</span><span class="o">,</span> <span class="n">finset.mem_image</span><span class="o">,</span> <span class="n">prod.swap_prod_mk</span><span class="o">,</span> <span class="n">prod.exists</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">transpose</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">young_diagram</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">young_diagram</span> <span class="n">n</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">squares</span> <span class="o">:=</span> <span class="n">d.squares.image</span> <span class="n">prod.swap</span><span class="o">,</span>
  <span class="n">left_closed</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_image_swap</span><span class="o">],</span> <span class="n">exact</span> <span class="n">d.up_closed</span> <span class="n">j</span> <span class="n">i</span> <span class="o">},</span>
  <span class="n">up_closed</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_image_swap</span><span class="o">],</span> <span class="n">exact</span> <span class="n">d.left_closed</span> <span class="n">j</span> <span class="n">i</span> <span class="o">}</span> <span class="o">}</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">young_diagram</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">transpose_transpose</span> <span class="o">:</span> <span class="n">d.transpose.transpose</span> <span class="bp">=</span> <span class="n">d</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext1</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">transpose_squares</span><span class="o">],</span>
  <span class="n">rw</span> <span class="n">finset.image_image</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>

<span class="sd">/-- The number of rows in the diagram. -/</span>
<span class="kd">def</span> <span class="n">rows</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">d.squares.sup</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s.1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="sd">/-- The number of columns in the diagram. -/</span>
<span class="kd">def</span> <span class="n">cols</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">d.squares.sup</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s.2</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="sd">/-- The number of squares in row i -/</span>
<span class="kd">def</span> <span class="n">row_squares</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">d.squares.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">s.1</span> <span class="bp">=</span> <span class="n">i</span><span class="o">))</span><span class="bp">.</span><span class="n">sup</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s.2</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="sd">/-- The number of squares in column j -/</span>
<span class="kd">def</span> <span class="n">col_squares</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">d.squares.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">s.2</span> <span class="bp">=</span> <span class="n">j</span><span class="o">))</span><span class="bp">.</span><span class="n">sup</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s.1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">rows_eq_first_col_squares</span> <span class="o">:</span> <span class="n">d.rows</span> <span class="bp">=</span> <span class="n">d.col_squares</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">rows</span><span class="o">,</span> <span class="n">col_squares</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">le_antisymm</span> <span class="n">_</span> <span class="o">(</span><span class="n">finset.sup_subset</span> <span class="o">(</span><span class="n">finset.filter_subset</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">finset.sup_le_iff</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">⟩</span> <span class="n">hij</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hi0</span> <span class="o">:=</span> <span class="n">d.left_closed</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hij</span> <span class="mi">0</span> <span class="o">(</span><span class="n">nat.zero_le</span> <span class="n">_</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">d.squares.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">s.snd</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hi0</span><span class="o">],</span> <span class="o">},</span>
  <span class="n">change</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">s.fst</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">finset.le_sup</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">sup_image_swap_eq</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">t.image</span> <span class="n">prod.swap</span><span class="o">)</span><span class="bp">.</span><span class="n">sup</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s.snd</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">t.sup</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s.fst</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">finset.sup</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset.fold_image</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">⟩</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">i'</span><span class="o">,</span> <span class="n">j'</span><span class="o">⟩</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">and_imp</span><span class="o">,</span> <span class="n">prod.mk.inj_iff</span><span class="o">,</span> <span class="n">prod.swap_prod_mk</span><span class="o">],</span>
  <span class="n">rintros</span> <span class="n">rfl</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">row_squares_of_transpose</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">d.transpose.row_squares</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">d.col_squares</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">row_squares</span><span class="o">,</span> <span class="n">col_squares</span><span class="o">,</span> <span class="n">transpose_squares</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">d.squares.image</span> <span class="n">prod.swap</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">s.fst</span> <span class="bp">=</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span>
    <span class="o">(</span><span class="n">d.squares.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">s.snd</span> <span class="bp">=</span> <span class="n">i</span><span class="o">))</span><span class="bp">.</span><span class="n">image</span> <span class="n">prod.swap</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">finset.image_filter</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">clear</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sup_image_swap_eq</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">col_squares_of_transpose</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">d.transpose.col_squares</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">d.row_squares</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">transpose_transpose</span> <span class="n">d</span><span class="o">,</span> <span class="n">row_squares_of_transpose</span><span class="o">,</span> <span class="n">transpose_transpose</span><span class="o">]</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">cols_of_transpose</span> <span class="o">:</span> <span class="n">d.transpose.cols</span> <span class="bp">=</span> <span class="n">d.rows</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">cols</span><span class="o">,</span> <span class="n">rows</span><span class="o">],</span> <span class="n">rw</span> <span class="n">sup_image_swap_eq</span> <span class="o">}</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">rows_of_transpose</span> <span class="o">:</span> <span class="n">d.transpose.rows</span> <span class="bp">=</span> <span class="n">d.cols</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">transpose_transpose</span> <span class="n">d</span><span class="o">,</span> <span class="n">cols_of_transpose</span><span class="o">,</span> <span class="n">transpose_transpose</span><span class="o">]</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">cols_eq_first_row_squares</span> <span class="o">:</span> <span class="n">d.cols</span> <span class="bp">=</span> <span class="n">d.row_squares</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">transpose_transpose</span> <span class="n">d</span><span class="o">,</span> <span class="n">cols_of_transpose</span><span class="o">,</span> <span class="n">row_squares_of_transpose</span><span class="o">,</span> <span class="n">rows_eq_first_col_squares</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">row_squares_pos</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">d.rows</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">d.row_squares</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="sd">/-- The partition associated to the rows -/</span>
<span class="kd">def</span> <span class="n">row_partition</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">n</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">parts</span> <span class="o">:=</span> <span class="o">(</span><span class="n">multiset.range</span> <span class="n">d.rows</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">d.row_squares</span><span class="o">,</span>
  <span class="n">parts_pos</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">and_imp</span><span class="o">,</span> <span class="n">multiset.mem_range</span><span class="o">,</span> <span class="n">forall_apply_eq_imp_iff₂</span><span class="o">,</span> <span class="n">multiset.mem_map</span><span class="o">,</span> <span class="n">exists_imp_distrib</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">d.row_squares_pos</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">parts_sum</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">partition_fn</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">p.parts.sort</span> <span class="o">(</span><span class="bp">≥</span><span class="o">)</span>
<span class="k">in</span> <span class="n">option.get_or_else</span> <span class="o">(</span><span class="n">s.nth</span> <span class="n">i</span><span class="o">)</span> <span class="mi">0</span>

<span class="sd">/-- inverse of `row_partition` -/</span>
<span class="kd">def</span> <span class="n">of_row_partition</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">young_diagram</span> <span class="n">n</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">squares</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finset.range</span> <span class="n">p.parts.card</span><span class="o">)</span><span class="bp">.</span><span class="n">bind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">finset.range</span> <span class="o">(</span><span class="n">partition_fn</span> <span class="n">p</span> <span class="n">i</span><span class="o">))</span><span class="bp">.</span><span class="n">image</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))),</span>
  <span class="n">left_closed</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">up_closed</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">young_diagram</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">young_tableau</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">young_diagram</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">filling</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">in_diagram</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span><span class="o">,</span> <span class="n">filling</span> <span class="n">s</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">d.squares</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">young_tableau</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">young_diagram</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">transpose</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">young_tableau</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="n">young_tableau</span> <span class="n">d.transpose</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">filling</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">t.filling</span> <span class="n">s.swap</span><span class="o">,</span>
  <span class="n">in_diagram</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span> <span class="n">h</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="k">have</span> <span class="n">h'</span> <span class="o">:=</span> <span class="n">t.in_diagram</span> <span class="n">s.swap</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">revert</span> <span class="n">h'</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">s</span> <span class="k">with</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="sd">/-- `t.filling` is a bijection from `d.squares` to `0,1,...,n-1`. -/</span>
<span class="kd">structure</span> <span class="n">is_standard</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">young_tableau</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">filling_inj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="n">s'</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">d.squares</span> <span class="bp">→</span> <span class="n">s'</span> <span class="bp">∈</span> <span class="n">d.squares</span> <span class="bp">→</span> <span class="n">t.filling</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">t.filling</span> <span class="n">s'</span> <span class="bp">→</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">s'</span><span class="o">)</span>
<span class="o">(</span><span class="n">filling_surj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">d.squares</span> <span class="bp">→</span> <span class="n">t.filling</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">young_tableau</span>

<span class="kd">end</span> <span class="n">partition</span>
</code></pre></div>



<a name="222894418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Young%20tableau/near/222894418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Young.20tableau.html#222894418">(Jan 15 2021 at 17:35)</a>:</h4>
<p>I deleted because I doubled back and started working with a vector-only definition (where I just have a vector of length n and build a lot of API to access the data easily.) Actually, we probably want tableau entries to be positive, since doing tableau calculations like the hook length formula would rely on that. I don't know if starting with diagrams without partitions will work out to be smoother. But looking at what you've done <span class="user-mention" data-user-id="306601">@Kyle Miller</span> , maybe the problem is that we don't have a good API for "finsets of N x N." I can't think of any examples off the top of my head except for young tableau, but "finsets of N x N" with certain graph-theoretic properties should be useful.</p>



<a name="222894878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Young%20tableau/near/222894878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Young.20tableau.html#222894878">(Jan 15 2021 at 17:38)</a>:</h4>
<p>I'll try some stuff with what you've started. There still needs to be a weakly decreasing condition on the entries. Proving the hook length would be a good test.</p>



<a name="223046467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Young%20tableau/near/223046467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Young.20tableau.html#223046467">(Jan 17 2021 at 14:56)</a>:</h4>
<p>When I made partitions a while ago I had a go at this too, my definition was essentially the same as yours (though I included the size in the structure like you realised), but I found it awkward to prove that transposition keeps the number of squares the same, ie that transposition is a well defined function <code>young_diagram n -&gt; young_diagram n</code>. If you can get this working I think it would make a good PR to mathlib</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
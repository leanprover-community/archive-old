---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html">Inductive definition with many base cases</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="206810718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206810718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206810718">(Aug 13 2020 at 12:52)</a>:</h4>
<p>Is it possible to make a inductive definition with arbitrarily many "base cases" ? I'm trying to define the constant recursive sequence of order <code>d : ℕ</code> with coefficients <code>c : fin d → α</code> and whose first <code>d</code> terms are given by <code>i : fin d → α</code> but I can't find how to do this since</p>



<a name="206812350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206812350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206812350">(Aug 13 2020 at 13:09)</a>:</h4>
<p>I don't really understand the problem statement, but yes it is possible to formulate recursions like this</p>



<a name="206812926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206812926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206812926">(Aug 13 2020 at 13:15)</a>:</h4>
<p>(not at computer keyboard atm), but for a proof of that definition later, something like obtain d, hd from d, then rcases d with _|_|_|d for four base cases, then induction d for the rest</p>



<a name="206813336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206813336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206813336">(Aug 13 2020 at 13:19)</a>:</h4>
<p>Oh sorry if that wasn't clear, let me make a more concrete example : let's say I want to define <code>superfib (d : ℕ) : ℕ → ℕ</code> such that <code>∀ i : fin d, superfib d i = i</code> and <code>∀ n,superfib d (n+d) = ∑ i in range d, superfib d (n+i)</code>. I know how to define <code>superfib 2</code> or <code>superfib 37</code> by making as much base constructors as I need and then the recursive one. But how can I define <code>superfib d</code> for any <code>d</code> since I can't write <code>d</code> constructors for every <code>d</code></p>



<a name="206814008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206814008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206814008">(Aug 13 2020 at 13:25)</a>:</h4>
<p>I'd use the proposition that i &lt; d instead of relying on the fin to nat coercion</p>



<a name="206814128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206814128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206814128">(Aug 13 2020 at 13:26)</a>:</h4>
<p>that doesn't answer the question though</p>



<a name="206814305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206814305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206814305">(Aug 13 2020 at 13:28)</a>:</h4>
<p>I guess you define an auxiliary function first sending i to [superfib i, superfib (i+1), ..., superfib (i + d - 1)] by usual recursion</p>



<a name="206814640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206814640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206814640">(Aug 13 2020 at 13:31)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">def</span> <span class="n">superfib_aux</span> <span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">d</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">d</span> <span class="bp">-</span> <span class="mi">1</span> <span class="k">then</span> <span class="n">superfib_aux</span> <span class="n">n</span> <span class="bp">⟨</span><span class="n">x</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="k">by</span> <span class="n">omega</span><span class="bp">⟩</span> <span class="k">else</span> <span class="err">Σ</span> <span class="n">i</span> <span class="k">in</span> <span class="n">fin</span> <span class="n">d</span><span class="o">,</span> <span class="n">superfib_aux</span> <span class="n">n</span> <span class="n">i</span>
</code></pre></div>



<a name="206814762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206814762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206814762">(Aug 13 2020 at 13:32)</a>:</h4>
<p>I don't know how that Sigma notation works, I've never used it before -- this doesn't compile but should be fixable easily</p>



<a name="206816234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206816234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206816234">(Aug 13 2020 at 13:45)</a>:</h4>
<p>Ok so this works and looks incredibly clever, now I just need to understand what is going on <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="206816327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206816327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206816327">(Aug 13 2020 at 13:46)</a>:</h4>
<p>Btw, the fix is : <code>∑ i : fin d</code> (the big sigma is <code>\sum</code>)</p>



<a name="206816476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206816476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206816476">(Aug 13 2020 at 13:47)</a>:</h4>
<p>You can define this by well founded recursion too</p>



<a name="206817517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206817517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206817517">(Aug 13 2020 at 13:56)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="n">def</span> <span class="n">superfib</span> <span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">d</span> <span class="k">then</span> <span class="n">n</span> <span class="k">else</span>
  <span class="err">∑</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">d</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span>
      <span class="n">nat</span><span class="bp">.</span><span class="n">add_lt_of_lt_sub_right</span> <span class="err">$</span>
        <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">sub_lt_sub_left_iff</span> <span class="err">$</span> <span class="n">le_of_not_gt</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="n">i</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
    <span class="n">superfib</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">i</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">superfib_lt_d</span> <span class="o">{</span><span class="n">d</span> <span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">superfib</span> <span class="n">d</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">superfib</span><span class="o">,</span> <span class="n">if_pos</span> <span class="n">h</span><span class="o">]</span>
<span class="kn">theorem</span> <span class="n">superfib_sum</span> <span class="o">{</span><span class="n">d</span> <span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">superfib</span> <span class="n">d</span> <span class="n">n</span> <span class="bp">=</span> <span class="err">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">d</span><span class="o">),</span> <span class="n">superfib</span> <span class="n">d</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">d</span> <span class="bp">+</span> <span class="err">↑</span><span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">superfib</span><span class="o">,</span> <span class="n">if_neg</span> <span class="o">(</span><span class="n">not_lt_of_ge</span> <span class="n">h</span><span class="o">)]</span>
</code></pre></div>



<a name="206817638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206817638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206817638">(Aug 13 2020 at 13:57)</a>:</h4>
<p>you have to supply a proof of decreasing in the middle of the definition but as you can see from the lemmas it doesn't appear there</p>



<a name="206817741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206817741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206817741">(Aug 13 2020 at 13:58)</a>:</h4>
<p>you misspelt <code>omega</code></p>



<a name="206817903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206817903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206817903">(Aug 13 2020 at 13:59)</a>:</h4>
<p>Ok I think I just understood <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> 's approach, it seems less mysterious now : it is basically like working on the vectors of <code>d</code> consecutive terms to go back to usual recursion.</p>



<a name="206818170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206818170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206818170">(Aug 13 2020 at 14:01)</a>:</h4>
<p>here I fixed the typo</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">superfib</span> <span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">d</span> <span class="k">then</span> <span class="n">n</span> <span class="k">else</span>
  <span class="err">∑</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">d</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">i</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span> <span class="k">by</span> <span class="k">have</span> <span class="o">:=</span> <span class="n">i</span><span class="bp">.</span><span class="mi">2</span><span class="bp">;</span> <span class="n">omega</span><span class="o">,</span>
    <span class="n">superfib</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">i</span><span class="o">)</span>
</code></pre></div>



<a name="206818176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206818176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206818176">(Aug 13 2020 at 14:01)</a>:</h4>
<p>(deleted)</p>



<a name="206818298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206818298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206818298">(Aug 13 2020 at 14:02)</a>:</h4>
<p>I am annoyed that my version doesn't work for d=0 and yours does</p>



<a name="206818343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206818343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206818343">(Aug 13 2020 at 14:03)</a>:</h4>
<p><code>def superfib' (d n : ℕ) (hd : d &gt; 0) := superfib'_aux d n ⟨0, hd⟩</code></p>



<a name="206818412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206818412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206818412">(Aug 13 2020 at 14:03)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="n">def</span> <span class="n">superfib&#39;_aux</span> <span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">d</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">d</span> <span class="bp">-</span> <span class="mi">1</span> <span class="k">then</span> <span class="n">superfib&#39;_aux</span> <span class="n">n</span> <span class="bp">⟨</span><span class="n">x</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="k">by</span> <span class="n">omega</span><span class="bp">⟩</span> <span class="k">else</span> <span class="err">∑</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">d</span><span class="o">,</span> <span class="n">superfib&#39;_aux</span> <span class="n">n</span> <span class="n">i</span>

<span class="n">def</span> <span class="n">superfib&#39;</span> <span class="o">(</span><span class="n">d</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="n">superfib&#39;_aux</span> <span class="n">d</span> <span class="n">n</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">hd</span><span class="bp">⟩</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="n">superfib&#39;</span> <span class="mi">3</span> <span class="mi">4</span> <span class="o">(</span><span class="n">dec_trivial</span><span class="o">)</span> <span class="c1">-- 6</span>
</code></pre></div>



<a name="206818532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206818532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206818532">(Aug 13 2020 at 14:04)</a>:</h4>
<p>You know what ? I'm dumb. I tried the exact same approach as Mario, except I didn't explicitly say <code>i : fin d</code>, so the type of <code>i</code> depended on the proof being present (<code>nat</code>) or not (<code>fin d</code>)</p>



<a name="206818610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206818610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206818610">(Aug 13 2020 at 14:05)</a>:</h4>
<p>no that's actually a really subtle part of the definition, I'm not surprised</p>



<a name="206818735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206818735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206818735">(Aug 13 2020 at 14:06)</a>:</h4>
<p>ideally we would be able to just sum over <code>i in range d</code> like you did but my approach requires that you be able to prove that the argument is well defined when it is used, which is often inconvenient</p>



<a name="206818858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206818858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206818858">(Aug 13 2020 at 14:07)</a>:</h4>
<p>Oh yeah I posted <code>range</code> and tried <code>fin</code> later for this exact reason, but it didn't work anyway cause I'm relying too much on type inferencce</p>



<a name="206818961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206818961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206818961">(Aug 13 2020 at 14:08)</a>:</h4>
<p>here's another way to do it using only <code>range</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">superfib</span> <span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">d</span> <span class="k">then</span> <span class="n">n</span> <span class="k">else</span> <span class="err">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="n">d</span><span class="o">,</span>
  <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">superfib</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">i</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>



<a name="206819009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206819009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206819009">(Aug 13 2020 at 14:08)</a>:</h4>
<p>This works to make the definition decreasing and punts on proving that the <code>else 0</code> never happens until the equational theorem</p>



<a name="206819089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206819089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206819089">(Aug 13 2020 at 14:09)</a>:</h4>
<p>Oooooh that's clever too. Thanks to everyone !</p>



<a name="206819911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206819911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206819911">(Aug 13 2020 at 14:16)</a>:</h4>
<p>you misspelt 37</p>



<a name="206869002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206869002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206869002">(Aug 13 2020 at 20:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases/near/206817741">said</a>:</p>
<blockquote>
<p>you misspelt <code>omega</code></p>
</blockquote>
<p>Kevin, we have a problem with <code>omega</code>. As you know, this tactic has some bugs and the author is no longer interested in maintaining it (or documenting it). Unless he suddenly comes back to it, we know for sure that <code>omega</code> won't survive the Lean4 migration. So we don't insist too much on using it more in mathlib.</p>



<a name="206873702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206873702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206873702">(Aug 13 2020 at 21:25)</a>:</h4>
<p>I wouldn't go that far. I think we should try to rewrite <code>omega</code>, not drop it</p>



<a name="206873741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206873741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206873741">(Aug 13 2020 at 21:25)</a>:</h4>
<p>Of course rewriting it would be even better!</p>



<a name="206873757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206873757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206873757">(Aug 13 2020 at 21:25)</a>:</h4>
<p>it obviously fills an important use case</p>



<a name="206873776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206873776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206873776">(Aug 13 2020 at 21:26)</a>:</h4>
<p>But that requires a lot of time and skills than avoiding to use it.</p>



<a name="206873839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206873839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206873839">(Aug 13 2020 at 21:26)</a>:</h4>
<p>avoiding it also requires time and skills though</p>



<a name="206874214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Inductive%20definition%20with%20many%20base%20cases/near/206874214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20definition.20with.20many.20base.20cases.html#206874214">(Aug 13 2020 at 21:29)</a>:</h4>
<p>It certainly needs a lot less skills, but it could need a lot more total time if we do it long enough.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
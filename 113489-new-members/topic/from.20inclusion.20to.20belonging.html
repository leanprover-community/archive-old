---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html">from inclusion to belonging</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="259260506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259260506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259260506">(Oct 27 2021 at 15:49)</a>:</h4>
<p>If I have <code>e: ↥(G.incidence_set ↑v)</code> and <code>h': ∀ (v : V), G.incidence_set v ⊆ G.edge_set</code>, how do I use <code>h'</code> to prove that <code>e</code> belongs to <code>G.edge_set</code>?</p>



<a name="259261216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259261216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259261216">(Oct 27 2021 at 15:54)</a>:</h4>
<p>Just apply it (-;</p>



<a name="259261233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259261233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259261233">(Oct 27 2021 at 15:54)</a>:</h4>
<p><code>h _ e</code></p>



<a name="259261343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259261343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259261343">(Oct 27 2021 at 15:55)</a>:</h4>
<p>The <em>definition</em> of <code>A ⊆ B</code> is <code>∀ x, x ∈ A → x ∈ B</code>, so tactics like <code>apply</code> (which work up to definitional equality) will work.</p>



<a name="259261479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259261479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259261479">(Oct 27 2021 at 15:56)</a>:</h4>
<p><code>h' _ e</code> or similar</p>



<a name="259262564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259262564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259262564">(Oct 27 2021 at 16:03)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">h'</span> <span class="bp">?</span><span class="n">m_1</span> <span class="n">e</span>
<span class="n">term</span>
  <span class="n">e</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">↥</span><span class="o">(</span><span class="n">G.incidence_set</span> <span class="bp">↑</span><span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m_1</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="bp">?</span><span class="n">m_2</span> <span class="o">:</span> <span class="kt">Prop</span>
</code></pre></div>
<p>Something I've been intending to ask for a while: what are those arrows pointing up (<code>↥</code> and <code>↑</code>)?</p>



<a name="259262834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259262834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259262834">(Oct 27 2021 at 16:05)</a>:</h4>
<p>These are coercion arrows. They are also covered in chapter 10 of TPiL: <a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#coercions-using-type-classes">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#coercions-using-type-classes</a></p>



<a name="259263063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259263063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259263063">(Oct 27 2021 at 16:07)</a>:</h4>
<p>Perhaps now is the time to explain this, because that error is a bit more complicated to debug.</p>



<a name="259263446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259263446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259263446">(Oct 27 2021 at 16:09)</a>:</h4>
<p>It seems to me that <code> G.incidence_set v</code> and <code>G.edge_set</code> are probably sets, because of (a) their name and (b) the fact that <code>G.incidence_set v ⊆ G.edge_set</code> typechecks. But Lean uses type theory, not set theory. Everything in Lean is either a universe, a type, or a term -- it exists at one of those three levels. Sets exist at the term level -- they are not types. But you have <code>e: ↥(G.incidence_set ↑v)</code>, so <code>e</code> is a term and its type is <code>↥(G.incidence_set ↑v)</code>, which is the type corresponding to the set <code>G.incidence_set ↑v</code>.</p>



<a name="259263726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259263726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259263726">(Oct 27 2021 at 16:11)</a>:</h4>
<p>So strictly speaking your original question does not even make sense: <code>e</code> is a term of the type <code>↥(G.incidence_set ↑v)</code>, and in particular it is not a term of type <code>sym2 V</code> (the set of unordered pairs of elements of V), so <code>e</code> cannot belong to <code>G.edge_set</code>.</p>



<a name="259263894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259263894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259263894">(Oct 27 2021 at 16:12)</a>:</h4>
<p>What is going on is that if <code>X</code> is a type (e.g. <code>sym2 V</code>) and if <code>S : set X</code> is a subset of <code>X</code> then there is an associated type <code>↥S</code>, and a term of this type is a <em>pair</em> consisting of <code>x : X</code> and a proof <code>hx : x ∈ S</code>.</p>



<a name="259264050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259264050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259264050">(Oct 27 2021 at 16:13)</a>:</h4>
<p>So <code>e</code> in your code is this pair; the element itself is called <code>e.1</code> and the proof that it's in the set is called <code>e.2</code>. The error indicates that where you put <code>e</code> Lean was expecting a proof, so I would replace <code>e</code> with <code>e.2</code>.</p>



<a name="259264649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259264649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259264649">(Oct 27 2021 at 16:17)</a>:</h4>
<p>So that's why I can use <code>e.val</code> and <code>e.property</code>? <code>.val</code> being the same as <code>.1</code> and <code>.property</code> the same as <code>.2</code>?</p>



<a name="259264685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259264685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259264685">(Oct 27 2021 at 16:17)</a>:</h4>
<p>yeah, those are the same thing</p>



<a name="259264775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259264775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259264775">(Oct 27 2021 at 16:18)</a>:</h4>
<p>e.val is the value (the term of type <code>sym2 V</code>) and <code>e.property</code> is the proof that it's in the set which you're coercing to a type</p>



<a name="259265125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259265125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259265125">(Oct 27 2021 at 16:20)</a>:</h4>
<p>The various flavours of arrows indicate when you want to conflate things which Lean thinks are different and which you might want to treat as the same; for example </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- ⊢ a = ↑b</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>the arrow means "yeah b is a natural, but we want it to be an integer, so we apply the obvious function from naturals to integers"</p>



<a name="259265398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259265398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259265398">(Oct 27 2021 at 16:22)</a>:</h4>
<p>That simple up-arrow is the most common, where terms get moved to terms. The one with the bottom edge is a more drastic one, where terms get moved to types. We see this in your setting because sets are terms because this is type theory not set theory. <code>set X</code> is the type of subsets of <code>X</code>, and <code>S : set X</code> is a term of that type, i.e. a subset of <code>X</code>, but it's not a type itself.</p>



<a name="259265841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259265841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259265841">(Oct 27 2021 at 16:25)</a>:</h4>
<p>And now, after <code>apply h' _ e.property,</code> it says:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">apply</span> <span class="n">tactic</span><span class="o">,</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">unify</span>
  <span class="bp">↥</span><span class="o">(</span><span class="n">G.edge_set</span><span class="o">)</span>
<span class="k">with</span>
  <span class="n">e.val</span> <span class="bp">∈</span> <span class="n">G.edge_set</span>
</code></pre></div>



<a name="259265898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259265898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259265898">(Oct 27 2021 at 16:25)</a>:</h4>
<p>yup, I can't unify those either. Are you up to posting some Lean code which I can run at my end yet?</p>



<a name="259265973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259265973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259265973">(Oct 27 2021 at 16:26)</a>:</h4>
<p>Showing the types of things will also help</p>



<a name="259266239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259266239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259266239">(Oct 27 2021 at 16:27)</a>:</h4>
<p>This is the complete state description:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">V</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">G</span><span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span>
<span class="n">_inst_1</span><span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">V</span>
<span class="n">_inst_2</span><span class="o">:</span> <span class="n">fintype</span> <span class="bp">↥</span><span class="o">(</span><span class="n">G.edge_set</span><span class="o">)</span>
<span class="n">_inst_3</span><span class="o">:</span> <span class="n">fintype</span> <span class="n">V</span>
<span class="n">_inst_4</span><span class="o">:</span> <span class="n">nonempty</span> <span class="n">V</span>
<span class="n">h</span><span class="o">:</span> <span class="n">G.is_tree</span>
<span class="n">root</span><span class="o">:</span> <span class="n">V</span>
<span class="n">v</span><span class="o">:</span> <span class="bp">↥</span><span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">|</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">root</span><span class="o">}</span>
<span class="n">e</span><span class="o">:</span> <span class="bp">↥</span><span class="o">(</span><span class="n">G.incidence_set</span> <span class="bp">↑</span><span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">next_edge</span> <span class="bp">↑</span><span class="n">v</span> <span class="n">root</span> <span class="n">_</span> <span class="bp">↑</span><span class="o">(</span><span class="n">G.tree_path</span> <span class="n">h</span> <span class="bp">↑</span><span class="n">v</span> <span class="n">root</span><span class="o">)</span>
<span class="n">h'</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G.incidence_set</span> <span class="n">v</span> <span class="bp">⊆</span> <span class="n">G.edge_set</span> <span class="o">:=</span> <span class="n">G.incidence_set_subset</span>
<span class="bp">⊢</span> <span class="bp">↥</span><span class="o">(</span><span class="n">G.edge_set</span><span class="o">)</span>
</code></pre></div>



<a name="259266308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259266308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259266308">(Oct 27 2021 at 16:28)</a>:</h4>
<p>Your goal isn't a Prop</p>



<a name="259266682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259266682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259266682">(Oct 27 2021 at 16:30)</a>:</h4>
<p>So something odd is happening. You can <code>specialize h' v</code> probably, and then <code>specialize h'  e.2</code> after that</p>



<a name="259266745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259266745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259266745">(Oct 27 2021 at 16:30)</a>:</h4>
<p>but it's much harder to help without having working code running in my own VS Code</p>



<a name="259266746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259266746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259266746">(Oct 27 2021 at 16:30)</a>:</h4>
<p><code>exact \&lt;_, h' _ e.2\&gt;</code> should work</p>



<a name="259266810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259266810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259266810">(Oct 27 2021 at 16:31)</a>:</h4>
<p>assuming that you want to prove that <code>e.1</code> is the element in the set</p>



<a name="259266974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259266974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259266974">(Oct 27 2021 at 16:32)</a>:</h4>
<p>The code is from that branch I pointed earlier: <code>more_on_trees</code>. I still find it hard to cut the exact pieces of the code and paste only essential things here</p>



<a name="259267035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259267035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259267035">(Oct 27 2021 at 16:32)</a>:</h4>
<p>but even when I tried to use that branch I couldn't get it working -- there were errors on a file you were importing</p>



<a name="259267133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259267133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259267133">(Oct 27 2021 at 16:33)</a>:</h4>
<p>if you can just push to the branch then I can pull and compile but the last time I tried that the first error was way before the part you were talking about, and I am reluctant to look at code beyond the first error in a file.</p>



<a name="259267219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259267219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259267219">(Oct 27 2021 at 16:34)</a>:</h4>
<p>errors in files have weird and unintended consequences</p>



<a name="259267747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259267747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259267747">(Oct 27 2021 at 16:37)</a>:</h4>
<p>branch updated. Kyle did what Mario proposed: <code>exact ⟨_, e.property.1⟩</code><br>
but I was trying to do it differently</p>



<a name="259268847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259268847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259268847">(Oct 27 2021 at 16:44)</a>:</h4>
<p>This was my line of thought... please notice that I'm still figuring things out:<br>
When Lean reads <code>let f : {v | v ≠ root} → G.edge_set</code>, it requests that I express how to take an element of <code>{v | v ≠ root}</code> to an element of <code>G.edge_set</code>. And the goal <code>↥(G.edge_set)</code> is how Lean demands it.<br>
Is it what's happening?</p>



<a name="259273306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/from%20inclusion%20to%20belonging/near/259273306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/from.20inclusion.20to.20belonging.html#259273306">(Oct 27 2021 at 17:13)</a>:</h4>
<p>Yes -- if you want to define a function in the middle of a tactic proof it's probably best to do it directly with <code>λ</code> etc: <code>let f : {v | v ≠ root} → G.edge_set := λ w, ...</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
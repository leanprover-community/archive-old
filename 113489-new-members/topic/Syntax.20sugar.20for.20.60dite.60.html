---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Syntax.20sugar.20for.20.60dite.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Syntax.20sugar.20for.20.60dite.60.html">Syntax sugar for `dite`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="202853194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Syntax%20sugar%20for%20%60dite%60/near/202853194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Syntax.20sugar.20for.20.60dite.60.html#202853194">(Jul 04 2020 at 03:04)</a>:</h4>
<p>Is there syntax sugar for <code>dite</code>? It would be nice to have a "dependent <code>if</code>" or maybe <code>if</code> could add the hypothesis to the context and generate <code>ite</code> or <code>dite</code> based on whether or not it was used.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">f</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">f</span><span class="bp">.</span><span class="n">pred</span> <span class="bp">_</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">dite</span> <span class="o">(</span><span class="n">f</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="n">f</span><span class="bp">.</span><span class="n">pred</span>
</code></pre></div>



<a name="202853205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Syntax%20sugar%20for%20%60dite%60/near/202853205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Syntax.20sugar.20for.20.60dite.60.html#202853205">(Jul 04 2020 at 03:04)</a>:</h4>
<p><code>if h : f = 0 then 0 else f.pred h</code></p>



<a name="202853216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Syntax%20sugar%20for%20%60dite%60/near/202853216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Syntax.20sugar.20for.20.60dite.60.html#202853216">(Jul 04 2020 at 03:05)</a>:</h4>
<p><code>if h : p then t else e = dite p (\lam h, t) (\lam h, e)</code></p>



<a name="202853335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Syntax%20sugar%20for%20%60dite%60/near/202853335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Syntax.20sugar.20for.20.60dite.60.html#202853335">(Jul 04 2020 at 03:09)</a>:</h4>
<p>Thank you very much!</p>



<a name="202901065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Syntax%20sugar%20for%20%60dite%60/near/202901065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Syntax.20sugar.20for.20.60dite.60.html#202901065">(Jul 05 2020 at 02:24)</a>:</h4>
<p>Is there an equivalent for <code>match</code>? I want a proof of equality with (e.g. <code>cmp x y = lt</code>) in each branch like I would have with the <code>cases</code> tactic.</p>
<div class="codehilite"><pre><span></span><code>  <span class="k">match</span> <span class="n">cmp</span> <span class="n">x</span> <span class="n">y</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">ordering</span><span class="bp">.</span><span class="n">lt</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="c1">-- I want a hypothesis `h : cmp x y = lt` here!</span>
  <span class="bp">|</span> <span class="n">ordering</span><span class="bp">.</span><span class="n">eq</span> <span class="o">:=</span> <span class="n">sorry</span>
  <span class="bp">|</span> <span class="n">ordering</span><span class="bp">.</span><span class="n">gt</span> <span class="o">:=</span> <span class="n">sorry</span>
  <span class="kn">end</span>
</code></pre></div>



<a name="202901650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Syntax%20sugar%20for%20%60dite%60/near/202901650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Syntax.20sugar.20for.20.60dite.60.html#202901650">(Jul 05 2020 at 02:45)</a>:</h4>
<p>I came up with the following, which is horribly ugly.</p>
<div class="codehilite"><pre><span></span><code>  <span class="bp">@</span><span class="n">ordering</span><span class="bp">.</span><span class="n">cases_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">o</span><span class="o">,</span> <span class="n">cmp</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">o</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span><span class="o">)</span> <span class="o">(</span><span class="n">cmp</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">sorry</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">sorry</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">sorry</span><span class="o">)</span> <span class="n">rfl</span>
</code></pre></div>



<a name="202901704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Syntax%20sugar%20for%20%60dite%60/near/202901704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Syntax.20sugar.20for.20.60dite.60.html#202901704">(Jul 05 2020 at 02:47)</a>:</h4>
<p>I am trying to define a function that lives on <code>Type</code>. I remember seeing here a while ago that tactics should only be used to generate proof and not definitions of function.</p>



<a name="202903577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Syntax%20sugar%20for%20%60dite%60/near/202903577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Syntax.20sugar.20for.20.60dite.60.html#202903577">(Jul 05 2020 at 03:51)</a>:</h4>
<p>You should not use tactics for definitions if you care about details of the generated term (e.g., presence of unneeded <code>id</code>s etc). If you don't care, then you can use tactics.</p>



<a name="202903591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Syntax%20sugar%20for%20%60dite%60/near/202903591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Syntax.20sugar.20for.20.60dite.60.html#202903591">(Jul 05 2020 at 03:51)</a>:</h4>
<p>You can also define <code>mydef</code> using tactics, then <code>#print mydef</code>.</p>



<a name="202903652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Syntax%20sugar%20for%20%60dite%60/near/202903652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Syntax.20sugar.20for.20.60dite.60.html#202903652">(Jul 05 2020 at 03:53)</a>:</h4>
<p>I don't know how to deal with <code>match</code> but you can use something like this (from <code>algebra/order</code>):</p>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm">- `compares o a b` means that `a` and `b` have the ordering relation</span>
<span class="cm">  `o` between them, assuming that the relation `a &lt; b` is defined -/</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">compares</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">ordering</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">lt</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">eq</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">gt</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">&gt;</span> <span class="n">b</span>

<span class="kn">theorem</span> <span class="n">compares</span><span class="bp">.</span><span class="n">eq_lt</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">o</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">compares</span> <span class="n">o</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="o">(</span><span class="n">o</span> <span class="bp">=</span> <span class="n">lt</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">lt</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>
<span class="bp">|</span> <span class="n">eq</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="n">injection</span> <span class="n">h</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="o">(</span><span class="n">ne_of_lt</span> <span class="n">h&#39;</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="bp">⟩</span>
<span class="bp">|</span> <span class="n">gt</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="n">injection</span> <span class="n">h</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="o">(</span><span class="n">lt_asymm</span> <span class="n">h</span> <span class="n">h&#39;</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">compares</span><span class="bp">.</span><span class="n">eq_eq</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">o</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">compares</span> <span class="n">o</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="o">(</span><span class="n">o</span> <span class="bp">=</span> <span class="n">eq</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">lt</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="n">injection</span> <span class="n">h</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="o">(</span><span class="n">ne_of_lt</span> <span class="n">h</span> <span class="n">h&#39;</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="bp">⟩</span>
<span class="bp">|</span> <span class="n">eq</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>
<span class="bp">|</span> <span class="n">gt</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="n">injection</span> <span class="n">h</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="o">(</span><span class="n">ne_of_gt</span> <span class="n">h</span> <span class="n">h&#39;</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="bp">⟩</span>
</code></pre></div>



<a name="202903705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Syntax%20sugar%20for%20%60dite%60/near/202903705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Syntax.20sugar.20for.20.60dite.60.html#202903705">(Jul 05 2020 at 03:55)</a>:</h4>
<p>Now I know:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">ordering</span><span class="bp">.</span><span class="n">compares</span><span class="bp">.</span><span class="n">symm</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">ordering</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">o</span><span class="bp">.</span><span class="n">compares</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">o</span><span class="bp">.</span><span class="n">swap</span><span class="bp">.</span><span class="n">compares</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">o</span><span class="o">,</span> <span class="n">h</span> <span class="k">with</span>
<span class="bp">|</span> <span class="n">ordering</span><span class="bp">.</span><span class="n">lt</span><span class="o">,</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h</span>
<span class="bp">|</span> <span class="n">ordering</span><span class="bp">.</span><span class="n">eq</span><span class="o">,</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="n">symm</span>
<span class="bp">|</span> <span class="n">ordering</span><span class="bp">.</span><span class="n">gt</span><span class="o">,</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h</span>
<span class="kn">end</span>
</code></pre></div>



<a name="202949890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Syntax%20sugar%20for%20%60dite%60/near/202949890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Syntax.20sugar.20for.20.60dite.60.html#202949890">(Jul 06 2020 at 03:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113489-new-members/topic/Syntax.20sugar.20for.20.60dite.60/near/202903705">said</a>:</p>
<blockquote>
<p>Now I know:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">ordering</span><span class="bp">.</span><span class="n">compares</span><span class="bp">.</span><span class="n">symm</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">ordering</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">o</span><span class="bp">.</span><span class="n">compares</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">o</span><span class="bp">.</span><span class="n">swap</span><span class="bp">.</span><span class="n">compares</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">o</span><span class="o">,</span> <span class="n">h</span> <span class="k">with</span>
<span class="bp">|</span> <span class="n">ordering</span><span class="bp">.</span><span class="n">lt</span><span class="o">,</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h</span>
<span class="bp">|</span> <span class="n">ordering</span><span class="bp">.</span><span class="n">eq</span><span class="o">,</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="n">symm</span>
<span class="bp">|</span> <span class="n">ordering</span><span class="bp">.</span><span class="n">gt</span><span class="o">,</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h</span>
<span class="kn">end</span>
</code></pre></div>


</blockquote>
<p>I ended up setting for a solution using <code>algebra/order</code>. This lemma is very elegant, thank you!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
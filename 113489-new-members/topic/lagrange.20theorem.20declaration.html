---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/lagrange.20theorem.20declaration.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html">lagrange theorem declaration</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="246440617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lagrange%20theorem%20declaration/near/246440617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html#246440617">(Jul 19 2021 at 10:56)</a>:</h4>
<p>I am working on partitioning G into the left cosets of H, and my last hiccup is the equality of any given section of the partition with a left coset of H. I see that the issue is using <code>=</code>, but I'm not sure what I could use in its stead to complete the statement.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">group_theory.coset</span>
<span class="kn">import</span> <span class="n">data.set.basic</span>
<span class="kn">import</span> <span class="n">group_theory.order_of_element</span>

<span class="kd">@[ext]</span> <span class="kd">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">Hnonempty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">C</span><span class="o">,</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span>
<span class="o">(</span><span class="n">Hcover</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">C</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">Hdisjoint</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">∈</span> <span class="n">C</span><span class="o">,</span> <span class="o">(</span><span class="n">X</span> <span class="bp">∩</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">partition</span>

<span class="kd">lemma</span> <span class="n">lagrange</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">P.C</span><span class="o">),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">left_coset</span> <span class="n">g</span> <span class="n">H</span> <span class="o">)</span> <span class="o">:</span>
<span class="n">fintype.card</span> <span class="n">H</span> <span class="bp">∣</span> <span class="n">fintype.card</span> <span class="n">G</span> <span class="o">:=</span> <span class="c1">--the size of the subgroup H divides the size of the group G</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
  <span class="c1">--partition G into left cosets of H</span>
  <span class="c1">--G is finite, so exists g₁, g₂, ..., gₖ s.t. g₁H, ..., gₖH partition G,</span>
  <span class="c1">--Then |G| = |g₁H| + |g₂H| + ... + |gₖH|</span>
  <span class="c1">--         = |H| + |H| + ... |H|</span>
  <span class="c1">--         = k|H|, k is number of distinct left cosets of H in H</span>
  <span class="c1">--Thus |H| divides |G| and the goal is fulfilled</span>
<span class="kd">end</span>
</code></pre></div>



<a name="246440984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lagrange%20theorem%20declaration/near/246440984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html#246440984">(Jul 19 2021 at 11:01)</a>:</h4>
<p>I think you have confused <code>:</code> and <code>∈</code> there; this works: <code>lemma lagrange (P : partition G) (h: ∀ X, X ∈ P.C → ∃ (g : G), X = left_coset g H ) :</code></p>



<a name="246441268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lagrange%20theorem%20declaration/near/246441268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html#246441268">(Jul 19 2021 at 11:05)</a>:</h4>
<p>Although your hypothesis isn't needed, and the statement is already in mathlib: <a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup.card_subgroup_dvd_card">docs#subgroup.card_subgroup_dvd_card</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- the size of the subgroup H divides the size of the group G -/</span>
<span class="kd">lemma</span> <span class="n">lagrange</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">H</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">X</span><span class="o">,</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P.C</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">left_coset</span> <span class="n">g</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">fintype.card</span> <span class="n">H</span> <span class="bp">∣</span> <span class="n">fintype.card</span> <span class="n">G</span> <span class="o">:=</span>
<span class="n">H.card_subgroup_dvd_card</span>  <span class="c1">-- oops I didn't use `h` or `P` at all</span>
</code></pre></div>



<a name="246442656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lagrange%20theorem%20declaration/near/246442656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html#246442656">(Jul 19 2021 at 11:24)</a>:</h4>
<p>Do you need to declare H as fintype if you've done so for G and make H a subgroup of G?</p>



<a name="246446620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lagrange%20theorem%20declaration/near/246446620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html#246446620">(Jul 19 2021 at 12:12)</a>:</h4>
<p>Yes, because you want your lemma to say "this works for any proof that <code>H</code> is finite, not just the one derived by filtering <code>G</code>"</p>



<a name="246446639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lagrange%20theorem%20declaration/near/246446639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html#246446639">(Jul 19 2021 at 12:12)</a>:</h4>
<p>For your case it probably doesn't matter, but that's why mathlib has both</p>



<a name="246446675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lagrange%20theorem%20declaration/near/246446675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html#246446675">(Jul 19 2021 at 12:13)</a>:</h4>
<p>(also, you can't derive it by filtering <code>G</code> unless you have <code>[decidable_pred (∈ H)]</code>)</p>



<a name="246457500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lagrange%20theorem%20declaration/near/246457500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html#246457500">(Jul 19 2021 at 13:54)</a>:</h4>
<div class="codehilite" data-code-language="import"><pre><span></span><code>import group_theory.coset
import data.set.basic
import group_theory.order_of_element
import data.fintype.basic
import week_1.Part_D_relations


variables {G : Type} [fintype G] [group G]
variables (H : subgroup G) [fintype H]

open function

lemma coset_sizes_long : ∀ (g : G), fintype.card (left_coset g H) = fintype.card H :=
begin
  intro g,
  let f := (λ H, left_coset g H),
  --I take issue with only needing to show injection to prove bijection
  --I'm not convinced the function should be from set G to set G
  --or at least cannot be implied that easily
  --the proof from FPM we proved both injection and surjection
  --we need map H → gH
  have h₂ : injective f,
  {refine set.image_injective.mpr _,
  dsimp,
  exact mul_right_injective g,
  },
  have h₃ : bijective f,
  exact fintype.injective_iff_bijective.mp h₂,
  have h₄ : H ≃ left_coset g H,
  {sorry,},
  exact fintype.card_congr (equiv.symm h₄),
end
</code></pre></div>
<p>Yeah just in a spot of pain. I see that I can pretty much jump to the end using</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">coset_sizes</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">left_coset</span> <span class="n">g</span> <span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">H</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">g</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₄</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">≃</span> <span class="n">left_coset</span> <span class="n">g</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">subgroup.left_coset_equiv_subgroup</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">fintype.card_congr</span> <span class="o">(</span><span class="n">equiv.symm</span> <span class="n">h₄</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>
<p>but that just skips the whole part where I learn.<br>
I see why Lean thinks it only needs to be injective, as then since we're going from set G to set G and G is finite, the function is bijective, but then I must've defined something incorrectly because I'm fairly sure you need to prove both injection and surjection.</p>



<a name="246462022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lagrange%20theorem%20declaration/near/246462022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html#246462022">(Jul 19 2021 at 14:30)</a>:</h4>
<p>(The first code snippet is highlighted badly because you forgot the line break between <code> ``` </code> and <code>import tactic</code>)</p>



<a name="246462151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lagrange%20theorem%20declaration/near/246462151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html#246462151">(Jul 19 2021 at 14:31)</a>:</h4>
<p>right, cheers for highlighting that</p>



<a name="246462347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lagrange%20theorem%20declaration/near/246462347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html#246462347">(Jul 19 2021 at 14:33)</a>:</h4>
<p>I think <a href="https://leanprover-community.github.io/mathlib_docs/find/injective_iff_surjective/src">src#injective_iff_surjective</a> is the core of the thing you take issue with</p>



<a name="248714796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lagrange%20theorem%20declaration/near/248714796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html#248714796">(Aug 07 2021 at 12:46)</a>:</h4>
<p>Sorry if this is a bit long but I'm checking if we've accidentally done something like used a fact to prove a fact. In proving Lagrange's Theorem we didn't end up making a partition but we did use the injective function and showed the cosets are disjoint. Would love to know if this is a solid proof, no worries if it's a bit too long/tedious to check.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">group_theory.coset</span>
<span class="kn">import</span> <span class="n">data.set.basic</span>
<span class="kn">import</span> <span class="n">group_theory.order_of_element</span>
<span class="kn">import</span> <span class="n">data.equiv.basic</span>
<span class="kn">import</span> <span class="n">data.fintype.card</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kn">import</span> <span class="n">data.list.defs</span>
<span class="kn">import</span> <span class="n">data.sigma.basic</span>
<span class="kn">import</span> <span class="n">algebra.big_operators.basic</span>

<span class="kn">open</span> <span class="n">subgroup</span>

<span class="kn">open</span> <span class="n">function</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">H</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">coset_sizes_mathlib</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">left_coset</span> <span class="n">g</span> <span class="n">H</span><span class="o">)]:</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">left_coset</span> <span class="n">g</span> <span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">H</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h₄</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">≃</span> <span class="n">left_coset</span> <span class="n">g</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">subgroup.left_coset_equiv_subgroup</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">fintype.card_congr</span> <span class="o">(</span><span class="n">equiv.symm</span> <span class="n">h₄</span><span class="o">),</span>
<span class="kd">end</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">def</span> <span class="n">is_refl_type</span> <span class="o">{</span><span class="n">X</span><span class="o">:</span><span class="kt">Type</span><span class="o">}(</span><span class="n">S</span><span class="o">:</span> <span class="n">X</span><span class="bp">→</span> <span class="n">X</span><span class="bp">→</span> <span class="kt">Prop</span><span class="o">):=</span> <span class="c1">-- Def 1 --</span>
<span class="bp">∀</span> <span class="n">a</span><span class="o">:</span><span class="n">X</span><span class="o">,</span> <span class="n">S</span> <span class="n">a</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">is_symm_type</span> <span class="o">{</span><span class="n">X</span><span class="o">:</span><span class="kt">Type</span><span class="o">}(</span><span class="n">S</span><span class="o">:</span> <span class="n">X</span><span class="bp">→</span> <span class="n">X</span><span class="bp">→</span> <span class="kt">Prop</span><span class="o">):=</span> <span class="c1">-- Def 2 --</span>
<span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">:</span><span class="n">X</span><span class="o">,</span> <span class="n">S</span> <span class="n">a</span> <span class="n">b</span><span class="bp">→</span> <span class="n">S</span> <span class="n">b</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">is_trans_type</span> <span class="o">{</span><span class="n">X</span><span class="o">:</span><span class="kt">Type</span><span class="o">}(</span><span class="n">S</span><span class="o">:</span><span class="n">X</span><span class="bp">→</span> <span class="n">X</span><span class="bp">→</span> <span class="kt">Prop</span><span class="o">):=</span> <span class="c1">-- Def 3 --</span>
<span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">:</span><span class="n">X</span><span class="o">,</span> <span class="n">S</span> <span class="n">a</span> <span class="n">b</span><span class="bp">→</span> <span class="n">S</span> <span class="n">b</span> <span class="n">c</span><span class="bp">→</span> <span class="n">S</span> <span class="n">a</span> <span class="n">c</span>

<span class="kd">def</span> <span class="n">is_equiv_type</span> <span class="o">{</span><span class="n">X</span><span class="o">:</span><span class="kt">Type</span><span class="o">}(</span><span class="n">S</span><span class="o">:</span><span class="n">X</span><span class="bp">→</span> <span class="n">X</span><span class="bp">→</span> <span class="kt">Prop</span><span class="o">):=</span> <span class="c1">-- Def 4--</span>
<span class="n">is_refl_type</span> <span class="n">S</span> <span class="bp">∧</span> <span class="n">is_symm_type</span> <span class="n">S</span>
<span class="bp">∧</span> <span class="n">is_trans_type</span> <span class="n">S</span>

<span class="kd">def</span> <span class="n">equiv_class_type</span> <span class="o">{</span><span class="n">X</span><span class="o">:</span><span class="kt">Type</span><span class="o">}(</span><span class="n">S</span><span class="o">:</span><span class="n">X</span><span class="bp">→</span> <span class="n">X</span><span class="bp">→</span> <span class="kt">Prop</span><span class="o">)(</span><span class="n">a</span><span class="o">:</span><span class="n">X</span><span class="o">):=</span> <span class="c1">-- Def 5 --</span>
<span class="o">{</span><span class="n">x</span><span class="o">:</span><span class="n">X</span> <span class="bp">|</span> <span class="n">S</span> <span class="n">x</span> <span class="n">a</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">left_coset_rel</span><span class="o">:</span> <span class="n">G</span><span class="bp">→</span> <span class="n">G</span><span class="bp">→</span> <span class="kt">Prop</span><span class="o">:=</span>
<span class="bp">λ</span><span class="n">a</span><span class="o">:</span><span class="n">G</span><span class="o">,</span><span class="bp">λ</span><span class="n">b</span><span class="o">:</span><span class="n">G</span><span class="o">,</span> <span class="n">left_coset</span> <span class="n">a</span> <span class="n">H</span> <span class="bp">=</span> <span class="n">left_coset</span> <span class="n">b</span> <span class="n">H</span>

<span class="kd">lemma</span> <span class="n">left_coset_rel_is_refl</span><span class="o">:</span><span class="n">is_refl_type</span> <span class="o">(</span><span class="n">left_coset_rel</span> <span class="n">H</span><span class="o">):=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">is_refl_type</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">left_coset_rel</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">left_coset_rel_is_symm</span><span class="o">:</span><span class="n">is_symm_type</span> <span class="o">(</span><span class="n">left_coset_rel</span> <span class="n">H</span><span class="o">):=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">is_symm_type</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">left_coset_rel</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">symmetry</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">f</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">left_coset_rel_is_trans</span><span class="o">:</span><span class="n">is_trans_type</span> <span class="o">(</span><span class="n">left_coset_rel</span> <span class="n">H</span><span class="o">):=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">is_trans_type</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">left_coset_rel</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">g</span> <span class="n">at</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">f</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">left_coset_rel_is_equiv</span><span class="o">:</span><span class="n">is_equiv_type</span> <span class="o">(</span><span class="n">left_coset_rel</span> <span class="n">H</span><span class="o">):=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">left_coset_rel_is_refl</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">left_coset_rel_is_symm</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">left_coset_rel_is_trans</span> <span class="n">H</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">in_coset</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">G</span><span class="o">):</span><span class="n">x</span><span class="bp">∈</span> <span class="n">left_coset</span> <span class="n">x</span> <span class="n">H</span><span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">left_coset</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">one_mem</span> <span class="n">H</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">equiv_class_is_coset</span><span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">G</span><span class="o">):</span>
<span class="n">equiv_class_type</span> <span class="o">(</span><span class="n">left_coset_rel</span> <span class="n">H</span><span class="o">)</span> <span class="n">a</span><span class="bp">=</span><span class="n">left_coset</span> <span class="n">a</span> <span class="n">H</span><span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext1</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>

  <span class="n">intro</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">equiv_class_type</span> <span class="n">at</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">left_coset_rel</span> <span class="n">at</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">in_coset</span> <span class="n">H</span><span class="o">)</span> <span class="n">x</span><span class="o">,</span>

  <span class="n">intro</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">equiv_class_type</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">left_coset_rel</span><span class="o">,</span>
  <span class="n">ext1</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">left_coset</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">temp</span><span class="o">:</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x_1</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x_1</span><span class="o">):=</span><span class="kd">begin</span>
    <span class="n">rw</span> <span class="n">mul_assoc</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">mul_assoc</span> <span class="n">x</span> <span class="n">x</span><span class="bp">⁻¹</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">temp</span><span class="o">,</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">mul_mem</span> <span class="n">H</span><span class="o">)</span> <span class="n">g</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">left_coset</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">g_inv</span><span class="o">:=(</span><span class="n">inv_mem</span> <span class="n">H</span><span class="o">)</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">g_inv</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">temp</span><span class="o">:</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x_1</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x_1</span><span class="o">):=</span><span class="kd">begin</span>
    <span class="n">rw</span> <span class="n">mul_assoc</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">mul_assoc</span> <span class="n">a</span> <span class="n">a</span><span class="bp">⁻¹</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">temp</span><span class="o">,</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">mul_mem</span> <span class="n">H</span><span class="o">)</span> <span class="n">g_inv</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">in_equiv_class</span> <span class="o">{</span><span class="n">X</span><span class="o">:</span><span class="kt">Type</span><span class="o">}{</span><span class="n">S</span><span class="o">:</span><span class="n">X</span><span class="bp">→</span> <span class="n">X</span><span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
<span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">is_equiv_type</span> <span class="n">S</span><span class="o">)(</span><span class="n">a</span><span class="o">:</span><span class="n">X</span><span class="o">):</span>
<span class="n">a</span><span class="bp">∈</span> <span class="n">equiv_class_type</span> <span class="n">S</span> <span class="n">a</span><span class="o">:=</span> <span class="c1">-- Lemma 7 --</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">p</span> <span class="n">a</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">equiv_iff_same_class</span> <span class="o">{</span><span class="n">X</span><span class="o">:</span><span class="kt">Type</span><span class="o">}{</span><span class="n">S</span><span class="o">:</span><span class="n">X</span><span class="bp">→</span> <span class="n">X</span><span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
<span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">is_equiv_type</span> <span class="n">S</span><span class="o">)(</span><span class="n">a</span><span class="o">:</span><span class="n">X</span><span class="o">)(</span><span class="n">b</span><span class="o">:</span><span class="n">X</span><span class="o">):</span>
<span class="n">S</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">equiv_class_type</span> <span class="n">S</span> <span class="n">a</span><span class="bp">=</span><span class="n">equiv_class_type</span> <span class="n">S</span> <span class="n">b</span>
<span class="o">:=</span>  <span class="c1">-- Lemma 9 --</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">rfl</span><span class="o">:=</span><span class="n">h.1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">sym</span><span class="o">:=</span><span class="n">h.2.1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">tran</span><span class="o">:=</span><span class="n">h.2.2</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>

  <span class="c">/-</span><span class="cm"> → -/</span>
  <span class="n">intro</span> <span class="n">f</span><span class="o">,</span>
  <span class="c1">--cases h with rfl st,</span>
  <span class="c1">--cases st with sym tran,</span>
  <span class="n">rw</span> <span class="n">set.subset.antisymm_iff</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="c">/-</span><span class="cm"> → ⊆-/</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">tran</span> <span class="n">x</span> <span class="n">a</span> <span class="n">b</span> <span class="n">g</span> <span class="n">f</span><span class="o">,</span>
  <span class="c">/-</span><span class="cm"> → ⊇ -/</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">g</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">t</span><span class="o">:=</span><span class="n">sym</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">tran</span> <span class="n">x</span> <span class="n">b</span> <span class="n">a</span> <span class="n">g</span> <span class="n">t</span><span class="o">,</span>

  <span class="c">/-</span><span class="cm"> ← -/</span>
  <span class="n">intro</span> <span class="n">f</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">u</span><span class="o">:=</span><span class="n">in_equiv_class</span> <span class="n">h</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">f</span> <span class="n">at</span> <span class="n">u</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">u</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">equiv_iff_class_intersect</span><span class="o">{</span><span class="n">X</span><span class="o">:</span><span class="kt">Type</span><span class="o">}{</span><span class="n">S</span><span class="o">:</span><span class="n">X</span><span class="bp">→</span> <span class="n">X</span><span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
<span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">is_equiv_type</span> <span class="n">S</span><span class="o">)(</span><span class="n">a</span><span class="o">:</span><span class="n">X</span><span class="o">)(</span><span class="n">b</span><span class="o">:</span><span class="n">X</span><span class="o">):</span>
<span class="n">S</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">equiv_class_type</span> <span class="n">S</span> <span class="n">a</span> <span class="bp">∩</span> <span class="n">equiv_class_type</span> <span class="n">S</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span>
<span class="o">:=</span> <span class="c1">--Lemma 10 --</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">rfl</span><span class="o">:=</span><span class="n">h.1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">sym</span><span class="o">:=</span><span class="n">h.2.1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">tran</span><span class="o">:=</span><span class="n">h.2.2</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>

  <span class="c">/-</span><span class="cm"> → -/</span>
  <span class="n">intro</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">set.nonempty</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">set.mem_inter_eq</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">t</span><span class="o">:=</span><span class="n">in_equiv_class</span> <span class="n">h</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">f</span><span class="o">,</span>

  <span class="c">/-</span><span class="cm"> ← -/</span>
  <span class="n">intro</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">f</span> <span class="k">with</span> <span class="n">x</span> <span class="n">fx</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">set.mem_inter_eq</span> <span class="n">at</span> <span class="n">fx</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">fx</span> <span class="k">with</span> <span class="n">fxp</span> <span class="n">fxq</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">t</span><span class="o">:=</span><span class="n">sym</span> <span class="n">x</span> <span class="n">a</span> <span class="n">fxp</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">tran</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span> <span class="n">t</span> <span class="n">fxq</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">same_class_iff_intersect</span><span class="o">{</span><span class="n">X</span><span class="o">:</span><span class="kt">Type</span><span class="o">}{</span><span class="n">S</span><span class="o">:</span><span class="n">X</span><span class="bp">→</span> <span class="n">X</span><span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
<span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">is_equiv_type</span> <span class="n">S</span><span class="o">)(</span><span class="n">a</span><span class="o">:</span><span class="n">X</span><span class="o">)(</span><span class="n">b</span><span class="o">:</span><span class="n">X</span><span class="o">):</span> <span class="c1">-- Lemma 11 --</span>
<span class="n">equiv_class_type</span> <span class="n">S</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">equiv_class_type</span> <span class="n">S</span> <span class="n">b</span> <span class="bp">↔</span>
<span class="o">(</span><span class="n">equiv_class_type</span> <span class="n">S</span> <span class="n">a</span> <span class="bp">∩</span> <span class="n">equiv_class_type</span> <span class="n">S</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">p</span><span class="o">:=</span><span class="n">equiv_iff_same_class</span> <span class="n">h</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">q</span><span class="o">:=</span><span class="n">equiv_iff_class_intersect</span> <span class="n">h</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">p</span> <span class="n">at</span> <span class="n">q</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">q</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">equiv.set.sigma_of_disjoint</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">disjoint</span> <span class="o">(</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="n">j</span><span class="o">))</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">↥⋃</span> <span class="n">i</span><span class="o">,</span> <span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="bp">≃</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="bp">↥</span><span class="o">(</span><span class="n">S</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">u</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">set.mem_Union.mp</span> <span class="n">u.prop</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">h.some</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="n">h.some_spec</span><span class="o">⟩,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="o">⟨</span><span class="n">s.2</span><span class="o">,</span> <span class="n">set.mem_Union.mpr</span> <span class="o">⟨</span><span class="n">s.1</span><span class="o">,</span> <span class="n">s.2.prop</span><span class="o">⟩⟩,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">u</span><span class="o">,</span> <span class="n">subtype.ext</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">sigma.subtype_ext</span> <span class="o">(</span><span class="kd">begin</span>
    <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">generalize_proofs</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">by_contra</span> <span class="n">hfst</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">set.not_disjoint_iff.mpr</span> <span class="o">⟨(</span><span class="n">s.snd</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">h.some_spec</span><span class="o">,</span> <span class="n">s.snd.prop</span><span class="o">⟩</span> <span class="o">(</span><span class="n">hS</span> <span class="n">h.some</span> <span class="n">s.fst</span> <span class="n">hfst</span><span class="o">),</span>
  <span class="kd">end</span><span class="o">)</span> <span class="n">rfl</span> <span class="o">}</span>


<span class="kd">lemma</span> <span class="n">lagrange_long_sum_attempt_3</span>
<span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="c1">-- (P : partition G)</span>
<span class="c1">-- (h: ∀ X, X ∈ P.C → ∃ (g : G), X = left_coset g H)</span>
<span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">G</span><span class="o">}</span>
<span class="o">{</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">injective</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)}</span>
<span class="o">{</span><span class="n">h₃</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="n">set.univ</span><span class="o">}</span>
<span class="o">[</span><span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)]</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="bp">⋃</span><span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)]:</span>
<span class="n">fintype.card</span> <span class="n">H</span> <span class="bp">∣</span> <span class="n">fintype.card</span> <span class="n">G</span> <span class="o">:=</span> <span class="c1">--the size of the subgroup H divides the size of the group G</span>
<span class="kd">begin</span>
  <span class="c1">--partition G into left cosets of H `done`</span>

  <span class="c1">--G is finite, so exists g₁, g₂, ..., gₖ s.t. g₁H, ..., gₖH partition G `done?`</span>

  <span class="k">have</span> <span class="n">h₄</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="n">set.univ</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">G</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">fintype.of_equiv_card</span> <span class="o">(</span><span class="n">equiv.set.univ</span> <span class="n">G</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">h₄</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">dvd_of_mul_left_eq</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">k</span><span class="o">,</span>
  <span class="c">/-</span><span class="cm">have h₁ : coe_sort set.univ = coe_sort (⋃(i : fin k), left_coset (γ i) H),</span>
<span class="cm">  exact congr_arg coe_sort h₃.symm,</span>
<span class="cm">  simp_rw h₁,-/</span>

  <span class="k">have</span> <span class="n">h_left_coset</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">:</span><span class="n">fin</span> <span class="n">k</span> <span class="o">,</span><span class="n">i</span><span class="bp">≠</span> <span class="n">j</span><span class="bp">→</span> <span class="n">disjoint</span> <span class="o">(</span><span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">j</span><span class="o">)</span> <span class="n">H</span><span class="o">):=</span><span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">i</span> <span class="n">j</span> <span class="n">f</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">disjoint</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">g</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">g</span> <span class="k">with</span> <span class="n">g_i</span> <span class="n">g_j</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">ne</span><span class="o">:</span><span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span> <span class="bp">≠</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">j</span><span class="o">)</span> <span class="n">H</span><span class="o">,</span> <span class="c1">--by h2</span>
      <span class="n">unfold</span> <span class="n">injective</span> <span class="n">at</span> <span class="n">h₂</span><span class="o">,</span>
      <span class="n">by_contradiction</span> <span class="n">K</span><span class="o">,</span>
      <span class="n">push_neg</span> <span class="n">at</span> <span class="n">K</span><span class="o">,</span>
      <span class="n">specialize</span> <span class="n">h₂</span> <span class="n">K</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">f</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="n">contrapose</span> <span class="n">ne</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">equiv_class_is_coset</span> <span class="n">H</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">equiv_class_is_coset</span> <span class="n">H</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">intersect</span><span class="o">:((</span><span class="n">equiv_class_type</span> <span class="o">(</span><span class="n">left_coset_rel</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">))</span><span class="bp">∩</span>
    <span class="o">(</span><span class="n">equiv_class_type</span> <span class="o">(</span><span class="n">left_coset_rel</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="n">j</span><span class="o">)))</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">:=</span><span class="kd">begin</span>
      <span class="n">rw</span> <span class="n">set.nonempty_def</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">simp</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">g_i</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">g_j</span><span class="o">,</span>
    <span class="kd">end</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">same_class_iff_intersect</span> <span class="o">(</span><span class="n">left_coset_rel_is_equiv</span> <span class="n">H</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">intersect</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>

  <span class="k">have</span> <span class="n">h₆</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⋃</span> <span class="n">i</span><span class="o">,</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span> <span class="bp">≃</span> <span class="o">(</span><span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">equiv.set.sigma_of_disjoint</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↑</span><span class="n">H</span><span class="o">)</span> <span class="n">h_left_coset</span><span class="o">,</span>

  <span class="k">have</span> <span class="n">h₇</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">set.univ</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">temp</span><span class="o">:(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span> <span class="bp">≃</span> <span class="n">set.univ</span><span class="o">:=</span><span class="n">equiv.cast</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">fintype.card_congr</span> <span class="n">temp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h₃</span><span class="o">,</span>

  <span class="k">have</span> <span class="n">h₅</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">),</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">fintype.card_sigma</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">fintype.card_congr</span> <span class="n">h₆</span><span class="o">,</span>

  <span class="n">rw</span> <span class="bp">←</span> <span class="n">h₇</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h₅</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">fintype.card</span> <span class="n">H</span><span class="o">,</span>

  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">coset_sizes_mathlib</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">this</span><span class="o">,</span>

  <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="248716824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lagrange%20theorem%20declaration/near/248716824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html#248716824">(Aug 07 2021 at 13:36)</a>:</h4>
<p>In a previous thread I showed you that <code>equiv.set.sigma_of_disjoint</code> already existed so there is no need to define it yourself</p>



<a name="248716999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lagrange%20theorem%20declaration/near/248716999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html#248716999">(Aug 07 2021 at 13:40)</a>:</h4>
<p>Your <code>have ne :</code> is <a href="https://leanprover-community.github.io/mathlib_docs/find/function.injective.ne">docs#function.injective.ne</a>, <code>h₂.ne f</code></p>



<a name="248762915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lagrange%20theorem%20declaration/near/248762915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html#248762915">(Aug 08 2021 at 10:04)</a>:</h4>
<p>Perfect I'll make those adjustments. Thank you for your input throughout!</p>



<a name="248763230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lagrange%20theorem%20declaration/near/248763230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html#248763230">(Aug 08 2021 at 10:13)</a>:</h4>
<p>Are you aware your <code>is_equiv_type</code> exists already as <a href="https://leanprover-community.github.io/mathlib_docs/find/equivalence">docs#equivalence</a>? It's not clear to me to what extent you are trying to prove things from scratch for pedagogical reasons (as your final result is obviously in mathlib already), and to what extent you are trying to learn about and leverage other parts of mathlib.</p>



<a name="248763303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lagrange%20theorem%20declaration/near/248763303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html#248763303">(Aug 08 2021 at 10:15)</a>:</h4>
<p>is_equiv_type is part of a parallel project that a group member is working on to define equivalence relations from the ground up. I originally used equivalence, but we wanted to prove that the left cosets formed a partition and he was more comfortable working in the foundation he laid. I would normally have used <a href="https://leanprover-community.github.io/mathlib_docs/find/equivalence">docs#equivalence</a> otherwise.</p>



<a name="248763347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lagrange%20theorem%20declaration/near/248763347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html#248763347">(Aug 08 2021 at 10:16)</a>:</h4>
<p>I see your point though, it's not quite consistent when I use something that already exists.</p>



<a name="248763350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lagrange%20theorem%20declaration/near/248763350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lagrange.20theorem.20declaration.html#248763350">(Aug 08 2021 at 10:16)</a>:</h4>
<p>We ended up not using the partition as well, which is unfortunate.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
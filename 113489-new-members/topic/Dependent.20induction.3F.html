---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Dependent.20induction.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html">Dependent induction?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="178468919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178468919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178468919">(Oct 18 2019 at 12:36)</a>:</h4>
<p>Hi,<br>
I am trying to formalize a few things in graph theory, and for that I am introducing a helper inductive type of non-empty lists, like this :</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">llist</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">|</span> <span class="n">P</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="n">llist</span> <span class="bp">|</span> <span class="n">L</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="n">llist</span> <span class="bp">-&gt;</span> <span class="n">llist</span>
</pre></div>


<p>Such lists have a first and last elements,</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">first</span> <span class="o">:</span> <span class="n">llist</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="n">V</span> <span class="bp">|</span> <span class="o">(</span><span class="n">P</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">v</span> <span class="bp">|</span> <span class="o">(</span><span class="n">L</span> <span class="n">v</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">v</span>
<span class="n">def</span> <span class="n">last</span>  <span class="o">:</span> <span class="n">llist</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="n">V</span> <span class="bp">|</span> <span class="o">(</span><span class="n">P</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">v</span> <span class="bp">|</span> <span class="o">(</span><span class="n">L</span> <span class="n">v</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">last</span> <span class="n">l</span>
</pre></div>


<p>and I define a <code>path</code> to be a <code>llist</code> with prescribed endpoints: </p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">path</span> <span class="o">(</span><span class="n">V</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">l</span> <span class="o">:</span> <span class="n">llist</span> <span class="n">V</span> <span class="bp">//</span> <span class="n">first</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">last</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">}</span>
</pre></div>


<p>So far so good, now I want to concatenate paths with compatible endpoints,</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">concat</span> <span class="o">{</span><span class="n">V</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="n">x</span> <span class="n">z</span>
</pre></div>


<p>just concatenating the lists of elements but without repeating the <code>y</code>. For the moment, the only way I manage to do it is to first define it on unconstrained llists, like this,</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">concat&#39;</span> <span class="o">{</span><span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">l1</span> <span class="n">l2</span> <span class="o">:</span> <span class="n">llist</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">last</span> <span class="n">l1</span> <span class="bp">=</span> <span class="n">first</span> <span class="n">l2</span><span class="o">)</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="o">(</span><span class="n">first</span> <span class="n">l1</span><span class="o">)</span> <span class="o">(</span><span class="n">last</span> <span class="n">l2</span><span class="o">)</span>
</pre></div>


<p>inductively, and then use that to define <code>concat</code>. When I try to define <code>concat</code> directly by induction on p1.val, it fails because in the inductive step, x is still there while the tail of p1.val obviously doesn't start with x, so the induction hypothesis is not useful.</p>
<p>Am I missing something? What is the right way to use induction for such dependent types?</p>



<a name="178469658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178469658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178469658">(Oct 18 2019 at 12:45)</a>:</h4>
<p>Hi! I'm guessing that you're doing induction by pattern-matching on the arguments (as in the tutorial here: <a href="https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html#pattern-matching" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html#pattern-matching">https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html#pattern-matching</a>). When definining <code>concat</code>, <code>x</code> is fixed (because it's on the left of the colon), but it varies in the recursive call. So you can put it on the right with a Π-type.</p>



<a name="178471555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178471555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178471555">(Oct 18 2019 at 13:07)</a>:</h4>
<blockquote>
<p>Hi! I'm guessing that you're doing induction by pattern-matching on the arguments</p>
</blockquote>
<p>I am doing it like this, which might be completely misguided:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">concat</span> <span class="o">{</span><span class="n">V</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="n">x</span> <span class="n">z</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">rcases</span> <span class="n">p1</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">l1</span><span class="o">,</span><span class="n">hx</span><span class="o">,</span><span class="n">hy</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">l1</span> <span class="k">with</span> <span class="n">v</span> <span class="n">v</span> <span class="n">l</span> <span class="n">hr</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">&lt;-</span><span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="o">],</span> <span class="n">exact</span> <span class="n">p2</span> <span class="o">},</span>
    <span class="c1">-- Now the state contains these, which are useless:</span>
    <span class="c1">-- hr : first l = x -&gt; last l = y -&gt; path x z</span>
    <span class="c1">-- hx : first (L v l) = x</span>
    <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>



<a name="178471867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178471867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178471867">(Oct 18 2019 at 13:11)</a>:</h4>
<p>don't use tactics for <code>def</code>s unless you know what you're doing</p>



<a name="178472063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178472063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178472063">(Oct 18 2019 at 13:13)</a>:</h4>
<p><span class="user-mention" data-user-id="242586">@Vincent Beffara</span> Kenny's warning is for the following reason: tactics usually leave artifacts that are very annoying to handle later on.</p>



<a name="178472115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178472115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178472115">(Oct 18 2019 at 13:14)</a>:</h4>
<p>For proofs this doesn't matter, because of proof irrelevance</p>



<a name="178472142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178472142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178472142">(Oct 18 2019 at 13:14)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> It might be helpful to show beginners how to actually do it right, instead of only telling them what not to do.</p>



<a name="178472382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178472382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178472382">(Oct 18 2019 at 13:17)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I am</p>



<a name="178472729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178472729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178472729">(Oct 18 2019 at 13:20)</a>:</h4>
<p>Yes an example would be very helpful, I tried to do it with pattern matching but wasn't able to get anywhere. Using tactics like this does feel wrong but it's the only way I managed to get a working definition :-(</p>



<a name="178472821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178472821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178472821">(Oct 18 2019 at 13:21)</a>:</h4>
<p>(I do get huge lambda terms when using <code>simp</code> later, is that what you mean by "very annoying"? because it is ...)</p>



<a name="178472863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178472863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178472863">(Oct 18 2019 at 13:21)</a>:</h4>
<p><span class="user-mention" data-user-id="242586">@Vincent Beffara</span> I think Tim suggests that you try something like</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">concat</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">V</span><span class="o">},</span> <span class="o">(</span><span class="n">path</span> <span class="n">V</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">path</span> <span class="n">V</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">→</span> <span class="n">path</span> <span class="n">V</span> <span class="n">x</span> <span class="n">z</span>
<span class="bp">|</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">p1</span> <span class="n">p2</span> <span class="o">:=</span> <span class="bp">_</span>
</pre></div>



<a name="178472886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178472886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178472886">(Oct 18 2019 at 13:22)</a>:</h4>
<p>But then... I'm not an expert pattern matcher</p>



<a name="178473243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178473243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178473243">(Oct 18 2019 at 13:25)</a>:</h4>
<p><span class="user-mention" data-user-id="242586">@Vincent Beffara</span> Slightly unrelated. Graph theory seems to be a tricky subject as a first project in Lean. You might get stuck and disappointed rather quickly. Nevertheless I would love to see more graph theory. Hence I suggest you write a bit more about what your goals are. People might be able to suggest a mathematically equivalent approach that makes lots of troubles vanish right away.</p>



<a name="178473348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178473348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178473348">(Oct 18 2019 at 13:26)</a>:</h4>
<p>It's something that took me a bit of time to adjust to. Two definitions can be mathematically equal/the same/indistinguishable. But they can behave quite differently in Lean...</p>



<a name="178473793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178473793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178473793">(Oct 18 2019 at 13:31)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">list</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="kn">theorem</span> <span class="n">list</span><span class="bp">.</span><span class="n">last_append&#39;</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="n">h₂</span><span class="o">),</span> <span class="o">(</span><span class="n">L₁</span> <span class="bp">++</span> <span class="n">L₂</span><span class="o">)</span><span class="bp">.</span><span class="n">last</span> <span class="n">h₁</span> <span class="bp">=</span> <span class="n">L₂</span><span class="bp">.</span><span class="n">last</span> <span class="n">h₂</span>
<span class="bp">|</span> <span class="o">[]</span>     <span class="n">L₂</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="bp">::</span><span class="n">t</span><span class="o">)</span> <span class="n">L₂</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="o">:=</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">last_cons</span> <span class="bp">_</span> <span class="err">$</span> <span class="n">list</span><span class="bp">.</span><span class="n">append_ne_nil_of_ne_nil_right</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h₂</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="err">$</span>
    <span class="n">list</span><span class="bp">.</span><span class="n">last_append&#39;</span> <span class="bp">_</span> <span class="bp">_</span>

<span class="n">def</span> <span class="n">llist</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span>
<span class="n">α</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">α</span>

<span class="kn">namespace</span> <span class="n">llist</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">llist</span> <span class="n">α</span><span class="o">)</span>

<span class="n">def</span> <span class="n">first</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">L</span><span class="bp">.</span><span class="mi">1</span>

<span class="n">def</span> <span class="n">last</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">list</span><span class="bp">.</span><span class="n">last</span> <span class="o">(</span><span class="n">L</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">::</span> <span class="n">L</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">no_confusion</span> <span class="n">h</span><span class="o">)</span>

<span class="kn">end</span> <span class="n">llist</span>

<span class="n">def</span> <span class="n">path</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">L</span> <span class="o">:</span> <span class="n">llist</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">L</span><span class="bp">.</span><span class="n">first</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">L</span><span class="bp">.</span><span class="n">last</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">concat</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">path</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">path</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">path</span> <span class="n">x</span> <span class="n">z</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="o">(</span><span class="n">p1</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">p1</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">++</span> <span class="n">p2</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">::</span> <span class="n">p2</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">2</span><span class="o">),</span> <span class="n">p1</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">llist</span><span class="bp">.</span><span class="n">last</span><span class="o">,</span> <span class="n">dsimp</span> <span class="n">only</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">list</span><span class="bp">.</span><span class="n">last_cons</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">last_append&#39;</span><span class="o">],</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">p2</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">list</span><span class="bp">.</span><span class="n">append_ne_nil_of_ne_nil_right</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">cons_ne_nil</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">}</span>
<span class="kn">end</span><span class="bp">⟩</span>
</pre></div>



<a name="178473948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178473948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178473948">(Oct 18 2019 at 13:33)</a>:</h4>
<p>Here is a pattern-matching based implementation, but unfortunately Lean doesn't recognize that it terminates:</p>
<div class="codehilite"><pre><span></span>def concat {V y z} : Π {x} (p1 : path V x y) (p2 : path V y z), path V x z
| x ⟨P x&#39;, ⟨rfl, rfl⟩⟩ p2 := p2
| x ⟨L x&#39; y&#39;, ⟨hx, hy⟩⟩ p2 :=
  let ⟨p1&#39; , ⟨_, hy&#39;⟩⟩ := concat ⟨y&#39;, ⟨rfl, hy⟩⟩ p2
  in ⟨L x&#39; p1&#39; , ⟨hx, hy&#39;⟩⟩
</pre></div>


<p>(I come from an Agda background, so to me this "should just work" and I can't quickly figure out why not :P)</p>



<a name="178474111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178474111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178474111">(Oct 18 2019 at 13:35)</a>:</h4>
<p>(deleted)</p>



<a name="178474266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178474266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178474266">(Oct 18 2019 at 13:37)</a>:</h4>
<blockquote>
<p>what are <code>P</code> and <code>L</code>?</p>
</blockquote>
<p><code>P</code> and <code>L</code> are the constructors of my non-empty-list type (<code>P</code> for point and <code>L</code> for link in my head)</p>



<a name="178474636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178474636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178474636">(Oct 18 2019 at 13:42)</a>:</h4>
<p>I tried a few approaches for the non-empty-list type:</p>
<ul>
<li>the explicit inductive type</li>
<li><code>{ l list V // l \neq [] }</code></li>
<li><code>V \times list V</code><br>
and also for the concatenation, I thought a bit about just concatenating without looking for compatibility, just dropping a vertex and trusting that it will never be used outside the compatible case, kind of like setting <code>1/0=0</code>, but then all the lemmas that I want to have, like <code>last (concat l1 l2) = last l2</code>, become conditional ...</li>
</ul>



<a name="178474655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178474655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178474655">(Oct 18 2019 at 13:42)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">universes</span> <span class="n">u</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="kn">inductive</span> <span class="n">llist</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">|</span> <span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">llist</span> <span class="bp">|</span> <span class="n">L</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">llist</span> <span class="bp">-&gt;</span> <span class="n">llist</span>

<span class="kn">namespace</span> <span class="n">llist</span>

<span class="n">def</span> <span class="n">first</span> <span class="o">:</span> <span class="n">llist</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">α</span> <span class="bp">|</span> <span class="o">(</span><span class="n">P</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">v</span> <span class="bp">|</span> <span class="o">(</span><span class="n">L</span> <span class="n">v</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">v</span>
<span class="n">def</span> <span class="n">last</span>  <span class="o">:</span> <span class="n">llist</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">α</span> <span class="bp">|</span> <span class="o">(</span><span class="n">P</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">v</span> <span class="bp">|</span> <span class="o">(</span><span class="n">L</span> <span class="n">v</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">last</span> <span class="n">l</span>

<span class="n">def</span> <span class="n">path</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">l</span> <span class="o">:</span> <span class="n">llist</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">first</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">last</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">concat_aux</span> <span class="o">{</span><span class="n">y</span> <span class="n">z</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="o">(</span><span class="n">p11</span> <span class="o">:</span> <span class="n">llist</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">first</span> <span class="n">p11</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">last</span> <span class="n">p11</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">path</span> <span class="n">y</span> <span class="n">z</span><span class="o">),</span> <span class="n">path</span> <span class="n">x</span> <span class="n">z</span>
<span class="bp">|</span> <span class="n">x</span> <span class="o">(</span><span class="n">P</span> <span class="n">x&#39;</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="n">p2</span> <span class="o">:=</span> <span class="n">p2</span>
<span class="bp">|</span> <span class="n">x</span> <span class="o">(</span><span class="n">L</span> <span class="n">x&#39;</span> <span class="n">y&#39;</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span> <span class="n">p2</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="bp">⟨</span><span class="n">p1&#39;</span> <span class="o">,</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">hy&#39;</span><span class="bp">⟩⟩</span> <span class="o">:=</span> <span class="n">concat_aux</span> <span class="n">y&#39;</span> <span class="bp">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span> <span class="n">p2</span>
  <span class="k">in</span> <span class="bp">⟨</span><span class="n">L</span> <span class="n">x&#39;</span> <span class="n">p1&#39;</span> <span class="o">,</span> <span class="bp">⟨</span><span class="n">hx</span><span class="o">,</span> <span class="n">hy&#39;</span><span class="bp">⟩⟩</span>

<span class="n">def</span> <span class="n">concat</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">path</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">path</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">path</span> <span class="n">x</span> <span class="n">z</span> <span class="o">:=</span>
<span class="n">concat_aux</span> <span class="n">p1</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p1</span><span class="bp">.</span><span class="mi">2</span> <span class="n">p2</span>

<span class="kn">end</span> <span class="n">llist</span>
</pre></div>



<a name="178474663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178474663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178474663">(Oct 18 2019 at 13:42)</a>:</h4>
<p><span class="user-mention" data-user-id="238446">@Tim Baanen</span> you need an auxiliary def</p>



<a name="178474673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178474673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178474673">(Oct 18 2019 at 13:42)</a>:</h4>
<p>for recursing in a subtype</p>



<a name="178474701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178474701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178474701">(Oct 18 2019 at 13:43)</a>:</h4>
<p><span class="user-mention" data-user-id="242586">@Vincent Beffara</span> my approach above is <code>\a \times list \a</code></p>



<a name="178476599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178476599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178476599">(Oct 18 2019 at 14:02)</a>:</h4>
<blockquote>
<p>you need an auxiliary def</p>
</blockquote>
<p>So what would be recommended, having an auxiliary def or using something else than a subtype?</p>



<a name="178476755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178476755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178476755">(Oct 18 2019 at 14:04)</a>:</h4>
<p>using library functions like I did :P</p>



<a name="178481910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178481910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178481910">(Oct 18 2019 at 14:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span>By auxiliary def do you mean one on the underlying type or something else? EDIT: ah, like <code>concat_aux</code>.</p>



<a name="178567040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178567040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178567040">(Oct 19 2019 at 22:58)</a>:</h4>
<p>Hi again, and thanks for all your replies. I'm afraid I am still confused about a few things ... So I have <code>llist</code> which is a non-empty list, <code>path</code> which is a <code>llist</code> with prescribed endpoints, I knew how to concatenate <code>llist</code>s, I learned how to concatenate <code>path</code>s and now I want to verify that the <code>llist</code> part coincides. Here is where I am:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">inductive</span> <span class="n">llist</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">|</span> <span class="n">P</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="n">llist</span> <span class="bp">|</span> <span class="n">L</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="n">llist</span> <span class="bp">-&gt;</span> <span class="n">llist</span>
<span class="kn">open</span> <span class="n">llist</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">first</span> <span class="o">{</span><span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">llist</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="n">V</span> <span class="bp">|</span> <span class="o">(</span><span class="n">P</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">v</span> <span class="bp">|</span> <span class="o">(</span><span class="n">L</span> <span class="n">v</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">v</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">last</span>  <span class="o">{</span><span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">llist</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="n">V</span> <span class="bp">|</span> <span class="o">(</span><span class="n">P</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">v</span> <span class="bp">|</span> <span class="o">(</span><span class="n">L</span> <span class="n">v</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">last</span> <span class="n">l</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">concat_llist</span> <span class="o">{</span><span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">last</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">first</span> <span class="n">l₂</span><span class="o">),</span> <span class="n">llist</span> <span class="n">V</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">P</span> <span class="n">v</span><span class="o">)</span>   <span class="n">l₂</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">l₂</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">L</span> <span class="n">v</span> <span class="n">l</span><span class="o">)</span> <span class="n">l₂</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">L</span> <span class="n">v</span> <span class="o">(</span><span class="n">concat_llist</span> <span class="n">l</span> <span class="n">l₂</span> <span class="n">h</span><span class="o">)</span>

<span class="n">def</span> <span class="n">path</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">l</span> <span class="o">:</span> <span class="n">llist</span> <span class="n">V</span> <span class="bp">//</span> <span class="n">first</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">last</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">}</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">llist</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">l₁</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="n">x</span> <span class="n">y</span><span class="o">}</span> <span class="o">{</span><span class="n">l₂</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="n">y</span> <span class="n">z</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">concat_aux</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">llist</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">first</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">last</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">p&#39;</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="n">y</span> <span class="n">z</span><span class="o">),</span> <span class="n">path</span> <span class="n">V</span> <span class="n">x</span> <span class="n">z</span>
    <span class="bp">|</span> <span class="n">x</span> <span class="o">(</span><span class="n">P</span> <span class="n">v</span><span class="o">)</span>   <span class="n">h</span> <span class="n">p&#39;</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">p&#39;</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">eq</span><span class="bp">.</span><span class="n">trans</span> <span class="n">p&#39;</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="n">symm</span> <span class="n">h</span><span class="bp">.</span><span class="mi">1</span><span class="o">),</span> <span class="n">p&#39;</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩⟩</span>
    <span class="bp">|</span> <span class="n">x</span> <span class="o">(</span><span class="n">L</span> <span class="n">v</span> <span class="n">l</span><span class="o">)</span> <span class="n">h</span> <span class="n">p&#39;</span> <span class="o">:=</span> <span class="k">let</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">concat_aux</span> <span class="n">l</span> <span class="bp">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">h</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span> <span class="n">p&#39;</span> <span class="k">in</span> <span class="bp">⟨</span><span class="n">L</span> <span class="n">x</span> <span class="n">q</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">q</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩⟩</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">concat</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="n">x</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">concat_aux</span> <span class="n">p1</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p1</span><span class="bp">.</span><span class="mi">2</span> <span class="n">p2</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">toto&#39;</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">last</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">last</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">first</span> <span class="n">l₂</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">:</span> <span class="o">(</span><span class="n">concat_aux</span> <span class="n">l</span> <span class="bp">⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">h1</span><span class="bp">⟩</span> <span class="n">l₂</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">concat_llist</span> <span class="n">l</span> <span class="n">l₂</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h2</span>
    <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">v</span> <span class="n">v</span> <span class="n">l</span> <span class="n">hr</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hr</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">toto</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">last</span> <span class="n">l₁</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">first</span> <span class="n">l₂</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">concat</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">concat_llist</span> <span class="n">l₁</span><span class="bp">.</span><span class="mi">1</span> <span class="n">l₂</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h</span>
    <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="k">have</span> <span class="n">tmp</span> <span class="o">:=</span> <span class="n">toto&#39;</span> <span class="n">l₁</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span> <span class="n">h</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">}</span>
</pre></div>


<p>In the last line, <code>tmp</code> and the goal look identical to me, and yet the tactic fails. What am I doing wrong?</p>



<a name="178567106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178567106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178567106">(Oct 19 2019 at 23:00)</a>:</h4>
<p>My guess would be that the <code>h</code> parameters (which are hidden) do not match, but I thought that for <code>Prop</code> this did not matter?</p>



<a name="178568346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178568346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178568346">(Oct 19 2019 at 23:45)</a>:</h4>
<p>if you change <code>assumption</code> to <code>convert tmp</code> then you can see what's wrong</p>



<a name="178568393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178568393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178568393">(Oct 19 2019 at 23:46)</a>:</h4>
<p>also since you never used <code>h</code> in <code>concat_llist</code> you shouldn't include it as an input</p>



<a name="178568448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178568448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178568448">(Oct 19 2019 at 23:48)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">inductive</span> <span class="n">llist</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">|</span> <span class="n">P</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="n">llist</span> <span class="bp">|</span> <span class="n">L</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="n">llist</span> <span class="bp">-&gt;</span> <span class="n">llist</span>
<span class="kn">open</span> <span class="n">llist</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">first</span> <span class="o">{</span><span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">llist</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="n">V</span> <span class="bp">|</span> <span class="o">(</span><span class="n">P</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">v</span> <span class="bp">|</span> <span class="o">(</span><span class="n">L</span> <span class="n">v</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">v</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">last</span>  <span class="o">{</span><span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">llist</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="n">V</span> <span class="bp">|</span> <span class="o">(</span><span class="n">P</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">v</span> <span class="bp">|</span> <span class="o">(</span><span class="n">L</span> <span class="n">v</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">last</span> <span class="n">l</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">concat_llist</span> <span class="o">{</span><span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">llist</span> <span class="n">V</span><span class="o">),</span> <span class="n">llist</span> <span class="n">V</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">P</span> <span class="n">v</span><span class="o">)</span>   <span class="n">l₂</span> <span class="o">:=</span> <span class="n">l₂</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">L</span> <span class="n">v</span> <span class="n">l</span><span class="o">)</span> <span class="n">l₂</span> <span class="o">:=</span> <span class="n">L</span> <span class="n">v</span> <span class="o">(</span><span class="n">concat_llist</span> <span class="n">l</span> <span class="n">l₂</span><span class="o">)</span>

<span class="n">def</span> <span class="n">path</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">l</span> <span class="o">:</span> <span class="n">llist</span> <span class="n">V</span> <span class="bp">//</span> <span class="n">first</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">last</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">}</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">llist</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">l₁</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="n">x</span> <span class="n">y</span><span class="o">}</span> <span class="o">{</span><span class="n">l₂</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="n">y</span> <span class="n">z</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">concat_aux</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">llist</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">first</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">last</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">p&#39;</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="n">y</span> <span class="n">z</span><span class="o">),</span> <span class="n">path</span> <span class="n">V</span> <span class="n">x</span> <span class="n">z</span>
    <span class="bp">|</span> <span class="n">x</span> <span class="o">(</span><span class="n">P</span> <span class="n">v</span><span class="o">)</span>   <span class="n">h</span> <span class="n">p&#39;</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">p&#39;</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">eq</span><span class="bp">.</span><span class="n">trans</span> <span class="n">p&#39;</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="n">symm</span> <span class="n">h</span><span class="bp">.</span><span class="mi">1</span><span class="o">),</span> <span class="n">p&#39;</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩⟩</span>
    <span class="bp">|</span> <span class="n">x</span> <span class="o">(</span><span class="n">L</span> <span class="n">v</span> <span class="n">l</span><span class="o">)</span> <span class="n">h</span> <span class="n">p&#39;</span> <span class="o">:=</span> <span class="k">let</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">concat_aux</span> <span class="n">l</span> <span class="bp">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">h</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span> <span class="n">p&#39;</span> <span class="k">in</span> <span class="bp">⟨</span><span class="n">L</span> <span class="n">x</span> <span class="n">q</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">q</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩⟩</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">concat</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="n">x</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">concat_aux</span> <span class="n">p1</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p1</span><span class="bp">.</span><span class="mi">2</span> <span class="n">p2</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">toto&#39;</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">last</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">last</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">first</span> <span class="n">l₂</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">:</span> <span class="o">(</span><span class="n">concat_aux</span> <span class="n">l</span> <span class="bp">⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">h1</span><span class="bp">⟩</span> <span class="n">l₂</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">concat_llist</span> <span class="n">l</span> <span class="n">l₂</span><span class="bp">.</span><span class="mi">1</span>
    <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">v</span> <span class="n">v</span> <span class="n">l</span> <span class="n">hr</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hr</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">toto</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">last</span> <span class="n">l₁</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">first</span> <span class="n">l₂</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">concat</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">concat_llist</span> <span class="n">l₁</span><span class="bp">.</span><span class="mi">1</span> <span class="n">l₂</span><span class="bp">.</span><span class="mi">1</span>
    <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="k">have</span> <span class="n">tmp</span> <span class="o">:=</span> <span class="n">toto&#39;</span> <span class="n">l₁</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span> <span class="n">h</span><span class="o">,</span> <span class="n">convert</span> <span class="n">tmp</span><span class="bp">;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">l₁</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span><span class="o">]</span> <span class="o">}</span>
</pre></div>



<a name="178580705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178580705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178580705">(Oct 20 2019 at 06:46)</a>:</h4>
<p>Thanks for the hint, I will look at it when I have access to Lean</p>



<a name="178580834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178580834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178580834">(Oct 20 2019 at 06:50)</a>:</h4>
<p>The reason I have h in concat is that I want the simplification lemma that <code>first (concat l1 l2) = first l1</code> which is wrong without it and I fear having to sprinkle a similar assumption around later. Is your advise to do the opposite then?</p>



<a name="178580886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178580886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178580886">(Oct 20 2019 at 06:52)</a>:</h4>
<p>you can still have that simplification lemma, you just put the side condition in the lemma</p>



<a name="178580902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178580902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178580902">(Oct 20 2019 at 06:53)</a>:</h4>
<p>I don't think <code>concat</code> should be marked <code>@[simp]</code></p>



<a name="178583797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Dependent%20induction%3F/near/178583797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Dependent.20induction.3F.html#178583797">(Oct 20 2019 at 08:26)</a>:</h4>
<p>I realize that I can put the condition in the lemma, but will simp know to look for it hidden in the current state as often as it would just use the lemma without the additional assumption in it?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
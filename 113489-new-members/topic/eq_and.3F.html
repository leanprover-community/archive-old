---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/eq_and.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html">eq_and?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="280749120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280749120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280749120">(Apr 30 2022 at 18:18)</a>:</h4>
<p>Do we have the following?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">eq_and</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">y</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>(corrected from <del><code>x = y ∧ p x ↔ p y</code></del>)</p>
<p>I did <code>library_search</code> for all four arrangements (<code>p x ∧ x = y</code> and so on) and didn't find it. This would be very convenient for rewrites. There is already</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">exists_eq_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="bp">?</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a'</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">p</span> <span class="n">a'</span>
</code></pre></div>
<p>and several variants (<code>exists_eq_right</code>, <code>exists_eq_left'</code>, <code>exists_eq_right_right</code>...), but I'm not sure how to use them exactly here.</p>



<a name="280749247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280749247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280749247">(Apr 30 2022 at 18:21)</a>:</h4>
<p>Surely that first one is false?</p>



<a name="280749297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280749297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280749297">(Apr 30 2022 at 18:22)</a>:</h4>
<p>Oh what am I saying.</p>



<a name="280749515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280749515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280749515">(Apr 30 2022 at 18:27)</a>:</h4>
<p>I think I meant <code>x = y ∧ p x ↔ x = y ∧ p y</code>.</p>



<a name="280749594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280749594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280749594">(Apr 30 2022 at 18:28)</a>:</h4>
<p>I'll edit the post.</p>



<a name="280749712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280749712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280749712">(Apr 30 2022 at 18:31)</a>:</h4>
<p>Your original lemma is false:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">¬Π</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">},</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">p</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="bp">@</span><span class="n">h</span> <span class="n">bool</span> <span class="n">ff</span> <span class="n">tt</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">),</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Your updated lemma seems too specific to be in mathlib, but it can be proved easily:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Are you sure that's what you want? Maybe you want this instead:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">p</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">P</span><span class="o">,</span> <span class="n">rw</span> <span class="n">h</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">specialize</span> <span class="n">h</span> <span class="o">(</span><span class="n">eq</span> <span class="n">x</span><span class="o">),</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="280749770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280749770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280749770">(Apr 30 2022 at 18:32)</a>:</h4>
<p>There is <code>and.congr_right_iff : ∀ {a b c : Prop}, a ∧ b ↔ a ∧ c ↔ a → (b ↔ c)</code> which seems related.</p>



<a name="280749797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280749797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280749797">(Apr 30 2022 at 18:33)</a>:</h4>
<p><span class="user-mention" data-user-id="456794">@Patrick Johnson</span> If you want a fun proof of the second example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">split</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">{</span> <span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span> <span class="o">}</span>
</code></pre></div>



<a name="280749882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280749882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280749882">(Apr 30 2022 at 18:35)</a>:</h4>
<p><span class="user-mention" data-user-id="456794">@Patrick Johnson</span> the point isn't to prove the (corrected) lemma, which I agree is easy, it's to have it for rewrites.</p>
<p>I have some situations where, for example, I am showing that two sets are equal, both defined in terms of <code>filter</code> and <code>insert</code>and so on in two different ways. Then <code>ext</code> converts this to two logical statements that each contain <code>x = y</code> somewhere, but statement 1 has the other properties in terms of <code>x</code> and statement 2 in terms of <code>y</code>.</p>



<a name="280749944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280749944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280749944">(Apr 30 2022 at 18:37)</a>:</h4>
<p>(I wish the <code>contextual</code> option were a flag that could join the likes of <code>!</code> and <code>?</code>. Perhaps <code>simpᶜ</code> or <code>simp¢</code>? Or <code>simp@</code> since <code>contextual</code> is adding additional assumptions from implication hypotheses?)</p>



<a name="280750024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280750024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280750024">(Apr 30 2022 at 18:38)</a>:</h4>
<p><span class="user-mention" data-user-id="391579">@Jake Levinson</span> Does adding <code>{ contextual := tt }</code> to a relevant <code>simp</code> help in your cases?</p>



<a name="280750027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280750027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280750027">(Apr 30 2022 at 18:38)</a>:</h4>
<p>For example I might have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">q</span> <span class="n">z</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">q</span> <span class="n">z</span>
</code></pre></div>



<a name="280750043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280750043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280750043">(Apr 30 2022 at 18:39)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="n">q</span> <span class="n">z</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">q</span> <span class="n">z</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">{</span> <span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="280750048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280750048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280750048">(Apr 30 2022 at 18:40)</a>:</h4>
<p>Neato, I'll try that. What does it mean?</p>



<a name="280750115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280750115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280750115">(Apr 30 2022 at 18:41)</a>:</h4>
<p>It adds additional simp lemmas contextually. There might be other effects, but the one I know about is that when simplifying <code>a -&gt; b</code> it adds <code>a</code> as a simp lemma when simplifying <code>b</code>.</p>



<a name="280750171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280750171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280750171">(Apr 30 2022 at 18:42)</a>:</h4>
<p>Key to this working in these cases is that <code>simp</code> is using <a href="https://leanprover-community.github.io/mathlib_docs/find/and_imp">docs#and_imp</a> first</p>



<a name="280750225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280750225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280750225">(Apr 30 2022 at 18:43)</a>:</h4>
<p>Also key is that <code>x = y</code> happened to be near the front on each side of the iff.</p>



<a name="280750283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280750283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280750283">(Apr 30 2022 at 18:44)</a>:</h4>
<p>This fails:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="n">q</span> <span class="n">z</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">q</span> <span class="n">z</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">{</span> <span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>though there are other tactics that can solve it automatically, like <code>by tidy</code> or <code>by split; cc</code>.</p>



<a name="280751538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280751538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280751538">(Apr 30 2022 at 19:15)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="456794">@Patrick Johnson</span> and <span class="user-mention" data-user-id="306601">@Kyle Miller</span>.</p>
<p>A more complicated version of the example would be something like </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">z</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">r</span> <span class="n">x</span> <span class="n">w</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">z</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">r</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">{</span> <span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span> <span class="o">}</span>
</code></pre></div>
<p>This seems to work great. I'll try it out in my actual situation soon.</p>
<p>In general I'm imagining something like doing <code>subst x</code> locally within a statement that contains an equation <code>x = y</code>, by rewriting away <code>x</code> (or perhaps <code>y</code>) from the remainder of the statement.</p>



<a name="280751753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280751753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280751753">(Apr 30 2022 at 19:20)</a>:</h4>
<p>Here's a quick tactic that simulates what <code>contextual</code> is doing here while also actually doing substitutions</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">w</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">p</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">r</span> <span class="n">x</span> <span class="n">w</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">p</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">r</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">repeat</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span> <span class="bp">&lt;|&gt;</span> <span class="n">rintro</span> <span class="n">rfl</span> <span class="bp">&lt;|&gt;</span> <span class="n">intro</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>(Notice the equalities are now at the end, so <code>contextual</code> alone doesn't work.)</p>



<a name="280751951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280751951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280751951">(Apr 30 2022 at 19:26)</a>:</h4>
<p>Is <code>rintro rfl</code> somehow doing substitutions?</p>



<a name="280752217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280752217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280752217">(Apr 30 2022 at 19:32)</a>:</h4>
<p>Also, a related question: I have vaguely heard that certain uses of ("nonterminal"?) <code>simp</code> are discouraged in mathlib because of either speed (simp being inefficient compared to <code>simp only</code> or an explicit proof) or fragility (updates to the library breaking a simp proof). Would the tactic you wrote be OK for code in mathlib, given that it repeatedly uses <code>simp</code>?</p>



<a name="280752882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280752882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280752882">(Apr 30 2022 at 19:50)</a>:</h4>
<p>I think it's similar to using <code>norm_num</code> to finish a proof. <code>norm_num</code> also repeatedly calls <code>simp</code>, but it's a tactic with understood behavior. Still, I think it would probably be better to turn that into a <code>simp only</code>.</p>



<a name="280752893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/eq_and%3F/near/280752893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/eq_and.3F.html#280752893">(Apr 30 2022 at 19:51)</a>:</h4>
<p><code>rintro rfl</code> is doing <code>subst</code> for you after doing <code>intro</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
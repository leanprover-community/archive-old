---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html">member of cartesian product of sets</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="226705270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226705270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226705270">(Feb 17 2021 at 18:44)</a>:</h4>
<p>I'm struggling to understand why this (contrived example) doesn't compile, I don't understand how sets work really:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.normed_space.basic</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">S</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_ring</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">x</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">set</span> <span class="n">S</span> <span class="bp">×</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">r</span><span class="o">,</span> <span class="bp">∥</span><span class="n">f</span> <span class="n">x.1</span><span class="bp">∥</span> <span class="bp">=</span> <span class="bp">∥</span><span class="n">f</span> <span class="n">x.2</span><span class="bp">∥</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226705632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226705632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226705632">(Feb 17 2021 at 18:47)</a>:</h4>
<p>I think this is just the Lean 3 parser giving up on you rather than any misunderstanding on your part.</p>



<a name="226705833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226705833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226705833">(Feb 17 2021 at 18:48)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">x</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">S</span> <span class="bp">×</span> <span class="n">S</span><span class="o">))</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">×</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">r</span><span class="o">),</span> <span class="bp">∥</span><span class="n">f</span> <span class="n">x.1</span><span class="bp">∥</span> <span class="bp">=</span> <span class="bp">∥</span><span class="n">f</span> <span class="n">x.2</span><span class="bp">∥</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226705874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226705874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226705874">(Feb 17 2021 at 18:48)</a>:</h4>
<p>Note that you had another problem. Lean parses the type of <code>r</code> as <code>(set S) × S</code></p>



<a name="226706091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226706091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226706091">(Feb 17 2021 at 18:50)</a>:</h4>
<p>Oh I see, so the point is that membership is a proposition?</p>



<a name="226706114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226706114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226706114">(Feb 17 2021 at 18:50)</a>:</h4>
<p>yes</p>



<a name="226706144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226706144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226706144">(Feb 17 2021 at 18:50)</a>:</h4>
<p>Cool thanks</p>



<a name="226706165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226706165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226706165">(Feb 17 2021 at 18:50)</a>:</h4>
<p><code>#print notation × -- _ `×`:35 _:34 := prod #1 #0</code> -- <code>\times</code> has a meagre binding power of 35, and <code>set</code> is a function so has a binding power of something like 1000.</p>



<a name="226708155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226708155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226708155">(Feb 17 2021 at 19:03)</a>:</h4>
<p>Hm okay does this <code>nonarchimedean_normed_ring.ultrametric</code> look like a reasonable statement then? It compiles but I'm not sure I'm using everything correctly.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.normed_space.basic</span>
<span class="kn">import</span> <span class="n">ring_theory.power_series.basic</span>

<span class="kn">open</span> <span class="n">filter</span>

<span class="kd">noncomputable theory</span>
<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">class</span> <span class="n">nonarchimedean_normed_ring</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">normed_ring</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">ultrametric_inequality</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="bp">∥</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">max</span> <span class="bp">∥</span><span class="n">x</span><span class="bp">∥</span> <span class="bp">∥</span><span class="n">y</span><span class="bp">∥</span><span class="o">))</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_ring</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">nonarchimedean_normed_ring.ultrametric</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">S</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">S</span><span class="o">}</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∥∑</span> <span class="n">p</span> <span class="k">in</span> <span class="n">t</span><span class="o">,</span> <span class="n">m</span> <span class="n">p</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="n">m</span> <span class="n">x</span><span class="bp">∥</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∥</span><span class="n">m</span> <span class="n">y</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="n">m</span> <span class="n">x</span><span class="bp">∥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226708288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226708288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226708288">(Feb 17 2021 at 19:04)</a>:</h4>
<p>Functions seem to have binding power 1024 by the way:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">moo</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="mi">0</span>

<span class="kd">notation</span> <span class="n">a</span> <span class="bp">`★`</span><span class="o">:</span><span class="mi">1025</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">moo</span> <span class="n">a</span> <span class="n">b</span> <span class="c1">-- will fail if you lower this to 1024</span>

<span class="k">#check</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">★</span> <span class="n">b</span> <span class="c1">-- works</span>
</code></pre></div>



<a name="226708735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226708735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226708735">(Feb 17 2021 at 19:06)</a>:</h4>
<p>For exactly this reason of binding powers, you shouldn't need <code>()</code> around <code>max</code> here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">ultrametric_inequality</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="bp">∥</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">max</span> <span class="bp">∥</span><span class="n">x</span><span class="bp">∥</span> <span class="bp">∥</span><span class="n">y</span><span class="bp">∥</span><span class="o">))</span>
</code></pre></div>



<a name="226708932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226708932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226708932">(Feb 17 2021 at 19:07)</a>:</h4>
<p>The lemma statement looks a bit non-idiomatic too me...</p>



<a name="226709212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226709212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226709212">(Feb 17 2021 at 19:09)</a>:</h4>
<p>I would replace <code>{S : set R}</code> by <code>{S : Type*}</code></p>



<a name="226709244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226709244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226709244">(Feb 17 2021 at 19:09)</a>:</h4>
<p>And use <code>[nonempty S]</code></p>



<a name="226709248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226709248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226709248">(Feb 17 2021 at 19:09)</a>:</h4>
<p>I'm not sure it's true as it stands. What about if S is infinite, m is unbounded, and t is empty?</p>



<a name="226709414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226709414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226709414">(Feb 17 2021 at 19:10)</a>:</h4>
<p>And also what Johan says -- S doesn't need to be anything to do with R. I think you want that t is nonempty.</p>



<a name="226709509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226709509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226709509">(Feb 17 2021 at 19:10)</a>:</h4>
<p>Sorry I'm confused, basically there should only be <code>S</code>, I wanted <code>t</code> to be a proof that <code>S</code> is finite, but I think I'm misinterpreting what a <code>finset</code> is</p>



<a name="226709597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226709597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226709597">(Feb 17 2021 at 19:11)</a>:</h4>
<p><code>t : finset S</code> means <code>t is a finite subset of S</code>. Maybe you want <code>hS : S.finite</code> then</p>



<a name="226709640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226709640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226709640">(Feb 17 2021 at 19:11)</a>:</h4>
<p>except that because you don't even need S to be a set, you maybe want a random nonempty finite type S.</p>



<a name="226709813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226709813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226709813">(Feb 17 2021 at 19:12)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nonarchimedean_normed_ring.ultrametric</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span>
<span class="o">[</span><span class="n">nonempty</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ι</span><span class="o">,</span> <span class="bp">∥∑</span> <span class="n">p</span><span class="o">,</span> <span class="n">m</span> <span class="n">p</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="n">m</span> <span class="n">x</span><span class="bp">∥</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ι</span><span class="o">,</span> <span class="bp">∥</span><span class="n">m</span> <span class="n">y</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="n">m</span> <span class="n">x</span><span class="bp">∥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>hopefully that's true.</p>



<a name="226709917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226709917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226709917">(Feb 17 2021 at 19:13)</a>:</h4>
<p>But actually, the version with <code>s : finset \iota</code> will probably be more useful in practice.</p>



<a name="226710006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226710006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226710006">(Feb 17 2021 at 19:14)</a>:</h4>
<p><code>set S</code> is the type of subsets of <code>S</code>, <code>finset S</code> is the type of finite subsets of <code>S</code>, <code>set.finite</code> is a predicate on <code>set S</code> saying "I am finite", <code>fintype</code> is a predicate on <code>Type</code> saying "I am finite".</p>



<a name="226710073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226710073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226710073">(Feb 17 2021 at 19:14)</a>:</h4>
<p>So the I would drop the <code>[fintype \iota]</code>, replace <code>[nonempty \iota]</code> by <code>(hs : s.nonempty)</code> and <code>\ex x : \iota</code> by <code>\ex x \in s</code>.</p>



<a name="226710114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226710114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226710114">(Feb 17 2021 at 19:14)</a>:</h4>
<p>with <code>s : finset iota</code></p>



<a name="226710545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226710545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226710545">(Feb 17 2021 at 19:17)</a>:</h4>
<p>I totally agree that this is confusing and that there is no obvious reference to point to.</p>



<a name="226710646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226710646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226710646">(Feb 17 2021 at 19:18)</a>:</h4>
<p>Thanks that clarifies things! Then this gives an error still</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nonarchimedean_normed_ring.ultrametric</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">}</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">S.nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∥∑</span> <span class="n">p</span><span class="o">,</span> <span class="n">m</span> <span class="n">p</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="n">m</span> <span class="n">x</span><span class="bp">∥</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∥</span><span class="n">m</span> <span class="n">y</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="n">m</span> <span class="n">x</span><span class="bp">∥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226710683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226710683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226710683">(Feb 17 2021 at 19:18)</a>:</h4>
<p>Apparently I can't make a map out of a finset... I guess it's not a type</p>



<a name="226710694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226710694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226710694">(Feb 17 2021 at 19:18)</a>:</h4>
<p>Maybe you want <code>m : iota -&gt; R</code></p>



<a name="226710809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226710809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226710809">(Feb 17 2021 at 19:19)</a>:</h4>
<p>But then presumably <code>m</code> has to be defined on all of <code>\iota</code>, when I would just want it to be defined on <code>S</code></p>



<a name="226710867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226710867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226710867">(Feb 17 2021 at 19:19)</a>:</h4>
<p><code>S : finset iota</code> is a term not a type, it has type <code>finset iota</code>. Types have type <code>Type</code>. But clearly you sometimes want to think of <code>S</code> as a type in itself, the type of elements of S, so there is a way to coerce it into a type, but it involves up-arrows because nobody fixed it yet.</p>



<a name="226711059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226711059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226711059">(Feb 17 2021 at 19:21)</a>:</h4>
<p>If you only want m to be defined on S then you could go with my [fintype iota] suggestion. But Johan's point is that actually if you think you have a map defined only on S, you might well find that Lean will happily let it be defined on all of iota, even if it involves things like division by 0, because this is some type theory philosophy that maps should be defined on all of a type and return junk values away from the domain of interest.</p>



<a name="226711172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226711172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226711172">(Feb 17 2021 at 19:21)</a>:</h4>
<p>If you really only want m defined on S then there's no point having iota.</p>



<a name="226711279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226711279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226711279">(Feb 17 2021 at 19:22)</a>:</h4>
<p>1/0=0, sup of the naturals in the reals is 0, as is sup of the empty set etc.</p>



<a name="226711344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226711344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226711344">(Feb 17 2021 at 19:22)</a>:</h4>
<p>if you're foolish enough to give a set to the <code>real.sup</code> function which isn't non-empty and bounded, you'll get a junk answer rather than an error.</p>



<a name="226711393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226711393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226711393">(Feb 17 2021 at 19:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="235423">Ashwin Iyengar</span> <a href="#narrow/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets/near/226710683">said</a>:</p>
<blockquote>
<p>Apparently I can't make a map out of a finset... I guess it's not a type</p>
</blockquote>
<p><code>S : finset \iota</code> means that <code>S</code> has type <code>finset \iota</code>. <code>S : Type</code> means that <code>S</code> has type <code>Type</code>. The latter means "<code>S</code> is a type". So indeed, finsets aren't types.<br>
It takes a bit of time to get used to, but really everything only has 1 type.</p>



<a name="226711402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226711402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226711402">(Feb 17 2021 at 19:23)</a>:</h4>
<p>so similarly here you might think that m is only defined on S but probably it will make sense on all of iota.</p>



<a name="226711546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226711546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226711546">(Feb 17 2021 at 19:24)</a>:</h4>
<p><span class="user-mention" data-user-id="235423">@Ashwin Iyengar</span> for proofs it will be extremely convenient to have <code>m</code> defined on all of <code>\iota</code>, but also have <code>s</code> around as finset.</p>



<a name="226711620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226711620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226711620">(Feb 17 2021 at 19:24)</a>:</h4>
<p>It means that you can restrict the sum to a smaller finset, or do induction on the size of the finset, and all the while <code>m : \iota \to R</code> doesn't change.</p>



<a name="226711689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226711689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226711689">(Feb 17 2021 at 19:25)</a>:</h4>
<p>Thousands of lines of code about <code>\sum x in s, m s</code> have shown that this model is extremely convenient to work with in practice.</p>



<a name="226711747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226711747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226711747">(Feb 17 2021 at 19:25)</a>:</h4>
<p>Okay thanks. Final question, do you imagine that</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nonarchimedean_normed_ring.ultrametric</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">S.nonempty</span><span class="o">):</span>
  <span class="bp">∃</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∥∑</span> <span class="n">p</span> <span class="k">in</span> <span class="n">S</span><span class="o">,</span> <span class="n">p</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="n">x</span><span class="bp">∥</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∥</span><span class="n">y</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="n">x</span><span class="bp">∥</span>
</code></pre></div>
<p>would be less useful than</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nonarchimedean_normed_ring.ultrametric</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">}</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">S.nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∥∑</span> <span class="n">p</span> <span class="k">in</span> <span class="n">S</span><span class="o">,</span> <span class="n">m</span> <span class="n">p</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="n">m</span> <span class="n">x</span><span class="bp">∥</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∥</span><span class="n">m</span> <span class="n">y</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="n">m</span> <span class="n">x</span><span class="bp">∥</span>
</code></pre></div>



<a name="226711839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226711839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226711839">(Feb 17 2021 at 19:26)</a>:</h4>
<p>sure</p>



<a name="226711939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226711939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226711939">(Feb 17 2021 at 19:27)</a>:</h4>
<p>the first is a trivial special case of the second, where two random types are being randomly decreed to be equal despite having nothing to do with each other.</p>



<a name="226711999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226711999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226711999">(Feb 17 2021 at 19:27)</a>:</h4>
<p>Even if you have a type which you are convinced is equal to R (e.g. a type canonically isomorphic to R), Lean might not let you prove that it's equal to R.</p>



<a name="226712085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226712085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226712085">(Feb 17 2021 at 19:28)</a>:</h4>
<p>Oh I see, you removed <code>m</code> too.</p>



<a name="226712123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226712123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226712123">(Feb 17 2021 at 19:28)</a>:</h4>
<p>I would certainly go for the second version</p>



<a name="226712130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226712130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226712130">(Feb 17 2021 at 19:28)</a>:</h4>
<p>I would still prove the second.</p>



<a name="226712188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226712188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226712188">(Feb 17 2021 at 19:29)</a>:</h4>
<p>The proof will be just as long as that of the first, but it will be much easier to apply the second version</p>



<a name="226712210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226712210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226712210">(Feb 17 2021 at 19:29)</a>:</h4>
<p>Okay thanks, maybe to convince myself I'll compare how hard it is to apply the first one vs the second one in my proof that you can multiply restricted power series</p>



<a name="226712294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226712294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226712294">(Feb 17 2021 at 19:29)</a>:</h4>
<p>(Note that when you apply the second version, usually lean will figure out automatically what <code>\iota</code> and <code>m</code> are. But with the first version you will hit situations quickly where you want to apply it, but lean will say "nope")</p>



<a name="226713913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226713913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226713913">(Feb 17 2021 at 19:41)</a>:</h4>
<p>Ashwin, if you think that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>f</mi><mi>g</mi><mo stretchy="false">]</mo><mo>=</mo><mi>R</mi><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>f</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>g</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[1/fg]=R[1/f][1/g]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">]</span></span></span></span> then your notion of what equality is is not the same as Lean's. If you think you have elements of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> and they're actually elements of a ring canonically isomorphic to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> then you need the map. Experience has shown us that having an index type is a powerful level of abstraction which covers essentially all use cases.</p>



<a name="226713995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226713995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226713995">(Feb 17 2021 at 19:42)</a>:</h4>
<p>If you really are in the situation where your map is not defined on all of iota, which does occasionally happen, then you just promote S to a type and continue anyway.</p>



<a name="226727517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226727517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226727517">(Feb 17 2021 at 21:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets/near/226708735">said</a>:</p>
<blockquote>
<p>For exactly this reason of binding powers, you shouldn't need <code>()</code> around <code>max</code> here:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">ultrametric_inequality</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="bp">∥</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">max</span> <span class="bp">∥</span><span class="n">x</span><span class="bp">∥</span> <span class="bp">∥</span><span class="n">y</span><span class="bp">∥</span><span class="o">))</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Oh btw it doesn't work without the () for some reason</p>



<a name="226727563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226727563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226727563">(Feb 17 2021 at 21:21)</a>:</h4>
<p>≤ seems to take priority over the application of <code>max</code> or something</p>



<a name="226745452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226745452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226745452">(Feb 17 2021 at 23:46)</a>:</h4>
<p><a href="#narrow/stream/113488-general/topic/parsing.20question.20about.20.60.E2.88.A5x.E2.88.A5.60/near/226744899">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/parsing.20question.20about.20.60.E2.88.A5x.E2.88.A5.60/near/226744899</a></p>



<a name="226763853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/member%20of%20cartesian%20product%20of%20sets/near/226763853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/member.20of.20cartesian.20product.20of.20sets.html#226763853">(Feb 18 2021 at 04:34)</a>:</h4>
<p><span class="user-mention" data-user-id="235423">@Ashwin Iyengar</span> ypu, you are right. sorry for making a false claim</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
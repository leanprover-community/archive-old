---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/intuitionistic.20logic.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html">intuitionistic logic</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="223857812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223857812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223857812">(Jan 25 2021 at 05:48)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">notnotLEM</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">t</span><span class="o">:</span><span class="n">M</span><span class="o">),</span> <span class="bp">¬¬</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">t</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">):=</span>
  <span class="k">assume</span> <span class="n">x</span> <span class="n">t</span><span class="o">,</span>
  <span class="kd">begin</span>
       <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
      <span class="c">/-</span><span class="cm">  now what? -/</span>


  <span class="kd">end</span>
</code></pre></div>
<p>push_neg  takes a  non-intuitionistic step.   How can I  push the negation into h  but don't erase the resulting double negation.<br>
I wrote a couple of such rules myself.      The tactic 'finish'  can't do this one,  which I really expected it to do.    It is about as<br>
hard to predict as Alexa--sometimes it works very well and other times it is lame.</p>



<a name="223858232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223858232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223858232">(Jan 25 2021 at 05:58)</a>:</h4>
<p>it's a tricky proof, and mathlib doesn't have any tactics that do intuitionistic proof search so you'll have to prove it yourself. The hint is to prove <code>\neg x \in t</code></p>



<a name="223864900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223864900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223864900">(Jan 25 2021 at 08:03)</a>:</h4>
<p>Michael, <code>push_neg</code> is the opposite of what you are doing. This tactic was written explicitly for teaching mathematics without any focus on exotic logic. For your specific need you can either create specific tools or go back to basics (here that would probably be <code>rw not_or_distrib</code>).</p>



<a name="223904858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223904858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223904858">(Jan 25 2021 at 14:35)</a>:</h4>
<p>Doesn't it need a bit more setup prior to attempting the proof?  For example <code>M</code> is not declared and you have <code>t m : M</code> followed by <code>x ∈ t</code> which is a little bit problematic unless <code>M</code> is some kind of lattice.  In any event <code>M</code> needs to have <code>∈ </code> defined, which it doesn't so far.  In this slight elaboration of the above sketch:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
</code></pre></div>
<p>lemma notnotLEM (M: Type*): ∀ (x t:M), ¬¬ (x ∈ t ∨ ¬ x ∈ t):=<br>
begin<br>
  sorry,<br>
end</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">we</span> <span class="n">get</span> <span class="n">the</span> <span class="n">error</span>
</code></pre></div>
<p>failed to synthesize type class instance for<br>
M : Type ?,<br>
x t : M<br>
⊢ has_mem M M</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Suppose</span> <span class="n">we</span> <span class="n">were</span> <span class="n">to</span> <span class="n">alter</span> <span class="n">it</span> <span class="n">slightly</span> <span class="n">so</span> <span class="n">that</span> <span class="bp">`</span><span class="n">M</span><span class="bp">`</span> <span class="n">is</span> <span class="n">a</span> <span class="n">set</span><span class="o">:</span>
</code></pre></div>
<p>import tactic</p>
<p>universe u</p>
<p>lemma notnotLEM1 (α: Type u) (M: set α): <br>
  ∀ (x t:M), ¬¬ (x ∈ t ∨ ¬ x ∈ t):=<br>
begin<br>
    sorry,<br>
end</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">it's</span> <span class="n">still</span> <span class="n">complaining</span> <span class="n">that</span> <span class="n">the</span> <span class="n">underlying</span> <span class="n">type</span> <span class="n">doesn't</span> <span class="k">have</span> <span class="n">membership</span> <span class="n">constructed.</span>

<span class="n">So</span> <span class="k">let</span><span class="bp">'</span><span class="n">s</span> <span class="k">let</span> <span class="bp">`</span><span class="n">M</span><span class="bp">`</span> <span class="n">be</span> <span class="n">sets</span> <span class="n">of</span> <span class="n">natural</span> <span class="n">numbers</span><span class="o">:</span>
</code></pre></div>
<p>import tactic</p>
<p>lemma notnotLEM2  (M: set ℤ): <br>
  ∀ (x t:M), ¬¬ (x ∈ t ∨ ¬ x ∈ t):=<br>
begin<br>
    sorry,<br>
end</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">it's</span> <span class="n">still</span> <span class="n">complaining</span> <span class="n">because</span> <span class="n">you</span> <span class="k">have</span> <span class="bp">`</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">t</span> <span class="bp">`</span> <span class="n">i.e.</span> <span class="n">trying</span> <span class="n">to</span> <span class="k">show</span> <span class="n">one</span> <span class="n">member</span> <span class="n">of</span> <span class="bp">`</span><span class="n">M</span><span class="bp">`</span> <span class="n">is</span> <span class="n">an</span> <span class="n">element</span> <span class="n">of</span> <span class="n">another</span> <span class="n">member</span> <span class="n">of</span> <span class="bp">`</span><span class="n">M</span><span class="bp">`.</span>

<span class="n">We</span> <span class="n">could</span> <span class="n">try</span> <span class="n">using</span> <span class="bp">`</span><span class="n">lattice</span><span class="bp">`</span> <span class="n">instead</span> <span class="n">of</span> <span class="bp">`</span><span class="n">set</span><span class="bp">`</span><span class="o">:</span>
</code></pre></div>
<p>import tactic<br>
import order.lattice</p>
<p>lemma notnotLEM3  (M: lattice ℤ): <br>
  ∀ (x t:M), ¬¬ (x ∈ t ∨ ¬ x ∈ t):=<br>
begin<br>
    sorry,<br>
end</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">This</span> <span class="k">then</span> <span class="n">resolves</span> <span class="n">the</span> <span class="n">problem</span> <span class="k">with</span> <span class="bp">`</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">t</span> <span class="bp">`</span> <span class="n">but</span> <span class="n">leads</span> <span class="n">to</span> <span class="n">a</span> <span class="n">new</span> <span class="n">and</span> <span class="n">confusing</span> <span class="n">to</span> <span class="n">me</span> <span class="n">error</span> <span class="n">that</span> <span class="n">for</span> <span class="n">type</span> <span class="bp">`</span><span class="n">M</span><span class="bp">`</span> <span class="n">we</span> <span class="n">can</span> <span class="n">no</span> <span class="n">longer</span> <span class="n">use</span> <span class="n">the</span> <span class="n">type</span> <span class="kd">notation</span> <span class="bp">`</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">M</span><span class="o">)</span><span class="bp">`.</span>  <span class="n">We</span> <span class="n">get</span> <span class="n">this</span> <span class="n">error</span> <span class="n">at</span> <span class="n">the</span> <span class="n">colen</span> <span class="k">in</span> <span class="bp">`</span><span class="n">x</span> <span class="n">t</span><span class="o">:</span><span class="n">M</span><span class="bp">`</span><span class="o">:</span>
</code></pre></div>
<p>type expected at<br>
  M<br>
term has type<br>
  lattice ℤ</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">At</span> <span class="n">this</span> <span class="n">point</span> <span class="n">you'd</span> <span class="k">have</span> <span class="n">to</span> <span class="n">call</span> <span class="n">an</span> <span class="n">expert.</span>

<span class="n">My</span> <span class="n">point</span> <span class="n">being</span> <span class="n">just</span> <span class="n">that</span> <span class="n">the</span> <span class="n">types</span> <span class="k">have</span> <span class="n">to</span> <span class="n">be</span> <span class="n">set</span> <span class="n">up</span> <span class="n">to</span> <span class="n">support</span> <span class="n">the</span> <span class="n">language</span> <span class="n">of</span> <span class="n">membership</span> <span class="n">that</span> <span class="n">you</span> <span class="n">are</span> <span class="n">using</span> <span class="n">before</span> <span class="n">you</span> <span class="n">can</span> <span class="n">prove</span> <span class="n">anything</span> <span class="n">about</span> <span class="n">that</span> <span class="n">language.</span>

<span class="n">I</span> <span class="n">am</span> <span class="n">a</span> <span class="n">beginner</span><span class="o">,</span> <span class="n">just</span> <span class="n">guessing</span> <span class="n">on</span> <span class="n">above.</span>  <span class="n">The</span> <span class="n">drill</span> <span class="n">for</span> <span class="n">newcomers</span> <span class="n">is</span> <span class="n">to</span> <span class="n">read</span> <span class="n">and</span> <span class="k">do</span> <span class="n">the</span> <span class="n">exercises</span> <span class="n">closely</span> <span class="k">in</span> <span class="n">these</span> <span class="n">two</span> <span class="n">sites</span> <span class="n">before</span> <span class="n">trying</span> <span class="n">to</span> <span class="k">do</span> <span class="n">anything</span> <span class="n">complicated</span><span class="o">:</span>

<span class="bp">*</span> <span class="bp">#</span><span class="n">nng</span>
<span class="bp">*</span> <span class="bp">#</span><span class="n">tpil</span>
</code></pre></div>



<a name="223906015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223906015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223906015">(Jan 25 2021 at 14:44)</a>:</h4>
<p><span class="user-mention" data-user-id="364351">@Lars Ericson</span>, I think the correction you were trying to make is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">notnotLEM</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">),</span> <span class="bp">¬¬</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">t</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">):=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>that is, changing <code>t</code> to be a <code>set</code> but leaving <code>x</code> alone.</p>



<a name="223908040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223908040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223908040">(Jan 25 2021 at 14:58)</a>:</h4>
<p>You don't need a lattice for this to typecheck, but you do need <code>has_mem M M</code>. The original statement is not self contained though so it's possible something equivalent to this is above the lemma in Michael Beeson's version (which is why <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>'s are important)</p>



<a name="223908321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223908321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223908321">(Jan 25 2021 at 15:00)</a>:</h4>
<p>For example based on <a href="#narrow/stream/113489-new-members/topic/introducing.20a.20weird.20less-than.20symbol/near/221327819">this</a> I expect that he has <code>(M : Type*) [Model M]</code> in the variables and <code>instance [Model M] : has_mem M M</code></p>



<a name="223908602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223908602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223908602">(Jan 25 2021 at 15:02)</a>:</h4>
<p>In any case, <code>x \in t</code> is just window dressing in this theorem. It may as well be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">notnotLEM</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬¬</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">p</span><span class="o">):=</span>
  <span class="kd">begin</span>
       <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
      <span class="c">/-</span><span class="cm">  now what? -/</span>


  <span class="kd">end</span>
</code></pre></div>



<a name="223909378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223909378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223909378">(Jan 25 2021 at 15:07)</a>:</h4>
<p>Mario, not to be a pain, but can you make your sketch into an <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>?  How do you <code>assume x t</code> when they are not declared?</p>



<a name="223909408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223909408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223909408">(Jan 25 2021 at 15:07)</a>:</h4>
<p>fixed</p>



<a name="223909525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223909525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223909525">(Jan 25 2021 at 15:08)</a>:</h4>
<p>So we already have intuitionistic logic by default.  Just don't <code>open classical</code>?</p>



<a name="223909599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223909599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223909599">(Jan 25 2021 at 15:09)</a>:</h4>
<p>actually that doesn't do very much besides make it easier to refer to some theorems that you shouldn't use here</p>



<a name="223909671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223909671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223909671">(Jan 25 2021 at 15:09)</a>:</h4>
<p>It's not as simple as that. Some tactics are classical. Try to find a proof and then at the end <code>#print axioms notnotLEM</code> and check that the output is empty.</p>



<a name="223909724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223909724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223909724">(Jan 25 2021 at 15:09)</a>:</h4>
<p>or at least that it doesn't use <code>classical.choice</code></p>



<a name="223909892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223909892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223909892">(Jan 25 2021 at 15:10)</a>:</h4>
<p>whether quotient types and/or propext are considered intuitionistic depend on your denomination of intuitionism</p>



<a name="223910099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223910099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223910099">(Jan 25 2021 at 15:12)</a>:</h4>
<p>I've just done this one. It's the same trick as the <code>not (p and not p)</code> question which comes up on a semi-regular basis. Are there any harder ones? My favourite so far was proving that various things were equivalent to LEM -- there's a list in the Software Foundations book and the question was marked super-hard.</p>



<a name="223910142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223910142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223910142">(Jan 25 2021 at 15:12)</a>:</h4>
<p>I think you mean <code>not (p iff not p)</code></p>



<a name="223910219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223910219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223910219">(Jan 25 2021 at 15:13)</a>:</h4>
<p>yeah, my one is much easier isn't it. Shows how little feeling I have for this stuff.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="kd">axioms</span> <span class="n">notnotLEM</span> <span class="c1">-- no axioms</span>
</code></pre></div>
<p>is what you're after Lars.</p>



<a name="223910430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223910430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223910430">(Jan 25 2021 at 15:15)</a>:</h4>
<p>Given that intuitionistic logic actually has an infinite lattice of truth values (even with only one indeterminate), I would think that there are actually long and interesting intuitionistic theorems, but these two examples are the hardest I know and they are pretty easy, objectively speaking</p>



<a name="223910539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223910539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223910539">(Jan 25 2021 at 15:15)</a>:</h4>
<p>Bottom of <a href="https://softwarefoundations.cis.upenn.edu/lf-current/Logic.html">https://softwarefoundations.cis.upenn.edu/lf-current/Logic.html</a> is the challenge I remember enjoying as a beginner. My strategy was to knock off four very easy proofs that LEM implied all of them, and then prove LEM from each of them.</p>



<a name="223910541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223910541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223910541">(Jan 25 2021 at 15:15)</a>:</h4>
<p>It's fun to come up with proofs and counterexamples for all the basic logic theorems</p>



<a name="223910598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223910598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223910598">(Jan 25 2021 at 15:16)</a>:</h4>
<p>lol there are no counterexamples</p>



<a name="223910604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223910604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223910604">(Jan 25 2021 at 15:16)</a>:</h4>
<p>the counterexamples are actually more mindbending than the proofs</p>



<a name="223910641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223910641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223910641">(Jan 25 2021 at 15:16)</a>:</h4>
<p>You need kripke frames</p>



<a name="223910647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223910647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223910647">(Jan 25 2021 at 15:16)</a>:</h4>
<p>all the theorems are true, you just can't prove them because you're missing some axioms</p>



<a name="223910676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223910676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223910676">(Jan 25 2021 at 15:16)</a>:</h4>
<p>If you believe Brouwer, they are real counterexamples.</p>



<a name="223910679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223910679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223910679">(Jan 25 2021 at 15:16)</a>:</h4>
<p>It's a godel completeness kind of situation</p>



<a name="223910732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223910732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223910732">(Jan 25 2021 at 15:17)</a>:</h4>
<p>Never trust a mathematician who doesn't believe their own theorems</p>



<a name="223910737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223910737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223910737">(Jan 25 2021 at 15:17)</a>:</h4>
<p>you just need more advanced models to capture the intuitionistic theorems instead of the classical ones</p>



<a name="223910773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223910773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223910773">(Jan 25 2021 at 15:17)</a>:</h4>
<p>oh wait, I started on this whole Lean thing because I was worried about my own theorems...</p>



<a name="223910846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223910846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223910846">(Jan 25 2021 at 15:18)</a>:</h4>
<p>Learning about the models also gives you a better sense for how to predict that a theorem won't be intuitionistically provable</p>



<a name="223910910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223910910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223910910">(Jan 25 2021 at 15:18)</a>:</h4>
<p>for example topological models, where truth values are open sets and negation is the interior of the complement</p>



<a name="223910940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223910940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223910940">(Jan 25 2021 at 15:19)</a>:</h4>
<p>it makes it easy to see why <code>p \/ ~p</code> should not hold</p>



<a name="223911031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223911031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223911031">(Jan 25 2021 at 15:19)</a>:</h4>
<p>how come nobody from paraconsistent logic ever shows up here? Don't they believe p and not p, or something?</p>



<a name="223911097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223911097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223911097">(Jan 25 2021 at 15:20)</a>:</h4>
<p>or is it p iff not p</p>



<a name="223911156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223911156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223911156">(Jan 25 2021 at 15:20)</a>:</h4>
<p>Relevance logic is fun, that's a paraconsistent logic that you see sometimes on the FOM mailing list</p>



<a name="223911227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223911227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223911227">(Jan 25 2021 at 15:20)</a>:</h4>
<p>it rejects <code>A -&gt; ~A -&gt; B</code> because <code>B</code> comes "out of nowhere"</p>



<a name="223911250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223911250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223911250">(Jan 25 2021 at 15:21)</a>:</h4>
<p>I think I'll go back to condensed sets</p>



<a name="223911661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223911661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223911661">(Jan 25 2021 at 15:23)</a>:</h4>
<p>But lean really <em>isn't</em> a playground for arbitrary logics, intuitionistic logic just has a special place here because MLTT is a direct descendent of intuitionism a la brouwer</p>



<a name="223911663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223911663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223911663">(Jan 25 2021 at 15:23)</a>:</h4>
<p>Can we please prove that <a href="https://www.jstor.org/stable/20013984?seq=1">if God possibly exists, then God necessarily exists</a>?</p>



<a name="223911748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223911748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223911748">(Jan 25 2021 at 15:24)</a>:</h4>
<p>in particular lean is also hostile to modal logic</p>



<a name="223911936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223911936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223911936">(Jan 25 2021 at 15:25)</a>:</h4>
<p>(also in that paraphrasing of the argument you forgot the six or so questionable axioms about goodness used in the proof)</p>



<a name="223912036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223912036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223912036">(Jan 25 2021 at 15:26)</a>:</h4>
<p>Don't leave <a href="https://mitpress.mit.edu/books/model-checking-second-edition">temporal logic</a> out.  Any kind of logic should be expressible in Lean as a new mathematical structure, it just won't proof automation tuned to that logic.  A new logic should be like any other structured like <code>ring</code> or <code>lattice</code>.  You just add the axioms for that logic in the structure definition.  Am I right?</p>



<a name="223912066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223912066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223912066">(Jan 25 2021 at 15:26)</a>:</h4>
<p>I think there is an isabelle formalization of that argument (or was it a different one?)</p>



<a name="223912196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223912196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223912196">(Jan 25 2021 at 15:27)</a>:</h4>
<p>Sure, lean can do natural numbers so it can represent any logic as a deep embedding. I'm talking about the shallow embedding, where the actual axioms of lean matter</p>



<a name="223912477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223912477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223912477">(Jan 25 2021 at 15:29)</a>:</h4>
<p>In a deep embedding, it doesn't really matter what axioms the meta logic has. PA can model ZFC, ZFC can model HOTT, HOTT can model modal logic, and you can freely mix and match</p>



<a name="223912480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223912480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223912480">(Jan 25 2021 at 15:29)</a>:</h4>
<p>If I've translated the software foundations exercises correctly, then these four theorems should all be provable constructively:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">lem</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">P</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">P</span>

<span class="kd">theorem</span> <span class="n">lem_of_peirce</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span>
  <span class="o">((</span><span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">lem</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">lem_of_double_negation_elimination</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="bp">¬¬</span><span class="n">P</span> <span class="bp">→</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">lem</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">lem_of_de_morgan_not_and_not</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="bp">¬</span><span class="o">(</span><span class="bp">¬</span><span class="n">P</span> <span class="bp">∧</span> <span class="bp">¬</span><span class="n">Q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">lem</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">lem_of_implies_to_or</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span><span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span><span class="o">))</span> <span class="bp">→</span> <span class="n">lem</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="223912676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223912676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223912676">(Jan 25 2021 at 15:30)</a>:</h4>
<p>that's correct (those are all iffs, although the reverse implication is just the classical proof)</p>



<a name="223912683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223912683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223912683">(Jan 25 2021 at 15:30)</a>:</h4>
<p>Given that it's trivial to show all the things applying LEM are true classically (just check the truth tables), these things are all hence constructively equivalent to LEM.</p>



<a name="223916578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223916578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223916578">(Jan 25 2021 at 15:56)</a>:</h4>
<p>These are easy.  They all have about the same proof.  Am I doing something wrong?  I didn't <code>open classical</code>.  Is this intuitionist?  Or are we missing a lattice and a typeclass of <code>intuitionistic_logic</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">def</span> <span class="n">lem</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">P</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">P</span>

<span class="kd">theorem</span> <span class="n">lem_of_peirce</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span>
  <span class="o">((</span><span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">lem</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">P</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">Q</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hQ</span><span class="o">:</span> <span class="n">Q</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">or.inl</span> <span class="n">hQ</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">or.inr</span> <span class="n">hQ</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">lem_of_double_negation_elimination</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="bp">¬¬</span><span class="n">P</span> <span class="bp">→</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">lem</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">P1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">lem</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">P</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hP</span><span class="o">:</span> <span class="n">P</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">or.inl</span> <span class="n">hP</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">or.inr</span> <span class="n">hP</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">lem_of_de_morgan_not_and_not</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="bp">¬</span><span class="o">(</span><span class="bp">¬</span><span class="n">P</span> <span class="bp">∧</span> <span class="bp">¬</span><span class="n">Q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">lem</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">P1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">lem</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">P</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hP</span><span class="o">:</span> <span class="n">P</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">or.inl</span> <span class="n">hP</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">or.inr</span> <span class="n">hP</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">lem_of_implies_to_or</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span><span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span><span class="o">))</span> <span class="bp">→</span> <span class="n">lem</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">lem</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">P</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hP</span><span class="o">:</span> <span class="n">P</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">or.inl</span> <span class="n">hP</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">or.inr</span> <span class="n">hP</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="223916700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223916700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223916700">(Jan 25 2021 at 15:57)</a>:</h4>
<p>That is, does the above respond to the original problem, or is it something fancier?</p>



<a name="223917031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223917031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223917031">(Jan 25 2021 at 15:59)</a>:</h4>
<p><code>by_cases</code> assumes LEM</p>



<a name="223919195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223919195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223919195">(Jan 25 2021 at 16:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="364351">Lars Ericson</span> <a href="#narrow/stream/113489-new-members/topic/intuitionistic.20logic/near/223916700">said</a>:</p>
<blockquote>
<p>That is, does the above respond to the original problem, or is it something fancier?</p>
</blockquote>
<p>You can ask Lean this question by writing <code>#print axioms lem_of_peirce</code>. Since it outputs <code>classical.choice</code>, you did use choice in your proof.</p>



<a name="223919592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223919592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223919592">(Jan 25 2021 at 16:12)</a>:</h4>
<p>Yes,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="kd">axioms</span> <span class="n">lem_of_peirce</span>
</code></pre></div>
<p>gives</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">classical.choice</span>
<span class="n">quot.sound</span>
<span class="n">propext</span>
</code></pre></div>
<p>So is it fair to say that if <span class="user-mention" data-user-id="284844">@Michael Beeson</span>  rewrites the above proofs without <code>by_cases</code>, then his original problem is addressed?  I.e., no need to define <code>intuitionistic_logic</code> as a structure with lattice-valued propositions or something like that?</p>



<a name="223919969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223919969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223919969">(Jan 25 2021 at 16:14)</a>:</h4>
<p>You just need to prove this theorem using <code>intro</code>, <code>apply</code>, and things like <code>or.inl</code> and <code>or.inr</code> (or <code>left</code> and <code>right</code>), and <code>have</code> if you want. Such a proof will be intuitionistic.</p>



<a name="223920059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223920059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223920059">(Jan 25 2021 at 16:15)</a>:</h4>
<p>also <code>cases</code> and/or <code>and.left</code> and <code>and.right</code> on the one with conjunction</p>



<a name="223920130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223920130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223920130">(Jan 25 2021 at 16:15)</a>:</h4>
<p>I assure you that lattices are not involved</p>



<a name="223920490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223920490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223920490">(Jan 25 2021 at 16:17)</a>:</h4>
<p>Also, you should notice that in your proof you never use any of the assumptions, you are just proving <code>lem</code> outright, which should give you a hint that something is wrong</p>



<a name="223923853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223923853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223923853">(Jan 25 2021 at 16:36)</a>:</h4>
<p>Here's an answer to my own question:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">notnotLEM</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span><span class="o">:</span><span class="kt">Prop</span><span class="o">),</span> <span class="bp">¬¬</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">P</span><span class="o">):=</span>
  <span class="k">assume</span> <span class="n">P</span><span class="o">,</span>
  <span class="kd">begin</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h2</span><span class="o">:</span> <span class="bp">¬</span> <span class="n">P</span> <span class="bp">∧</span> <span class="bp">¬¬</span> <span class="n">P</span><span class="o">:=</span> <span class="kd">begin</span> <span class="n">ifinish</span> <span class="kd">end</span><span class="o">,</span>
    <span class="n">ifinish</span><span class="o">,</span>
  <span class="kd">end</span>
</code></pre></div>
<p>In short,  ifinish can do this in two steps.</p>



<a name="223923965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223923965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223923965">(Jan 25 2021 at 16:37)</a>:</h4>
<p>Nope, check the axioms</p>



<a name="223924135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223924135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223924135">(Jan 25 2021 at 16:38)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="kd">axioms</span> <span class="n">notnotLEM</span>
<span class="c1">-- propext</span>
<span class="c1">-- classical.choice</span>
<span class="c1">-- quot.sound</span>
</code></pre></div>
<p>yes, <code>ifinish</code> is broken (<a href="https://github.com/leanprover-community/mathlib/issues/1922">#1922</a>)</p>



<a name="223927741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223927741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223927741">(Jan 25 2021 at 17:02)</a>:</h4>
<p>OK.   I have 30,000 lines of Lean code with hundreds of applications of  the 'ifinish'  tactic to finish off small goals.    I knew already <br>
that 'ifinish' will sometimes prove something that is not intuitionistically valid.   But what I have now learned is that it also will <br>
prove an intuitionistically valid theorem  by a classical proof.    That means that my proofs are not intuitionistically valid after all.<br>
Since I am not skilled in meta programming I don't think I'll be able to fix the broken tactic myself.   It looks like I will have to <br>
supply a list of basic intuitionistic logic theorems and use them myself by hand to fix all those proofs.</p>



<a name="223929207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223929207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223929207">(Jan 25 2021 at 17:11)</a>:</h4>
<p>The manual proof of this theorem is not difficult, and most theorems are even easier than this one - generally intuitionistically valid theorems will have an "obvious" proof that is intuitionistic</p>



<a name="223929348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223929348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223929348">(Jan 25 2021 at 17:12)</a>:</h4>
<p>in general you should just be using the theorems in <code>logic.basic</code>, which are all intuitionistic where possible and use decidable hypotheses otherwise</p>



<a name="223929601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223929601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223929601">(Jan 25 2021 at 17:14)</a>:</h4>
<p>If you want to know that your theorems are intuitionistic, always use <code>#print axioms</code> because you never know if a tactic snuck one past you (especially if you are using high powered tactics like <code>finish</code>)</p>



<a name="223930074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223930074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223930074">(Jan 25 2021 at 17:17)</a>:</h4>
<p>This may sound like a joke, but...are there any software applications whose verification requires intuitionistic logic for physical safety?</p>
<p>If there were, then the matter of strictly being able to control what axioms are available in the namespace would take on more importance.  For example, in addition to <code>open classical</code>, you might want to introduce a directive <code>prohibit classical</code> which forces tactics to throw an error if they use LEM or try to open that namespace.</p>



<a name="223930383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223930383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223930383">(Jan 25 2021 at 17:19)</a>:</h4>
<p>Probably a <code>@[restrict_axioms [axioms, here]]</code> attribute is the best way to achieve that goal, if it's a goal anyone really has - it can then just do the equivalent of <code>#print axioms</code> and verify that it contains only the provided axioms.</p>



<a name="223930638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223930638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223930638">(Jan 25 2021 at 17:21)</a>:</h4>
<blockquote>
<p>are there any software applications whose verification requires intuitionistic logic for physical safety?</p>
</blockquote>
<p>It depends on how the logic is interpreted. If it is used to express things that are true and false about the behavior of a program or physical system, then I would say no - classical logic is admissible for such applications. If however there is some other aspect of the logic being invoked, for example the "computability" of the proofs or the inability to make certain kinds of statements a la HoTT, enabling more unusual models that don't literally read the theorems as stated, then these alternate logics can in fact capture something beyond classical logic</p>



<a name="223930944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223930944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223930944">(Jan 25 2021 at 17:23)</a>:</h4>
<p>One way to do it would be a command like <code>#lint</code> that checks all theorems in the current file for intuitionism unless they have <code>@[classical]</code> or some such</p>



<a name="223931103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223931103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223931103">(Jan 25 2021 at 17:24)</a>:</h4>
<p>Not strictly analogous but a few examples of connections of logical modelling to real-world:</p>
<ul>
<li>Chee Yap's <a href="https://cs.nyu.edu/exact/">zero project</a>, using real algebraic number arithmetic to never confuse left and right.</li>
<li>Ed Clarke's <a href="https://link.springer.com/chapter/10.1007/978-3-540-69850-0_1">temporal logic applied to VLSI design</a></li>
</ul>
<p>So what I'm asking, loosely, is if there is a real-world application and rationale for excluding LEM.  Or in general why is it an interesting project to exclude LEM.  Not being facetious.  I just don't honestly know why it's a thing.</p>



<a name="223931110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223931110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223931110">(Jan 25 2021 at 17:24)</a>:</h4>
<p>When I did this a few months ago with the core library, I just grepped for all theorem names in the file and edited a big list of <code>#print axioms</code> at the end</p>



<a name="223931184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223931184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223931184">(Jan 25 2021 at 17:24)</a>:</h4>
<p>Constructivism is a thing</p>



<a name="223931234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223931234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223931234">(Jan 25 2021 at 17:25)</a>:</h4>
<p>you can literally run proofs that don't use choice</p>



<a name="223931248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223931248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223931248">(Jan 25 2021 at 17:25)</a>:</h4>
<p><code>#reduce</code> will do this in lean</p>



<a name="223931413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223931413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223931413">(Jan 25 2021 at 17:26)</a>:</h4>
<p>That said I'm not going to defend it too hard, it's mostly a puzzle game for me</p>



<a name="223931445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223931445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223931445">(Jan 25 2021 at 17:27)</a>:</h4>
<p>it's interesting to use less axioms when you can</p>



<a name="223931733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223931733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223931733">(Jan 25 2021 at 17:29)</a>:</h4>
<p>However the list of axioms strongly influences the kinds of subsystems you will try to study. In metamath, I did a lot of stuff with avoiding the axiom of choice (obvious) but also the axiom of foundation (turns out it's never needed for anything) and the axiom of replacement (this one is pretty important but you can still do a fair bit). In lean all of that is off the table because we have ZF+U right out the door even with <code>no axioms</code></p>



<a name="223932514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223932514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223932514">(Jan 25 2021 at 17:34)</a>:</h4>
<p>On the other hand, in metamath (or at least <a href="http://us.metamath.org/mpeuni/mmset.html">set.mm</a>), the very first axioms are the 3 axioms of classical logic, so intuitionism / no-LEM is not even considered, while in lean that's actually a thing you can try to pursue. (There is however an alternate axiomatization, <a href="http://us.metamath.org/ileuni/mmil.html">iset.mm</a>, that I created specifically to investigate intuitionistic and minimal logic, as well as IZF and CZF. Lean doesn't support those kinds of axiomatic investigations.)</p>



<a name="223932670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223932670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223932670">(Jan 25 2021 at 17:35)</a>:</h4>
<p>On the topic of <code>classical</code>, is it the case that in general, <code>nonempty α</code> is not decidable? Under what constraints is it? I'm trying to see if I can make some variant of <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.subtype_of_fintype/src">src#fintype.subtype_of_fintype</a> lose the noncomputability.</p>



<a name="223932745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223932745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223932745">(Jan 25 2021 at 17:36)</a>:</h4>
<p>It's as decidable as any arbitrary proposition</p>



<a name="223932764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223932764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223932764">(Jan 25 2021 at 17:36)</a>:</h4>
<p>which is to say, not in general</p>



<a name="223932804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223932804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223932804">(Jan 25 2021 at 17:36)</a>:</h4>
<p>specifically, <code>nonempty (plift p) &lt;-&gt; p</code></p>



<a name="223933012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223933012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223933012">(Jan 25 2021 at 17:38)</a>:</h4>
<p>I think the most appropriate variant on <code>fintype.subtype_of_fintype</code> would be to add a <code>decidable_pred p</code> assumption</p>



<a name="223933534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223933534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223933534">(Jan 25 2021 at 17:42)</a>:</h4>
<p>How would you modify this then? Or avoid it entirely in the <code>decidable_pred</code> version of <code>fintype.subtype_of_fintype</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">of_injective</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">letI</span> <span class="o">:=</span> <span class="n">classical.dec</span><span class="bp">;</span> <span class="n">exact</span>
<span class="k">if</span> <span class="n">hα</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">α</span> <span class="k">then</span> <span class="kd">by</span> <span class="n">letI</span> <span class="o">:=</span> <span class="n">classical.inhabited_of_nonempty</span> <span class="n">hα</span><span class="bp">;</span>
  <span class="n">exact</span> <span class="n">of_surjective</span> <span class="o">(</span><span class="n">inv_fun</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">inv_fun_surjective</span> <span class="n">H</span><span class="o">)</span>
<span class="k">else</span> <span class="o">⟨</span><span class="bp">∅</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">hα</span> <span class="o">⟨</span><span class="n">x</span><span class="o">⟩)</span><span class="bp">.</span><span class="n">elim</span><span class="o">⟩</span>
</code></pre></div>



<a name="223933590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223933590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223933590">(Jan 25 2021 at 17:42)</a>:</h4>
<p>Like, adding a <code>[decidable_eq α]</code> and using the inverse from <a href="https://github.com/leanprover-community/mathlib/issues/5872">#5872</a>?</p>



<a name="223934050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223934050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223934050">(Jan 25 2021 at 17:46)</a>:</h4>
<p>Probably avoid it entirely. The direct proof is simpler, because you can use <code>univ.filter p</code> as the witness</p>



<a name="223934137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223934137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223934137">(Jan 25 2021 at 17:46)</a>:</h4>
<p>There is an analogue of this for <code>of_injective</code> but the decidability assumption is more complicated</p>



<a name="223934198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223934198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223934198">(Jan 25 2021 at 17:47)</a>:</h4>
<p>If you're looking for decision procedures for sublanguages of set theory that you could tuck into Lean, there's a whole cottage industry for that, I linked a few papers <a href="#narrow/stream/113489-new-members/topic/What.20is.20a.20deterministic.20timeout/near/219470104">here</a>.</p>
<p>The point of my question was not really to question utility of excluding LEM but rather to point out that, if there is a material requirement for that in a program verification system (canonical example: 737MAX autopilot), then the fact that  <span class="user-mention" data-user-id="284844">@Michael Beeson</span>  has 30,000 lines of proof that he thought were LEM-free but are not would be a significant fail in a real world application.  This raises the utility of <code>restrict axioms</code> or similar.</p>



<a name="223934322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223934322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223934322">(Jan 25 2021 at 17:48)</a>:</h4>
<p>Decision procedures? Not really. Most of the interesting subsystems are undecidable. But a collection of theorems proved under minimal assumptions is useful</p>



<a name="223934581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223934581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223934581">(Jan 25 2021 at 17:50)</a>:</h4>
<p>Lean + mathlib is currently not geared toward intuitionistic logic. The base axiom system, dependent type theory, draws on intuitionism, but if you actually care about intuitionistic or constructive mathematics you should use coq instead</p>



<a name="223934790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223934790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223934790">(Jan 25 2021 at 17:51)</a>:</h4>
<p>The user base doesn't care about constructive logic, and as you've already pointed out it's not really needed for applications. There is the notion of <code>noncomputable</code> which is drawn at the (IMO much more useful) distinction of whether lean can generate executable code for the definition</p>



<a name="223938618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223938618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223938618">(Jan 25 2021 at 18:20)</a>:</h4>
<p>Mario and I are talking about this notnotLEM as if everyone knows how to solve it constructively, but in case anyone this thread is actually hoping someone will post a solution, here's what I came up with:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">notnotLEM</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span><span class="o">:</span><span class="kt">Prop</span><span class="o">),</span> <span class="bp">¬¬</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">P</span><span class="o">):=</span>
  <span class="k">assume</span> <span class="n">P</span><span class="o">,</span>
  <span class="kd">begin</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h2</span><span class="o">:</span> <span class="bp">¬</span> <span class="n">P</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">hP</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">left</span><span class="o">,</span>
      <span class="n">assumption</span> <span class="o">},</span>
    <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">right</span><span class="o">,</span>
    <span class="n">assumption</span>
  <span class="kd">end</span>

  <span class="k">#print</span> <span class="kd">axioms</span> <span class="n">notnotLEM</span> <span class="c1">-- no axioms</span>
</code></pre></div>
<p>The trick is to prove not P first. This is the same trick as the not (P iff not P) puzzle in TPIL. The four problems I posted earlier should also be solvable nonconstructively.</p>
<p>Regarding <code>ifinish</code>, everyone always says "well nobody really uses it and so what's the point fixing it" but could it be the case that there's just a one liner which makes it far more likely to be constructive? <code>ifinish</code> seems to call<code> finish</code> with <code>{classical := ff}</code>. Do people actually understand what the issue is or it is just <code>WONTFIX</code>? Edit: Oh, I see Jeremy looked at this seriously in <a href="https://github.com/leanprover-community/mathlib/issues/1922">#1922</a> . Hmm.</p>



<a name="223938751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223938751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223938751">(Jan 25 2021 at 18:21)</a>:</h4>
<p>there is some discussion about this on the issue</p>



<a name="223938797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223938797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223938797">(Jan 25 2021 at 18:21)</a>:</h4>
<p>some of it was oversight in the implementation but there is also a part that requires C++ changes</p>



<a name="223938887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223938887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223938887">(Jan 25 2021 at 18:22)</a>:</h4>
<p>"Fixing this leak could be a decent medium-sized project for anyone interested in learning tactic programming."</p>



<a name="223939143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223939143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223939143">(Jan 25 2021 at 18:24)</a>:</h4>
<p>Perhaps for someone in Michael's situation it might be easier to just write a new tactic, which blunders through some known techniques e.g. uses some simp set consisting of all the constructive lemmas in logic.basic?</p>



<a name="223939242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223939242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223939242">(Jan 25 2021 at 18:25)</a>:</h4>
<p>and the obligatory golfed version:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">notnotLEM</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬¬</span><span class="o">(</span><span class="n">P</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span> <span class="o">(</span><span class="n">or.inr</span> <span class="bp">$</span> <span class="n">h</span> <span class="bp">∘</span> <span class="n">or.inl</span><span class="o">)</span>
</code></pre></div>



<a name="223939274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223939274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223939274">(Jan 25 2021 at 18:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/intuitionistic.20logic/near/223934322">said</a>:</p>
<blockquote>
<p>Decision procedures? Not really. Most of the interesting subsystems are undecidable. But a collection of theorems proved under minimal assumptions is useful</p>
</blockquote>
<p>It depends on the meaning of "interesting", for example "The class of unquantified formulae of set theory involving Boolean operators, the powerset and singleton operators, and the equality and membership predicates is shown to have a solvable satisfiability problem.  It is shown that whenever a formula φ in the above class is satisfiable there exists a hereditarily finite model of φ, whose rank is bounded by a doubly exponential expression in the number of variables<br>
occurring in φ. "</p>
<p>So if you are writing procedures like <code>finish</code> and <code>ring</code> and are permitted to embed magic widgets in them that solve certain subsets of expressions, for example the subset described above, then it is at least useful to know</p>
<ul>
<li>That there is a fully constructive/programmable decision procedure for that class of expression</li>
<li>If the expression has more than a few variables in it, it's intractable</li>
<li>Any other solution you might think of for that class of expressions is equally intractable</li>
</ul>



<a name="223939432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223939432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223939432">(Jan 25 2021 at 18:26)</a>:</h4>
<blockquote>
<p>It depends on the meaning of "interesting"</p>
</blockquote>
<p>Put another way, if a theory is decidable then it is uninteresting, because a computer can solve all the problems so there is nothing left for me to do</p>



<a name="223939595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223939595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223939595">(Jan 25 2021 at 18:27)</a>:</h4>
<p>Do you not want to use <code>linarith</code> and <code>ring</code> and <code>finish</code> when you can?  There's enough heavy lifting to do out there without making trivial things hard when they don't have to be.</p>



<a name="223939673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223939673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223939673">(Jan 25 2021 at 18:28)</a>:</h4>
<p>I don't care for doubly-exponential proofs of anything</p>



<a name="223939761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223939761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223939761">(Jan 25 2021 at 18:28)</a>:</h4>
<p>I know 3 people that got tenure just by cranking out papers like that.  It's a living.</p>



<a name="223939800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223939800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223939800">(Jan 25 2021 at 18:29)</a>:</h4>
<p>it's nice to know these subsets are decidable in theory but it has very little practical application besides knowing that certain search strategies will terminate</p>



<a name="223939801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223939801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223939801">(Jan 25 2021 at 18:29)</a>:</h4>
<p>I may be mistaken, but "decidability" in lean usually refers to the presence of a <a href="https://leanprover-community.github.io/mathlib_docs/find/decidable">docs#decidable</a> instance right? So <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> isn't talking about tactics like <code>ring</code>, <code>linarith</code>, and <code>finish</code>?</p>



<a name="223939926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223939926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223939926">(Jan 25 2021 at 18:30)</a>:</h4>
<p>No I mean decidable in the same sense as Lars, i.e. you can prove or disprove all problems in a class. <code>ring</code> is a decision procedure, as is <code>linarith</code>, but <code>finish</code> is a heuristic solving an undecidable problem</p>



<a name="223961507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223961507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223961507">(Jan 25 2021 at 21:17)</a>:</h4>
<p>In case anyone cares,  what I'm going to do about this is simply to go through my 16 files and manually replace all use of <br>
ifinish  with a few lines of code.  This is taking about,  I would guess,  one minute per occurrence,  and there were about forty in <br>
the file I'm working on now,  so it's a couple of days and then I'm done with it.    Also for the record I did not "think these proofs were<br>
LEM-free",  I only thought "these proofs ought to be LEM-free".   I always knew I needed to "check axioms"  when I was done.   What <br>
I didn't anticipate is that simple,  intuitionistically correct,  inferences would get classical proofs via ifinish.   Oh well,  it's just another speed bump.</p>



<a name="223962254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223962254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223962254">(Jan 25 2021 at 21:22)</a>:</h4>
<p><span class="user-mention" data-user-id="284844">@Michael Beeson</span> some time back <span class="user-mention" data-user-id="110032">@Reid Barton</span> wrote some meta code for you to make this checking quite fast, I'm sure that will be useful here<br>
<span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/not.20equals/near/209186002">said</a>:</p>
<blockquote>
<p>Here is a super hacky way to print all the axioms used by everything in the current file. Import it and invoke it with <code>#axioms_all</code>. You could grep the output for <code>choice</code>.</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.core</span>

<span class="kn">section</span>

<span class="kn">open</span> <span class="n">lean</span> <span class="n">lean.parser</span>

<span class="kd">@[user_command]</span> <span class="kd">meta</span> <span class="kd">def</span> <span class="n">axioms_all</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">interactive.parse</span> <span class="bp">$</span> <span class="n">tk</span> <span class="s2">"#axioms_all"</span><span class="o">)</span> <span class="o">:</span> <span class="n">parser</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">e</span> <span class="bp">←</span> <span class="n">get_env</span><span class="o">,</span>
   <span class="n">e.fold</span> <span class="o">(</span><span class="n">return</span> <span class="o">())</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">d</span> <span class="n">rest</span><span class="o">,</span> <span class="k">do</span>
     <span class="n">when</span> <span class="o">(</span><span class="n">e.in_current_file</span> <span class="n">d.to_name</span><span class="o">)</span>
       <span class="o">(</span><span class="k">do</span> <span class="n">emit_command_here</span> <span class="o">(</span><span class="s2">"#check "</span> <span class="bp">++</span> <span class="n">d.to_name.to_string</span><span class="o">),</span>
           <span class="n">emit_command_here</span> <span class="o">(</span><span class="s2">"#print axioms "</span> <span class="bp">++</span> <span class="n">d.to_name.to_string</span><span class="o">),</span>
           <span class="n">return</span> <span class="o">()),</span>
     <span class="n">rest</span><span class="o">),</span>
   <span class="n">return</span> <span class="o">()</span>

<span class="kd">end</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="223989399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223989399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223989399">(Jan 26 2021 at 02:06)</a>:</h4>
<p>I'm using that code.   Sometimes it works,  sometimes it generates "not enough memory"  messages.   But I'm just going to <br>
eliminate all uses of 'ifinish' and be done with it.</p>



<a name="223996088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223996088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223996088">(Jan 26 2021 at 04:26)</a>:</h4>
<p>simp  also produces intuitionistically incorrect results.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">foo</span><span class="o">:</span> <span class="bp">¬¬</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span><span class="o">:</span><span class="kt">Prop</span><span class="o">),</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">false</span><span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="kd">end</span>
</code></pre></div>
<p>Of course foo is not a correct result--that's irrelevant-- the point is that simp transforms h   incorrectly.    Since foo is not a theorem<br>
I can't see what #check axioms foo would report.</p>
<p>But one of my actual theorems makes use of simp,  and in that proof simp makes an incorrect step.</p>



<a name="223997117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223997117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223997117">(Jan 26 2021 at 04:48)</a>:</h4>
<p>That's also to be expected, since <code>simp</code> uses all lemmas marked with the attribute <code>@[simp]</code> and we tag useful lemmas with that attribute regardless of whether they are intuitionistically valid.</p>
<p>As a workaround, you could create a custom <code>simp</code> set using <a href="https://leanprover-community.github.io/mathlib_docs/commands.html#mk_simp_attribute">command#mk_simp_attribute</a> that only contains intuitionistic lemmas. You can find some examples of its use in <code>mathlib</code> <a href="https://github.com/leanprover-community/mathlib/search?q=mk_simp_attribute">here</a>.</p>



<a name="223997167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/223997167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#223997167">(Jan 26 2021 at 04:49)</a>:</h4>
<p>Was there a way that I could have discovered that (I mean that simp is possibly not intuitionistic)  by reading some piece of documentation?   I naively believed that as long as I did not explicitly "turn on" classical logic,  I would get only intuitionistic logic.   Thanks for pointing me to mk_simp_attribute.   That might be useful.   I didn't make all that much use of simp so I think I'll just go through and eliminate them.</p>



<a name="224001318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224001318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224001318">(Jan 26 2021 at 06:19)</a>:</h4>
<p>Unfortunately, the population of Lean users interested in intuitionistic logic is low (or silent) enough that most of the documentation completely ignores these (valid) concerns. So I would suggest proceeding with the opposite prior: tactics and theorems assume classical logic unless explicitly mentioned otherwise. (That the documentation of <code>ifinish</code> doesn't mention that it's broken is an oversight which we'll hopefully fix soon.)</p>



<a name="224013270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224013270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224013270">(Jan 26 2021 at 09:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284844">Michael Beeson</span> <a href="#narrow/stream/113489-new-members/topic/intuitionistic.20logic/near/223997167">said</a>:</p>
<blockquote>
<p>Was there a way that I could have discovered that (I mean that simp is possibly not intuitionistic)  by reading some piece of documentation? </p>
</blockquote>
<p>The technical answer is yes: the <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#simp">documentation of simp</a> says "<code>simp</code> simplifies the main goal target using lemmas tagged with the attribute <code>[simp]</code>." So, if you are interested in knowing which lemmas are used by <code>simp</code> you need to have a look at lemmas tagged with simp, such as <a href="https://leanprover-community.github.io/mathlib_docs/find/not_not">docs#not_not</a>.</p>
<p>But the honest answer is no: I think there is nothing we could write that you would accept to understand and make you come out of your alternate reality. We tried to tell you so many times. mathlib is 470.000  lines of normal mathematics. Each time you load a file from mathlib you're summoning some of those 470.000 lines that will try to prevent you from staying intuitionist. Why are you doing that? Why not creating your own tactics or, much easier, use a tool like the Coq standard library or mathcomp that is designed for the kind of exotic math you're doing? There is nothing wrong with intuitionism, this is simply not what mathlib is doing. Do you complain about the documentation of your car that doesn't mention on every page that you shouldn't use it as a boat?</p>
<p>All that being repeated, I still think we should entirely remove <code>ifinish</code> from mathlib. There is no point at all in keeping a tactic that is known to be so broken. I'll try to convince the other maintainers and I really apologize for the inconvenience.</p>



<a name="224023698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224023698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224023698">(Jan 26 2021 at 11:04)</a>:</h4>
<p>Presumably it would be an entry-level <code>tactic</code> project to write a new <code>isimp</code> that only used simp lemmas that don't rely on <code>choice</code>? Obviously mathlib wouldn't use it much, but it would at least make it more viable for those looking for intuitionistic logic.</p>



<a name="224024331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224024331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224024331">(Jan 26 2021 at 11:11)</a>:</h4>
<p>I think there's no easy way to check the axioms used by a declaration in <code>meta</code> land.</p>



<a name="224024645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224024645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224024645">(Jan 26 2021 at 11:14)</a>:</h4>
<p>Oh, I didn't look at the code above for collecting axioms - indeed, it just uses <code>emit_command_here "#print axioms"</code>. Can meta-land code capture the output of <code>emit_command_here</code>?</p>



<a name="224024744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224024744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224024744">(Jan 26 2021 at 11:15)</a>:</h4>
<p>Since mathlib is by design classical, I wouldn't see the point. A library building something seriously intuitionistic in Lean should probably be something different from mathlib.</p>



<a name="224025042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224025042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224025042">(Jan 26 2021 at 11:19)</a>:</h4>
<p>It seems a shame to throw out all of mathlib when intuitionistic users object to only parts of it. I wonder what fraction of our  ~50k theorems use choice. Even if it's 90%, getting a 5k theorem head-start still seems like an argument to build an intuitionistic library on top of mathlib rather than from scratch.</p>



<a name="224025607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224025607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224025607">(Jan 26 2021 at 11:25)</a>:</h4>
<p>A clear-cut choice seems much better from my point of view, as otherwise some people will get some expectations, and then they will be disappointed when they realize these expectations can not be met with mathlib. (This is a situation we can already see!)</p>



<a name="224025972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224025972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224025972">(Jan 26 2021 at 11:28)</a>:</h4>
<p>Indeed there is no need for a thought experiment here: we <em>know</em> what happens when people try to use mathlib for intuitionistic maths.</p>



<a name="224026451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224026451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224026451">(Jan 26 2021 at 11:33)</a>:</h4>
<p>See also <a href="https://github.com/leanprover-community/mathlib/issues/5897">#5897</a>.</p>



<a name="224032277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224032277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224032277">(Jan 26 2021 at 12:37)</a>:</h4>
<p>Regarding the other point Michael made, about <code>simp</code> -- are there any non-intuitionistic <code>simp</code> lemmas in core Lean 3? I ask because a proposal crystallising here is "if you want to be 100% sure you are intuitionistic in lean then do not import any mathlib modules", which sounds fair enough to me as we have made no attempt whatsoever to correctly document which tactics are intuitionistic (cf broken claims about ifinish which nobody has even bothered to fix). However if there is a single non-intuitionistic simp lemma in core then one interpretation of this is that actually lean 3 is not safe to use <em>at all</em> if you want to be sure you are intuitionistic. This would be a shame for Michael and others who want to use Lean in this way. Of course the converse argument is that one reason for the terrifying growth of mathlib is precisely because we are not held back by issues involving constructivism -- the deep-rooted classical foundations of mathlib have attracted more number theorists, geometers, analysts etc than the other systems.</p>
<p>Of course there is also the other attitude, which given Michael's situation is probably the more pragmatic one, that he simply continues to use lean as he is doing and constantly runs <code>#print axioms</code> to make sure he is not selling his soul to Hilbert.</p>



<a name="224033510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224033510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224033510">(Jan 26 2021 at 12:49)</a>:</h4>
<blockquote>
<p>"if you want to be 100% sure you are intuitionistic in lean then do not import any mathlib modules"</p>
</blockquote>
<p>If you want to be 100% sure you are intuitionistic in lean, a necessary and sufficient condition is to run <code>#print axioms</code></p>



<a name="224033592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224033592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224033592">(Jan 26 2021 at 12:50)</a>:</h4>
<p>it's completely possible to do this while still using mathlib, and it's also possible to screw up when using core lean</p>



<a name="224033674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224033674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224033674">(Jan 26 2021 at 12:51)</a>:</h4>
<p>There is a decent amount of intuitionistic maths in mathlib, it just isn't marked in any way, you need <code>#print axioms</code> to see it</p>



<a name="224033769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224033769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224033769">(Jan 26 2021 at 12:52)</a>:</h4>
<p>It probably wouldn't be too hard to indicate it in docgen, if somehow can show me how to get the result of <code>#print axioms</code> in meta code</p>



<a name="224033794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224033794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224033794">(Jan 26 2021 at 12:52)</a>:</h4>
<p>I'm not saying this is something we need to change</p>



<a name="224033878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224033878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224033878">(Jan 26 2021 at 12:53)</a>:</h4>
<p>It means that we can still have a decent intuitionistic coverage without getting in the way of the 99% of users who don't want to be bothered about it</p>



<a name="224033978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224033978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224033978">(Jan 26 2021 at 12:54)</a>:</h4>
<p>That said, pre-running <code>#print axioms</code> and displaying it in docgen is generally a good idea, that's been a selling point of the metamath web pages since the beginning</p>



<a name="224034025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224034025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224034025">(Jan 26 2021 at 12:55)</a>:</h4>
<p>In principle this is useful to anyone who uses the <code>axiom</code> keyword (and uses doc-gen), not just intuitionist users</p>



<a name="224034066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224034066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224034066">(Jan 26 2021 at 12:55)</a>:</h4>
<p>well, <code>axiom</code> is more or less banned in mathlib, and docgen only works on mathlib AFAIK</p>



<a name="224034143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224034143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224034143">(Jan 26 2021 at 12:56)</a>:</h4>
<p>I made docgen work on my own project with only a few lines of hacks in a shell script: <a href="https://github.com/pygae/lean-ga/blob/3027ba22a5698d0d2a9e4f497399a55027704aa9/.github/workflows/lean_doc.yml#L71-L73">https://github.com/pygae/lean-ga/blob/3027ba22a5698d0d2a9e4f497399a55027704aa9/.github/workflows/lean_doc.yml#L71-L73</a></p>



<a name="224034220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224034220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224034220">(Jan 26 2021 at 12:57)</a>:</h4>
<p>In third party projects I can definitely see the use, it means that people can see whether you've used extra axioms in your big theorem without having to boot up lean</p>



<a name="224040672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224040672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224040672">(Jan 26 2021 at 13:50)</a>:</h4>
<p>How hard would it be to put a # directive in Lean which causes any proof to fail which uses a specific axiom, so</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">#</span><span class="n">prohibit</span> <span class="n">classical.choice</span>
</code></pre></div>
<p>This seems like an easy hack. Then it wouldn't matter if a use was buried, the proof would just fail when it got to that use, and then you could rework the proof.  You wouldn't have to introspect so much on what is buried in the tactics and pre-existing proofs.</p>
<p>An alternate approach would be to axiomatize multiple logics and try to factor out more the underlying axiomatic system.  For example, you could have system <code>I</code> (intuitionist), system <code>C</code> (classical) and system <code>Q</code> (whatever <a href="https://en.wikipedia.org/wiki/Q0_(mathematical_logic)">that</a> is) and modal logics and temporal logics and so on.  I would have thought that could just be done inside the <code>class</code> mechanism.   However I guess there is some meta glue surrounding the process of proof checking such that the system of logic used is somewhat hard-wired.  Is Lean 4 more flexible in this regard?</p>



<a name="224040988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224040988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224040988">(Jan 26 2021 at 13:52)</a>:</h4>
<p>Like I said, lean isn't cut out for this. It's not a logical foundation; the baseline axioms are already way stronger than most systems logicians care to study</p>



<a name="224041038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224041038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224041038">(Jan 26 2021 at 13:52)</a>:</h4>
<p>Lean 4 is actually less flexible in this regard</p>



<a name="224041260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224041260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224041260">(Jan 26 2021 at 13:54)</a>:</h4>
<p>Shouldn't we have a new documentation page and a new Zulip magic url so that you can stop repeating all this over and over? I'm pretty sure you could enjoy doing something else.</p>



<a name="224041319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224041319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224041319">(Jan 26 2021 at 13:55)</a>:</h4>
<p>Lean 2 seriously entertained the possibility of alternate "settings" for the foundations, such as HoTT; lean 3 has a few vestigial remnants of this but is basically just one specific DTT foundation; and lean 4 is doubling down on this approach because mathlib has made the interest in this approach even less attractive</p>



<a name="224041539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224041539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224041539">(Jan 26 2021 at 13:56)</a>:</h4>
<p>Will this scare off the computer scientists? Or are they expected to just #print axioms?</p>



<a name="224041615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224041615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224041615">(Jan 26 2021 at 13:57)</a>:</h4>
<p>Maybe they actually run code or something? So I guess they notice then</p>



<a name="224041618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224041618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224041618">(Jan 26 2021 at 13:57)</a>:</h4>
<p>I'm not sure most computer scientists care about intuitionism</p>



<a name="224041682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224041682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224041682">(Jan 26 2021 at 13:57)</a>:</h4>
<p>Certainly the kind of mathematics you see in algorithms classes is completely classical</p>



<a name="224041853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224041853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224041853">(Jan 26 2021 at 13:59)</a>:</h4>
<p>it's just this one type theory offshoot community that cares about MLTT and its extensions that latch on to this particular notion of intuitionism</p>



<a name="224041882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224041882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224041882">(Jan 26 2021 at 13:59)</a>:</h4>
<p>Am I right in thinking that one motivation behind "running proofs" is that you can extract a witness of existentials computably?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="bp">*</span><span class="n">x</span> <span class="bp">=</span> <span class="mi">4</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">2</span><span class="o">,</span> <span class="kd">by</span> <span class="n">norm_num</span><span class="o">⟩</span>

<span class="k">#reduce</span> <span class="n">foo</span>  <span class="c1">-- prints a term which involves `2`</span>
</code></pre></div>
<p>Is there a way of doing this without either <code>classical</code> or <code>#reduce</code>, to get the result in a <code>def</code>?</p>



<a name="224041920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224041920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224041920">(Jan 26 2021 at 13:59)</a>:</h4>
<p>Yeah, just use <code>{x // x*x = 4}</code> instead</p>



<a name="224042012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224042012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224042012">(Jan 26 2021 at 14:00)</a>:</h4>
<p>basically in lean you decide upfront whether you care about the witness or not</p>



<a name="224042237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224042237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224042237">(Jan 26 2021 at 14:01)</a>:</h4>
<p>Yeah, I understand that's a bad way to write it, I'm just asking out of curiousity.<br>
I assume then there's no builtin computable <code>get_witness h</code> that requires <code>h</code> to be constructively proven?</p>



<a name="224042307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224042307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224042307">(Jan 26 2021 at 14:02)</a>:</h4>
<p>I guess that would violate proof irrelevance</p>



<a name="224042499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224042499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224042499">(Jan 26 2021 at 14:03)</a>:</h4>
<p>No, I'm answering your question</p>



<a name="224042591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224042591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224042591">(Jan 26 2021 at 14:04)</a>:</h4>
<p>If you want to get the value without <code>classical</code> or <code>#reduce</code>, you make the lemma data-carrying by using <code>subtype</code> in place of <code>Exists</code></p>



<a name="224042646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224042646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224042646">(Jan 26 2021 at 14:04)</a>:</h4>
<p>Yeah, that was the model I already had in my head</p>



<a name="224042660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224042660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224042660">(Jan 26 2021 at 14:04)</a>:</h4>
<p><code>get_witness</code> would be inconsistent</p>



<a name="224042709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224042709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224042709">(Jan 26 2021 at 14:05)</a>:</h4>
<p>that's basically <code>classical.choice</code> but it doesn't have the properties of a function</p>



<a name="224043128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224043128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224043128">(Jan 26 2021 at 14:08)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">get_witness</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span>
<span class="kd">axiom</span> <span class="n">get_witness_ex</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">get_witness</span> <span class="n">p</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="bp">=</span> <span class="n">x</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:=</span> <span class="n">get_witness_ex</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="n">tt</span> <span class="n">trivial</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:=</span> <span class="n">get_witness_ex</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="n">ff</span> <span class="n">trivial</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">bool.ff_ne_tt</span> <span class="o">(</span><span class="n">h2.symm.trans</span> <span class="n">h1</span><span class="o">)</span>
<span class="kd">end</span>
</code></pre></div>



<a name="224043387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224043387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224043387">(Jan 26 2021 at 14:10)</a>:</h4>
<p>I was thinking something like <a href="https://leanprover-community.github.io/mathlib_docs/find/quotient.unquot">docs#quotient.unquot</a> could exist, which works only in the vm</p>



<a name="224043456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224043456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224043456">(Jan 26 2021 at 14:10)</a>:</h4>
<p>Yeah, what I wrote could be implemented computably in the same way as <code>quotient.unquot</code>, although it would require propositions to carry data in the VM</p>



<a name="224043469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224043469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224043469">(Jan 26 2021 at 14:10)</a>:</h4>
<p>however it's inconsistent</p>



<a name="224043489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224043489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224043489">(Jan 26 2021 at 14:11)</a>:</h4>
<p>just like <code>quotient.unquot</code></p>



<a name="224043685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224043685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224043685">(Jan 26 2021 at 14:12)</a>:</h4>
<p>The way compilation works, a proof of <code>exists x, p x</code> is represented as <code>()</code>, i.e. nothing at all, meaning that a <code>get_witness</code> function in the VM would have nowhere to get the data</p>



<a name="224044251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224044251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224044251">(Jan 26 2021 at 14:16)</a>:</h4>
<p>So in a sense, the way to do constructive logic safely in lean is to use <code>trunc (subtype p)</code> (<a href="https://leanprover-community.github.io/mathlib_docs/find/trunc">docs#trunc</a>) instead of <code>Exists p</code>, and something similar for disjunctions? Then you know your proofs are intuitionist because if they weren't you'd need <code>noncomputable</code>?</p>



<a name="224045141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224045141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224045141">(Jan 26 2021 at 14:22)</a>:</h4>
<p>I think it's seriously difficult to build a good formalized math library which supports both classical and constructive logic well; more difficult than just writing two independent libraries.</p>



<a name="224050312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224050312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224050312">(Jan 26 2021 at 14:57)</a>:</h4>
<p>If it's a single offending axiom (LEM), I don't get from this discussion why you can't just add a flag to throw an error when that axiom is invoked.  This is a simple solution, why wouldn't it be adequate?  The main complaint here is that <code>classical.choice</code> was invoked inadvertently.   It seems easy to flag, and doesn't require a large rethink of the design.</p>



<a name="224054078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224054078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224054078">(Jan 26 2021 at 15:22)</a>:</h4>
<p>Well the obvious way to get an error on all uses of an axiom is to delete the axiom</p>



<a name="224054158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224054158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224054158">(Jan 26 2021 at 15:23)</a>:</h4>
<p>if you completely don't want it then it shouldn't be in the environment</p>



<a name="224054258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224054258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224054258">(Jan 26 2021 at 15:23)</a>:</h4>
<p><span class="user-mention" data-user-id="364351">@Lars Ericson</span> How do you know if you've touched that "one axiom"? It's not always clear that it's invoked. For reference, there was this cool thread <a href="#narrow/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound</a><br>
where there are many ways to prove <code>em</code>.</p>



<a name="224056299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224056299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224056299">(Jan 26 2021 at 15:37)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> , the advice so far has been to <code>#print axioms notnotLEM </code> and if it doesn't print <code>classical.choice</code>, then you're blessed as intuitionist.  So either that advice is wrong, or there is a fairly simple mechanism (whatever function/store accumulates results for <code>#print axioms</code> to inspect) which you can stick an exception/breakpoint into whenever it tries to add <code>classical.choice</code> to it's store.</p>
<p>Or the advice is wrong.  But the claim above is that you know you've touched that one axiom <code>classical.choice</code> based on the <code>#print</code>.</p>
<p>I'm assuming here also that for the proof checking mechanism, there is a list of axioms which is explicitly declared in the same sense that we declare properties in type classes.   If it's not so explicit, i.e. if it's a bunch of C++ code under the hood that encodes the axioms by hand, then that's a different story.</p>



<a name="224057773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224057773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224057773">(Jan 26 2021 at 15:46)</a>:</h4>
<blockquote>
<p>whatever function/store accumulates results for #print axioms to inspect</p>
</blockquote>
<p>There is no such store. When you use <code>#print axioms</code> it traverses the entire proof, and the entire proof of all referenced theorems and so on recursively, until it finds uses of <code>axiom</code> constants.</p>



<a name="224058500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224058500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224058500">(Jan 26 2021 at 15:50)</a>:</h4>
<blockquote>
<p>I'm assuming here also that for the proof checking mechanism, there is a list of axioms which is explicitly declared in the same sense that we declare properties in type classes. If it's not so explicit, i.e. if it's a bunch of C++ code under the hood that encodes the axioms by hand, then that's a different story.</p>
</blockquote>
<p>Lean actually has both kinds of axiom. The kind that <code>#print axioms</code> picks up are those that were introduced with actual <code>axiom</code> invocations in the source. But there are other constants like <code>nat.rec</code> and <code>quot.mk</code> and definitional equality axioms like proof irrelevance and a countable hierarchy of universes that are built in to the C++, cannot be turned off, and do not show up in <code>#print axioms</code>. These are the "no axioms" axioms, and it's impossible to meaningfully do proofs with a subset of these axioms.</p>



<a name="224094059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224094059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224094059">(Jan 26 2021 at 19:59)</a>:</h4>
<p>Be that all as it may, if the project were to implement system <a href="https://en.wikipedia.org/wiki/Q0_(mathematical_logic)">Q</a> as a <code>class</code> and prove theorems either in or about <code>Q</code>, without straying from the bounds of <code>Q</code>, is that doable in Lean?</p>
<p>In other words, just as much as a <code>topology</code> or a <code>lattice</code> is a mathematical structure, something like <code>Q</code> is a mathematical structure, so what are the limits to reasoning about or in <code>Q</code> versus say the limits of reasoning about a topology or lattice?</p>
<p>I hope the question isn't too fuzzy, it's a bit fuzzy in my mind, but you get the idea.</p>



<a name="224115557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224115557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224115557">(Jan 26 2021 at 22:42)</a>:</h4>
<p>A model I've had in mind, but I'm not sure how accurate it is, is that if you want to be as constructive as possible then you should avoid <code>Prop</code> entirely.   Is this more or less a reasonable model?</p>
<p>Something I've never been quite sure about with intuitionism is what the scope is of what needs to be constructible.  At a basic level, you can give a computation for an object and in that sense the object exists, but is it generally accepted that every aspect of the proof that this is the right object needs to be constructible as well? or is that a more of an extreme position?</p>
<p>I like Lean's pragmatic approach where so long as a definition isn't <code>noncomputable</code> then that implies there's a construction.  It just might use not-incorrect inferences along the way.  I guess it seems meaningful to me having computable definitions (even if I'm never going to evaluate them), but avoiding choice in proofs seems more like a curiosity unless reverse mathematics is your specialty.</p>



<a name="224139749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224139749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224139749">(Jan 27 2021 at 04:42)</a>:</h4>
<p>Just for the record,   my files do not import mathlib  and I knew that I could not expect mathlib to be intuitionistic. <br>
I only have  import tactic.basic.      I had a mistaken idea about the behavior of those tactics.   I did not intend to be <br>
"complaining"   (especially not that "my car is not a boat");  I'm grateful that Lean exists and I'm appreciative of the <br>
work that has been done on it.   When I asked if there was something I could/should have read to avoid my mistaken idea,<br>
I did not mean to complain,  I just wanted to know if these things are written down somewhere.   The last thing I intended<br>
was to annoy anyone.  Thanks to all of you who have considered this issue.</p>



<a name="224142869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224142869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224142869">(Jan 27 2021 at 05:46)</a>:</h4>
<p>We should keep an open mind.<br>
<a href="/user_uploads/3121/roMe2wxp6QLsrveIqW72xiaU/BN-KK363_0922my_M_20150921164148.jpg">BN-KK363_0922my_M_20150921164148.jpg</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/roMe2wxp6QLsrveIqW72xiaU/BN-KK363_0922my_M_20150921164148.jpg" title="BN-KK363_0922my_M_20150921164148.jpg"><img src="/user_uploads/3121/roMe2wxp6QLsrveIqW72xiaU/BN-KK363_0922my_M_20150921164148.jpg"></a></div>



<a name="224228848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224228848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224228848">(Jan 27 2021 at 18:47)</a>:</h4>
<p>OK,  I still want to make sure my proofs are intuitionistic.   I seem to have two options.</p>
<ol>
<li>
<p>continue to import tactic.basic,   but avoid simp, simp_rw,  and ifinish,   and check which axioms are used to make sure classical choice isn't.</p>
</li>
<li>
<p>remove import tactic.basic from all my files.</p>
</li>
</ol>
<p>Questions:   <br>
Q1:   with option 2  is it correct that my proofs will all pass through an intuitionistic kernel  and it won't be necessary to "check axioms"? <br>
And,  if that is the case,  </p>
<p>Q2:   I will still need to eliminate the need for tactic  'use'  to  call exists.intro from tactic mode and leave a goal still to solve, since<br>
'use'  is defined in tactic.basic.  </p>
<p>Is that easy or hard?   </p>
<p>and <br>
Q3:  with option 1, i.e.  check axioms,   how airtight is the guarantee that the proof is intuitionistically correct?   I guess it does not quite<br>
have the certainty of passing through the kernel?   I am intending to publish  a proof,  and naturally I wish to be CERTAIN that it is <br>
correct--that is why I am using Lean in the first place.</p>



<a name="224229761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224229761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224229761">(Jan 27 2021 at 18:52)</a>:</h4>
<p>I think that the conclusion of the discussion above is that 2. is not going to solve your problems. LEM is defined as an axiom in core Lean, and this axiom cannot be overridden or removed. Having thought about this over the last few days, I personally think that the easiest path is simple: import tactic.basic, import what the heck you like. You can't make LEM go away, and nobody is able to <em>guarantee</em> that it won't randomly appear when you use a tactic like <code>simp</code> or even, unfortunately, <code>ifinish</code>. However I believe we _can_ guarantee that <code>#print axioms</code> will report on usage of nonintuitionistic things if it finds them. Apparently it's difficult to even get Lean to automatically check that no axioms are used automatically. But this kind of question can be solved. So in fact my instinct would be to continue to use both mathlib and the dubious tactics, and just keep checking that your proofs are intuitionistic. If they're not, then rewrite until they are.</p>



<a name="224230226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224230226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224230226">(Jan 27 2021 at 18:55)</a>:</h4>
<p>And be aware that the fact your proofs are intuitionistic today will not guarantee that they still are after updating lean / mathlib, as the simp set may have changed</p>



<a name="224230927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224230927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224230927">(Jan 27 2021 at 18:59)</a>:</h4>
<p>I know that Patrick was keen on just nuking <code>ifinish</code>, because it is dishonest to have a tactic which claims to do something that it does not do, and the user has to explicitly check that it did its job every time. Is there an example known where <code>finish</code> produces a non-intuitionistic proof and <code>ifinish</code>produces an axiom-free one?</p>



<a name="224233828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224233828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224233828">(Jan 27 2021 at 19:19)</a>:</h4>
<p>Is it possible to create <code>itheorem</code> which will error if the proof uses axioms?</p>



<a name="224240177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224240177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224240177">(Jan 27 2021 at 20:08)</a>:</h4>
<p><code>itheorem</code> is hard because it is a <code>def</code>-variant command, which means that you have to replicate all the parsing stuff that <code>def</code> does</p>



<a name="224240220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224240220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224240220">(Jan 27 2021 at 20:08)</a>:</h4>
<p>Maybe an attribute can do something similar though</p>



<a name="224362808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224362808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224362808">(Jan 28 2021 at 17:33)</a>:</h4>
<p>Here is a small MWE  on which checking axioms produces output  I cannot interpret.  What is going on here?   Is there an <br>
error in my Lean code?   The example<br>
begins with "import barton".   The contents of barton.lean will be pasted in below.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">barton</span>
<span class="kd">reserve</span> <span class="kd">infix</span> <span class="bp">`</span> <span class="bp">∈</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">49</span>

<span class="kd">class</span>  <span class="n">Model</span> <span class="o">(</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mem</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="kd">infix</span>  <span class="bp">∈</span> <span class="o">:=</span>  <span class="n">mem</span> <span class="o">)</span>
<span class="o">(</span><span class="n">union</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">union_axiom</span><span class="o">:</span>   <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">:</span><span class="n">M</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">union</span> <span class="n">y</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">z</span><span class="o">:</span><span class="n">M</span><span class="o">),</span> <span class="o">(</span><span class="n">z</span> <span class="bp">∈</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">z</span><span class="o">)))</span>
 <span class="c">/-</span><span class="cm"> end of class definition because next line doesn't declare a member -/</span>

 <span class="bp">#</span><span class="n">axioms_all</span>
</code></pre></div>
<p>Here is barton.lean </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.core</span>

<span class="kn">section</span>

<span class="kn">open</span> <span class="n">lean</span> <span class="n">lean.parser</span>

<span class="kd">@[user_command]</span> <span class="kd">meta</span> <span class="kd">def</span> <span class="n">axioms_all</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">interactive.parse</span> <span class="bp">$</span> <span class="n">tk</span> <span class="s2">"#axioms_all"</span><span class="o">)</span> <span class="o">:</span> <span class="n">parser</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">e</span> <span class="bp">←</span> <span class="n">get_env</span><span class="o">,</span>
   <span class="n">e.fold</span> <span class="o">(</span><span class="n">return</span> <span class="o">())</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">d</span> <span class="n">rest</span><span class="o">,</span> <span class="k">do</span>
     <span class="n">when</span> <span class="o">(</span><span class="n">e.in_current_file</span> <span class="n">d.to_name</span><span class="o">)</span>
       <span class="o">(</span><span class="k">do</span> <span class="n">emit_command_here</span> <span class="o">(</span><span class="s2">"#check "</span> <span class="bp">++</span> <span class="n">d.to_name.to_string</span><span class="o">),</span>
           <span class="n">emit_command_here</span> <span class="o">(</span><span class="s2">"#print axioms "</span> <span class="bp">++</span> <span class="n">d.to_name.to_string</span><span class="o">),</span>
           <span class="n">return</span> <span class="o">()),</span>
     <span class="n">rest</span><span class="o">),</span>
   <span class="n">return</span> <span class="o">()</span>

<span class="kd">end</span>
</code></pre></div>



<a name="224362950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224362950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224362950">(Jan 28 2021 at 17:34)</a>:</h4>
<p>Does putting a full stop after the definition of the class help?</p>



<a name="224363091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224363091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224363091">(Jan 28 2021 at 17:35)</a>:</h4>
<p>No,  output does not change with a full stop.</p>



<a name="224363811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224363811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224363811">(Jan 28 2021 at 17:40)</a>:</h4>
<p>What is the output?</p>



<a name="224364047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224364047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224364047">(Jan 28 2021 at 17:41)</a>:</h4>
<p>I get four infos and an error on the <code>#axioms_all</code> line:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">info</span><span class="o">:</span>
<span class="n">Model.cases_on</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Model</span> <span class="bp">?</span><span class="n">M_1</span><span class="o">),</span>
    <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">mem</span> <span class="o">:</span> <span class="bp">?</span><span class="n">M_1</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">M_1</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">union</span> <span class="o">:</span> <span class="bp">?</span><span class="n">M_1</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">M_1</span><span class="o">)</span>
     <span class="o">(</span><span class="n">union_axiom</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">?</span><span class="n">M_1</span><span class="o">),</span> <span class="n">mem</span> <span class="n">x</span> <span class="o">(</span><span class="n">union</span> <span class="n">y</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="bp">?</span><span class="n">M_1</span><span class="o">),</span> <span class="n">mem</span> <span class="n">z</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">mem</span> <span class="n">x</span> <span class="n">z</span><span class="o">),</span>
       <span class="bp">?</span><span class="n">M_2</span> <span class="o">{</span><span class="n">mem</span> <span class="o">:=</span> <span class="n">mem</span><span class="o">,</span> <span class="n">union</span> <span class="o">:=</span> <span class="n">union</span><span class="o">,</span> <span class="n">union_axiom</span> <span class="o">:=</span> <span class="n">union_axiom</span><span class="o">})</span> <span class="bp">→</span>
    <span class="bp">?</span><span class="n">M_2</span> <span class="n">n</span>

<span class="n">info</span><span class="o">:</span>
<span class="n">no</span> <span class="kd">axioms</span>

<span class="n">info</span><span class="o">:</span>
<span class="n">Model.union_axiom</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">?</span><span class="n">M_1</span><span class="o">),</span> <span class="n">Model.mem</span> <span class="n">x</span> <span class="o">(</span><span class="n">Model.union</span> <span class="n">y</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="bp">?</span><span class="n">M_1</span><span class="o">),</span> <span class="n">Model.mem</span> <span class="n">z</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">Model.mem</span> <span class="n">x</span> <span class="n">z</span>

<span class="n">info</span><span class="o">:</span>
<span class="n">no</span> <span class="kd">axioms</span>

<span class="n">error</span><span class="o">:</span>
<span class="n">invalid</span> <span class="bp">'</span><span class="n">Model.no_confusion'</span> <span class="n">application</span><span class="o">,</span> <span class="n">elaborator</span> <span class="n">has</span> <span class="n">special</span> <span class="n">support</span> <span class="n">for</span> <span class="n">no_confusion</span>
<span class="n">but</span> <span class="n">the</span> <span class="n">expected</span> <span class="n">type</span> <span class="n">must</span> <span class="n">be</span> <span class="n">known</span>
</code></pre></div>



<a name="224364841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224364841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224364841">(Jan 28 2021 at 17:45)</a>:</h4>
<p>I guess it emits <code>#check Model.no_confusion</code>, which isn't a valid application</p>



<a name="224364869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224364869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224364869">(Jan 28 2021 at 17:45)</a>:</h4>
<p>right, you need</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>           <span class="n">emit_command_here</span> <span class="o">(</span><span class="s2">"#check @"</span> <span class="bp">++</span> <span class="n">d.to_name.to_string</span><span class="o">),</span>
</code></pre></div>



<a name="224364944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224364944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224364944">(Jan 28 2021 at 17:46)</a>:</h4>
<p>While we're on this topic, does <code>#check @@f</code> ever give a different result to <code>#check @f</code>?</p>



<a name="224365077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224365077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224365077">(Jan 28 2021 at 17:46)</a>:</h4>
<p>Answer: yes, <code>@@mul_assoc</code> is an example</p>



<a name="224365095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224365095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224365095">(Jan 28 2021 at 17:46)</a>:</h4>
<p>also <code>@@list.rec</code></p>



<a name="224365180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224365180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224365180">(Jan 28 2021 at 17:47)</a>:</h4>
<p>Perhaps <code>@@</code> is actually a good idea here to avoid noise while avoiding the error caused by no <code>@</code>?</p>



<a name="224365268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224365268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224365268">(Jan 28 2021 at 17:48)</a>:</h4>
<p>No, I think it's best to avoid metavariable insertion since that could cause unexpected elaboration errors</p>



<a name="224365367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224365367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224365367">(Jan 28 2021 at 17:48)</a>:</h4>
<p>You could use <code>#print decl</code> instead but that shows the whole function definition too</p>



<a name="224365430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224365430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224365430">(Jan 28 2021 at 17:48)</a>:</h4>
<p>probably just <code>trace decl</code> is sufficient</p>



<a name="224365749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224365749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224365749">(Jan 28 2021 at 17:51)</a>:</h4>
<p>or rather <code>emit_command_here ("#eval tactic.trace `" ++ d.to_name.to_string)</code> since otherwise it isn't sequenced properly with the <code>#print axioms</code></p>



<a name="224366490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224366490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224366490">(Jan 28 2021 at 17:56)</a>:</h4>
<p>Thank you Mario,  once again you have made my day.   One little @ sign seems to get rid of the red ink.</p>



<a name="224366494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224366494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224366494">(Jan 28 2021 at 17:56)</a>:</h4>
<p>Here's another version of that command with these adjustments:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[user_command]</span> <span class="kd">meta</span> <span class="kd">def</span> <span class="n">axioms_all</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">interactive.parse</span> <span class="bp">$</span> <span class="n">tk</span> <span class="s2">"#axioms_all"</span><span class="o">)</span> <span class="o">:</span> <span class="n">parser</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">info</span> <span class="bp">←</span> <span class="n">option.is_some</span> <span class="bp">&lt;$&gt;</span> <span class="n">optional</span> <span class="o">(</span><span class="n">tk</span> <span class="s2">"?"</span><span class="o">),</span>
  <span class="n">e</span> <span class="bp">←</span> <span class="n">get_env</span><span class="o">,</span>
  <span class="n">e.fold</span> <span class="o">(</span><span class="n">return</span> <span class="o">())</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">d</span> <span class="n">rest</span><span class="o">,</span> <span class="k">do</span>
    <span class="n">when</span> <span class="o">(</span><span class="n">e.in_current_file</span> <span class="n">d.to_name</span><span class="o">)</span> <span class="o">(</span><span class="k">do</span>
      <span class="n">when</span> <span class="n">info</span> <span class="bp">$</span> <span class="n">emit_command_here</span> <span class="o">(</span><span class="s2">"#eval tactic.trace `"</span> <span class="bp">++</span> <span class="n">d.to_name.to_string</span><span class="o">)</span> <span class="bp">$&gt;</span> <span class="o">(),</span>
      <span class="n">emit_command_here</span> <span class="o">(</span><span class="s2">"#print axioms "</span> <span class="bp">++</span> <span class="n">d.to_name.to_string</span><span class="o">)</span> <span class="bp">$&gt;</span> <span class="o">()),</span>
    <span class="n">rest</span><span class="o">)</span>
</code></pre></div>



<a name="224366639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224366639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224366639">(Jan 28 2021 at 17:57)</a>:</h4>
<p>You can use <code>#axioms_all</code> and it will not print the names of things, but it should be easy to scan for the odd one out in a sea of <code>no axioms</code>. If you use <code>#axioms_all?</code> it will print the names of declarations so you can go find the offender</p>



<a name="224366902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224366902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224366902">(Jan 28 2021 at 17:59)</a>:</h4>
<p>Unfortunately <code>#print axioms</code> does not provide its information via tactics so it still requires some eyeball work</p>



<a name="224366990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224366990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224366990">(Jan 28 2021 at 18:00)</a>:</h4>
<p>Is there no way to run a command and capture the trace messages?</p>



<a name="224367006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224367006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224367006">(Jan 28 2021 at 18:00)</a>:</h4>
<p>not that I know of</p>



<a name="224367126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224367126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224367126">(Jan 28 2021 at 18:01)</a>:</h4>
<p>It shouldn't be hard to make a hook for this in lean C++</p>



<a name="224367147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224367147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224367147">(Jan 28 2021 at 18:01)</a>:</h4>
<p>Can you do something dumb like vm_override trace?</p>



<a name="224367281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224367281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224367281">(Jan 28 2021 at 18:02)</a>:</h4>
<p><code>#print axioms</code> is a bit of an unusual case because it predates a lot of the tactic framework. It just writes straight to the editor, lean never sees anything</p>



<a name="224367303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224367303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224367303">(Jan 28 2021 at 18:02)</a>:</h4>
<p>trace isn't called, this is 100% C++ code</p>



<a name="224367488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224367488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224367488">(Jan 28 2021 at 18:03)</a>:</h4>
<p>the hook I'm referring to is something like <code>constant tactic.get_axioms_used : name -&gt; tactic (list name)</code></p>



<a name="224368113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224368113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224368113">(Jan 28 2021 at 18:08)</a>:</h4>
<p>#axioms_all?   (with question mark)  produces great output,  I'm happy with that.   <br>
Without the question mark it just prints  "no axioms"  or "propext"  or occasionally "quot.sound";  so I guess<br>
if I do not say any occurrence of "choice"  I'm good to go without a question mark.   The plan is to do leanproject build and <br>
grep the output for "choice".</p>



<a name="224368156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224368156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224368156">(Jan 28 2021 at 18:08)</a>:</h4>
<p>yeah, that's the idea</p>



<a name="224368207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224368207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224368207">(Jan 28 2021 at 18:09)</a>:</h4>
<p>That was working fine before you improved the code, except on the file containing the class definition.   Now that works too, thanks.</p>



<a name="224368272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224368272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224368272">(Jan 28 2021 at 18:09)</a>:</h4>
<p>I suppose with the other version you might get in trouble if you happen to have a declaration called <code>choice</code> something</p>



<a name="224368355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224368355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224368355">(Jan 28 2021 at 18:10)</a>:</h4>
<p>I don't have any such declaration so that's not a problem.</p>



<a name="224368391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224368391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224368391">(Jan 28 2021 at 18:10)</a>:</h4>
<p>I wonder why quot.sound pops up now and then.  I don't have any explicit quotient types.</p>



<a name="224368423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224368423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224368423">(Jan 28 2021 at 18:10)</a>:</h4>
<p>If you use <code>funext</code> then quot.sound will get involved</p>



<a name="224372208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224372208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224372208">(Jan 28 2021 at 18:37)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">environment.is_builtin</span> <span class="o">(</span><span class="n">env</span> <span class="o">:</span> <span class="n">environment</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span>
<span class="n">env.is_inductive</span> <span class="n">n</span> <span class="bp">||</span> <span class="n">env.is_recursor</span> <span class="n">n</span> <span class="bp">||</span> <span class="n">env.is_constructor</span> <span class="n">n</span> <span class="bp">||</span>
<span class="n">to_bool</span> <span class="o">(</span><span class="n">n</span> <span class="bp">∈</span> <span class="o">[</span><span class="bp">``</span><span class="n">quot</span><span class="o">,</span> <span class="bp">``</span><span class="n">quot.lift</span><span class="o">,</span> <span class="bp">``</span><span class="n">quot.ind</span><span class="o">,</span> <span class="bp">``</span><span class="n">quot.mk</span><span class="o">])</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.get_axioms_used_aux</span> <span class="o">(</span><span class="n">env</span> <span class="o">:</span> <span class="n">environment</span><span class="o">)</span> <span class="o">:</span> <span class="n">name</span> <span class="bp">→</span>
  <span class="n">list</span> <span class="n">name</span> <span class="bp">×</span> <span class="n">name_set</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">list</span> <span class="n">name</span> <span class="bp">×</span> <span class="n">name_set</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">p</span><span class="bp">@</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">ns</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">ns.contains</span> <span class="n">n</span> <span class="k">then</span> <span class="n">pure</span> <span class="n">p</span> <span class="k">else</span> <span class="k">do</span>
  <span class="n">d</span> <span class="bp">←</span> <span class="n">env.get</span> <span class="n">n</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">ns</span> <span class="o">:=</span> <span class="n">ns.insert</span> <span class="n">n</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">process</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">list</span> <span class="n">name</span> <span class="bp">×</span> <span class="n">name_set</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="k">do</span>
    <span class="n">v.fold</span> <span class="o">(</span><span class="n">pure</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">ns</span><span class="o">))</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">e</span> <span class="n">_</span> <span class="n">r</span><span class="o">,</span> <span class="n">r</span> <span class="bp">&gt;&gt;=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span>
      <span class="k">if</span> <span class="n">e.is_constant</span> <span class="k">then</span> <span class="n">tactic.get_axioms_used_aux</span> <span class="n">e.const_name</span> <span class="n">p</span> <span class="k">else</span> <span class="n">pure</span> <span class="n">p</span><span class="o">),</span>
  <span class="k">match</span> <span class="n">d</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">declaration.defn</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">v</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">process</span> <span class="n">v</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">declaration.thm</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">v</span><span class="o">)</span>      <span class="o">:=</span> <span class="n">process</span> <span class="n">v.get</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">pure</span> <span class="bp">$</span> <span class="k">if</span> <span class="n">env.is_builtin</span> <span class="n">n</span> <span class="k">then</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">ns</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">n</span><span class="o">::</span><span class="n">l</span><span class="o">,</span> <span class="n">ns</span><span class="o">)</span>
  <span class="kd">end</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.get_axioms_used</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">list</span> <span class="n">name</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">env</span> <span class="bp">←</span> <span class="n">tactic.get_env</span><span class="o">,</span>
  <span class="n">prod.fst</span> <span class="bp">&lt;$&gt;</span> <span class="n">tactic.get_axioms_used_aux</span> <span class="n">env</span> <span class="n">n</span> <span class="o">([],</span> <span class="n">mk_name_set</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">tactic.get_axioms_used</span> <span class="bp">`</span><span class="n">classical.em</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic.trace</span>
<span class="c1">-- [propext, quot.sound, classical.choice]</span>
</code></pre></div>



<a name="224372999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224372999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224372999">(Jan 28 2021 at 18:43)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[user_attribute]</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">intuit_attr</span> <span class="o">:</span> <span class="n">user_attribute</span> <span class="n">unit</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">name</span>   <span class="o">:=</span> <span class="bp">`</span><span class="n">intuit</span><span class="o">,</span>
  <span class="n">descr</span>  <span class="o">:=</span> <span class="s2">"intuit"</span><span class="o">,</span>
  <span class="n">after_set</span> <span class="o">:=</span> <span class="n">some</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">n</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="k">do</span>
    <span class="n">l</span> <span class="bp">←</span> <span class="n">tactic.get_axioms_used</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">guard</span> <span class="o">(</span><span class="bp">``</span><span class="n">classical.choice</span> <span class="bp">∉</span> <span class="n">l</span><span class="o">)</span> <span class="bp">&lt;|&gt;</span>
    <span class="n">tactic.fail</span> <span class="s2">"ERROR: classical axioms used"</span> <span class="o">}</span>

<span class="kd">@[intuit]</span> <span class="kd">theorem</span> <span class="n">bad</span> <span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="c1">-- fail</span>
<span class="kd">by</span> <span class="n">by_cases</span> <span class="n">p</span><span class="bp">;</span> <span class="n">simp</span>

<span class="kd">@[intuit]</span> <span class="kd">theorem</span> <span class="n">good</span> <span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="c1">-- ok</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="k">have</span> <span class="bp">¬</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">h.1</span> <span class="n">i</span> <span class="n">i</span><span class="o">,</span> <span class="n">this</span> <span class="o">(</span><span class="n">h.2</span> <span class="n">this</span><span class="o">)</span>
</code></pre></div>



<a name="224377901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224377901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224377901">(Jan 28 2021 at 19:15)</a>:</h4>
<p>I'm not sure about the attribute, but those meta defs look worth PRing to me</p>



<a name="224378161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224378161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224378161">(Jan 28 2021 at 19:17)</a>:</h4>
<p>If I understand this correctly,  here is how I should use it:  import the code and then tag all my theorems with @[intuit].<br>
Is that right?</p>



<a name="224527060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224527060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224527060">(Jan 29 2021 at 20:14)</a>:</h4>
<p>Here's a MWE.   In this case it is really a working example,  instead of a non-working example.  My question is this:  I first wrote it with <br>
[M:Type]  instead of {M:Type}.   It didn't work.  But this version, with {M},  does work.    Is anybody willing to explain why?  I suppose if I studied the documentation hard enough it would explain the difference between curly brackets and braces,  so I'm hesitant to post, but maybe somebody can tell me easily.  Also:  would there be a way to write it so the final 'simp'  to cause beta-reduction would be already applied?  </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">notnot_forall</span><span class="o">{</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">}:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="o">(</span><span class="bp">¬¬</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">M</span><span class="o">),</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">M</span><span class="o">),</span> <span class="bp">¬¬</span> <span class="n">P</span> <span class="n">x</span><span class="o">:=</span>
  <span class="c1">-- credit: Troestra 344, p. 8</span>
  <span class="k">assume</span> <span class="n">P</span><span class="o">,</span>
  <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">h</span> <span class="n">t</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h2</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h3</span><span class="o">:</span>  <span class="bp">¬</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">M</span><span class="o">),</span> <span class="n">P</span> <span class="n">x</span><span class="o">:=</span>
      <span class="kd">begin</span>
        <span class="n">intro</span> <span class="n">h4</span><span class="o">,</span>
        <span class="n">specialize</span> <span class="n">h4</span> <span class="n">t</span><span class="o">,</span>
        <span class="n">contradiction</span><span class="o">,</span>
      <span class="kd">end</span><span class="o">,</span>
   <span class="n">contradiction</span><span class="o">,</span>
 <span class="kd">end</span>

<span class="kd">reserve</span> <span class="kd">infix</span> <span class="bp">`</span> <span class="bp">∈</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">49</span>

<span class="kd">class</span>  <span class="n">Model</span> <span class="o">(</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mem</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="kd">infix</span>  <span class="bp">∈</span> <span class="o">:=</span>  <span class="n">mem</span> <span class="o">)</span>
<span class="o">(</span><span class="n">union</span><span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">union_axiom</span><span class="o">:</span>   <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">:</span><span class="n">M</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">union</span> <span class="n">y</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">z</span><span class="o">:</span><span class="n">M</span><span class="o">),</span> <span class="o">(</span><span class="n">z</span> <span class="bp">∈</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">z</span><span class="o">)))</span><span class="bp">.</span>
 <span class="c">/-</span><span class="cm"> end of class definition because next line doesn't declare a member -/</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">M</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Model</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">X</span> <span class="n">R</span> <span class="n">W</span><span class="o">:</span> <span class="n">M</span><span class="o">)</span>
<span class="kn">open</span> <span class="n">Model</span>

<span class="kd">lemma</span> <span class="n">test</span><span class="o">:</span> <span class="o">(</span><span class="bp">¬¬</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">M</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">M</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="k">have</span> <span class="n">h</span><span class="o">:=</span> <span class="n">notnot_forall</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">M</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">),</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="kd">end</span>
</code></pre></div>



<a name="224527370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224527370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224527370">(Jan 29 2021 at 20:17)</a>:</h4>
<p>square brackets are only for typeclass arguments</p>



<a name="224527493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224527493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224527493">(Jan 29 2021 at 20:18)</a>:</h4>
<p>Usually type arguments will be in curly braces like <code>{M : Type}</code>, because they are not going to be supplied explicitly in lemmas</p>



<a name="224527596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224527596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224527596">(Jan 29 2021 at 20:19)</a>:</h4>
<p>Since all the variables in your variables line are explicit except for <code>[Model M]</code>, that means that if you use <code>test</code> you will have to write <code>test M h x</code> to apply it (where <code>h</code> is a proof of <code>¬¬ ∀ (x:M), x = x</code>, even though lean can infer <code>M</code> from <code>h</code></p>



<a name="224527813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224527813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224527813">(Jan 29 2021 at 20:21)</a>:</h4>
<p>Yes,  I always supply M explicitly.  If I don't type the variables in my lemmas  then Lean often complains that it cannot synthesize their types so I just got in the habit of typing everything.</p>



<a name="224527932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224527932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224527932">(Jan 29 2021 at 20:22)</a>:</h4>
<p>For the variables like <code>a b x y</code> this is reasonable, but for type variables it's pretty rare that they can't be inferred</p>



<a name="224527959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224527959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224527959">(Jan 29 2021 at 20:22)</a>:</h4>
<p>If you use <code>(M)</code> instead of <code>{M}</code> in <code>notnot_forall</code>, in <code>test</code> you can write <code>have h := notnot_forall _ (λ (x:M), x = x),</code> but <code>have h := notnot_forall (λ (x:M), x = x),</code> won't work. If you use <code>[M:Type]</code>, then it will attempt to use typeclass inference to infer <code>M</code>, which will fail because <code>Type</code> is not a typeclass</p>



<a name="224528124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224528124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224528124">(Jan 29 2021 at 20:24)</a>:</h4>
<p>The standard rule we use in mathlib is that if a variable appears in the types of arguments that come later, then it should be implicit, otherwise it should be explicit</p>



<a name="224528237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224528237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224528237">(Jan 29 2021 at 20:25)</a>:</h4>
<p>so if you have <code>lemma foo (M : Type) (a : M) (h : a = a)</code> then you could make <code>M</code> and <code>a</code> implicit because <code>h</code> contains <code>a</code> in its type and <code>a</code> contains <code>M</code> in its type</p>



<a name="224528278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224528278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224528278">(Jan 29 2021 at 20:25)</a>:</h4>
<p>because the elaborator will be able to pick up the type from the later occurrences?   having temporarily substituted a metavariable that it will then fill in when it encounters the correct type?</p>



<a name="224528365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224528365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224528365">(Jan 29 2021 at 20:26)</a>:</h4>
<p>right, when you apply it with say <code>a</code> being <code>3 : nat</code> it can figure out that <code>M := nat</code></p>



<a name="224528439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224528439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224528439">(Jan 29 2021 at 20:27)</a>:</h4>
<p>Except your example would hit the infamous "a" bug,  as it uses "a" for that metavariable, if I understand things.</p>



<a name="224528457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224528457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224528457">(Jan 29 2021 at 20:27)</a>:</h4>
<p>if you just wrote <code>foo rfl</code> it would have trouble though because <code>rfl</code> doesn't follow this rule of implicitness, it has all arguments implicit. With <code>foo (eq.refl (3:nat))</code> or <code>foo (rfl : 3 = 3)</code> it would work</p>



<a name="224528509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224528509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224528509">(Jan 29 2021 at 20:28)</a>:</h4>
<p>Nah, the a bug is dead and gone</p>



<a name="224528523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224528523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224528523">(Jan 29 2021 at 20:28)</a>:</h4>
<p>long live the alpha-vrachy <code>ᾰ</code> bug</p>



<a name="224528608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224528608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224528608">(Jan 29 2021 at 20:29)</a>:</h4>
<p>OK!</p>



<a name="224528665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224528665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224528665">(Jan 29 2021 at 20:30)</a>:</h4>
<p>How come if I write (M)  I can get away with an underscore?   I don't know how that works.</p>



<a name="224530656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224530656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224530656">(Jan 29 2021 at 20:46)</a>:</h4>
<p>Also:   simp often uses classical choice.  How can I cause beta-reduction  and ONLY beta-reduction?   Similar to #reduce,  but in a tactic.    'simp only'  works at least sometimes,  maybe that is the answer.</p>



<a name="224531788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224531788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224531788">(Jan 29 2021 at 20:53)</a>:</h4>
<p><code>dsimp only</code></p>



<a name="224532364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224532364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224532364">(Jan 29 2021 at 20:58)</a>:</h4>
<p>Looking at the manual for dsimp,  it looks like the "only"  after dsimp  would be superfluous.   Or maybe not.  Anyway thanks,  I did not know about dsimp,  even though it is right there in the manual.</p>



<a name="224532679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224532679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224532679">(Jan 29 2021 at 21:00)</a>:</h4>
<p><code>dsimp</code> without <code>only</code> means <code>dsimp</code> with all definitional simp lemmas</p>



<a name="224532712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224532712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224532712">(Jan 29 2021 at 21:00)</a>:</h4>
<p>those lemmas can't use axioms so it's safe in your case, but it's more than just beta reduction</p>



<a name="224532949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/224532949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#224532949">(Jan 29 2021 at 21:02)</a>:</h4>
<blockquote>
<p>How come if I write (M) I can get away with an underscore? I don't know how that works.</p>
</blockquote>
<p>For the same reason that <code>{M}</code> works. Lean can infer it if you ask it to; you can either signal this on the definition of the function itself using <code>{M}</code>, in which case lean will insert the underscore unless you ask it not to, or you can do it at point of use if the function uses <code>(M)</code> but you have an actual <code>_</code> at the application</p>



<a name="226262179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/226262179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#226262179">(Feb 13 2021 at 19:20)</a>:</h4>
<p>I did leanproject update.    Now I wish I had not,  as it seems that the "broken" tactic  'finish'  has been removed.   But I was still using it.<br>
Many times it DOES produce an intuitionistically correct proof.    I guess now I will really have to eliminate ALL use of it.   Unless there is an <br>
easy way to revert to the previous version?</p>



<a name="226262207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/226262207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#226262207">(Feb 13 2021 at 19:21)</a>:</h4>
<p>You can take the one-line definitions of <code>ifinish</code> etc from old <code>mathlib</code> and copy to your project.</p>



<a name="226262719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/226262719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#226262719">(Feb 13 2021 at 19:34)</a>:</h4>
<p>I tried</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">tactic</span> <span class="n">expr</span>
<span class="kn">namespace</span> <span class="n">auto</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">ifinish</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">simp_lemmas</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">ps</span> <span class="o">:</span> <span class="n">list</span> <span class="n">pexpr</span><span class="o">)</span> <span class="o">(</span><span class="n">cfg</span> <span class="o">:</span> <span class="n">auto_config</span> <span class="o">:=</span> <span class="o">{})</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
  <span class="n">finish</span> <span class="n">s</span> <span class="n">ps</span> <span class="o">{</span><span class="n">classical</span> <span class="o">:=</span> <span class="n">ff</span><span class="o">,</span> <span class="bp">..</span><span class="n">cfg</span><span class="o">}</span>
<span class="kd">end</span> <span class="n">auto</span>
</code></pre></div>
<p>But it produced</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="kd">structure</span> <span class="n">value</span> <span class="o">{</span> <span class="bp">...</span> <span class="o">},</span> <span class="bp">'</span><span class="n">classical'</span> <span class="n">is</span> <span class="n">not</span> <span class="n">a</span> <span class="n">field</span> <span class="n">of</span> <span class="kd">structure</span> <span class="bp">'</span><span class="n">auto.auto_conf</span>
</code></pre></div>



<a name="226263578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/226263578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#226263578">(Feb 13 2021 at 19:55)</a>:</h4>
<p>There were some other changes made to <code>finish</code> in that commit, so the easiest thing to do might just be to copy the entire file from the commit before and rename some of the declarations in it <a href="https://github.com/leanprover-community/mathlib/blob/c64aa1327ea3ce07673e98f9a1a33097ad377019/src/tactic/finish.lean">https://github.com/leanprover-community/mathlib/blob/c64aa1327ea3ce07673e98f9a1a33097ad377019/src/tactic/finish.lean</a></p>
<p>It looks like there's also one fix to <code>normalize_hyp</code> you'll have to port from the Lean 3.26.0 upgrade: <a href="https://github.com/leanprover-community/mathlib/commit/c64aa1327ea3ce07673e98f9a1a33097ad377019#diff-a0d8d6b754a5f49a85e923e6ca891150d76bd8d1e7f66f395db8a81af79f1b09">https://github.com/leanprover-community/mathlib/commit/c64aa1327ea3ce07673e98f9a1a33097ad377019#diff-a0d8d6b754a5f49a85e923e6ca891150d76bd8d1e7f66f395db8a81af79f1b09</a></p>



<a name="226263644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/226263644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#226263644">(Feb 13 2021 at 19:56)</a>:</h4>
<p>Maybe it'd be easier to rename the <code>auto</code> namespace rather than all of the individual declarations in it.</p>



<a name="226460263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/intuitionistic%20logic/near/226460263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Beeson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/intuitionistic.20logic.html#226460263">(Feb 16 2021 at 00:55)</a>:</h4>
<p>I've just gone through all my files and replaced all calls to ifinish with explicit proofs.    It was kinda sorta fun and now it's done,  so I can keep using the current version.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
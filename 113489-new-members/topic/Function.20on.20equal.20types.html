---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Function.20on.20equal.20types.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html">Function on equal types</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="207764003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207764003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207764003">(Aug 23 2020 at 09:17)</a>:</h4>
<p>Why does the second example below not even type check?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">s</span> <span class="err">∪</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">t</span> <span class="err">∪</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">union_comm</span> <span class="n">s</span> <span class="n">t</span> <span class="c1">-- this works, of course</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">s</span> <span class="err">∪</span> <span class="n">t</span><span class="o">)</span> <span class="bp">→</span> <span class="n">nat</span> <span class="bp">=</span> <span class="o">(</span><span class="n">t</span> <span class="err">∪</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="c1">-- why does this not even typecheck?</span>
</code></pre></div>



<a name="207764170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207764170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207764170">(Aug 23 2020 at 09:22)</a>:</h4>
<p>Ah, sorry, I see it now. It seems to be a parenthesis thing</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="o">((</span><span class="n">s</span> <span class="err">∪</span> <span class="n">t</span><span class="o">)</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">=</span> <span class="o">((</span><span class="n">t</span> <span class="err">∪</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="c1">-- this typechecks</span>
</code></pre></div>



<a name="207764853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207764853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207764853">(Aug 23 2020 at 09:44)</a>:</h4>
<p>oh that looks like trouble coming</p>



<a name="207764854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207764854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207764854">(Aug 23 2020 at 09:44)</a>:</h4>
<p>equality of types is a Bad Thing</p>



<a name="207765133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207765133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207765133">(Aug 23 2020 at 09:52)</a>:</h4>
<p>Yes, I am beginning to realize that I am in trouble. Here is a MWE of the problem I faced when trying to formalize something </p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">union_comm_func</span> <span class="o">:</span> <span class="o">((</span><span class="n">s</span> <span class="err">∪</span> <span class="n">t</span><span class="o">)</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">=</span> <span class="o">((</span><span class="n">t</span> <span class="err">∪</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">union_comm</span> <span class="n">s</span> <span class="n">t</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">f_ones</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">nat</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">f_ones</span> <span class="o">(</span><span class="n">t</span> <span class="err">∪</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">eq</span><span class="bp">.</span><span class="n">mp</span> <span class="o">(</span><span class="n">union_comm_func</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">f_ones</span> <span class="o">(</span><span class="n">s</span> <span class="err">∪</span> <span class="n">t</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>


<p>This example looks not very nice and I don't know how to prove it. I would just like to say</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="n">f_ones</span> <span class="o">(</span><span class="n">t</span> <span class="err">∪</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f_ones</span> <span class="o">(</span><span class="n">s</span> <span class="err">∪</span> <span class="n">t</span><span class="o">)</span>
</code></pre></div>


<p>but I can't. What is the Good Thing to do?</p>



<a name="207765769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207765769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207765769">(Aug 23 2020 at 10:07)</a>:</h4>
<p>And is there some documentation about good and bad practices for formalizing in Lean?</p>



<a name="207765775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207765775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207765775">(Aug 23 2020 at 10:07)</a>:</h4>
<p>Don't talk about equality of functions between non-definitionally equal types I guess</p>



<a name="207765817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207765817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207765817">(Aug 23 2020 at 10:08)</a>:</h4>
<p>This is a pretty vague question, but there are lots of resources listed at <a href="https://leanprover-community.github.io/learn.html">https://leanprover-community.github.io/learn.html</a></p>



<a name="207765834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207765834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207765834">(Aug 23 2020 at 10:09)</a>:</h4>
<p>See also the playlist at <a href="https://www.youtube.com/watch?v=8mVOIGW5US4&amp;list=PLlF-CfQhukNlxexiNJErGJd2dte_J1t1N">https://www.youtube.com/watch?v=8mVOIGW5US4&amp;list=PLlF-CfQhukNlxexiNJErGJd2dte_J1t1N</a></p>
<div class="youtube-video message_inline_image"><a data-id="8mVOIGW5US4" href="https://www.youtube.com/watch?v=8mVOIGW5US4&amp;list=PLlF-CfQhukNlxexiNJErGJd2dte_J1t1N"><img src="https://i.ytimg.com/vi/8mVOIGW5US4/default.jpg"></a></div>



<a name="207767945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207767945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207767945">(Aug 23 2020 at 11:08)</a>:</h4>
<p>Actually, why don't we prove that <code>eq.rec</code> is a group hom etc?</p>



<a name="207767949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207767949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207767949">(Aug 23 2020 at 11:08)</a>:</h4>
<p>instead of just avoiding it like the plague</p>



<a name="207767952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207767952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207767952">(Aug 23 2020 at 11:08)</a>:</h4>
<p>is this infeasible?</p>



<a name="207767964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207767964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207767964">(Aug 23 2020 at 11:09)</a>:</h4>
<p>I have a dream: that one day we will stop relying on definitional equality</p>



<a name="207775627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207775627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207775627">(Aug 23 2020 at 14:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/113489-new-members/topic/Function.20on.20equal.20types/near/207767949">said</a>:</p>
<blockquote>
<p>instead of just avoiding it like the plague</p>
</blockquote>
<p>OK, so the Good Thing is to avoid non-definitionally equal types like the plague. But how do I do this? Should I just refrain from proving certain mathematical statements or is there always a way around it? In particular, is there some alternative formalization of the (trivial) mathematical statement <code>f_ones (t ∪ s) = f_ones (s ∪ t)</code>in my example that avoids non-definitionally equal types?</p>



<a name="207775880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207775880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207775880">(Aug 23 2020 at 14:25)</a>:</h4>
<p>There is a way. You are clearly fighting the system instead of playing with it, but we don't have enough context to understand what you are trying to do (see also <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a>).</p>



<a name="207779499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207779499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207779499">(Aug 23 2020 at 16:03)</a>:</h4>
<p>Oh, I didn't know I was fighting the system. I do think a problem similar to the MWE arised naturally.</p>
<p>Sure, I'll give some context. I want to formalize a result about a database query language in <a href="https://arxiv.org/abs/1904.03934">this paper</a>. The theory is low-level and self-contained,  so it seems doable. This <a href="https://github.com/rbrijder/ARAk_lean">lean code</a> is what I have now. It is mostly definitions. The problem is the commutativity of the union operation for relations: <code>theorem rel_union_comm</code>.</p>



<a name="207876956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207876956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207876956">(Aug 24 2020 at 18:15)</a>:</h4>
<p>From a mathematical point of view, it boils down to this:  I am trying to define higher-dimensional matrices (tensors) and I am interested in formalizing a result about the expressivity of a certain set of operations on them (i.e., what kind of computations/queries I can do). If <code>X</code> is some finite set of dimensions of one tensor and <code>Y</code> of another, then union operation obtains a tensor with <code>X \cup Y</code> as the set of dimensions. I would like to show (as a first tiny step) that union is commutative, but now I run into the trouble that I have a tensor with <code>X \cup Y</code> as the set of dimensions and another with <code>Y \cup X</code> as the set of dimensions. In the case of an ordinary matrix <code>X</code> would be {row, col}, and in the case of a column vector <code>X</code> would be {col}, but in this case <code>X</code> is arbitrary. Now, just like in matrix multiplication, we also need to keep track of the sizes of each dimension (or, more generally, assign of set of indices to each dimension) for things to make sense. The notion of relation in the linked github repo captures this notion of a tensor (it is called a relation instead of a tensor because of the database context).</p>
<p>Any help on how to avoid non-definitionally equal types here is appreciated.</p>



<a name="207877966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207877966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207877966">(Aug 24 2020 at 18:22)</a>:</h4>
<p>Instead of defining a function on s union t, why not define it on all of alpha and then ignore its values outside s union t?</p>



<a name="207878307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207878307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207878307">(Aug 24 2020 at 18:25)</a>:</h4>
<p>You might want to look at <a href="https://leanprover-community.github.io/mathlib_docs/find/holor">docs#holor</a></p>



<a name="207878696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207878696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207878696">(Aug 24 2020 at 18:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Function.20on.20equal.20types/near/207877966">said</a>:</p>
<blockquote>
<p>Instead of defining a function on s union t, why not define it on all of alpha and then ignore its values outside s union t?</p>
</blockquote>
<p>Perhaps that would work. So, I should store the "real" set of dimensions separately, say together as a structure?</p>



<a name="207879538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207879538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207879538">(Aug 24 2020 at 18:34)</a>:</h4>
<p>I don't really know the type of the things you're talking about. I'm just saying that sets are terms and when you promote them to types, equal sets may become non-defeq types. On the other hand if you're only interested in equality of functions on these sets then you could define functions on a bigger type without doing the promotion which is causing the problem</p>



<a name="207879653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207879653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207879653">(Aug 24 2020 at 18:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/Function.20on.20equal.20types/near/207878307">said</a>:</p>
<blockquote>
<p>You might want to look at <a href="https://leanprover-community.github.io/mathlib_docs/find/holor">docs#holor</a></p>
</blockquote>
<p>Yes. The problem for me with that definition (and mine for that matter) is that the index set is baked-in the type, which apparently is something I should avoid.</p>



<a name="207880158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207880158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207880158">(Aug 24 2020 at 18:39)</a>:</h4>
<p>It seems like you already have a way of moving <code>relation</code>s across subset inclusions, so one option is to move the two sides together using the inclusion of <code>X \cup Y</code> in <code>Y \cup X</code></p>



<a name="207880434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207880434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207880434">(Aug 24 2020 at 18:41)</a>:</h4>
<p>Another option is to move the <code>X</code> index of the <code>relation</code> type into a structure field, so effectively work with <code>\Sigma X, relation D X alpha</code></p>



<a name="207880564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207880564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207880564">(Aug 24 2020 at 18:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Function.20on.20equal.20types/near/207879538">said</a>:</p>
<blockquote>
<p>if you're only interested in equality of functions on these sets</p>
</blockquote>
<p>Unfortunately, I am not only interested in this. I do want to keep track of the real set of dimensions. Like in linear algebra, where one would need to be able to distinguish a vector from a matrix.</p>



<a name="207880618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207880618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207880618">(Aug 24 2020 at 18:42)</a>:</h4>
<p>this can be awkward if you have operations which require two <code>relation</code>s with the same <code>X</code>, for example, but your existing operations don't appear to be of this sort</p>



<a name="207881134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207881134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207881134">(Aug 24 2020 at 18:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/Function.20on.20equal.20types/near/207880618">said</a>:</p>
<blockquote>
<p>this can be awkward if you have operations which require two <code>relation</code>s with the same <code>X</code>, for example, but your existing operations don't appear to be of this sort</p>
</blockquote>
<p>Unfortunately, one such operation requires this! (Actually, it is the union operation; I didn't want to over-complicate my message by saying that union is actually only defined if the index sets are equal. Details are in the above mentioned lean repo and paper.)</p>



<a name="207881179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207881179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207881179">(Aug 24 2020 at 18:47)</a>:</h4>
<p>I'm actually looking at the repo and paper and I'm confused about this point</p>



<a name="207881196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207881196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207881196">(Aug 24 2020 at 18:47)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">rel_union</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">relation</span> <span class="n">D</span> <span class="n">X</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">r&#39;</span> <span class="o">:</span> <span class="n">relation</span> <span class="n">D</span> <span class="n">X&#39;</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
              <span class="n">relation</span> <span class="n">D</span> <span class="o">(</span><span class="n">X</span> <span class="err">∪</span> <span class="n">X&#39;</span><span class="o">)</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="n">r</span><span class="o">(</span><span class="n">tuple_comp</span> <span class="n">t</span> <span class="o">(</span><span class="n">inclusion_compat</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">subset_union_left</span> <span class="n">X</span> <span class="n">X&#39;</span><span class="o">)))</span> <span class="bp">+</span>
                                            <span class="n">r&#39;</span><span class="o">(</span><span class="n">tuple_comp</span> <span class="n">t</span> <span class="o">(</span><span class="n">inclusion_compat</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">subset_union_right</span> <span class="n">X</span> <span class="n">X&#39;</span><span class="o">))))</span>
</code></pre></div>



<a name="207881297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207881297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207881297">(Aug 24 2020 at 18:48)</a>:</h4>
<p>Indeed, isn't this the very function which originated this topic?</p>



<a name="207881474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207881474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207881474">(Aug 24 2020 at 18:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/Function.20on.20equal.20types/near/207881297">said</a>:</p>
<blockquote>
<p>Indeed, isn't this the very function which originated this topic?</p>
</blockquote>
<p>Yes, it is! I am defining it in the lean code in higher generality (thinking this might help in formalization), but the query language requires that X' = X. I have defined a notion of well-typed expressions in the lean code which says that the schemas should coincide.</p>



<a name="207881672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207881672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207881672">(Aug 24 2020 at 18:51)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">ARA_well_typed</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">ARAe</span> <span class="n">rel</span> <span class="n">att</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">rel</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">att</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">ARAe</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">e</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">R</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="c1">-- relnm</span>
              <span class="o">(</span><span class="bp">λ</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">e1W</span> <span class="n">e2W</span><span class="o">,</span> <span class="n">e1W</span> <span class="bp">∧</span> <span class="n">e2W</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">ARAschema</span> <span class="n">e1</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">ARAschema</span> <span class="n">e2</span> <span class="n">S</span><span class="o">))</span> <span class="c1">-- union</span>
              <span class="o">(</span><span class="bp">λ</span> <span class="n">Y</span> <span class="n">e1</span> <span class="n">e1W</span><span class="o">,</span> <span class="n">e1W</span><span class="o">)</span> <span class="c1">-- proj</span>
              <span class="o">(</span><span class="bp">λ</span> <span class="n">Y</span> <span class="n">hmutc</span> <span class="n">e1</span> <span class="n">e1W</span><span class="o">,</span> <span class="n">e1W</span><span class="o">)</span> <span class="c1">-- selection</span>
              <span class="o">(</span><span class="bp">λ</span> <span class="n">φ</span> <span class="n">hinj</span> <span class="n">hc</span> <span class="n">e1</span> <span class="n">e1W</span><span class="o">,</span> <span class="n">e1W</span><span class="o">)</span> <span class="c1">-- rename</span>
              <span class="o">(</span><span class="bp">λ</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">e1W</span> <span class="n">e2W</span><span class="o">,</span> <span class="n">e1W</span> <span class="bp">∧</span> <span class="n">e2W</span><span class="o">)</span> <span class="c1">-- join</span>
</code></pre></div>



<a name="207881782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207881782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207881782">(Aug 24 2020 at 18:52)</a>:</h4>
<p>If you have a <code>relation</code> with <code>X</code> as a structure field then you can still impose a propositional condition <code>r.X = r'.X</code> if you want to.</p>



<a name="207881823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207881823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207881823">(Aug 24 2020 at 18:52)</a>:</h4>
<p>It just might be less convenient than if you knew they were definitionally equal.</p>



<a name="207882056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207882056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207882056">(Aug 24 2020 at 18:55)</a>:</h4>
<p>It looks like you're halfway down that road already with this definition of <code>ARA_well_typed</code></p>



<a name="207882192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207882192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207882192">(Aug 24 2020 at 18:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/Function.20on.20equal.20types/near/207881823">said</a>:</p>
<blockquote>
<p>It just might be less convenient than if you knew they were definitionally equal.</p>
</blockquote>
<p>Whatever is most convenient. If restricting the definition of union is better, then great.</p>



<a name="207882420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207882420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207882420">(Aug 24 2020 at 18:58)</a>:</h4>
<p>It is not yet clear to me how I should define the notion of a relation.</p>



<a name="207882454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207882454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207882454">(Aug 24 2020 at 18:58)</a>:</h4>
<p>so to be explicit, I am suggesting something like</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">relation</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">dom_assign</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">schema</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">att</span><span class="o">)</span>
<span class="o">(</span><span class="n">rel</span> <span class="o">:</span> <span class="n">tuple</span> <span class="n">D</span> <span class="n">schema</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>

<span class="n">def</span> <span class="n">rel_join</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">relation</span> <span class="n">D</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">r&#39;</span> <span class="o">:</span> <span class="n">relation</span> <span class="n">D</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>     <span class="c1">-- for example</span>
              <span class="n">relation</span> <span class="n">D</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">schema</span> <span class="o">:=</span> <span class="n">r</span><span class="bp">.</span><span class="n">schema</span> <span class="err">∪</span> <span class="n">r&#39;</span><span class="bp">.</span><span class="n">schema</span><span class="o">,</span> <span class="n">rel</span> <span class="o">:=</span> <span class="bp">...</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">rel_union</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">relation</span> <span class="n">D</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">r&#39;</span> <span class="o">:</span> <span class="n">relation</span> <span class="n">D</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">r</span><span class="bp">.</span><span class="n">schema</span> <span class="bp">=</span> <span class="n">r&#39;</span><span class="bp">.</span><span class="n">schema</span><span class="o">)</span> <span class="o">:</span>
              <span class="n">relation</span> <span class="n">D</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">schema</span> <span class="o">:=</span> <span class="n">r</span><span class="bp">.</span><span class="n">schema</span><span class="o">,</span> <span class="c1">--say</span>
  <span class="n">rel</span> <span class="o">:=</span> <span class="bp">...</span> <span class="o">}</span>
</code></pre></div>



<a name="207882524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207882524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207882524">(Aug 24 2020 at 18:59)</a>:</h4>
<p>now that the schema is not exposed in the type of relations, it won't get in the way of formulating statements like commutativity</p>



<a name="207882983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207882983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207882983">(Aug 24 2020 at 19:02)</a>:</h4>
<p>I see! By bundling the schema you make the types definitially equal. Thank you very much! I will try this.</p>



<a name="207883296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207883296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207883296">(Aug 24 2020 at 19:04)</a>:</h4>
<p>Another situation you might think about is an expression like</p>
<div class="codehilite"><pre><span></span><code><span class="n">rel_union</span>
  <span class="o">(</span><span class="n">rel_join</span> <span class="n">r</span> <span class="n">r&#39;</span><span class="o">)</span>
  <span class="o">(</span><span class="n">rel_join</span> <span class="n">r&#39;</span> <span class="n">r</span><span class="o">)</span>
</code></pre></div>


<p>where <code>rel_union</code> has a type that enforces that the schemas agree.<br>
This expression is valid, but only because of a theorem in propositional logic. So either you have to reject this expression, or extend <code>rel_union</code> to the situation where the schemas might not be equal, or explain to Lean somehow why the expression makes sense.</p>



<a name="207883439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207883439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207883439">(Aug 24 2020 at 19:05)</a>:</h4>
<p>This is just to point out that the issue is going to crop up other places besides <code>rel_union_comm</code>.</p>



<a name="207883835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207883835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207883835">(Aug 24 2020 at 19:09)</a>:</h4>
<p>Oh dear, this is a valid expression in the language so I cannot reject this. It is the same problem of non-definitially-equal types again.</p>



<a name="207884207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207884207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207884207">(Aug 24 2020 at 19:12)</a>:</h4>
<p>You might also be interested in the <a href="#narrow/stream/116395-maths/topic/CDGAs/near/167848869">CDGA challenge topic</a> (where, probably not by coincidence, addition and multiplication play very similar roles to your <code>union</code> and <code>join</code>).</p>



<a name="207884992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/207884992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#207884992">(Aug 24 2020 at 19:20)</a>:</h4>
<p>I see, a challenge for </p>
<blockquote>
<p>Anyone who doesn't already believe that this will be a mess</p>
</blockquote>
<p>And I was thinking formalizing this low-level self-contained paper would be a doable exercise for a beginner like me....</p>



<a name="208796269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208796269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208796269">(Sep 02 2020 at 08:57)</a>:</h4>
<p>Bundling the domain indeed solved my problem: I can now prove that union on relations commutes. However, my proof is very slow using tactics <code>congr' 3</code> and <code>finish</code>. This seems unnecessary because I can get in a sane and fast way to this state:</p>
<div class="codehilite"><pre><span></span><code><span class="n">att</span> <span class="n">dom</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">att</span><span class="o">,</span>
<span class="n">D</span> <span class="o">:</span> <span class="n">dom_assign</span><span class="o">,</span>
<span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">semiring</span> <span class="n">K</span><span class="o">,</span>
<span class="n">r</span> <span class="n">r&#39;</span> <span class="o">:</span> <span class="n">relation</span> <span class="n">D</span> <span class="n">K</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">tuple</span> <span class="n">D</span> <span class="o">(</span><span class="n">r</span><span class="bp">.</span><span class="n">schema</span> <span class="err">∪</span> <span class="n">r&#39;</span><span class="bp">.</span><span class="n">schema</span><span class="o">),</span>
<span class="n">a&#39;</span> <span class="o">:</span> <span class="n">tuple</span> <span class="n">D</span> <span class="o">(</span><span class="n">r&#39;</span><span class="bp">.</span><span class="n">schema</span> <span class="err">∪</span> <span class="n">r</span><span class="bp">.</span><span class="n">schema</span><span class="o">),</span>
<span class="n">a_1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">a&#39;</span>
<span class="err">⊢</span> <span class="n">r&#39;</span><span class="bp">.</span><span class="n">rel</span> <span class="o">(</span><span class="n">tuple_comp</span> <span class="n">a</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">+</span> <span class="n">r</span><span class="bp">.</span><span class="n">rel</span> <span class="o">(</span><span class="n">tuple_comp</span> <span class="n">a</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">==</span> <span class="n">r&#39;</span><span class="bp">.</span><span class="n">rel</span> <span class="o">(</span><span class="n">tuple_comp</span> <span class="n">a&#39;</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">+</span> <span class="n">r</span><span class="bp">.</span><span class="n">rel</span> <span class="o">(</span><span class="n">tuple_comp</span> <span class="n">a&#39;</span> <span class="bp">_</span><span class="o">)</span>
</code></pre></div>


<p>How do I finish such a goal in a proper way?</p>



<a name="208796364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208796364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208796364">(Sep 02 2020 at 08:58)</a>:</h4>
<p>MWE</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">finite</span>
<span class="kn">import</span> <span class="n">init</span><span class="bp">.</span><span class="n">data</span><span class="bp">.</span><span class="n">quot</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">setoid</span><span class="bp">.</span><span class="n">partition</span>

<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>

<span class="kn">namespace</span> <span class="n">ARA</span>
<span class="kn">section</span> <span class="n">ARA</span>

<span class="kn">parameters</span> <span class="o">{</span><span class="n">rel</span> <span class="n">att</span> <span class="n">dom</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">setoid</span> <span class="n">att</span><span class="o">]</span>

<span class="n">def</span> <span class="n">dom_assign</span> <span class="o">:=</span> <span class="n">quotient</span> <span class="bp">_</span><span class="n">inst_1</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">dom</span>
<span class="n">def</span> <span class="n">tuple</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">dom_assign</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">att</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="o">(</span><span class="err">↑</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">att</span><span class="o">)),</span> <span class="o">(</span><span class="err">↑</span><span class="o">(</span><span class="n">D</span><span class="err">⟦</span><span class="n">A</span><span class="err">⟧</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">dom</span><span class="o">)</span>
<span class="kn">structure</span> <span class="n">relation</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">dom_assign</span><span class="o">)</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">schema</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">att</span><span class="o">)</span>
  <span class="o">(</span><span class="n">rel</span> <span class="o">:</span> <span class="n">tuple</span> <span class="n">D</span> <span class="n">schema</span> <span class="bp">→</span> <span class="n">K</span><span class="o">)</span>
<span class="n">def</span> <span class="n">compat_func</span> <span class="o">{</span><span class="n">att</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">setoid</span> <span class="n">att</span><span class="o">]</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">att</span><span class="o">}</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">att</span><span class="o">)</span> <span class="bp">≈</span> <span class="o">((</span><span class="n">φ</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">att</span><span class="o">)</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">D</span> <span class="o">:</span> <span class="n">dom_assign</span><span class="o">}</span> <span class="o">{</span><span class="n">X</span> <span class="n">X&#39;</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">att</span><span class="o">}</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">K</span><span class="o">]</span>

<span class="kn">theorem</span> <span class="n">inclusion_compat</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⊆</span> <span class="n">X&#39;</span><span class="o">)</span> <span class="o">:</span> <span class="n">compat_func</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inclusion</span> <span class="n">h</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">compat_att_eq_dom</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">att</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="err">⟦</span><span class="n">A</span><span class="err">⟧</span> <span class="bp">=</span> <span class="err">⟦</span><span class="n">B</span><span class="err">⟧</span><span class="o">)</span> <span class="o">:</span>
  <span class="err">↥</span><span class="o">(</span><span class="err">↑</span><span class="o">(</span><span class="n">D</span><span class="err">⟦</span><span class="n">A</span><span class="err">⟧</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">dom</span><span class="o">)</span> <span class="bp">=</span> <span class="err">↥</span><span class="o">(</span><span class="err">↑</span><span class="o">(</span><span class="n">D</span><span class="err">⟦</span><span class="n">B</span><span class="err">⟧</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">dom</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">congr</span> <span class="n">rfl</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">coe</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">D</span> <span class="n">h</span><span class="o">))</span>

<span class="kn">theorem</span> <span class="n">func_compat_eq_dom</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="err">↑</span><span class="n">X&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="n">att</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="err">↑</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">att</span><span class="o">)}</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">compat_func</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="o">(</span><span class="err">↑</span><span class="n">X&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="n">att</span><span class="o">))</span> <span class="o">:</span> <span class="err">⟦</span><span class="o">(</span><span class="n">f</span> <span class="n">A</span> <span class="o">:</span> <span class="n">att</span><span class="o">)</span><span class="err">⟧</span> <span class="bp">=</span> <span class="err">⟦</span><span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">att</span><span class="o">)</span><span class="err">⟧</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">eq_rel</span><span class="bp">.</span><span class="n">mpr</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">compat_func</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">set_coe</span><span class="bp">.</span><span class="k">forall</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">setoid</span><span class="bp">.</span><span class="n">symm&#39;</span> <span class="bp">_</span><span class="n">inst_1</span> <span class="o">(</span><span class="n">h</span> <span class="n">A_val</span> <span class="n">A_property</span><span class="o">),</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">tuple_comp</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="err">↑</span><span class="n">X&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="n">att</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="err">↑</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">att</span><span class="o">)}</span>
  <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">tuple</span> <span class="n">D</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">compat_func</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">tuple</span> <span class="n">D</span> <span class="n">X&#39;</span> <span class="o">:=</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">mp</span> <span class="o">(</span><span class="n">compat_att_eq_dom</span> <span class="o">(</span><span class="n">func_compat_eq_dom</span> <span class="n">h</span> <span class="n">A</span><span class="o">))</span> <span class="o">(</span><span class="n">t</span> <span class="o">(</span><span class="n">f</span> <span class="n">A</span><span class="o">))))</span>

<span class="n">def</span> <span class="n">rel_union</span> <span class="o">(</span><span class="n">r</span> <span class="n">r&#39;</span> <span class="o">:</span> <span class="n">relation</span> <span class="n">D</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span> <span class="n">relation</span> <span class="n">D</span> <span class="n">K</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">schema</span> <span class="o">:=</span> <span class="n">r</span><span class="bp">.</span><span class="n">schema</span> <span class="err">∪</span> <span class="n">r&#39;</span><span class="bp">.</span><span class="n">schema</span><span class="o">,</span>
  <span class="n">rel</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="n">r</span><span class="bp">.</span><span class="n">rel</span><span class="o">(</span><span class="n">tuple_comp</span> <span class="n">t</span> <span class="o">(</span><span class="n">inclusion_compat</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">subset_union_left</span> <span class="n">r</span><span class="bp">.</span><span class="n">schema</span> <span class="n">r&#39;</span><span class="bp">.</span><span class="n">schema</span><span class="o">)))</span> <span class="bp">+</span>
                <span class="n">r&#39;</span><span class="bp">.</span><span class="n">rel</span><span class="o">(</span><span class="n">tuple_comp</span> <span class="n">t</span> <span class="o">(</span><span class="n">inclusion_compat</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">subset_union_right</span> <span class="n">r</span><span class="bp">.</span><span class="n">schema</span> <span class="n">r&#39;</span><span class="bp">.</span><span class="n">schema</span><span class="o">))))</span>
<span class="o">}</span>

<span class="kn">instance</span> <span class="n">rel_has_union</span> <span class="o">:</span> <span class="n">has_union</span> <span class="o">(</span><span class="n">relation</span> <span class="n">D</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">rel_union</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">rel_union_comm</span> <span class="o">(</span><span class="n">r</span> <span class="n">r&#39;</span> <span class="o">:</span> <span class="n">relation</span> <span class="n">D</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="err">∪</span> <span class="n">r&#39;</span> <span class="bp">=</span> <span class="n">r&#39;</span> <span class="err">∪</span> <span class="n">r</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">has_union</span><span class="bp">.</span><span class="n">union</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">rel_union</span><span class="o">,</span>
  <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">union_comm</span><span class="o">,</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">union_comm</span><span class="o">,</span>
  <span class="n">intros</span><span class="o">,</span>
  <span class="n">conv</span>
    <span class="k">begin</span>
      <span class="n">to_lhs</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">add_comm</span><span class="o">,</span>
    <span class="kn">end</span><span class="o">,</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">ARA</span>
<span class="kn">end</span> <span class="n">ARA</span>
</code></pre></div>



<a name="208802186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208802186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208802186">(Sep 02 2020 at 10:04)</a>:</h4>
<p>the solution to heq is not to use heq</p>



<a name="208853475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208853475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208853475">(Sep 02 2020 at 16:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/113489-new-members/topic/Function.20on.20equal.20types/near/208802186">said</a>:</p>
<blockquote>
<p>the solution to heq is not to use heq</p>
</blockquote>
<p>Right. But the problem is that I never use heq in my code. For some reason it is introduced by invoking tactic <code>congr' 1</code> in my proof. Perhaps I should have used some alternative to <code>congr' 1</code>?</p>



<a name="208905177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208905177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208905177">(Sep 03 2020 at 00:08)</a>:</h4>
<p>the first step is to prove an extensionality lemma for <code>relation</code>, preferably one that doesn't involve heq</p>



<a name="208907368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208907368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208907368">(Sep 03 2020 at 00:40)</a>:</h4>
<p><span class="user-mention" data-user-id="269768">@Robert Brijder</span> </p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">finite</span>

<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>

<span class="kn">namespace</span> <span class="n">ARA</span>
<span class="kn">section</span> <span class="n">ARA</span>

<span class="kn">parameters</span> <span class="o">{</span><span class="n">rel</span> <span class="n">att</span> <span class="n">dom</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">setoid</span> <span class="n">att</span><span class="o">]</span>

<span class="n">def</span> <span class="n">dom_assign</span> <span class="o">:=</span> <span class="n">quotient</span> <span class="bp">_</span><span class="n">inst_1</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">dom</span>
<span class="n">def</span> <span class="n">tuple</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">dom_assign</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">att</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">dom</span> <span class="bp">//</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">D</span><span class="err">⟦</span><span class="n">A</span><span class="err">⟧</span><span class="o">}</span>

<span class="n">def</span> <span class="n">tuple</span><span class="bp">.</span><span class="n">sub</span> <span class="o">{</span><span class="n">D</span> <span class="o">:</span> <span class="n">dom_assign</span><span class="o">}</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">att</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⊆</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">tuple</span> <span class="n">D</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">tuple</span> <span class="n">D</span> <span class="n">X</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="n">h</span><span class="o">,</span> <span class="n">T</span> <span class="n">a</span> <span class="o">(</span><span class="n">H</span> <span class="n">h</span><span class="o">)</span>

<span class="c1">-- @[ext]</span>
<span class="kn">theorem</span> <span class="n">tuple</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">D</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">t₁</span> <span class="n">t₂</span> <span class="o">:</span> <span class="n">tuple</span> <span class="n">D</span> <span class="n">X</span><span class="o">}</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">att</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">X</span><span class="o">),</span> <span class="o">(</span><span class="n">t₁</span> <span class="n">A</span> <span class="n">h</span> <span class="o">:</span> <span class="n">dom</span><span class="o">)</span> <span class="bp">=</span> <span class="n">t₂</span> <span class="n">A</span> <span class="n">h</span><span class="o">)</span> <span class="o">:</span> <span class="n">t₁</span> <span class="bp">=</span> <span class="n">t₂</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">ext</span> <span class="n">a</span> <span class="n">h</span> <span class="o">:</span> <span class="mi">3</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">H</span>

<span class="kn">structure</span> <span class="n">relation</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">dom_assign</span><span class="o">)</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">schema</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">att</span><span class="o">)</span>
  <span class="o">(</span><span class="n">rel</span> <span class="o">:</span> <span class="n">tuple</span> <span class="n">D</span> <span class="n">schema</span> <span class="bp">→</span> <span class="n">K</span><span class="o">)</span>
<span class="n">def</span> <span class="n">compat_func</span> <span class="o">{</span><span class="n">att</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">setoid</span> <span class="n">att</span><span class="o">]</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">att</span><span class="o">}</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">att</span><span class="o">)</span> <span class="bp">≈</span> <span class="o">((</span><span class="n">φ</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">att</span><span class="o">)</span>

<span class="c1">-- @[ext]</span>
<span class="kn">theorem</span> <span class="n">relation_ext</span> <span class="o">{</span><span class="n">D</span> <span class="n">K</span><span class="o">}</span> <span class="o">(</span><span class="n">r₁</span> <span class="n">r₂</span> <span class="o">:</span> <span class="n">relation</span> <span class="n">D</span> <span class="n">K</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">r₁</span><span class="bp">.</span><span class="n">schema</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">r₂</span><span class="bp">.</span><span class="n">schema</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">tuple</span> <span class="n">D</span> <span class="n">r₂</span><span class="bp">.</span><span class="n">schema</span><span class="o">),</span> <span class="n">r₁</span><span class="bp">.</span><span class="n">rel</span> <span class="o">(</span><span class="n">T</span><span class="bp">.</span><span class="n">sub</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">h₁</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="n">r₂</span><span class="bp">.</span><span class="n">rel</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">r₁</span> <span class="bp">=</span> <span class="n">r₂</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">r₁</span> <span class="k">with</span> <span class="n">S₁</span> <span class="n">R₁</span><span class="o">,</span> <span class="n">cases</span> <span class="n">r₂</span> <span class="k">with</span> <span class="n">S₂</span> <span class="n">R₂</span><span class="o">,</span>
  <span class="k">obtain</span> <span class="n">rfl</span> <span class="o">:</span> <span class="n">S₁</span> <span class="bp">=</span> <span class="n">S₂</span><span class="o">,</span> <span class="o">{</span><span class="n">ext</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h₁</span><span class="o">},</span>
  <span class="n">congr</span><span class="o">,</span> <span class="n">ext</span> <span class="n">T</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h₂</span>
<span class="kn">end</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">D</span> <span class="o">:</span> <span class="n">dom_assign</span><span class="o">}</span> <span class="o">{</span><span class="n">X</span> <span class="n">X&#39;</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">att</span><span class="o">}</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">K</span><span class="o">]</span>

<span class="n">def</span> <span class="n">rel_union</span> <span class="o">(</span><span class="n">r</span> <span class="n">r&#39;</span> <span class="o">:</span> <span class="n">relation</span> <span class="n">D</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span> <span class="n">relation</span> <span class="n">D</span> <span class="n">K</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">schema</span> <span class="o">:=</span> <span class="n">r</span><span class="bp">.</span><span class="n">schema</span> <span class="err">∪</span> <span class="n">r&#39;</span><span class="bp">.</span><span class="n">schema</span><span class="o">,</span>
  <span class="n">rel</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="n">r</span><span class="bp">.</span><span class="n">rel</span> <span class="o">(</span><span class="n">t</span><span class="bp">.</span><span class="n">sub</span> <span class="err">$</span> <span class="n">finset</span><span class="bp">.</span><span class="n">subset_union_left</span> <span class="n">r</span><span class="bp">.</span><span class="n">schema</span> <span class="n">r&#39;</span><span class="bp">.</span><span class="n">schema</span><span class="o">)</span> <span class="bp">+</span>
              <span class="n">r&#39;</span><span class="bp">.</span><span class="n">rel</span> <span class="o">(</span><span class="n">t</span><span class="bp">.</span><span class="n">sub</span> <span class="err">$</span> <span class="n">finset</span><span class="bp">.</span><span class="n">subset_union_right</span> <span class="n">r</span><span class="bp">.</span><span class="n">schema</span> <span class="n">r&#39;</span><span class="bp">.</span><span class="n">schema</span><span class="o">)</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="n">rel_has_union</span> <span class="o">:</span> <span class="n">has_union</span> <span class="o">(</span><span class="n">relation</span> <span class="n">D</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">rel_union</span><span class="bp">⟩</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">rel_union_mem</span> <span class="o">{</span><span class="n">r</span> <span class="n">r&#39;</span> <span class="o">:</span> <span class="n">relation</span> <span class="n">D</span> <span class="n">K</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">x</span> <span class="err">∈</span> <span class="o">(</span><span class="n">r</span> <span class="err">∪</span> <span class="n">r&#39;</span><span class="o">)</span><span class="bp">.</span><span class="n">schema</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">r</span><span class="bp">.</span><span class="n">schema</span> <span class="bp">∨</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">r&#39;</span><span class="bp">.</span><span class="n">schema</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simp</span> <span class="o">[(</span><span class="err">∪</span><span class="o">),</span> <span class="n">rel_union</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">rel_union_rel</span> <span class="o">{</span><span class="n">r</span> <span class="n">r&#39;</span> <span class="o">:</span> <span class="n">relation</span> <span class="n">D</span> <span class="n">K</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">r</span> <span class="err">∪</span> <span class="n">r&#39;</span><span class="o">)</span><span class="bp">.</span><span class="n">rel</span> <span class="n">t</span> <span class="bp">=</span>
  <span class="n">r</span><span class="bp">.</span><span class="n">rel</span> <span class="o">(</span><span class="n">t</span><span class="bp">.</span><span class="n">sub</span> <span class="err">$</span> <span class="n">finset</span><span class="bp">.</span><span class="n">subset_union_left</span> <span class="n">r</span><span class="bp">.</span><span class="n">schema</span> <span class="n">r&#39;</span><span class="bp">.</span><span class="n">schema</span><span class="o">)</span> <span class="bp">+</span>
  <span class="n">r&#39;</span><span class="bp">.</span><span class="n">rel</span> <span class="o">(</span><span class="n">t</span><span class="bp">.</span><span class="n">sub</span> <span class="err">$</span> <span class="n">finset</span><span class="bp">.</span><span class="n">subset_union_right</span> <span class="n">r</span><span class="bp">.</span><span class="n">schema</span> <span class="n">r&#39;</span><span class="bp">.</span><span class="n">schema</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">rel_union_comm</span> <span class="o">(</span><span class="n">r</span> <span class="n">r&#39;</span> <span class="o">:</span> <span class="n">relation</span> <span class="n">D</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="err">∪</span> <span class="n">r&#39;</span> <span class="bp">=</span> <span class="n">r&#39;</span> <span class="err">∪</span> <span class="n">r</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">fapply</span> <span class="n">relation_ext</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">or_comm</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">add_comm</span><span class="o">],</span> <span class="n">refl</span> <span class="o">},</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">ARA</span>
<span class="kn">end</span> <span class="n">ARA</span>
</code></pre></div>



<a name="208907391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208907391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208907391">(Sep 03 2020 at 00:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> The two commented <code>@[ext]</code> lemmas fail with <code>match failed</code>. Do you know what's happening?</p>



<a name="208909942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208909942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208909942">(Sep 03 2020 at 01:25)</a>:</h4>
<p>Can you minimize it?</p>



<a name="208910894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208910894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208910894">(Sep 03 2020 at 01:44)</a>:</h4>
<p>It's a parameter problem.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">ext</span>
<span class="kn">section</span>

<span class="kn">parameters</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>

<span class="n">def</span> <span class="n">tuple</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ext</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">tuple</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">t₁</span> <span class="n">t₂</span> <span class="o">:</span> <span class="n">tuple</span> <span class="n">a</span><span class="o">}</span> <span class="o">:</span> <span class="n">t₁</span> <span class="bp">=</span> <span class="n">t₂</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="c1">-- match failed</span>

<span class="kn">end</span>
</code></pre></div>



<a name="208910910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208910910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208910910">(Sep 03 2020 at 01:44)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span></p>



<a name="208913264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208913264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208913264">(Sep 03 2020 at 02:25)</a>:</h4>
<p>Yes I see. When we call <code>resolve_constant</code>, it calls <code>resolve_name</code> expecting that the result will be a <code>const</code>. Because of the parameter, we get this as a response instead: <code>as_atomic ((«@» tuple) («@» A))</code></p>



<a name="208913720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208913720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208913720">(Sep 03 2020 at 02:34)</a>:</h4>
<p>whoa that's new</p>



<a name="208914014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208914014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208914014">(Sep 03 2020 at 02:37)</a>:</h4>
<p>Yeah. I think that's because pre-elaboration terms have much more annotations. What we can do is implement an alternative <code>resolve_constant</code> that checks if <code>resolve_name</code> gives a <code>const</code> and, if not, use <code>e &lt;- to_expr</code> and then use <code>e.get_app_fn.const_name</code></p>



<a name="208914204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208914204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208914204">(Sep 03 2020 at 02:38)</a>:</h4>
<p>resolve_name returns a pexpr?</p>



<a name="208914242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208914242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208914242">(Sep 03 2020 at 02:38)</a>:</h4>
<p>It does</p>



<a name="208914283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208914283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208914283">(Sep 03 2020 at 02:38)</a>:</h4>
<p>but you already have an expr, don't you?</p>



<a name="208914438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208914438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208914438">(Sep 03 2020 at 02:41)</a>:</h4>
<p>no, it's right after parsing the parameters of <code>ext</code>. They come as a list of names and they're not necessarily fully qualified. We need <code>resolve_constant</code> (and <code>resolve_name</code>) to figure out what their full name is</p>



<a name="208914921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208914921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208914921">(Sep 03 2020 at 02:50)</a>:</h4>
<p>This works:</p>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="n">def</span> <span class="n">resolve_constant&#39;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">name</span> <span class="o">:=</span>
<span class="n">do</span> <span class="n">e</span> <span class="err">←</span> <span class="n">resolve_name</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">(</span><span class="n">expr</span><span class="bp">.</span><span class="n">const_name</span> <span class="err">∘</span> <span class="n">expr</span><span class="bp">.</span><span class="n">app_fn</span><span class="o">)</span> <span class="bp">&lt;</span><span class="err">$</span><span class="bp">&gt;</span> <span class="n">to_expr</span> <span class="n">e</span> <span class="n">tt</span> <span class="n">ff</span><span class="o">,</span>
</code></pre></div>



<a name="208914966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208914966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208914966">(Sep 03 2020 at 02:51)</a>:</h4>
<p><code>resolve_constant</code> is in core though so this will have to be a patch until the next version</p>



<a name="208915249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208915249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208915249">(Sep 03 2020 at 02:57)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/4032">#4032</a></p>



<a name="208915308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208915308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208915308">(Sep 03 2020 at 02:58)</a>:</h4>
<p>I did something similar. In the normal case, we don't need to go through elaboration so I only call <code>to_expr</code> when <code>resolve_constant</code> would crash</p>



<a name="208915400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208915400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208915400">(Sep 03 2020 at 03:01)</a>:</h4>
<p>Oh and I use <code>expr.get_app_fn</code> (which is recursive) instead of <code>expr.app_fn</code></p>



<a name="208924334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20on%20equal%20types/near/208924334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Brijder <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20on.20equal.20types.html#208924334">(Sep 03 2020 at 06:08)</a>:</h4>
<p>Wow, thank you very much Mario for the rewrite of my code! I am learning a lot from this.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
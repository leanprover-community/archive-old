---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html">Show explicit coercions?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="276113337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276113337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276113337">(Mar 21 2022 at 21:02)</a>:</h4>
<p>Is there a way to make the pretty printer indicate what specific coercion hides under a <code>↑</code>? <code>set_option pp.coercions true</code> does not do that (and <code>false</code> apparently suppresses them completely), and using <code>set_option pp.all true</code> is way too much.<br>
I'm trying to prove a result on p-adic numbers and can't seem to figure out what the <code>↑</code> in <code>u - ↑(1 : zmod p)</code> means (where <code>u : ℤ_[p]</code>). <code>norm_cast</code> seemingly cannot do anything with this expression, so I'm looking for a library lemma that gives me that  <code>↑(1 : zmod p) = 1</code>, and knowing what the coercion map is called would probably help.</p>



<a name="276113547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276113547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276113547">(Mar 21 2022 at 21:04)</a>:</h4>
<p><span class="user-mention" data-user-id="479359">@Michael Stoll</span> If you use VSCode, do you know about the ability to get this information by clicking on the arrow in the infoview?</p>



<a name="276113650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276113650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276113650">(Mar 21 2022 at 21:05)</a>:</h4>
<p>Now I know...</p>



<a name="276113772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276113772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276113772">(Mar 21 2022 at 21:06)</a>:</h4>
<p>It says <code>coe</code>  <code>zmod p</code> <code>ℤ_[p]</code> <code>coe_to_lift</code> <code>(1 : zmod p))</code>. How do I interpret this?</p>



<a name="276114148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276114148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276114148">(Mar 21 2022 at 21:10)</a>:</h4>
<p>Hmm ... what do you get by clicking on the <code>coe_to_lift</code>?</p>



<a name="276114166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276114166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276114166">(Mar 21 2022 at 21:10)</a>:</h4>
<p>(You can keep clicking and clicking to dive deeper)</p>



<a name="276114264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276114264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276114264">(Mar 21 2022 at 21:11)</a>:</h4>
<p><code>coe_to_lift</code> <code>zmod p</code> <code>ℤ_[p]</code> <code>zmod.has_coe_t p</code></p>



<a name="276114399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276114399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276114399">(Mar 21 2022 at 21:12)</a>:</h4>
<p>And then from <code>zmod.has_coe_t p</code>:<br>
<code>zmod.has_coe_t</code> <code>ℤ_[p]</code> <code>padic_int.has_zero</code> <code>padic_int.has_one</code> <code>padic_int.has_add</code> <code>padic_int.has_neg</code> <code>p</code></p>



<a name="276114445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276114445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276114445">(Mar 21 2022 at 21:12)</a>:</h4>
<p>Right, so it's <a href="https://leanprover-community.github.io/mathlib_docs/find/zmod.has_coe_t">docs#zmod.has_coe_t</a></p>



<a name="276114676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276114676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276114676">(Mar 21 2022 at 21:13)</a>:</h4>
<p>which converts an element of <code>zmod p</code> to an element of any ring (or even any <code>R</code> satisfying <code>[has_zero R] [has_one R] [has_add R] [has_neg R]</code>)</p>



<a name="276114866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276114866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276114866">(Mar 21 2022 at 21:14)</a>:</h4>
<p>If I remember correctly, the existence of this coercion is rather controversial, since it's so clearly badly behaved on a non-char-<code>p</code> ring.</p>



<a name="276114880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276114880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276114880">(Mar 21 2022 at 21:14)</a>:</h4>
<p>But somehow I fail to see the statement that <code>1 : zmod p</code> is mapped to <code>1 : ℤ_[p]</code>...</p>



<a name="276114935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276114935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276114935">(Mar 21 2022 at 21:15)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/padic_int.coe_one">docs#padic_int.coe_one</a> ?</p>



<a name="276114961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276114961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276114961">(Mar 21 2022 at 21:15)</a>:</h4>
<p>or is that the wrong way around?</p>



<a name="276114995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276114995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276114995">(Mar 21 2022 at 21:15)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/zmod.cast_one">docs#zmod.cast_one</a> ?</p>



<a name="276115173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276115173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276115173">(Mar 21 2022 at 21:17)</a>:</h4>
<p>The first is <code>↑(1 : ℤ_[p]) = (1 : ℚ_[p])</code><br>
The second has an assumption <code>m | n</code></p>



<a name="276115290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276115290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276115290">(Mar 21 2022 at 21:18)</a>:</h4>
<p>So the challenge is to prove</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="kd">variables</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="n">nat.prime</span> <span class="n">p</span><span class="o">)]</span> <span class="o">:</span> <span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℤ_</span><span class="o">[</span><span class="n">p</span><span class="o">])</span> <span class="bp">=</span> <span class="mi">1</span>
</code></pre></div>



<a name="276115370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276115370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276115370">(Mar 21 2022 at 21:19)</a>:</h4>
<p>(deleted)</p>



<a name="276115702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276115702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276115702">(Mar 21 2022 at 21:22)</a>:</h4>
<p>Replacing <code>1</code> by <code>0</code> (on both sides <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>) is <code>zmod.cast_zero</code> (although both <code>suggest</code> and <code>library_search</code> give me a timeout).</p>



<a name="276115874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276115874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276115874">(Mar 21 2022 at 21:23)</a>:</h4>
<p>There is <code>zmod.cast_one'</code>, but it wants a target of characteristic <code>p</code>...</p>



<a name="276116891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276116891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276116891">(Mar 21 2022 at 21:32)</a>:</h4>
<p>Yeah the library lemmas seem a bit inefficient, this works, but we need the cardinality at least two (which lean knows is implied by prime)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.zmod.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="o">)]</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">cast_one</span> <span class="o">:</span> <span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">casesI</span> <span class="n">p</span><span class="o">,</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="n">apply</span> <span class="o">(</span><span class="bp">@</span><span class="n">fact.out</span> <span class="n">_</span> <span class="o">(</span><span class="n">_inst_1</span><span class="o">)),</span>
  <span class="n">casesI</span> <span class="n">p</span><span class="o">,</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="n">apply</span> <span class="o">(</span><span class="bp">@</span><span class="n">fact.out</span> <span class="n">_</span> <span class="o">(</span><span class="n">_inst_1</span><span class="o">)),</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="276116928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276116928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276116928">(Mar 21 2022 at 21:32)</a>:</h4>
<p>After that</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">[</span><span class="n">fact</span> <span class="n">p.prime</span><span class="o">]</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>works</p>



<a name="276117430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276117430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276117430">(Mar 21 2022 at 21:37)</a>:</h4>
<p>Thanks! This looks like a useful addition to the library.</p>



<a name="276117599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276117599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276117599">(Mar 21 2022 at 21:39)</a>:</h4>
<p>What is the intended mathematical content of this lemma?</p>



<a name="276117680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276117680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276117680">(Mar 21 2022 at 21:40)</a>:</h4>
<p>Why would you expect a coercion from <code>zmod p</code> to any ring?</p>



<a name="276117702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276117702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276117702">(Mar 21 2022 at 21:40)</a>:</h4>
<p>Here is now what all of this was about.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.zmod.basic</span>
<span class="kn">import</span> <span class="n">number_theory.padics</span>
<span class="kn">import</span> <span class="n">number_theory.padics.ring_homs</span> <span class="c1">-- should not be necessary?</span>
<span class="kn">import</span> <span class="n">number_theory.padics.hensel</span>
<span class="kn">import</span> <span class="n">data.polynomial.derivative</span>

<span class="kn">namespace</span> <span class="n">test</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="c1">-- From Alex J. Best:</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">cast_one</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="o">)]</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">casesI</span> <span class="n">p</span><span class="o">,</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="n">apply</span> <span class="o">(</span><span class="bp">@</span><span class="n">fact.out</span> <span class="n">_</span> <span class="o">(</span><span class="n">_inst_1</span><span class="o">)),</span>
  <span class="n">casesI</span> <span class="n">p</span><span class="o">,</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="n">apply</span> <span class="o">(</span><span class="bp">@</span><span class="n">fact.out</span> <span class="n">_</span> <span class="o">(</span><span class="n">_inst_1</span><span class="o">)),</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">square_of_principal_unit</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">[</span><span class="n">fact</span> <span class="n">p.prime</span><span class="o">]</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≠</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">ℤ_</span><span class="o">[</span><span class="n">p</span><span class="o">])</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">u.to_zmod</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">ℤ_</span><span class="o">[</span><span class="n">p</span><span class="o">],</span> <span class="n">s</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">u</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- We want to use Hensel's lemma, so set up a suitable polynomial</span>
  <span class="k">let</span> <span class="n">F</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">ℤ_</span><span class="o">[</span><span class="n">p</span><span class="o">]</span> <span class="o">:=</span> <span class="n">X</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">C</span> <span class="n">u</span><span class="o">,</span>
  <span class="c1">-- and show the relevant condition.</span>
  <span class="k">have</span> <span class="n">hnorm</span> <span class="o">:</span> <span class="bp">∥</span><span class="n">eval</span> <span class="mi">1</span> <span class="n">F</span><span class="bp">∥</span> <span class="bp">&lt;</span> <span class="bp">∥</span><span class="n">eval</span> <span class="mi">1</span> <span class="o">(</span><span class="n">derivative</span> <span class="n">F</span><span class="o">)</span><span class="bp">∥^</span><span class="mi">2</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span>
       <span class="k">have</span> <span class="n">h₂</span> <span class="o">:</span> <span class="bp">∥</span><span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℤ_</span><span class="o">[</span><span class="n">p</span><span class="o">])</span><span class="bp">∥</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
       <span class="kd">by</span> <span class="o">{</span> <span class="n">change</span> <span class="bp">∥</span><span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℚ_</span><span class="o">[</span><span class="n">p</span><span class="o">])</span><span class="bp">∥</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
            <span class="n">rw</span> <span class="o">[(</span><span class="kd">by</span> <span class="n">norm_cast</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℚ_</span><span class="o">[</span><span class="n">p</span><span class="o">])</span> <span class="bp">=</span> <span class="o">((</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℚ_</span><span class="o">[</span><span class="n">p</span><span class="o">])),</span> <span class="n">padic_norm_e.eq_padic_norm</span><span class="o">],</span>
            <span class="n">norm_cast</span><span class="o">,</span>
            <span class="n">rw</span> <span class="o">[(</span><span class="kd">by</span> <span class="n">norm_cast</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">↑</span><span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)),</span> <span class="n">padic_norm.padic_norm_of_prime_of_ne</span> <span class="n">hp</span><span class="o">],</span> <span class="o">},</span>
       <span class="n">simp</span> <span class="o">[</span><span class="n">h₂</span><span class="o">],</span>
       <span class="k">have</span> <span class="n">h₃</span> <span class="o">:=</span> <span class="n">padic_int.to_zmod_spec</span> <span class="n">u</span><span class="o">,</span>
       <span class="n">simp</span> <span class="o">[</span><span class="n">hu</span><span class="o">]</span> <span class="n">at</span> <span class="n">h₃</span><span class="o">,</span>
       <span class="n">rw</span> <span class="o">[</span><span class="n">norm_sub_rev</span><span class="o">]</span> <span class="n">at</span> <span class="n">h₃</span><span class="o">,</span>
       <span class="n">exact</span> <span class="n">h₃</span><span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">hensels_lemma</span> <span class="n">hnorm</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">s</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">s</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hensel</span> <span class="o">:=</span> <span class="n">h.left</span><span class="o">,</span> <span class="n">clear</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">F</span><span class="o">]</span> <span class="n">at</span> <span class="n">hensel</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sub_eq_zero</span> <span class="n">at</span> <span class="n">hensel</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hensel</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">test</span>
</code></pre></div>



<a name="276117740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276117740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276117740">(Mar 21 2022 at 21:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/Show.20explicit.20coercions.3F/near/276117680">said</a>:</p>
<blockquote>
<p>Why would you expect a coercion from <code>zmod p</code> to any ring?</p>
</blockquote>
<p>Patrick, sadly, we have this coercion and it's used in several places :). <a href="https://leanprover-community.github.io/mathlib_docs/find/zmod.has_coe_t">docs#zmod.has_coe_t</a></p>



<a name="276117758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276117758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276117758">(Mar 21 2022 at 21:40)</a>:</h4>
<p>I'd be interested in seeing how one can do this (i.e., mostly the proof of <code>hnorm</code>) more elegantly.</p>



<a name="276117896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276117896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276117896">(Mar 21 2022 at 21:42)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> <span class="user-mention" data-user-id="260507">@Heather Macbeth</span>  The point is <a href="https://leanprover-community.github.io/mathlib_docs/find/padic_int.to_zmod_spec">docs#padic_int.to_zmod_spec</a>, which uses exactly this map.</p>



<a name="276117951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276117951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276117951">(Mar 21 2022 at 21:42)</a>:</h4>
<p>There is even an issue to remove it: <a href="https://github.com/leanprover-community/mathlib/pull/3975">#3975</a></p>



<a name="276118161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276118161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276118161">(Mar 21 2022 at 21:44)</a>:</h4>
<p>This map really sounds like a very bad idea.</p>



<a name="276118267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276118267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276118267">(Mar 21 2022 at 21:45)</a>:</h4>
<p>In the context of p-adic numbers, one wants to have a map that sends a p-adic integer to an approximation in the integers (or naturals), so something like that will be necessary.</p>



<a name="276118481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276118481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276118481">(Mar 21 2022 at 21:47)</a>:</h4>
<p>Probably if we had the teichmuller lift as a map from <code>zmod p</code> to <code>Z_p</code> in mathlib that could replace the coe in <a href="https://leanprover-community.github.io/mathlib_docs/find/padic_int.to_zmod_spec">docs#padic_int.to_zmod_spec</a> and everyone would be happy, but as far as I know we don't have it in this context yet (though it is there for Witt vectors)</p>



<a name="276118818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276118818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276118818">(Mar 21 2022 at 21:51)</a>:</h4>
<p>I think one definitely wants a map to ℕ or ℤ here. The Teichmüller lift would also be useful, but would not be an adequate replacement.</p>



<a name="276119132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276119132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276119132">(Mar 21 2022 at 21:54)</a>:</h4>
<p>Also, it is not just about ℤ/pℤ, but also ℤ/p^nℤ...</p>



<a name="276148499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276148499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276148499">(Mar 22 2022 at 06:38)</a>:</h4>
<p><span class="user-mention" data-user-id="479359">@Michael Stoll</span> I agree the map should be there. But I think it shouldn't be a coercion.<br>
We have <a href="https://github.com/leanprover-community/mathlib/pull/3975">#3975</a> to remind us that this coercion should be down-graded to an ordinary map. I haven't actually done the work yet.</p>



<a name="276159807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276159807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276159807">(Mar 22 2022 at 09:12)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I think what is missing is something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">padic_int.to_zmod_spec</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="n">nat.prime</span> <span class="n">p</span><span class="o">)]</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℤ_</span><span class="o">[</span><span class="n">p</span><span class="o">])</span> <span class="o">:</span> <span class="n">z.to_zmod.val</span> <span class="bp">=</span> <span class="n">z.zmod_repr</span> <span class="o">:=</span> <span class="bp">...</span>
<span class="kd">theorem</span> <span class="n">padic_int.to_zmod_pow_spec</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="n">nat.prime</span> <span class="n">p</span><span class="o">)]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℤ_</span><span class="o">[</span><span class="n">p</span><span class="o">])</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⇑</span><span class="o">(</span><span class="n">padic_int.to_zmod_pow</span> <span class="n">n</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">z.appr</span> <span class="n">n</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>Then one can do reasonable computations.</p>



<a name="276159880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276159880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276159880">(Mar 22 2022 at 09:12)</a>:</h4>
<p>As a side note, I would suggest to switch the arguments of <code>padic_int.to_zmopd_pow</code> so that one can write <code>z.to_zmod_pow n</code> instead of <code>padic_int.to_zmod_pow n z</code>.</p>



<a name="276159903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276159903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276159903">(Mar 22 2022 at 09:13)</a>:</h4>
<p>I think you should still be able to do that. Does it fail?</p>



<a name="276160004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276160004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276160004">(Mar 22 2022 at 09:14)</a>:</h4>
<p>I haven't tried yet. I assume the proofs should be easy, since this should be basically the definition of <code>to_zmod</code>/<code>to_zmod_pow</code>.</p>



<a name="276160014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276160014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276160014">(Mar 22 2022 at 09:14)</a>:</h4>
<p><code>X.foobar Y</code> looks at the type of <code>X</code>, say <code>quux</code>, and then looks up the declaration <code>quux.foobar</code>. It then plugs <code>X</code> into the first explicit argument with type <code>quux</code>. But <code>X</code> doesn't need to be the first explicit argument. Just the first one with type <code>quux</code>.</p>



<a name="276160059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276160059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276160059">(Mar 22 2022 at 09:15)</a>:</h4>
<p>IIRC, when I tried to write <code>z.to_zmod_pow n</code>, it complained...</p>



<a name="276160097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276160097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276160097">(Mar 22 2022 at 09:15)</a>:</h4>
<p>Perhaps because nat has a coercion to p-adic integers?</p>



<a name="276160267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276160267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276160267">(Mar 22 2022 at 09:17)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℤ_</span><span class="o">[</span><span class="mi">2</span><span class="o">])</span>

<span class="k">#check</span> <span class="n">z.to_zmod_pow</span> <span class="mi">3</span>
</code></pre></div>
<p>gives <code>invalid field notation, function 'padic_int.to_zmod_pow' does not have explicit argument with type (padic_int ...)
</code></p>



<a name="276160375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276160375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276160375">(Mar 22 2022 at 09:18)</a>:</h4>
<p><code>#check padic_int.to_zmod_pow</code> --&gt; <code>Π (n : ℕ), ℤ_[?M_1] →+* zmod (?M_1 ^ n)</code></p>



<a name="276160390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276160390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276160390">(Mar 22 2022 at 09:18)</a>:</h4>
<p>Hmm, that's a surprising error message. Because it clearly does have such an explicit argument.</p>



<a name="276160445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276160445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276160445">(Mar 22 2022 at 09:19)</a>:</h4>
<p>There is an implicit ⇑ involved, but I have no idea whether this is relevant.</p>



<a name="276160763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276160763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276160763">(Mar 22 2022 at 09:22)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> Do you understand what's going on?</p>



<a name="276160976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276160976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276160976">(Mar 22 2022 at 09:24)</a>:</h4>
<p>While trying to prove the first of the two <code>theorems</code> I stated above:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">padic_int.to_zmod_spec</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="n">nat.prime</span> <span class="n">p</span><span class="o">)]</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℤ_</span><span class="o">[</span><span class="n">p</span><span class="o">]):</span>
  <span class="n">z.to_zmod.val</span> <span class="bp">=</span> <span class="n">z.zmod_repr</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">padic_int.to_zmod</span><span class="o">,</span> <span class="n">padic_int.to_zmod_hom</span><span class="o">,</span> <span class="n">padic_int.zmod_repr</span><span class="o">],</span>
  <span class="c1">-- turns the goal into ↑(classical.some _).val = classical.some _</span>
  <span class="c1">-- what to do with that?</span>
<span class="kd">end</span>
</code></pre></div>



<a name="276161130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276161130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276161130">(Mar 22 2022 at 09:25)</a>:</h4>
<p>That doesn't look pleasant.</p>



<a name="276161192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276161192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276161192">(Mar 22 2022 at 09:26)</a>:</h4>
<p>Let me take a look</p>



<a name="276161268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276161268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276161268">(Mar 22 2022 at 09:27)</a>:</h4>
<p>Shouldn't there be a constructive way of defining <code>to_zmod</code>? By definition of a Cauchy sequence, there must be an index <code>n</code> such that the corresponding and all following terms have nonnegative valuation and the lowest p-adic bit stays fixed; then take the image of that term.</p>



<a name="276161428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276161428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276161428">(Mar 22 2022 at 09:28)</a>:</h4>
<p>That would require the homomorphism from <code>{x : ℚ // ¬ p ∣ x.denom}</code> (i.e., the localization of  ℤ at the prime ideal generated by <code>p</code>) to <code>zmod p</code>. Is this available?</p>



<a name="276161785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276161785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276161785">(Mar 22 2022 at 09:32)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">padic_int.to_zmod_spec'</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="n">nat.prime</span> <span class="n">p</span><span class="o">)]</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℤ_</span><span class="o">[</span><span class="n">p</span><span class="o">])</span> <span class="o">:</span>
  <span class="n">z.to_zmod.val</span> <span class="bp">=</span> <span class="n">z.zmod_repr</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">padic_int.to_zmod</span><span class="o">,</span> <span class="n">padic_int.to_zmod_hom</span><span class="o">,</span> <span class="n">ring_hom.coe_mk</span><span class="o">],</span>
  <span class="n">rw</span> <span class="n">zmod.val_cast_of_lt</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">padic_int.zmod_repr_lt_p</span> <span class="n">z</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="276161807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276161807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276161807">(Mar 22 2022 at 09:32)</a>:</h4>
<p>Note that I added a <code>'</code> to the name, to avoid a conflict.</p>



<a name="276161887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276161887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276161887">(Mar 22 2022 at 09:33)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">padic_int.to_zmod_spec'</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="n">nat.prime</span> <span class="n">p</span><span class="o">)]</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℤ_</span><span class="o">[</span><span class="n">p</span><span class="o">]):</span>
  <span class="n">z.to_zmod.val</span> <span class="bp">=</span> <span class="n">z.zmod_repr</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ring_hom.coe_mk</span><span class="o">,</span> <span class="n">padic_int.to_zmod</span><span class="o">,</span> <span class="n">padic_int.to_zmod_hom</span><span class="o">],</span>
  <span class="n">rw</span> <span class="n">zmod.val_cast_of_lt</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">padic_int.zmod_repr_lt_p</span> <span class="n">z</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>... pretty close :)</p>



<a name="276162134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276162134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276162134">(Mar 22 2022 at 09:36)</a>:</h4>
<p>OK, then also:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">padic_int.to_zmod_pow_spec'</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="n">nat.prime</span> <span class="n">p</span><span class="o">)]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℤ_</span><span class="o">[</span><span class="n">p</span><span class="o">])</span> <span class="o">:</span>
  <span class="o">((</span><span class="n">padic_int.to_zmod_pow</span> <span class="n">n</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">z.appr</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">padic_int.to_zmod_pow</span><span class="o">,</span> <span class="n">padic_int.to_zmod_hom</span><span class="o">,</span> <span class="n">ring_hom.coe_mk</span><span class="o">],</span>
  <span class="n">rw</span> <span class="n">zmod.val_cast_of_lt</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">padic_int.appr_lt</span> <span class="n">z</span> <span class="n">n</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="276162327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276162327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276162327">(Mar 22 2022 at 09:39)</a>:</h4>
<p>As a general remark, if your goal looks like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- turns the goal into ↑(classical.some _).val = classical.some _</span>
</code></pre></div>
<p>then you have most likely unfolded one definition too many.</p>



<a name="276162347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276162347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276162347">(Mar 22 2022 at 09:39)</a>:</h4>
<p>But if you can redefine it without <code>classical.some</code>, it may be worth doing so</p>



<a name="276162349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276162349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276162349">(Mar 22 2022 at 09:39)</a>:</h4>
<p>In this case the definition of <code>zmod.repr</code></p>



<a name="276162505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276162505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276162505">(Mar 22 2022 at 09:41)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/zmod.repr">docs#zmod.repr</a> doesn't seem to exist</p>



<a name="276162538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276162538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276162538">(Mar 22 2022 at 09:41)</a>:</h4>
<p>Ah, <a href="https://leanprover-community.github.io/mathlib_docs/find/padic_int.zmod_repr">docs#padic_int.zmod_repr</a></p>



<a name="276162677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276162677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276162677">(Mar 22 2022 at 09:43)</a>:</h4>
<p>Sorry, my bad</p>



<a name="276167240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276167240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276167240">(Mar 22 2022 at 10:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/113489-new-members/topic/Show.20explicit.20coercions.3F/near/276161268">said</a>:</p>
<blockquote>
<p>Shouldn't there be a constructive way of defining <code>to_zmod</code>? By definition of a Cauchy sequence, there must be an index <code>n</code> such that the corresponding and all following terms have nonnegative valuation and the lowest p-adic bit stays fixed; then take the image of that term.</p>
</blockquote>
<p>I don't think this is enough to compute with, as "the corresponding and all following terms have nonnegative valuation" doesn't look like a decidable predicate to me.</p>



<a name="276173485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276173485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276173485">(Mar 22 2022 at 11:24)</a>:</h4>
<p>Right, you would need to work with modulated Cauchy sequences: don't just take a quotient of (sequences such that for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>, there exists <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>, ...) but rather a quotient of (sequences together with a modulus of convergence function sending <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>)</p>



<a name="276174520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276174520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276174520">(Mar 22 2022 at 11:34)</a>:</h4>
<p>OK, I guess I'll leave this for the time being.</p>



<a name="276238350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276238350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276238350">(Mar 22 2022 at 18:56)</a>:</h4>
<p>If one does not take the route to define ℚ_p as a completion of ℚ and then ℤ_p as a subring of ℚ_p, but instead defines ℤ_p as the projective limit of the finite rings ℤ/p^nℤ and then ℚ_p as its field of fractions (or by inverting p), the maps from ℤ_p to ℤ/pℤ etc. would be constructive and immediate.</p>



<a name="276239350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276239350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276239350">(Mar 22 2022 at 19:02)</a>:</h4>
<p>I was discussing with a post-doc the idea of refactoring Q_p so it's defined the "Bourbaki way" as the uniform space completion of Q with respect to the uniform structure coming from the p-adic metric. But I'm not sure it's worth it.</p>



<a name="276240673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276240673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276240673">(Mar 22 2022 at 19:13)</a>:</h4>
<p>My point is that I want to <em>use</em> p-adics, in particular to do computations with them. For this, the more concrete the construction is, the better.</p>



<a name="276241126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276241126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276241126">(Mar 22 2022 at 19:17)</a>:</h4>
<p>Does it really make a difference what the construction is? Can't you write tactics to do computations? I don't know anything about these matters but with Lean 4 around the corner (where computations will become feasible) I'm interested to hear what you mean. What kind of computations?</p>



<a name="276243059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276243059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276243059">(Mar 22 2022 at 19:33)</a>:</h4>
<p>My fairly immediate concern is to be able to prove statements like "if z = 1 mod 8 in ℤ_2, then z is a square" without having to go through contortions. For this, it would be advantageous (or so I think) to have the maps to the finite ring quotients in a fairly explicit way, so that it is easy to use them (instead of having to go via the p-adic norm, for example).</p>



<a name="276251270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276251270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276251270">(Mar 22 2022 at 20:42)</a>:</h4>
<p>I had similar concerns when I started using Lean.  However, my impression now is that the definition is actually irrelevant, as long as it is equivalent to the definition that you want.</p>
<p>What is certainly important is that one of the lemmas is going to say that elements of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">Z</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{Z}_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> are coherent sequences elements of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><msup><mi>p</mi><mi>n</mi></msup><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}/p^n\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Z</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord mathbb">Z</span></span></span></span>.</p>
<p>Of course, there should be a proof of Hensel's lemma as well.</p>
<p>Michael, I think that the contortions that you are worrying about will involve the first few lemmas after the actual definition.  Once those are done, I imagine that what the definition actually was will be irrelevant.</p>



<a name="276251896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276251896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276251896">(Mar 22 2022 at 20:47)</a>:</h4>
<p>My impression, during the Witt vector project, was that the API for <code>ℤ_[p]</code> would be easier to setup if the definition is the algebraic one.</p>



<a name="276251911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276251911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276251911">(Mar 22 2022 at 20:47)</a>:</h4>
<p>But I never tested that claim</p>



<a name="276252012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276252012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276252012">(Mar 22 2022 at 20:48)</a>:</h4>
<p>One hybrid approach would be to take the analytic definition of <code>ℚ_[p]</code> and the algebraic definition of <code>ℤ_[p]</code>. And then show <code>is_fraction_ring</code> to glue the two together.</p>



<a name="276252271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276252271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276252271">(Mar 22 2022 at 20:50)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> A version of <a href="https://leanprover-community.github.io/mathlib_docs/find/hensels_lemma">docs#hensels_lemma</a> is actually there. However, I've written a variant (the simpler version using that the reduction mod p is zero for the polynomial and nonzero for the derivative) that I hope will be easier to apply.</p>



<a name="276252282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276252282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276252282">(Mar 22 2022 at 20:50)</a>:</h4>
<p>Could there be a coercion from <code>ℤ_[p]</code> to <code>ℚ_[p]</code> with the hybrid approach?  Maybe the answer is trivially yes, I'm not sure...</p>



<a name="276252482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276252482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276252482">(Mar 22 2022 at 20:52)</a>:</h4>
<p>Yes, but maybe not trivially yes (-;</p>



<a name="276252528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276252528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276252528">(Mar 22 2022 at 20:53)</a>:</h4>
<p>Where I had to go through contortions was here (not directly related to p-adics):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">two_nonzero_mod_odd_prime</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">[</span><span class="n">fact</span> <span class="n">p.prime</span><span class="o">]</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≠</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">(</span><span class="kd">by</span> <span class="n">norm_cast</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="o">((</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)),</span>
  <span class="n">intro</span> <span class="n">hf</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">zmod.int_coe_zmod_eq_zero_iff_dvd</span> <span class="n">at</span> <span class="n">hf</span><span class="o">,</span>
  <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">hf</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">nat.prime_dvd_prime_iff_eq</span> <span class="n">_inst_1.1</span> <span class="n">nat.prime_two</span> <span class="n">at</span> <span class="n">hf</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hp</span> <span class="n">hf</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>I'm wondering how to deal with this in a better way. Any suggestions?</p>



<a name="276252530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276252530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276252530">(Mar 22 2022 at 20:53)</a>:</h4>
<p><span class="user-mention" data-user-id="479359">@Michael Stoll</span> Note that there is also <a href="https://leanprover-community.github.io/mathlib_docs/find/henselian_ring">docs#henselian_ring</a>. And mathlib knows that <code>ℤ_[p]</code> is an example.</p>



<a name="276252538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276252538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276252538">(Mar 22 2022 at 20:53)</a>:</h4>
<p>Michael, I think that what you are doing is precisely developping the API to make "some" definition workable.  This is exactly what needs to be done and what ultimately makes the initial definition irrelevant, since all the ways in which you might want to use it have already been implemented.</p>



<a name="276252693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276252693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276252693">(Mar 22 2022 at 20:54)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/henselian_local_ring.tfae">docs#henselian_local_ring.tfae</a> gives some versions of Hensel's lemma. But other versions are missing, because the proof is actually non-trivial that they are equivalent. You need a bunch about etale maps, iirc</p>



<a name="276252806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276252806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276252806">(Mar 22 2022 at 20:55)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Henselian rings feel way more abstract than what I need...</p>



<a name="276252936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276252936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276252936">(Mar 22 2022 at 20:56)</a>:</h4>
<p>Michael I'm not at a computer right now, but I would try to prove that 2 &lt; p, being p prime and not two and then use that to conclude the incongruence.  I'm not sure whether it would be faster or not, though...</p>



<a name="276253310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276253310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276253310">(Mar 22 2022 at 20:59)</a>:</h4>
<p>OK, here is a one-liner: <code>exact_mod_cast zmod.prime_ne_zero p 2 hp</code><br>
EDIT: ...which is not found by <code>library_search</code> or <code>suggest using hp</code>.</p>



<a name="276253692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276253692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276253692">(Mar 22 2022 at 21:02)</a>:</h4>
<p>It seems to me that we need to figure out how to fill in the following blank:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">number_theory.number_field</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">number_field</span> <span class="n">K</span><span class="o">]</span>

<span class="kd">class</span> <span class="n">is_completion</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">ideal</span> <span class="o">(</span><span class="n">number_field.ring_of_integers</span> <span class="n">K</span><span class="o">))</span> <span class="o">(</span><span class="n">hP</span> <span class="o">:</span> <span class="n">P.is_prime</span><span class="o">)</span>
  <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span> <span class="o">:=</span> <span class="n">_</span>
</code></pre></div>



<a name="276253817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276253817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276253817">(Mar 22 2022 at 21:03)</a>:</h4>
<p>I think a student of <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> has done something related.</p>



<a name="276256762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276256762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276256762">(Mar 22 2022 at 21:24)</a>:</h4>
<p>The dumb thing you can do is just ask for a K-algebra isomorphism to the completion (which Maria has, as Michael says).</p>



<a name="276268494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Show%20explicit%20coercions%3F/near/276268494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Show.20explicit.20coercions.3F.html#276268494">(Mar 22 2022 at 23:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/113489-new-members/topic/Show.20explicit.20coercions.3F/near/276253310">said</a>:</p>
<blockquote>
<p>OK, here is a one-liner: <code>exact_mod_cast zmod.prime_ne_zero p 2 hp</code><br>
EDIT: ...which is not found by <code>library_search</code> or <code>suggest using hp</code>.</p>
</blockquote>
<p>Library search and suggest will only ever really find one refine or exact statement that matches the goal. So specialized tactics like exact_mod_cast can definitely do more in the situations they are designed for.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
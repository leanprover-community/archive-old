---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html">How do I make a type class instance of a finset</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="219744963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219744963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219744963">(Dec 13 2020 at 05:17)</a>:</h4>
<p>This works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kd">def</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">fin</span> <span class="mi">3</span>
<span class="kd">instance</span> <span class="n">X_has_one</span> <span class="o">:</span> <span class="n">has_one</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">fin.has_one</span>
</code></pre></div>
<p>This does not work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kd">def</span> <span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">X_one</span> <span class="o">:</span> <span class="n">X</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="kd">instance</span> <span class="n">X_has_one</span> <span class="o">:</span> <span class="n">has_one</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">one</span> <span class="o">:=</span> <span class="n">X_one</span> <span class="o">}</span>
</code></pre></div>
<p>Is there a way to make it work?  The main error is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="bp">⊢</span> <span class="n">has_one</span> <span class="bp">↥</span><span class="n">X</span>
<span class="n">All</span> <span class="n">Messages</span> <span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>and I don't know how to make a type class instance of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">finset</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">nodup</span> <span class="o">:</span> <span class="n">nodup</span> <span class="n">val</span><span class="o">)</span>
</code></pre></div>



<a name="219746569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219746569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219746569">(Dec 13 2020 at 06:09)</a>:</h4>
<p>Well the only way lean knows what the symbol 1 means is via a <code>has_one</code>  instance, so what you've written is circular.</p>



<a name="219746573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219746573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219746573">(Dec 13 2020 at 06:09)</a>:</h4>
<p>By writing <code>X_one : X</code>  you are coercing the set of naturals <code>X</code> into a type, which is what the up arrow means</p>



<a name="219746629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219746629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219746629">(Dec 13 2020 at 06:11)</a>:</h4>
<p>This type is then the subtype <code>{x : nat // x \in {1,2,3}</code>  so to make an element we give  a pair of a natural number, and a proof it is in the set <code>{1,2,3}</code></p>



<a name="219746633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219746633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219746633">(Dec 13 2020 at 06:11)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">X_one</span> <span class="o">:</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span><span class="n">set.mem_insert</span> <span class="mi">1</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∨</span> <span class="n">list.mem</span> <span class="n">b</span> <span class="o">[</span><span class="mi">3</span><span class="o">])⟩</span>
</code></pre></div>
<p>works (via library search so the proof is kinda random)</p>



<a name="219746750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219746750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219746750">(Dec 13 2020 at 06:15)</a>:</h4>
<p>To make a finset you must provide both these fields like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">my_finset</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">val</span> <span class="o">:=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span>
  <span class="n">nodup</span> <span class="o">:=</span> <span class="n">multiset.erase_dup_eq_self.mp</span> <span class="n">rfl</span><span class="o">}</span>
</code></pre></div>
<p>once again i used library search to find a proof of the second, in general what you write for nodup will depend on the form of val</p>



<a name="219764690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219764690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219764690">(Dec 13 2020 at 14:50)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="127136">@Alex J. Best</span> , from your advice, this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kd">def</span> <span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">X_one</span> <span class="o">:</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span><span class="n">set.mem_insert</span> <span class="mi">1</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∨</span> <span class="n">list.mem</span> <span class="n">b</span> <span class="o">[</span><span class="mi">3</span><span class="o">])⟩</span>
<span class="kd">instance</span> <span class="n">X_has_one</span> <span class="o">:</span> <span class="n">has_one</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">one</span> <span class="o">:=</span> <span class="n">X_one</span> <span class="o">}</span>
</code></pre></div>



<a name="219764987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219764987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219764987">(Dec 13 2020 at 14:58)</a>:</h4>
<p>(deleted)</p>



<a name="219765915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219765915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219765915">(Dec 13 2020 at 15:22)</a>:</h4>
<blockquote>
<p><code>set.mem_insert 1 (λ (b : ℕ), b = 2 ∨ list.mem b [3])</code></p>
</blockquote>
<p>wow that's a really unique way to write <code>1 \in {1,2,3}</code></p>



<a name="219765972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219765972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219765972">(Dec 13 2020 at 15:23)</a>:</h4>
<p>The theorem you are claiming is false</p>



<a name="219766024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219766024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219766024">(Dec 13 2020 at 15:24)</a>:</h4>
<p>it is not true that <code>{1} \cap \empty = {1}</code></p>



<a name="219767774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219767774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219767774">(Dec 13 2020 at 16:10)</a>:</h4>
<p>I think Lars wants 1 to be univ</p>



<a name="219770012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219770012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219770012">(Dec 13 2020 at 17:05)</a>:</h4>
<p>DONE, thanks!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset.basic</span>

<span class="kd">def</span> <span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">PX_mul</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∩</span> <span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>
<span class="kd">instance</span> <span class="n">PX_has_mul</span> <span class="o">:</span> <span class="n">has_mul</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="n">PX_mul</span> <span class="o">⟩</span>

<span class="kd">theorem</span> <span class="n">PX_mul_assoc</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span>  <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="n">inf_assoc</span>

<span class="kd">instance</span> <span class="n">PX_semigroup</span> <span class="o">:</span> <span class="n">semigroup</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="n">PX_mul</span><span class="o">,</span> <span class="n">PX_mul_assoc</span> <span class="o">⟩</span>

<span class="kd">instance</span> <span class="n">PX_has_one</span> <span class="o">:</span> <span class="n">has_one</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">one</span> <span class="o">:=</span> <span class="n">set.univ</span> <span class="o">}</span>  <span class="c1">-- OK</span>

<span class="kd">lemma</span> <span class="n">PX_one_mul</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">top_inf_eq</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">PX_mul_one</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">inf_top_eq</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">instance</span> <span class="n">PX_monoid</span> <span class="o">:</span> <span class="n">monoid</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="n">PX_has_one.one</span><span class="o">,</span>
  <span class="n">mul</span> <span class="o">:=</span> <span class="n">PX_mul</span><span class="o">,</span>
  <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="n">PX_mul_assoc</span><span class="o">,</span>
  <span class="n">one_mul</span> <span class="o">:=</span> <span class="n">PX_one_mul</span><span class="o">,</span>
  <span class="n">mul_one</span> <span class="o">:=</span> <span class="n">PX_mul_one</span>
<span class="o">}</span>
</code></pre></div>



<a name="219770161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219770161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219770161">(Dec 13 2020 at 17:09)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">def</span> <span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span>

<span class="bp">...</span>
</code></pre></div>
<p>would be a saner way to start. This has nothing to do with finsets.</p>



<a name="219770230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219770230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219770230">(Dec 13 2020 at 17:11)</a>:</h4>
<p>and</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">PX_monoid</span> <span class="o">:</span> <span class="n">monoid</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">mul</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">*</span><span class="o">),</span>
<span class="bp">...</span>
</code></pre></div>
<p>is a better way to finish, because you want to stick as much as possible to <code>has_mul.mul</code> and <code>has_one.one</code> rather than anything defeq to them.</p>



<a name="219770370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219770370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219770370">(Dec 13 2020 at 17:14)</a>:</h4>
<p>You should learn the trick of moving stuff before the colon in the statements of the lemmas; this saves you having to <code>intro</code> in the proofs, which saves a line. In fact with stuff like <code>mul_one</code> you don't even need to use tactic mode with this trick:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">PX_mul_one</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">inf_top_eq</span>
</code></pre></div>
<p>Finally, instead of all this <code>PX_</code> stuff you should just go into a namespace and call your lemmas what they want to be called, e.g. <code>mul_one</code>. Rigidly sticking to the naming conventions makes everyone's lives easier.</p>



<a name="219771129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219771129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219771129">(Dec 13 2020 at 17:36)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  here is the revised example.   It doesn't require <code>import tactic</code>.  When would I use that?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset.basic</span>

<span class="kn">namespace</span> <span class="n">finite_monoid_example</span>

<span class="kd">def</span> <span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">mul</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∩</span> <span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mul</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="n">mul</span> <span class="o">⟩</span>
<span class="kd">lemma</span> <span class="n">mul_assoc</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="n">inf_assoc</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="n">set.univ</span> <span class="o">⟩</span>
<span class="kd">lemma</span> <span class="n">one_mul</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">top_inf_eq</span>
<span class="kd">lemma</span> <span class="n">mul_one</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">):</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">inf_top_eq</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">monoid</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">mul</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">*</span><span class="o">),</span>
  <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="n">mul_assoc</span><span class="o">,</span>
  <span class="n">one_mul</span> <span class="o">:=</span> <span class="n">one_mul</span><span class="o">,</span>
  <span class="n">mul_one</span> <span class="o">:=</span> <span class="n">mul_one</span>
<span class="o">}</span>

<span class="kd">end</span> <span class="n">finite_monoid_example</span>
</code></pre></div>



<a name="219773057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219773057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219773057">(Dec 13 2020 at 18:23)</a>:</h4>
<p>Importing finsets for the sole reason of creating a finset and then instantly coercing it to a set seems a bit crazy to me. I imported tactic because I import this every time I use Lean. I imported it on this occasiont simply because it gave me stuff like <code>monoid</code>.</p>



<a name="219776242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219776242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219776242">(Dec 13 2020 at 19:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> , for self-training, I am filling out finite nontrivial concrete set examples for each box in this picture:</p>
<p><a href="/user_uploads/3121/v-M_BlwgIfPfM0adMFktRFwa/Screenshot-from-2020-12-12-09-15-45.png">Screenshot-from-2020-12-12-09-15-45.png</a> </p>
<div class="message_inline_image"><a href="/user_uploads/3121/v-M_BlwgIfPfM0adMFktRFwa/Screenshot-from-2020-12-12-09-15-45.png" title="Screenshot-from-2020-12-12-09-15-45.png"><img src="/user_uploads/3121/v-M_BlwgIfPfM0adMFktRFwa/Screenshot-from-2020-12-12-09-15-45.png"></a></div><p>I find filling out each box to be a challenge.  I am using two representations of the finite concrete nontrivial set <code>{0,1,2}</code> because they sometimes work exactly the same and sometimes don't, so I learn little bits of stuff when they work differently.  The two representations are <code>def X := fin 3</code> and <code>def X : set ℕ := ({0,1,2} : finset ℕ)</code>.   You could view these exercises as redundant, trivial and a bit crazy.  I still find them hard to perform correctly.</p>
<p>I'm not trying to come up with anything new.  I'm just trying to learn how to work with lean.   I never took an algebra course in college.  I only understand things that I can program.   When I am done, if quizzed on the street, I should be able to tell the difference between a canonically ordered additive monoid and a commutative semiring, and I should be able to give practical, simple, nontrivial examples of each structure.</p>



<a name="219776330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219776330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219776330">(Dec 13 2020 at 19:26)</a>:</h4>
<p>You will find it a lot easier to use examples like <code>int</code> rather than finite sets</p>



<a name="219776419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219776419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219776419">(Dec 13 2020 at 19:28)</a>:</h4>
<p>My point is simply that you are using <code>finset</code> to make a set, and you can just make the set directly with the same notation <code>{1,2,3}</code>.</p>



<a name="219776535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219776535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219776535">(Dec 13 2020 at 19:31)</a>:</h4>
<p>not sure if your picture goes as far as ordered rings but I can tell you <code>{1,2,3}</code> isn't one</p>



<a name="219777003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219777003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219777003">(Dec 13 2020 at 19:40)</a>:</h4>
<p>The naturals will be a nice example of pretty much all of these. I wrote the natural number game by trying to construct loads of typeclass instances on the naturals and then it was just a case of sorting everything into some kind of order which didn't introduce too many tactics all at once</p>



<a name="219777076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219777076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219777076">(Dec 13 2020 at 19:41)</a>:</h4>
<p>I was genuinely stunned to find that I could construct the commutative semiring instance on nat with just <code>rw</code>, <code>refl</code> and <code>induction</code>. I mentioned this to Jeremy and he laughed at me :-) and said something about equational theories which I didn't understand. mathematicians don't really need to understand mathematics in some sense</p>



<a name="219777146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219777146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219777146">(Dec 13 2020 at 19:42)</a>:</h4>
<p>I mean they don't need to understand the way it works under the hood</p>



<a name="219777165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219777165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219777165">(Dec 13 2020 at 19:43)</a>:</h4>
<p>On the other hand proving it was a partial order needed loads of tactics</p>



<a name="219784689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219784689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219784689">(Dec 13 2020 at 22:18)</a>:</h4>
<p>Most of these work for ℕ as one-liners. The point of the {0,1,2} or {1,2,3} examples is that they make me do a little more work.  Also, if I try to do ordered ring with {1,2,3} and it doesn't go through, then I have to think harder about ordered rings and if there is a nontrivial finite example and then construct that.  I say <code>nontrivial</code> in the Lean technical sense because it makes it a little more challenging.   I.e. there are probably trivial instances of ordered ring that are provable with less effort, but not in a way that generalizes. I feel like {0,1,2} proofs are more likely to generalize to the ℕ case, so I get more intuition from doing them than from doing proofs for trivial sets.</p>
<p>I'm trying to firm up my mathematical education by going through these kinds of exercises.  I am building up a vocabulary I haven't yet acquired.  I don't know enough to easily see that  {1,2,3} isn't an ordered ring.  Lean is perfect in that regard because every assumption about an object can be clearly stated and clearly verified.  There is no hand-waving.  I see it as a mental prosthetic which will help me acquire and learn how to work with concepts that were previously too daunting or mysterious to approach, like the construction of the reals or the Lebesgue integral.</p>



<a name="219786400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219786400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219786400">(Dec 13 2020 at 22:57)</a>:</h4>
<p>Learning mathematics by doing it in Lean seems very difficult. My successful students at Imperial are the ones who know the maths already and learn formalising by formalising mathematics they can do already on paper.</p>



<a name="219786423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219786423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219786423">(Dec 13 2020 at 22:57)</a>:</h4>
<p>Two educationalists did a study on one of my courses and this was one of their main conclusions.</p>



<a name="219786475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219786475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219786475">(Dec 13 2020 at 22:58)</a>:</h4>
<p>Next term I'm going to be teaching undergraduate mathematics in lean to PhD students and I'm very excited about this because here everyone will know all the mathematical material already so it will be a very different experience to what people like Heather, Patrick and I have experienced before</p>



<a name="219794003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219794003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219794003">(Dec 14 2020 at 02:26)</a>:</h4>
<p>My self-assessment is that what I am doing (stepping through these exercises) is the path most likely to give me insight.  </p>
<p>I have a practical goal, which is to teach friends about strong and weak numerical approximations of stochastic processes using various kinds of discretizations involving stochastic Taylor series expansions of Ito and Stratonovich integrals.  Formalizing and checking definitions related to this in Lean seems to me like the shortest path to being able to explain the material to others.  </p>
<p>That may seem a little far-fetched, but I feel like Lean will give me a bionic exoskeleton comfort level that I wouldn't have otherwise.  For example, if I were told to prove that  the <code>β</code> in the following construction was a measurable function, in Lean I feel like I would have a shot, and the result would be rigorous.   If I had to do it completely on my own by hand, I would have no such confidence:</p>
<p><a href="/user_uploads/3121/mYGSlY6ZZ-1UddCYhmXayoCv/Screenshot-from-2020-12-13-21-18-06.png">Screenshot-from-2020-12-13-21-18-06.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/mYGSlY6ZZ-1UddCYhmXayoCv/Screenshot-from-2020-12-13-21-18-06.png" title="Screenshot-from-2020-12-13-21-18-06.png"><img src="/user_uploads/3121/mYGSlY6ZZ-1UddCYhmXayoCv/Screenshot-from-2020-12-13-21-18-06.png"></a></div>



<a name="219796675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219796675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219796675">(Dec 14 2020 at 03:28)</a>:</h4>
<p>I think a possible fear is that two things could be happening. There's stumbling to solve the problems at hand without seeing why related constructions don't satisfy the same constraints. Or there's cargo culting proofs from one topic to another. Both lead to an understanding that's not as deep as one would like, or could get from a larger mathematical training. That's not to say that it's easy to get that training, or that it's a given that deep understanding comes easily. Just pointing out potential pitfalls.</p>



<a name="219796712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219796712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219796712">(Dec 14 2020 at 03:29)</a>:</h4>
<p>Those could be some of the things Kevin is referring to, in the students that had more difficulty in being successful.</p>



<a name="219798851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20make%20a%20type%20class%20instance%20of%20a%20finset/near/219798851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20make.20a.20type.20class.20instance.20of.20a.20finset.html#219798851">(Dec 14 2020 at 04:17)</a>:</h4>
<p>The back story here is that I'm 61 years old and I've worked with computer algebra systems and theorem proving systems quite a bit, including Macsyma, Maple, Mathematica, Axiom, SymPy, Edinburgh LCF back in the day, CAML and implementations of real algebraic number arithmetic including Sturm sequences, resultants, and Grobner bases and decision procedures for sublanguages of set theory.  Most of the time I am cargo culting.  I know real mathematicians with larger and proper mathematical training when I see them.  I know I don't have that training.  But I do have a little bit of common sense and I know that I've learned something over the last several weeks by trying to get things to go in Lean, if only that you don't like putting names on things when you don't have to and you like to organize around measurable spaces but you don't like to organize around sigma algebras.  There is no chance, at my age, in my career, with my practical options, that I will have the time or resources to go back to school and get proper training.  Not that any mathematician would want me.  At one point I wanted to pick up the family and go study with Jordan Stoyanov, an itinerant mathematician retired from Newcastle.  My wife threw a fit.  She likes a big house.  So I do what I can.  Lean and Zulip are a gift from God in that respect.  To some extent things like EdX and Coursera can be helpful, and I've been there, but for some reason, the MOOC world is full of interesting exotic topics but a solid and thorough curriculum in core mathematics is just not there.  So I do what I can, and what comes easily.  Printing a graph of Lean definitions and then trying to find concrete instances that satisfy each definition is something that fits my skill set and temperament.  It's not math maybe, but I find it satisfying.  It's what I can do.  It may or not be fruitful for me individually.  It won't matter to anybody else if it is or isn't.  I'm not trying to cure cancer here, just scratch my own personal itch.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
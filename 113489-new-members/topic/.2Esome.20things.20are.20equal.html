---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/.2Esome.20things.20are.20equal.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.2Esome.20things.20are.20equal.html">.some things are equal</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="258847742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/.some%20things%20are%20equal/near/258847742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.2Esome.20things.20are.20equal.html#258847742">(Oct 23 2021 at 23:17)</a>:</h4>
<p>Informally speaking, when choosing a witness for the same thing under two different descriptions, we get the same witnesses.<br>
When I <code>#print</code> I get a proof term that doesn't round-trip, i.e., I can't copy and paste it and have it work. So, what would a correct proof be?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">some_theorem</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">):</span>
    <span class="n">h1.some</span> <span class="bp">=</span> <span class="n">h2.some</span> <span class="o">:=</span>
    <span class="kd">begin</span> <span class="n">tidy</span><span class="o">,</span> <span class="kd">end</span>
<span class="k">#print</span> <span class="n">some_theorem</span>
</code></pre></div>



<a name="258848944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/.some%20things%20are%20equal/near/258848944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.2Esome.20things.20are.20equal.html#258848944">(Oct 23 2021 at 23:55)</a>:</h4>
<p>If you're ok with match syntax, this is a proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">some_theorem</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">),</span> <span class="n">h1.some</span> <span class="bp">=</span> <span class="n">h2.some</span>
<span class="bp">|</span> <span class="n">p</span> <span class="n">q</span> <span class="n">rfl</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>It uses <code>h</code> to substitute <code>p</code> for <code>q</code> immediately.</p>



<a name="258849094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/.some%20things%20are%20equal/near/258849094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.2Esome.20things.20are.20equal.html#258849094">(Oct 23 2021 at 23:59)</a>:</h4>
<p>Somehow, using <code>subst</code> instead gives a nicer term proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">some_theorem</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">),</span> <span class="n">h1.some</span> <span class="bp">=</span> <span class="n">h2.some</span>
<span class="bp">|</span> <span class="n">p</span> <span class="n">q</span> <span class="n">h</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">subst</span> <span class="n">h</span>
</code></pre></div>
<p>Printing it, we get something that survives the round-trip.  After some simplification, I got</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">some_theorem</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">):</span>
    <span class="n">h1.some</span> <span class="bp">=</span> <span class="n">h2.some</span> <span class="o">:=</span>
<span class="n">eq.rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)</span> <span class="n">h</span> <span class="n">h2</span>
</code></pre></div>



<a name="258849273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/.some%20things%20are%20equal/near/258849273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.2Esome.20things.20are.20equal.html#258849273">(Oct 24 2021 at 00:02)</a>:</h4>
<p>I think what's going on with failure to round-trip is that Lean's having a difficult time figuring out motives, which it needs to do since they're implicit arguments so aren't printed out.  If you do <code>set_option pp.all true</code> and then copy/paste, you get something from your <code>tidy</code> version that does work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">some_theorem</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">):</span>
    <span class="n">h1.some</span> <span class="bp">=</span> <span class="n">h2.some</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">Exists.dcases_on.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">@</span><span class="n">Exists.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span><span class="o">)),</span>
       <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">V</span> <span class="o">(</span><span class="bp">@</span><span class="n">Exists.some.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="n">h1</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">Exists.some.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="n">h2</span><span class="o">))</span>
    <span class="n">h2</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h2_w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h2_h</span> <span class="o">:</span> <span class="n">q</span> <span class="n">h2_w</span><span class="o">),</span>
       <span class="bp">@</span><span class="n">Exists.dcases_on.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span>
         <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">@</span><span class="n">Exists.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)),</span>
            <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">V</span> <span class="o">(</span><span class="bp">@</span><span class="n">Exists.some.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="n">h1</span><span class="o">)</span>
              <span class="o">(</span><span class="bp">@</span><span class="n">Exists.some.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">Exists.intro.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="n">h2_w</span> <span class="n">h2_h</span><span class="o">)))</span>
         <span class="n">h1</span>
         <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h1_w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h1_h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">h1_w</span><span class="o">),</span>
            <span class="bp">@</span><span class="n">eq.drec.</span><span class="o">{</span><span class="mi">0</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="mi">1</span><span class="o">)}</span> <span class="o">(</span><span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="n">p</span>
              <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">@</span><span class="n">eq.</span><span class="o">{(</span><span class="n">max</span> <span class="o">(</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="mi">1</span><span class="o">)}</span> <span class="o">(</span><span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="n">p</span> <span class="n">q</span><span class="o">),</span>
                 <span class="bp">∀</span> <span class="o">(</span><span class="n">h2_h</span> <span class="o">:</span> <span class="n">q</span> <span class="n">h2_w</span><span class="o">),</span>
                   <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">V</span>
                     <span class="o">(</span><span class="bp">@</span><span class="n">Exists.some.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">Exists.intro.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="n">h1_w</span> <span class="n">h1_h</span><span class="o">))</span>
                     <span class="o">(</span><span class="bp">@</span><span class="n">Exists.some.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">Exists.intro.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="n">h2_w</span> <span class="n">h2_h</span><span class="o">)))</span>
              <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h2_h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">h2_w</span><span class="o">),</span>
                 <span class="bp">@</span><span class="n">eq.refl.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">V</span>
                   <span class="o">(</span><span class="bp">@</span><span class="n">Exists.some.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">Exists.intro.</span><span class="o">{</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="n">h1_w</span> <span class="n">h1_h</span><span class="o">)))</span>
              <span class="n">q</span>
              <span class="n">h</span>
              <span class="n">h2_h</span><span class="o">))</span>
</code></pre></div>



<a name="258851404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/.some%20things%20are%20equal/near/258851404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.2Esome.20things.20are.20equal.html#258851404">(Oct 24 2021 at 01:04)</a>:</h4>
<p>Thanks! The last one is so complicated...</p>



<a name="258866161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/.some%20things%20are%20equal/near/258866161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.2Esome.20things.20are.20equal.html#258866161">(Oct 24 2021 at 08:08)</a>:</h4>
<p><code>tidy</code> is a heaviweight tactic and the proof terms it produces are not designed to be scrutinized. It's a "kitchen sink" tactic. If you use <code>tidy?</code> it shows the more complicated tidy-free proof it discovered, and this can often be simplified by the user, eg it often tries <code>dsimp, simp</code> and one or both of these can sometimes be removed. Even <code>simp</code> will often produce really messy terms. The point of these high-powered tactics is to get things done, eg to help mathematicians solve goals which are math-trivial, not to produce reasonable proof terms.</p>



<a name="258885724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/.some%20things%20are%20equal/near/258885724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.2Esome.20things.20are.20equal.html#258885724">(Oct 24 2021 at 16:15)</a>:</h4>
<p>In this case, <code>tidy</code> ends up doing just <code>cases h2, cases h1, induction h, refl</code>, and the term you get, without the implicit arguments, is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">h2.dcases_on</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h2_w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h2_h</span> <span class="o">:</span> <span class="n">q</span> <span class="n">h2_w</span><span class="o">),</span>
       <span class="n">h1.dcases_on</span>
         <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h1_w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h1_h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">h1_w</span><span class="o">),</span> <span class="n">eq.drec</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h2_h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">h2_w</span><span class="o">),</span> <span class="n">eq.refl</span> <span class="o">(</span><span class="n">Exists.intro</span> <span class="n">h1_w</span> <span class="n">h1_h</span><span class="o">)</span><span class="bp">.</span><span class="n">some</span><span class="o">)</span> <span class="n">h</span> <span class="n">h2_h</span><span class="o">))</span>
</code></pre></div>
<p>This isn't enough for elaboration, though. Type inference for motives is a special algorithm, and it seems to fail here for the three different functions that have such an implicit argument (<code>exists.dcases_on</code> and <code>eq.drec</code>).</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
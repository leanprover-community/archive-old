---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Union.20of.20finsets.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Union.20of.20finsets.html">Union of finsets</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="229320979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Union%20of%20finsets/near/229320979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Guilherme Espada <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Union.20of.20finsets.html#229320979">(Mar 08 2021 at 15:54)</a>:</h4>
<p>How do I talk about the result of a union of finite sets? The expected, \union operator doesn't seem to work</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">consts</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">-&gt;</span> <span class="n">finset</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">t_true</span> <span class="o">:=</span> <span class="n">singleton</span> <span class="n">t_true</span>
<span class="bp">|</span> <span class="n">t_false</span> <span class="o">:=</span> <span class="n">singleton</span> <span class="n">t_false</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">t_if</span> <span class="n">t1</span> <span class="n">t2</span> <span class="n">t3</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">consts</span> <span class="n">t1</span><span class="o">)</span> <span class="bp">∪</span>  <span class="o">(</span><span class="n">consts</span> <span class="n">t2</span><span class="o">)</span> <span class="bp">∪</span>  <span class="o">(</span><span class="n">consts</span> <span class="n">t3</span><span class="o">)</span>
</code></pre></div>
<p>gives me the error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">consts</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">term</span><span class="o">,</span>
<span class="n">t1</span> <span class="n">t2</span> <span class="n">t3</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">⊢</span> <span class="n">has_union</span> <span class="o">(</span><span class="n">finset</span> <span class="n">term</span><span class="o">)</span>
</code></pre></div>



<a name="229321345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Union%20of%20finsets/near/229321345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Union.20of.20finsets.html#229321345">(Mar 08 2021 at 15:56)</a>:</h4>
<p><span class="user-mention" data-user-id="379013">@Guilherme Espada</span> For various reasons, we don't use <code>\union</code> but <code>\sup</code></p>



<a name="229321403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Union%20of%20finsets/near/229321403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Union.20of.20finsets.html#229321403">(Mar 08 2021 at 15:57)</a>:</h4>
<p>So that gives you a square union symbol</p>



<a name="229321619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Union%20of%20finsets/near/229321619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Guilherme Espada <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Union.20of.20finsets.html#229321619">(Mar 08 2021 at 15:58)</a>:</h4>
<p>I did try sup too after scrolling a bit thru the source of finset, but I get a similar error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">consts</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">term</span><span class="o">,</span>
<span class="n">t1</span> <span class="n">t2</span> <span class="n">t3</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">⊢</span> <span class="n">has_sup</span> <span class="o">(</span><span class="n">finset</span> <span class="n">term</span><span class="o">)</span>
</code></pre></div>



<a name="229321891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Union%20of%20finsets/near/229321891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Union.20of.20finsets.html#229321891">(Mar 08 2021 at 15:59)</a>:</h4>
<p>Do you need decidable equality?</p>



<a name="229322088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Union%20of%20finsets/near/229322088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Union.20of.20finsets.html#229322088">(Mar 08 2021 at 16:00)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="kd">def</span> <span class="n">finset.has_union</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
<span class="n">has_union</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)</span>
</code></pre></div>



<a name="229323089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Union%20of%20finsets/near/229323089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Union.20of.20finsets.html#229323089">(Mar 08 2021 at 16:03)</a>:</h4>
<p>Probably easiest to get by writing "@[derive decidable_eq]" wherever you define "term"</p>



<a name="229323848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Union%20of%20finsets/near/229323848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Guilherme Espada <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Union.20of.20finsets.html#229323848">(Mar 08 2021 at 16:06)</a>:</h4>
<p>This does work! it also allows me to use the set syntax which didn't work before. What exactly does this do? mark this type as something which can be "equaled"?</p>



<a name="229324445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Union%20of%20finsets/near/229324445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Union.20of.20finsets.html#229324445">(Mar 08 2021 at 16:08)</a>:</h4>
<p>Exactly. You might want to say "@[derive [decidable_eq, fintype]]"</p>



<a name="229324844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Union%20of%20finsets/near/229324844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Union.20of.20finsets.html#229324844">(Mar 08 2021 at 16:10)</a>:</h4>
<p>It marks that you can decidably check it two terms are equal or not equal. Examples of types where that isn't true for terms are the reals, or infinite streams, etc</p>



<a name="229332660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Union%20of%20finsets/near/229332660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Union.20of.20finsets.html#229332660">(Mar 08 2021 at 16:45)</a>:</h4>
<p><code>finset</code> keeps explicit track of the terms in the set, so it can offer a computable <code>finset.card</code>. This is problematic if you're dealing with sets like the real numbers, because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msup><mi>π</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>6</mn><mo separator="true">,</mo><msub><mo>∑</mo><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow></msub><msup><mi>n</mi><mrow><mo>−</mo><mn>2</mn></mrow></msup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{\pi^2/6,\sum_{n\geq1}n^{-2}\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.208997em;vertical-align:-0.39488900000000005em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139799999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mrel mtight">≥</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.39488900000000005em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> is a set of size one but checking this needs as input a theorem of Euler. This is fixed in Lean by demanding that there's an algorithm which can tell whether two terms of your type are equal, because then you don't run into these problems when trying to compute the size of your set. Whether or not <code>finset</code> is the appropriate thing to use depends on your use case.</p>



<a name="229335126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Union%20of%20finsets/near/229335126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Guilherme Espada <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Union.20of.20finsets.html#229335126">(Mar 08 2021 at 16:58)</a>:</h4>
<p>Cool, thanks for the info. Where is the fintype deriveable located? I can't seem to import it</p>



<a name="229387045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Union%20of%20finsets/near/229387045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Union.20of.20finsets.html#229387045">(Mar 08 2021 at 22:22)</a>:</h4>
<p>If you don't need it, then you don't need it. Otherwise, tactic.derive_fintype like Bryan said below</p>



<a name="229390514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Union%20of%20finsets/near/229390514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Union.20of.20finsets.html#229390514">(Mar 08 2021 at 22:49)</a>:</h4>
<p>I think the derive handler is in <a href="https://leanprover-community.github.io/mathlib_docs/tactic/derive_fintype.html"><code>tactic.derive_fintype</code></a>.</p>



<a name="229390630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Union%20of%20finsets/near/229390630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Union.20of.20finsets.html#229390630">(Mar 08 2021 at 22:50)</a>:</h4>
<p>This imports <code>data.fintype.basic</code>, so presumably you can't get it by importing <code>data.fintype.basic</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
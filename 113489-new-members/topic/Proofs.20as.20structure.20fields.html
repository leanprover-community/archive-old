---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html">Proofs as structure fields</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="204464652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204464652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204464652">(Jul 20 2020 at 19:23)</a>:</h4>
<p>I hope it's okay that I start a new topic, even though I'm working with the same structure. I'm hoping someone might be able to suggest a possible strategy and that I haven't set myself up for failure.</p>
<p>So I've got my base structure, one of which's fields is evidence that  a predicate on executions holds for every execution in the structure.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">LTS_Claim</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">LTS</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">LTS</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">execution</span> <span class="n">M</span><span class="o">))</span>
<span class="bp">...</span>
<span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">execution</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span>                 <span class="c1">-- C is for Claim</span>
<span class="bp">...</span>
</code></pre></div>


<p>I've also built a function which takes an LTS_Claim and turns it into an indexed family of LTS_Claims partitioned according to the pre-images of some evaluation function. </p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">domain_decomp</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">LTS</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">CM</span> <span class="o">:</span> <span class="n">LTS_Claim</span> <span class="n">M</span> <span class="n">α</span> <span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">CM</span><span class="bp">.</span><span class="n">n</span> <span class="bp">→</span> <span class="n">LTS_Claim</span> <span class="n">M</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
<span class="k">let</span> <span class="n">X</span><span class="err">ᵢ</span> <span class="o">:=</span> <span class="n">preimages</span> <span class="n">CM</span> <span class="n">i</span><span class="o">,</span>
<span class="k">have</span> <span class="n">HX</span><span class="err">ᵢ</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">execution</span> <span class="n">M</span><span class="o">),</span> <span class="k">from</span> <span class="n">preimages</span> <span class="n">CM</span> <span class="n">i</span><span class="o">,</span>
<span class="bp">...</span>
<span class="k">have</span> <span class="n">C</span><span class="err">ᵢ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="err">ᵢ</span><span class="o">,</span> <span class="n">CM</span><span class="bp">.</span><span class="n">P</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span>
<span class="bp">...</span>
<span class="n">exact</span> <span class="n">LTS_Claim</span><span class="bp">.</span><span class="n">mk</span> <span class="n">M</span> <span class="n">X</span><span class="err">ᵢ</span> <span class="n">E</span><span class="err">ᵢ</span> <span class="n">CM</span><span class="bp">.</span><span class="n">P</span> <span class="n">C</span><span class="err">ᵢ</span> <span class="n">CM</span><span class="bp">.</span><span class="n">f</span> <span class="n">CM</span><span class="bp">.</span><span class="n">n</span> <span class="n">CM</span><span class="bp">.</span><span class="n">D</span> <span class="n">CM</span><span class="bp">.</span><span class="n">sets_D</span> <span class="n">CM</span><span class="bp">.</span><span class="n">subs_D</span>
<span class="kn">end</span>
</code></pre></div>


<p>I want to try to express a relation between and LTS_Claim and an indexed family of LTS_Claims which says that the conjunction of every claim C in the indexed family implies the original structure's claim.</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">foo</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">LTS</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">Original_CM</span> <span class="o">:</span> <span class="n">LTS_Claim</span> <span class="n">M</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">CMs</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">Original_CM</span><span class="bp">.</span><span class="n">n</span> <span class="bp">→</span> <span class="n">LTS_Claim</span> <span class="n">M</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="c1">-- (CM₀.C ∧ CM₂.C ∧ ... ∧ CMₙ.C) → Orgininal_CM.C</span>
</code></pre></div>


<p>I've tried a variety of ways of extracting the "C" fields from the indexed family of claims, but I'm worried that I may have painted myself into a corner by defining C as a term of type (∀ x ∈ X, P x) rather than a term of type Prop.  Should I be able to find a way to accomplish this?</p>



<a name="204465425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204465425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204465425">(Jul 20 2020 at 19:29)</a>:</h4>
<p><code>\forall x \in X, P x</code> is a proposition too</p>



<a name="204466697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204466697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204466697">(Jul 20 2020 at 19:40)</a>:</h4>
<p>Right, and so one of my ideas was to do something like </p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">claim_set</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">LTS</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">Original_CM</span> <span class="o">:</span> <span class="n">LTS_Claim</span> <span class="n">M</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">CMs</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">Original_CM</span><span class="bp">.</span><span class="n">n</span> <span class="bp">→</span> <span class="n">LTS_Claim</span> <span class="n">M</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="err">⋃</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">Original_CM</span><span class="bp">.</span><span class="n">n</span><span class="o">,</span> <span class="o">{</span> <span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="bp">|</span> <span class="n">p</span> <span class="bp">=</span> <span class="o">(</span><span class="n">CMs</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">C</span><span class="o">}</span>
</code></pre></div>


<p>but lean complains that (CMs i).C is not of type Prop</p>



<a name="204471218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204471218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204471218">(Jul 20 2020 at 20:22)</a>:</h4>
<p>(deleted)</p>



<a name="204471456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204471456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204471456">(Jul 20 2020 at 20:23)</a>:</h4>
<p>What does it think the type is? It might be asking for some random other inputs. Lean is pretty good at telling you the types of things.</p>



<a name="204471747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204471747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204471747">(Jul 20 2020 at 20:26)</a>:</h4>
<p>It reads the type as  : ∀ (x : execution M), x ∈ (CMs i).X → (CMs i).P x : Prop . Does this mean I am supposed to provide more arguments?</p>



<a name="204472219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204472219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204472219">(Jul 20 2020 at 20:30)</a>:</h4>
<p>I don't really understand your question. Are you saying "I want something to have type <code>Prop</code> but it has type <code>∀ (x : execution M), x ∈ (CMs i).X → (CMs i).P x</code>?</p>



<a name="204472242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204472242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204472242">(Jul 20 2020 at 20:30)</a>:</h4>
<p>Why don't you post some complete working code?</p>



<a name="204495080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204495080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204495080">(Jul 20 2020 at 23:02)</a>:</h4>
<p>I guess the core problem is that I'm struggling with taking an indexed family of structures with fields (C : ∀ x ∈ X, P x), and writing a function which can express the conjunction of the individual C fields. Here's the whole file I'm working with.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">-- Basic Transition System,</span>
<span class="kn">structure</span> <span class="n">LTS</span>  <span class="o">:=</span>
<span class="n">mk</span> <span class="bp">::</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">TransRel</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">S</span> <span class="bp">×</span> <span class="n">A</span> <span class="bp">×</span> <span class="n">S</span><span class="o">))</span>

<span class="kn">inductive</span> <span class="n">execution</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">LTS</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">init</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">M</span><span class="bp">.</span><span class="n">S</span> <span class="bp">→</span> <span class="n">execution</span>
<span class="bp">|</span> <span class="n">cons</span>  <span class="o">:</span>  <span class="n">M</span><span class="bp">.</span><span class="n">A</span> <span class="bp">×</span> <span class="n">M</span><span class="bp">.</span><span class="n">S</span> <span class="bp">→</span> <span class="n">execution</span> <span class="bp">→</span> <span class="n">execution</span>
<span class="kn">open</span> <span class="n">execution</span>
<span class="kn">notation</span> <span class="n">e</span> <span class="err">∘</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">cons</span> <span class="n">p</span> <span class="n">e</span>

<span class="c1">-- Given a finite execution in an LTS M, extract its current (latest) state</span>
<span class="n">def</span> <span class="n">cur_st</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">LTS</span><span class="o">},</span> <span class="n">execution</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="bp">.</span><span class="n">S</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">M</span> <span class="n">eM</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">eM</span> <span class="k">with</span> <span class="n">x</span> <span class="n">p</span> <span class="n">eM&#39;</span><span class="o">,</span>
   <span class="o">{</span><span class="n">exact</span> <span class="n">x</span><span class="o">},</span>
   <span class="k">have</span> <span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="bp">.</span><span class="n">S</span><span class="o">,</span> <span class="k">from</span> <span class="n">p</span><span class="bp">.</span><span class="n">snd</span><span class="o">,</span>
   <span class="n">exact</span> <span class="n">x</span>
<span class="kn">end</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Predicate on executions that they are valid</span>
<span class="cm">with respect to the transition relation of the</span>
<span class="cm">corresponding LTS</span>
<span class="cm">-/</span>


<span class="n">def</span> <span class="n">valid</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">LTS</span><span class="o">}</span> <span class="o">:</span> <span class="n">execution</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">init</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">p</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="o">((</span><span class="n">p</span><span class="bp">.</span><span class="n">snd</span><span class="o">,</span> <span class="n">p</span><span class="bp">.</span><span class="n">fst</span><span class="o">,</span> <span class="n">cur_st</span> <span class="n">e</span><span class="o">)</span> <span class="err">∈</span> <span class="n">M</span><span class="bp">.</span><span class="n">TransRel</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">valid</span> <span class="n">e</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm"> An LTS_Claim consists of an LTS with :</span>
<span class="cm">- A set X of executions of the LTS about which the claim is made</span>
<span class="cm">- Evidence E that all executions in the above set are valid in M</span>
<span class="cm">- Some predicate P of executions in M</span>
<span class="cm">- A claim C that the above is predicated of all executions in X</span>
<span class="cm">- some valuation function f from executions of M to values of α</span>
<span class="cm">- set D of values with the type α,</span>
<span class="cm">- set of sets of type α ;</span>
<span class="cm">- Evidence that elements the above set are universally subsets of D</span>
<span class="cm">-/</span>


<span class="kn">structure</span> <span class="n">LTS_Claim</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">LTS</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">LTS</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">execution</span> <span class="n">M</span><span class="o">))</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="n">valid</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">execution</span> <span class="n">M</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">execution</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">sets_D</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">subs_D</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">sets_D</span> <span class="n">i</span> <span class="err">⊆</span> <span class="n">D</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Given an LTS_Claim for an LTS M, [preimages] returns an indexed family of sets of</span>
<span class="cm">executions of Xs = {X₁, X₂, ... Xₙ} where  Xᵢ = {x | f(x) ∈ Dᵢ}</span>
<span class="cm">or at least, that&#39;s what I&#39;m trying to accomplish.</span>
<span class="cm">-/</span>

<span class="n">def</span> <span class="n">preimages</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">LTS</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">CM</span> <span class="o">:</span> <span class="n">LTS_Claim</span> <span class="n">M</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">CM</span><span class="bp">.</span><span class="n">n</span> <span class="bp">→</span> <span class="n">set</span> <span class="o">(</span><span class="n">execution</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">CM</span><span class="bp">.</span><span class="n">n</span><span class="o">),</span> <span class="o">{</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">CM</span><span class="bp">.</span><span class="n">X</span> <span class="bp">|</span> <span class="n">CM</span><span class="bp">.</span><span class="n">f</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">CM</span><span class="bp">.</span><span class="n">sets_D</span> <span class="n">i</span><span class="o">}</span>



<span class="kn">lemma</span> <span class="n">helper</span>  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">LTS</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">CM</span> <span class="o">:</span> <span class="n">LTS_Claim</span> <span class="n">M</span> <span class="n">α</span> <span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">execution</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">CM</span><span class="bp">.</span><span class="n">n</span><span class="o">)</span> <span class="o">:</span>
<span class="n">x</span> <span class="err">∈</span> <span class="n">preimages</span> <span class="n">CM</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">CM</span><span class="bp">.</span><span class="n">X</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span><span class="bp">.</span><span class="mi">1</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Turns and LTS claim into an indexed family of LTS claims</span>
<span class="cm">according to how the evaluation function f partitions the</span>
<span class="cm">original set X.</span>
<span class="cm">CM read as &quot;claim for system M&quot;</span>
<span class="cm">(definitely not the most concise proof)</span>
<span class="cm">-/</span>

<span class="n">def</span> <span class="n">domain_decomp</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">LTS</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">CM</span> <span class="o">:</span> <span class="n">LTS_Claim</span> <span class="n">M</span> <span class="n">α</span> <span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">CM</span><span class="bp">.</span><span class="n">n</span> <span class="bp">→</span> <span class="n">LTS_Claim</span> <span class="n">M</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
<span class="k">let</span> <span class="n">X</span><span class="err">ᵢ</span> <span class="o">:=</span> <span class="n">preimages</span> <span class="n">CM</span> <span class="n">i</span><span class="o">,</span>
<span class="k">have</span> <span class="n">HX</span><span class="err">ᵢ</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">execution</span> <span class="n">M</span><span class="o">),</span> <span class="k">from</span> <span class="n">preimages</span> <span class="n">CM</span> <span class="n">i</span><span class="o">,</span>
<span class="k">have</span> <span class="n">H₀</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">CM</span><span class="bp">.</span><span class="n">X</span><span class="o">,</span> <span class="n">valid</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">CM</span><span class="bp">.</span><span class="n">E</span><span class="o">,</span>
<span class="k">have</span> <span class="n">E</span><span class="err">ᵢ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="err">ᵢ</span><span class="o">,</span> <span class="n">valid</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span>
   <span class="k">begin</span>
   <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
   <span class="n">intro</span> <span class="n">H₁</span><span class="o">,</span>
   <span class="n">apply</span> <span class="n">H₀</span><span class="o">,</span>
   <span class="n">apply</span> <span class="n">helper</span> <span class="n">CM</span> <span class="n">x</span> <span class="n">i</span><span class="o">,</span>
   <span class="n">apply</span> <span class="n">H₁</span><span class="o">,</span>
   <span class="kn">end</span><span class="o">,</span>
<span class="k">have</span> <span class="n">C</span><span class="err">ᵢ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="err">ᵢ</span><span class="o">,</span> <span class="n">CM</span><span class="bp">.</span><span class="n">P</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span>
   <span class="k">begin</span>
   <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
   <span class="n">intro</span> <span class="n">H₁</span><span class="o">,</span>
   <span class="k">have</span> <span class="n">CMC</span> <span class="o">:</span>  <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">CM</span><span class="bp">.</span><span class="n">X</span><span class="o">,</span> <span class="n">CM</span><span class="bp">.</span><span class="n">P</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">CM</span><span class="bp">.</span><span class="n">C</span><span class="o">,</span>
   <span class="n">apply</span> <span class="n">CMC</span><span class="o">,</span>
   <span class="n">apply</span> <span class="n">helper</span> <span class="n">CM</span> <span class="n">x</span> <span class="n">i</span><span class="o">,</span>
   <span class="n">apply</span> <span class="n">H₁</span><span class="o">,</span>
   <span class="kn">end</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">LTS_Claim</span><span class="bp">.</span><span class="n">mk</span> <span class="n">M</span> <span class="n">X</span><span class="err">ᵢ</span> <span class="n">E</span><span class="err">ᵢ</span> <span class="n">CM</span><span class="bp">.</span><span class="n">P</span> <span class="n">C</span><span class="err">ᵢ</span> <span class="n">CM</span><span class="bp">.</span><span class="n">f</span> <span class="n">CM</span><span class="bp">.</span><span class="n">n</span> <span class="n">CM</span><span class="bp">.</span><span class="n">D</span> <span class="n">CM</span><span class="bp">.</span><span class="n">sets_D</span> <span class="n">CM</span><span class="bp">.</span><span class="n">subs_D</span>
<span class="kn">end</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">   The actual idea I&#39;m trying to formalize now:</span>
<span class="cm">   Given an LTS_Claim &quot;CM&quot; and an indexed family of LTS_Claims [CM₁, CM₂, ... CMₙ],</span>
<span class="cm">   the two are said to be in a  special relation if</span>
<span class="cm">   CM₁.C ∧ CM₂.C ∧ ... ∧ CMₙ.C → CM.C</span>
<span class="cm">   I.e. the evidence that the property P holds for the sets X_i</span>

<span class="cm">-/</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">One strategy:</span>

<span class="cm">Given a family of LTS_Claims, take the set of their &quot;C&quot; fields</span>
<span class="cm">The idea is that if I can form this set, I can (maybe) take their conjunction.</span>

<span class="cm">-/</span>
<span class="n">def</span> <span class="n">set_claims</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">LTS</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">original</span> <span class="o">:</span> <span class="n">LTS_Claim</span> <span class="n">M</span> <span class="n">α</span><span class="o">}</span>
<span class="o">(</span><span class="n">subclaims</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">original</span><span class="bp">.</span><span class="n">n</span> <span class="bp">→</span> <span class="n">LTS_Claim</span> <span class="n">M</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="204495592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204495592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204495592">(Jul 20 2020 at 23:10)</a>:</h4>
<p>But I  feel like I'm stuck between considering the "C" fields as evidence or as propositions, and so I need to clarify that distinction before I will be able to find a solution. Again, sorry for the messy code and confusing questions.</p>



<a name="204495650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204495650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204495650">(Jul 20 2020 at 23:11)</a>:</h4>
<p>And what is the question?</p>



<a name="204495818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204495818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204495818">(Jul 20 2020 at 23:14)</a>:</h4>
<p>Given an indexed family of structures, each of whom has a field C proving a proposition, how can you form the set of those fields?</p>



<a name="204495831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204495831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204495831">(Jul 20 2020 at 23:14)</a>:</h4>
<p>And why do you want to make such a set?</p>



<a name="204495837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204495837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204495837">(Jul 20 2020 at 23:14)</a>:</h4>
<p>Lean doesn't have sets, it only has subsets of types</p>



<a name="204495981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204495981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204495981">(Jul 20 2020 at 23:17)</a>:</h4>
<p>right. I think I need to re-evaluate what exactly I'm trying to show. Thanks for the patience</p>



<a name="204496076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204496076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204496076">(Jul 20 2020 at 23:18)</a>:</h4>
<p><code>CM₁.C ∧ CM₂.C</code> doesn't make sense.</p>



<a name="204496098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204496098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204496098">(Jul 20 2020 at 23:18)</a>:</h4>
<p>If <code>P : Prop</code> and <code>Q : Prop</code> then <code>P ∧ Q</code> makes sense.</p>



<a name="204496120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204496120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204496120">(Jul 20 2020 at 23:19)</a>:</h4>
<p>If <code>h : P</code> and <code>j : Q</code> then <code>h ∧ j</code> doesn't make sense.</p>



<a name="204496124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204496124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204496124">(Jul 20 2020 at 23:19)</a>:</h4>
<p>Yeah that's part of the problem. I want to take the conjunct of the propositions which are the types of CM1.C and CM2.C. So maybe I need to redefine the fields as arbitrary Prop's</p>



<a name="204496135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204496135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204496135">(Jul 20 2020 at 23:19)</a>:</h4>
<p>exactly right</p>



<a name="204496285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204496285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204496285">(Jul 20 2020 at 23:21)</a>:</h4>
<p>So you know the type of <code>a.C</code>, it's <code>∀ x ∈ a.X, a.P x</code></p>



<a name="204496297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204496297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204496297">(Jul 20 2020 at 23:21)</a>:</h4>
<p>and <code>∀ x ∈ a.X, a.P x : Prop</code></p>



<a name="204496426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204496426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204496426">(Jul 20 2020 at 23:23)</a>:</h4>
<p>You only need to define <code>a.X</code> and <code>a.P</code> to define this type. There's no point defining <code>a.C</code> to equal <code>∀ x ∈ a.X, a.P x</code>, you already have a name for that and it's <code>∀ x ∈ a.X, a.P x</code></p>



<a name="204496510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204496510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204496510">(Jul 20 2020 at 23:24)</a>:</h4>
<p>The question is whether to construct <code>a : LTS_Claim M alpha</code> you want to be demanding a <em>proof</em> of <code>∀ x ∈ a.X, a.P x</code> or not.</p>



<a name="204496532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204496532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204496532">(Jul 20 2020 at 23:24)</a>:</h4>
<p>I would suggest adjusting language to not refer to proofs by name</p>



<a name="204496581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204496581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204496581">(Jul 20 2020 at 23:25)</a>:</h4>
<p>e.g.</p>
<div class="codehilite"><pre><span></span><code> An LTS_Claim consists of an LTS with :
- A set X of executions of the LTS about which the claim is made
- which are valid in M
- Some predicate P of executions in M
- that holds on all executions in X
- some valuation function f from executions of M to values of α
- set D of values with the type α,
- set of sets of type α ;
- which are subsets of D
</code></pre></div>



<a name="204496687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204496687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204496687">(Jul 20 2020 at 23:27)</a>:</h4>
<p>Yeah that's a good point. I guess can always just define predicates on the claims which are the atcual propositions I want to reason about.</p>



<a name="204496763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204496763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204496763">(Jul 20 2020 at 23:28)</a>:</h4>
<p>(deleted)</p>



<a name="204497611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204497611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204497611">(Jul 20 2020 at 23:40)</a>:</h4>
<p>also, I don't have a good sense of what you are trying to do, but it seems like your "claims" are more like theorems, because you require proofs, and this is why you are having a hard time writing something that makes sense</p>



<a name="204497644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204497644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204497644">(Jul 20 2020 at 23:41)</a>:</h4>
<p>I mean there are a lot of moving parts whose purpose I don't know</p>



<a name="204497672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204497672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204497672">(Jul 20 2020 at 23:41)</a>:</h4>
<p>but certainly given a bunch of propositions <code>P1</code>, <code>P2</code>, ..., <code>Pn</code>, <code>P</code> we can form the proposition <code>P1 /\ P2 /\ ... /\ Pn -&gt; P</code></p>



<a name="204497682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204497682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204497682">(Jul 20 2020 at 23:41)</a>:</h4>
<p>but if we also already have proofs of all the propositions then it's not a very interesting thing to do</p>



<a name="204497691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204497691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204497691">(Jul 20 2020 at 23:41)</a>:</h4>
<p>since all the propositions are just equal to <code>true</code> anyways</p>



<a name="204497763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204497763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204497763">(Jul 20 2020 at 23:42)</a>:</h4>
<p>A Proposition is a true/false statement, for example <code>2+2=4</code> or <code>2+2=5</code>. Propositions have type <code>Prop</code>. If <code>P</code> is a proposition then you can think of it as a type with one term if it's true, and with 0 terms if it's false. If <code>h : P</code> then <code>h</code> can be thought of as a proof of <code>P</code>. For example it's possible to make a term of type <code>2 + 2 = 4</code> in Lean, but it's not possible to make a term of type <code>2 + 2 = 5</code>.</p>



<a name="204497861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204497861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204497861">(Jul 20 2020 at 23:44)</a>:</h4>
<p>Things like <code>2+2=4 \or 2+2=5</code> and <code>2+2=4 \and 2+2=5</code> make sense, and are also Propositions.</p>



<a name="204502185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20as%20structure%20fields/near/204502185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20as.20structure.20fields.html#204502185">(Jul 21 2020 at 00:48)</a>:</h4>
<p>Thanks for the thorough explanation guys. I'm actually just trying to strong-arm a colleague's paper about decomposing Safety Cases/Goal Structuring Notation into Lean <em>post hoc,</em> which is part of why it seems awkward (I'm also just still pretty green with Dep. TT). I'm still really enjoying working with Lean in spite of the learning curve though :)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
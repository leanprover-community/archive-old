---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/extensionality.20for.20functors.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html">extensionality for functors</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="231537373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/231537373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#231537373">(Mar 23 2021 at 20:21)</a>:</h4>
<p>Hi,<br>
correct me if I'm wrong: In mathlib, there seems to be no extensionality Lemma for functors. <br>
Moreover, I noticed that I can't even <em>state</em> extensionality for functors without getting a type error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.functor</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">D</span><span class="o">]</span>

<span class="c1">--doesn't even typecheck</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">F</span> <span class="n">G</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="bp">=</span> <span class="n">G.obj</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">F.map</span> <span class="bp">=</span> <span class="n">G.map</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">=</span> <span class="n">G</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>and it makes sense, because the types of <code>F.map</code> and <code>G.map</code> are a priori different, but of course they actually aren't because I'm requiring <code>F.obj = G.obj</code> as a hypothesis as well. I remember seeing issues like this in a CS class on Coq once, where because of dependently typed hypothesis, we couldn't even <em>state</em> a particular Lemma. Unfortunately, I don't remember how we worked around this problem, if we did...</p>
<p>Is there a workaround? And how can I prove that two functors are equal, or is this something that we shouldn't even do in mathlib?</p>



<a name="231539203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/231539203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#231539203">(Mar 23 2021 at 20:33)</a>:</h4>
<p>We actually do have <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.functor.ext">docs#category_theory.functor.ext</a>, which uses <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.eq_to_hom">docs#category_theory.eq_to_hom</a> to work around the problem you described. As you already guessed, this is rarely a good idea. In the vast majority of cases, it is much better to instead provide a natural isomorphism between the two functors.</p>



<a name="231539905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/231539905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#231539905">(Mar 23 2021 at 20:38)</a>:</h4>
<p>More generally, unless your category is some kind of partial order, the moment when you start talking about equality of objects, it is probably a good idea to think about whether there is a better approach that avoids this (and talks about isomorphisms instead).</p>



<a name="231540785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/231540785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#231540785">(Mar 23 2021 at 20:44)</a>:</h4>
<p>Note that you can state the lemma by using <a href="https://leanprover-community.github.io/mathlib_docs/find/heq">docs#heq</a> (<code>==</code>) between the maps</p>



<a name="231541646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/231541646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#231541646">(Mar 23 2021 at 20:50)</a>:</h4>
<p>Oh, I didn't see that one, thanks!</p>



<a name="231542281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/231542281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#231542281">(Mar 23 2021 at 20:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260921">Markus Himmel</span> <a href="#narrow/stream/113489-new-members/topic/extensionality.20for.20functors/near/231539905">said</a>:</p>
<blockquote>
<p>More generally, unless your category is some kind of partial order, the moment when you start talking about equality of objects, it is probably a good idea to think about whether there is a better approach that avoids this (and talks about isomorphisms instead).</p>
</blockquote>
<p>If we are talking about paper-math, I 100% agree with this statement. But I thought since Lean doesn't have univalence, isomorphisms would be a pain to work with, since we can't rewrite with them. Is this not the case?</p>



<a name="231542424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/231542424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#231542424">(Mar 23 2021 at 20:57)</a>:</h4>
<p>I don't have any experience with isomorphisms in Lean yet, so any additional information about how to properly use them would be nice :)</p>



<a name="231543419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/231543419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#231543419">(Mar 23 2021 at 21:03)</a>:</h4>
<p>They're not exactly fun to work with, but I would argue that dealing with <code>heq</code> or <code>eq_to_hom</code> is even worse. In my experience, with well-chosen simp lemmas, many isomorphisms that could potentially be annoying are almost invisible.</p>



<a name="231546411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/231546411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#231546411">(Mar 23 2021 at 21:25)</a>:</h4>
<p>We also have <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.functor.hext">docs#category_theory.functor.hext</a> if you REALLY want to worry about heq</p>



<a name="231546649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/231546649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#231546649">(Mar 23 2021 at 21:27)</a>:</h4>
<p>These are not marked with <code>@[ext]</code> because you should think twice about using them <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="231548955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/231548955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#231548955">(Mar 23 2021 at 21:45)</a>:</h4>
<p>How does Coq handle heq?</p>



<a name="231562259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/231562259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#231562259">(Mar 24 2021 at 00:00)</a>:</h4>
<p>Not very well, because it doesn't have proof irrelevance</p>



<a name="231562371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/231562371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#231562371">(Mar 24 2021 at 00:01)</a>:</h4>
<p>It's possible to define, of course, but it doesn't have a lot of the properties you would want. It's better to use pathovers as in HoTT</p>



<a name="231562699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/231562699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#231562699">(Mar 24 2021 at 00:05)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">path</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="o">(</span><span class="n">fa</span> <span class="o">:</span> <span class="n">F</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">b</span><span class="o">},</span> <span class="n">F</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">:</span> <span class="n">path</span> <span class="n">fa</span> <span class="n">rfl</span>

<span class="kd">notation</span> <span class="n">a</span> <span class="bp">`=</span><span class="o">[</span><span class="bp">`</span><span class="n">F</span><span class="bp">`;`</span><span class="n">p</span><span class="bp">`</span><span class="o">]</span><span class="bp">`</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">path</span> <span class="n">F</span> <span class="n">a</span> <span class="n">b</span> <span class="n">p</span>
</code></pre></div>



<a name="231590670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/231590670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#231590670">(Mar 24 2021 at 06:53)</a>:</h4>
<p>I remember seeing a thread about <code>path</code>s a while ago; has it been concluded they're less convenient to work with than <code>heq</code>, or has no one really tried them out seriously in lean?</p>



<a name="231590857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/231590857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#231590857">(Mar 24 2021 at 06:57)</a>:</h4>
<p>No one has tried them out seriously. I think they would be better than <code>heq</code>, but not as good as avoiding them entirely using sigma-type encodings</p>



<a name="231590891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/231590891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#231590891">(Mar 24 2021 at 06:58)</a>:</h4>
<p>One problem with pathovers is that you eventually find yourself needing pathoverovers too</p>



<a name="231591349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/231591349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#231591349">(Mar 24 2021 at 07:04)</a>:</h4>
<p>Is <code>path F a b p</code> different to <code>eq.rec a p = b</code> other than having F explicit unlike the C of <a href="https://leanprover-community.github.io/mathlib_docs/find/eq.rec">docs#eq.rec</a>?</p>



<a name="231611294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/231611294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#231611294">(Mar 24 2021 at 10:26)</a>:</h4>
<p>I tried out using <code>eq.rec</code> instead of <code>==</code>, but the elaborator makes it harder for me than I'd like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- With `heq` -/</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">γ</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x.1</span> <span class="bp">=</span> <span class="n">y.1</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">x.2.1</span> <span class="bp">==</span> <span class="n">y.2.1</span><span class="o">)</span> <span class="o">(</span><span class="n">h3</span> <span class="o">:</span> <span class="n">x.2.2</span> <span class="bp">==</span> <span class="n">y.2.2</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">x</span><span class="o">,</span> <span class="n">cases</span> <span class="n">y</span><span class="o">,</span> <span class="n">cases</span> <span class="n">x_snd</span><span class="o">,</span> <span class="n">cases</span> <span class="n">y_snd</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h1</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h2</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h3</span><span class="o">,</span> <span class="n">refl</span>
<span class="kd">end</span>

<span class="kd">@[ext]</span>
<span class="kd">def</span> <span class="n">sigma_ext_rec</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x.fst</span> <span class="bp">=</span> <span class="n">y.fst</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">h1.rec</span> <span class="n">x.2</span> <span class="bp">=</span> <span class="n">y.2</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">y1</span><span class="o">,</span> <span class="n">xy</span><span class="o">⟩</span> <span class="n">rfl</span> <span class="n">rfl</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="sd">/-- With `eq.rec` -/</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">γ</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x.1</span> <span class="bp">=</span> <span class="n">y.1</span><span class="o">)</span>
  <span class="c1">-- `(h1.rec x.2).1 = y.2.1` isn't accepted by the elaborator</span>
  <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="o">(</span><span class="n">eq.rec</span> <span class="n">x.2</span> <span class="n">h1</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">a</span><span class="o">,</span> <span class="n">γ</span> <span class="n">y.1</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">y.2.1</span><span class="o">)</span>
  <span class="c1">-- `h2.rec (h1.rec x.2).2 = y.2.2` isn't accepted by the elaborator</span>
  <span class="o">(</span><span class="n">h3</span> <span class="o">:</span> <span class="o">(</span><span class="n">eq.rec</span> <span class="o">(</span><span class="n">eq.rec</span> <span class="n">x.2</span> <span class="n">h1</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">a</span><span class="o">,</span> <span class="n">γ</span> <span class="n">y.1</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">γ</span> <span class="n">y.1</span> <span class="n">y.2.1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">y.2.2</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- the previous proof would work too</span>
  <span class="n">ext</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h3</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="257877719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/257877719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#257877719">(Oct 17 2021 at 01:44)</a>:</h4>
<p>I guess it's still preferable to replace isomorphisms by equalities whenever possible? For example I was just able to get :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">map_id'</span> <span class="o">:</span> <span class="n">map</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="n">X</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">𝟭</span> <span class="o">(</span><span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">unfold</span> <span class="n">map</span><span class="o">,</span> <span class="n">congr</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="n">ext</span> <span class="o">}</span>
</code></pre></div>
<p>in place of <a href="https://leanprover-community.github.io/mathlib_docs/topology/category/Top/opens.html#topological_space.opens.map_id">https://leanprover-community.github.io/mathlib_docs/topology/category/Top/opens.html#topological_space.opens.map_id</a><br>
I'm looking into this because I want to prove an equality involving pushforward of sheaves, in turn because I want to show any pushforward of a sheaf is a sheaf (using the pairwise_intersection condition), where I'd like to show two cones (implemented as natural transformation between functors) inside <code>is_limit</code> are equal.</p>
<p>BTW I find that initializing Lean in the file presheaf.lean (or maybe it's Top/opens.lean) cost a long time and 2-3 GB memory on my machine, even though I have freshly made .olean files with mk-cache and get-cache ...</p>



<a name="257878205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/257878205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#257878205">(Oct 17 2021 at 01:52)</a>:</h4>
<p>No, the opposite, when talking about functors it is better to replace equalities with isomorphisms, because relying on the equalities will result in badness (either eq.rec / cast in goals, or heavy refl proofs) down the line that you don't have control over, whereas working with isomorphisms (which is admittedly more cumbersome) you at least know what you're getting into.</p>



<a name="257878355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/257878355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#257878355">(Oct 17 2021 at 01:55)</a>:</h4>
<p>(Opening <code>topology/sheaves/presheaf.lean</code> after restarting the Lean server takes &lt;5s on my machine. <code>Top/opens.lean</code> took more like 2s.)</p>



<a name="257937374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/257937374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#257937374">(Oct 17 2021 at 18:09)</a>:</h4>
<p>Hmm, revert to an earlier commit fixes the problem (though it still takes several minutes to initialize on my machine, which is normal) and the memory used is now less than 1.5 GB.<br>
I guess the problem is that I added lemmas named <code>op_comp</code> and <code>comp_assoc</code> to category_theory/opposite.lean and functor.lean and these may break some proofs in other files due to name conflict (in fact I fixed two in opposite.lean) and these broken proofs may be imported by the files opens.lean and presheaf.lean I am working on, so Lean is confused and stays in the yellow busy state. Is there an easy way to confirm this is the case? Lean doesn't output anything when busy, and mk-cache doesn't detect the problem (it doesn't abort or output anything).</p>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/extensionality.20for.20functors/near/257878355">said</a>:</p>
<blockquote>
<p>(Opening <code>topology/sheaves/presheaf.lean</code> after restarting the Lean server takes &lt;5s on my machine. <code>Top/opens.lean</code> took more like 2s.)</p>
</blockquote>



<a name="257937548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/257937548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#257937548">(Oct 17 2021 at 18:12)</a>:</h4>
<p>I guess the equalities should still be useful; one can easily construct an iso from an eq. Maybe just add a <code>'</code> or <code>_eq</code> to the eq's name and construct the iso using it? Would you approve this kind of change?<br>
<span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/extensionality.20for.20functors/near/257878205">said</a>:</p>
<blockquote>
<p>No, the opposite, when talking about functors it is better to replace equalities with isomorphisms, because relying on the equalities will result in badness (either eq.rec / cast in goals, or heavy refl proofs) down the line that you don't have control over, whereas working with isomorphisms (which is admittedly more cumbersome) you at least know what you're getting into.</p>
</blockquote>



<a name="257953966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/257953966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#257953966">(Oct 17 2021 at 22:30)</a>:</h4>
<p>Compile the file you think you might have broken on the command line</p>



<a name="258143543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258143543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258143543">(Oct 19 2021 at 05:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/113489-new-members/topic/extensionality.20for.20functors/near/257877719">said</a>:</p>
<blockquote>
<p>I'm looking into this because I want to prove an equality involving pushforward of sheaves, in turn because I want to show any pushforward of a sheaf is a sheaf (using the pairwise_intersection condition), where I'd like to show two cones (implemented as natural transformation between functors) inside <code>is_limit</code> are equal.</p>
</blockquote>
<p><a href="https://github.com/alreadydone/mathlib/commit/71230c42843765c05d0864e7309ca288b2fe18b5#diff-a88d397f1b2629d53f1609f24801d984c31d5553a27f873cef23c20a563c7535R87">Alright I finished the proof</a>, but I'm not really sure how it works! Especially where the <code>congr</code> and <code>convert</code> tactics (or <code>functor.hext</code> which uses <code>congr</code>) which often reduces an eq goal to some eq goals but also some heq goals.<br>
Although it's in mathlib that we can transfer <code>is_limit</code> between two isomorphic cones, we can't state that two cones / natural transformations are isomorphic before proving that they're over the same (defeq) functor / between the same two functors, and there doesn't seem to be a more sophisticated theorem that applies (maybe more higher category theory needs to be developed), so I'm content with the current approach. Would be fantastic if someone can further golf it.</p>



<a name="258144248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258144248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258144248">(Oct 19 2021 at 05:38)</a>:</h4>
<p>Probably best to make a PR so others can take a look taking advantage of precompiled oleans.</p>



<a name="258144984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258144984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258144984">(Oct 19 2021 at 05:50)</a>:</h4>
<p>Done (<a href="https://github.com/leanprover-community/mathlib/issues/9801">#9801</a>)! The branch doesn't have to be in the main leanprover-community repo for oleans to be generated, right?</p>



<a name="258145370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258145370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258145370">(Oct 19 2021 at 05:56)</a>:</h4>
<p>It does, unfortunately, because the oleans need to be deployed to our server.</p>



<a name="258145428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258145428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258145428">(Oct 19 2021 at 05:57)</a>:</h4>
<p>I just sent you an invitation with write access to non-master branches. Could you close your PR and open a new one from a branch on the main repo?</p>



<a name="258146040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258146040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258146040">(Oct 19 2021 at 06:05)</a>:</h4>
<p>On a side note, I am also actively working towards the adjunction based on the blueprints of Justus. If you are planning to your proofs into mathlib, it would be great if we could coordinate together and split the work to avoid stepping on each other's toes.</p>



<a name="258146546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258146546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258146546">(Oct 19 2021 at 06:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/extensionality.20for.20functors/near/258145428">said</a>:</p>
<blockquote>
<p>I just sent you an invitation with write access to non-master branches. Could you close your PR and open a new one from a branch on the main repo?</p>
</blockquote>
<p>Thanks! I accepted and made new PR <a href="https://github.com/leanprover-community/mathlib/issues/9802">#9802</a></p>



<a name="258146693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258146693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258146693">(Oct 19 2021 at 06:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439483">Andrew Yang</span> <a href="#narrow/stream/113489-new-members/topic/extensionality.20for.20functors/near/258146040">said</a>:</p>
<blockquote>
<p>On a side note, I am also actively working towards the adjunction based on the blueprints of Justus. If you are planning to your proofs into mathlib, it would be great if we could coordinate together and split the work to avoid stepping on each other's toes.</p>
</blockquote>
<p>Of course! All my current work is in the PR. Now that I proved f_* O_X is a sheaf, it's just a matter of plugging in the arguments to define the sheaf morphism in the counit of the adjunction.</p>



<a name="258146800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258146800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258146800">(Oct 19 2021 at 06:16)</a>:</h4>
<p>(Yeah, I now realize the unit-counit approach is simpler and no longer pursues the hom_equiv route.)</p>



<a name="258148219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258148219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258148219">(Oct 19 2021 at 06:36)</a>:</h4>
<p>As for gluing morphisms on sheaves, the equivalent formulation on my path was just finished some days ago at <a href="https://github.com/leanprover-community/mathlib/issues/9694">#9694</a>.<br>
I suppose it would be better to use that to avoid duplicate code.<br>
Also IMHO the fact that the pushforward of a sheaf is a sheaf should probably go in <code>src/topology/sheaves/stalks.lean</code>.<br>
(another way to show this is to show that continuous maps induces continuous functors between sites, which could potentially unlock more stuff such as pullbacks, but I doubt we would need that generality for now).</p>



<a name="258156397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258156397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258156397">(Oct 19 2021 at 08:02)</a>:</h4>
<p>Congrats on your colossal series of work! If you can just prove <a href="https://github.com/leanprover-community/mathlib/pull/9802/files#diff-d7cc616887430b2cb5792e3d691f45c1bbc3eaa32c3abf1c4e735ab8b9a904d9R153">the last theorem from basis_le.lean</a> then I can mostly abandon the rest of the file. <code>lim_basis_le_of_sheaf</code> and <code>mono_to_basis_le_of_sheaf</code> might be useful for other purposes and it would be nice to derive these specialized versions from more general versions that you probably already proved.<br>
The pushforward of sheaf thing doesn't involve stalks at all, so I think should just go into <code>topology/sheaves/sheaf.lean</code>, which should import the pairwise_intersection file and prove the is_sheaf version of the theorem. If pairwise_intersection is promoted to the official definition then there would be nothing to prove. In fact the proof is rather trivial and I expect the same for the sites version, but the type system complicates matters. I even think it should be proven by defeq under the "ideal" defeq, but Lean's algorithmic defeq doesn't recognize it. Probably Lean has problem defequating one morphism from <code>le_supr</code> and another from mapping <code>le_supr</code> by a functor (<code>opens.map f</code>); for sites this issue may not exist. (Or maybe the problem is elsewhere: preimage of intersection seems to be defeq, but preimage_Union seems not. <code>opens X</code> as subtype of <code>set X</code> seems fine, so seems the <code>plift</code> <code>ulift</code> to promote open set inclusion to a morphism.)</p>



<a name="258159837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258159837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258159837">(Oct 19 2021 at 08:36)</a>:</h4>
<p>Oh yes I mistyped...<br>
I meant <code>sheaf.lean</code>. <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="258161386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258161386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258161386">(Oct 19 2021 at 08:50)</a>:</h4>
<p>The sites version of the pushforward stuff is probably <a href="https://github.com/leanprover-community/mathlib/issues/9691">#9691</a>.<br>
That said, to show that continuous functions are <code>compatible_preserving</code>, the right way is probably to show that it preserves finite limits and to use <a href="https://github.com/leanprover-community/mathlib/issues/9519">#9519</a>. However, Bhavik seems to have some more thoughts on flat functors, and thus it would probably take some time before It goes into mathlib.</p>
<p>At first glance, <code>mono_to_basis_le_of_sheaf_condition</code> seems to be either <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.presieve.is_separated_for.ext">docs#category_theory.presieve.is_separated_for.ext</a> or <code>cover_dense.ext</code> in <a href="https://github.com/leanprover-community/mathlib/issues/9694">#9694</a>. As for <code>lim_basis_le_of_sheaf</code>, the sheaf condition of sites is not defined in terms of limits, and thus there probably would not be an analogue for now.</p>



<a name="258170194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258170194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258170194">(Oct 19 2021 at 10:10)</a>:</h4>
<p>This is great that we are now beginning to be able to start defining the basic "arithmetic" of sheaves, e.g. pushing forward and pulling back. One goal would be to prove that these are adjoint functors (although strictly speaking this is a construction, not a proof). </p>
<p>For me a good next challenge might be to start thinking about sheaves of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">O</mi><mi>X</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{O}_X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-modules. The reason that this will be a challenge is that my memory was that there were several competing proposals for what the definition of a sheaf of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">O</mi><mi>X</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{O}_X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-modules should be. Choosing a definition and then trying to define pushforward and pullback, and then proving the adjointness of the corresponding constructions, would surely be worth a paper. The category of quasicoherent <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">O</mi><mi>X</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{O}_X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-modules over a scheme is a fundamental object in algebraic geometry. Me+Amelia+Kenny+Chris+Ramon+Scott's paper on the definition of a scheme got published, and I should think that the Isabelle definition of a scheme will end up published too, but if we're in an algebraic geometry race with Isabelle (which I hope we are!) then this would be a really good marker to put down. The computer scientists might complain that it's definition, definition, definition and not theorem, theorem, theorem, but algebraic geometry is a complicated subject and we need all the definitions before we can start stating the theorems. Sheaf cohomology is another definition which we will need before too long, but there have been a bunch of breakthroughs in homological algebra recently as part of LTE and so it's only a matter of time. Once we have that, then we can start stating a whole bunch of theorems, and attempting to prove them will inform our API.</p>



<a name="258846371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258846371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258846371">(Oct 23 2021 at 22:40)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/5c5d818dd8b76450bebff89bf1719be5259f9672/src/topology/category/Top/opens.lean#L148">Here</a> it says <code>map_comp_obj</code> is "not quite <code>rfl</code>, since we don't have eta for records", but currently it can actually be proven by <code>rfl</code>. Is this due to some change in the kernel? <code>map_id_obj</code> indeed isn't <code>rfl</code> but almost is, as it can be proven with <code>let ⟨_,_⟩ := U in rfl</code>. Moreover, <code>le_map_top</code> can be proven simply by <code>le_top U</code>, and similarly the definition of the global section functor in presheafed_space.lean can omit the composition with le_top.<br>
I'm going through these files (and presheaf.lean) to simplify many other such cases and make some additions, and I think it's a good idea to ask here to ensure that such simplifications aren't discouraged for some reason.</p>



<a name="258846648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258846648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258846648">(Oct 23 2021 at 22:47)</a>:</h4>
<p>I don't think <code>let ⟨_,_⟩ := U in rfl</code> is substantially different than the existing proof of <code>map_id_obj</code>.</p>



<a name="258846700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258846700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258846700">(Oct 23 2021 at 22:48)</a>:</h4>
<p>For <code>map_comp_obj</code>, yes, this seems to be a mistake. There's enough code using this stuff downstream that you can safely just try out the change. If nothing breaks downstream then it's fine. If something does break downstream you can improve the comment to explain what's really going on!</p>



<a name="258846778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258846778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258846778">(Oct 23 2021 at 22:50)</a>:</h4>
<p>Removing the composition with <code>le_top</code> in the global section functor (I haven't actually looked at this recently, so take this with a grain of salt) sounds like a bad idea, however. It may be forcing Lean to do more definitional unfolding, so if it is there is may well be there to improve a performance issue. (Ideally there would be a comment explaining this if that is the case, but ....)</p>



<a name="258847032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258847032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258847032">(Oct 23 2021 at 22:57)</a>:</h4>
<p>Interesting that there are such tricks that make definitions more complicated to improve performance. However it's making one of my proofs more complicated and forced me to prove a lemma stating <code>Gamma.map f.op = f.1.c.app (op T)</code>for a morphism f of LocallyRingedSpace while it should really be <code>rfl</code>. Maybe I could also submit a PR and compare the compile time?</p>
<p>By the way, a consequence of <code>map_comp_obj</code>'s rfl is that the equality version of <code>map_comp</code>is also rfl.</p>



<a name="258847095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258847095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258847095">(Oct 23 2021 at 22:59)</a>:</h4>
<p>Usually you don't even need to compare overall compile times (which are noisy and hard to compare anyway). Usually a problem like this exhibits itself as a deterministic timeout, so as long as you can <code>lean --make -T100000 src</code> successfully you probably haven't broken anything.</p>



<a name="258847101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258847101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258847101">(Oct 23 2021 at 22:59)</a>:</h4>
<p>I wrote a fair bit of this stuff, but it was a long time ago, and I remember struggling in places. I wouldn't be at all surprised if there are just mistakes.</p>



<a name="258847607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258847607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258847607">(Oct 23 2021 at 23:12)</a>:</h4>
<p>Thanks this is the first time I see the compile command. I'm recently getting (100 seconds?) deterministic timeouts in my working Spec-Gamma adjunction file in VSCode and had to increase the time limit (it's in the VSCode Lean setting), but hopefully it goes away when more lemmas are placed into appropriate files.</p>
<p>So you think these are not due to changes in how the kernel checks defeq, and you just didn't try? In the same file, <code>map_comp_obj_unop</code> and <code>op_map_comp_obj</code> are also <code>rfl</code>s, but not <code>op_map_id_obj</code>, not even <code>let ⟨_,_⟩ := U.unop in rfl</code> ...</p>



<a name="258847619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258847619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258847619">(Oct 23 2021 at 23:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/extensionality.20for.20functors/near/258846648">said</a>:</p>
<blockquote>
<p>I don't think <code>let ⟨_,_⟩ := U in rfl</code> is substantially different than the existing proof of <code>map_id_obj</code>.</p>
</blockquote>
<p>Yes it's probably equivalent but would such term mode proof be faster in general?</p>



<a name="258847728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258847728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258847728">(Oct 23 2021 at 23:16)</a>:</h4>
<p>No, I wouldn't expect it to be faster.</p>



<a name="258847730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258847730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258847730">(Oct 23 2021 at 23:16)</a>:</h4>
<p>Please don't change the time limit in the VSCode extension.</p>



<a name="258847739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258847739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258847739">(Oct 23 2021 at 23:17)</a>:</h4>
<p>Commit to mathlib are all compiled with that time limit in place, and you are only going to cause yourself pain to develop code with the limit raised, only to have to get it back down afterwards.</p>



<a name="258847793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258847793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258847793">(Oct 23 2021 at 23:18)</a>:</h4>
<p>I'm pretty certain no kernel change could affect anything like this. It may be that some earlier definition has changed, or just I made a mistake at the time.</p>



<a name="258847801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258847801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258847801">(Oct 23 2021 at 23:18)</a>:</h4>
<p>If anything you should _lower_ the time limit, to be sure that you're contributing code that still has some margin. :-)</p>



<a name="258866482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258866482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258866482">(Oct 24 2021 at 08:18)</a>:</h4>
<p>Something which Scott doesn't seem to say but which is something I learnt from him in the past is that "trying to make the proof <code>rfl</code>" is something which is a great idea for simple objects but which can become an actively bad idea as your objects become more complicated. Rewriting a non-<code>rfl</code> proof can sometimes be much quicker than <code>rfl</code> once terms start getting big. My (perhaps ignorant) impression of people who work with different provers or on different kinds of questions can somehow become obsessed with making things <code>refl</code> perhaps because they're computer scientists so feel that everything should compute. In maths it doesn't work like that. I'd far rather have a quick <code>rw</code> proof than a slow <code>refl</code> proof because beyond some point in mathematics <code>refl</code> doesn't actually buy you anything.</p>



<a name="258868887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258868887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258868887">(Oct 24 2021 at 09:21)</a>:</h4>
<p>Exactly. Expecting <code>rfl</code> proofs at some point just becomes a trap: Lean can unexpectedly go off and do very inefficient proofs by definitional unfolding. Often it's better to intentionally make definitions irreducible, or wrapped in structures, precisely so Lean <em>can't</em> see through them!</p>



<a name="258931018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258931018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258931018">(Oct 25 2021 at 08:45)</a>:</h4>
<p>I've finished the aforementioned planned changes to <a href="https://github.com/alreadydone/mathlib/commit/ea89922c5e6b12fb70fc342041e6b504d5b45c44#diff-252fb30c3a3221e6472db5ba794344dfb423898696e70299653d95f635de06ad">presheafed_space.lean</a><br>
 and associated files, but Spec.lean and has_colimits.lean have some broken proofs not yet fixed, so I haven't compiled mathlib with the time limit yet. Nonetheless, here is a preview commit containing the main changes. You can see my philosophy is to prove and make use of equalities (to "collapse tower of isomorphisms") and take advantage of defeqs (which may or may not be bad, as discussed above) whenever possible, and use eq_to_hom if involved types are not defeq. As you can see the changes already resulted in a lot of simplified proofs (though I have no idea about the compile time yet), but I only made minimum changes in other files, and those proofs likely can be further optimized under the new definitions. Let me know if this seems like the right approach to you.</p>



<a name="258937004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258937004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258937004">(Oct 25 2021 at 09:48)</a>:</h4>
<p>I think I'd like to see no sorries and no timeouts before having any opinion. :-)</p>



<a name="258937038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258937038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258937038">(Oct 25 2021 at 09:49)</a>:</h4>
<p>(As I said before, developing with the timelimit turned off is counterproductive.)</p>



<a name="258968481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/258968481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#258968481">(Oct 25 2021 at 14:41)</a>:</h4>
<p>I developed this on another machine where time limit wasn't turned off. I didn't get any deterministic timeouts in the files I checked, but this computer is faster (MacBook Pro 2019, 2.3GHz 8-Core Intel i9, 32 GB memory).</p>



<a name="259049443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/259049443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#259049443">(Oct 26 2021 at 03:59)</a>:</h4>
<p>I fixed all proofs and compilation using the command you gave me finished in several minutes, so I opened PR <a href="https://github.com/leanprover-community/mathlib/issues/9972">#9972</a>. I didn't merge latest mathlib before compiling though. Lean spat out about 20 lines of output and they are truncated to the window width so I can't see the full messages and am not sure if the compilation has been successful. Let's wait for the automated mathlib build with the PR.</p>



<a name="259050017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/259050017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#259050017">(Oct 26 2021 at 04:08)</a>:</h4>
<p>continuous integration / Build mathlib (push) Successful in 9m</p>



<a name="259056859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/259056859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#259056859">(Oct 26 2021 at 06:35)</a>:</h4>
<p>Looks great!!</p>



<a name="259056875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/259056875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#259056875">(Oct 26 2021 at 06:35)</a>:</h4>
<p>Apologies if I was skeptical earlier. This is a big improvement.</p>



<a name="269454125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/269454125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anthony Bordg <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#269454125">(Jan 26 2022 at 17:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/extensionality.20for.20functors/near/258170194">said</a>:</p>
<blockquote>
<p>Me+Amelia+Kenny+Chris+Ramon+Scott's paper on the definition of a scheme got published, and I should think that the Isabelle definition of a scheme will end up published too, </p>
</blockquote>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> <br>
Hopefully, this is currently in the hands of referees.</p>



<a name="288193375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/extensionality%20for%20functors/near/288193375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anthony Bordg <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/extensionality.20for.20functors.html#288193375">(Jul 01 2022 at 16:22)</a>:</h4>
<p>For the record, our paper <em>Simple Type Theory is not too Simple: Grothendieck's Schemes Without Dependent Types</em> has been published in the journal Experimental Mathematics and is open access <a href="https://www.tandfonline.com/doi/full/10.1080/10586458.2022.2062073">online</a>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
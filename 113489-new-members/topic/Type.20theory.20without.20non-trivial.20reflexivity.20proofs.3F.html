---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Type.20theory.20without.20non-trivial.20reflexivity.20proofs.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20theory.20without.20non-trivial.20reflexivity.20proofs.3F.html">Type theory without non-trivial reflexivity proofs?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="213556175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20theory%20without%20non-trivial%20reflexivity%20proofs%3F/near/213556175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20theory.20without.20non-trivial.20reflexivity.20proofs.3F.html#213556175">(Oct 16 2020 at 12:59)</a>:</h4>
<p>In the Lean tutorial it says that nontrivial identities can be proved by reflexivity. An example is :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="mi">2</span><span class="bp">+</span><span class="mi">3</span><span class="bp">=</span><span class="mi">5</span> <span class="o">:=</span> <span class="n">eq.refl</span> <span class="n">_</span>
</code></pre></div>

<p>My understanding of how the Lean type checker does this is that it kind of "computes 2 + 5 at compile time, and if it indeed computes to 5, accepts the proof". </p>
<p>So in a sense, we ca  think of an equality proof as a kind of "compile-time computation" that gives you a token that allows you to "skip the computation at runtime" and just grab the precomputed result.</p>
<p>Are there type systems (other than Lean's) where this is explicit? I.e. where you have to actually do the "compile time computation" yourself, and can only use equational reflexivity for the trivial case?</p>



<a name="213577791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20theory%20without%20non-trivial%20reflexivity%20proofs%3F/near/213577791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20theory.20without.20non-trivial.20reflexivity.20proofs.3F.html#213577791">(Oct 16 2020 at 15:47)</a>:</h4>
<p>Yes, metamath computations work like this, HOL too</p>



<a name="213577873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20theory%20without%20non-trivial%20reflexivity%20proofs%3F/near/213577873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20theory.20without.20non-trivial.20reflexivity.20proofs.3F.html#213577873">(Oct 16 2020 at 15:48)</a>:</h4>
<p>In fact I think it is a feature unique to DTT</p>



<a name="213578167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%20theory%20without%20non-trivial%20reflexivity%20proofs%3F/near/213578167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Type.20theory.20without.20non-trivial.20reflexivity.20proofs.3F.html#213578167">(Oct 16 2020 at 15:50)</a>:</h4>
<p>See for example <a href="http://us.metamath.org/mpeuni/2p2e4.html">http://us.metamath.org/mpeuni/2p2e4.html</a> and note that the proof is not "by refl" but rather by a couple of applications of associativity</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
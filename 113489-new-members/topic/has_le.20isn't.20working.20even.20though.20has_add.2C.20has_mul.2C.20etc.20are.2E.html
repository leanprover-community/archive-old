---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html">has_le isn't working even though has_add, has_mul, etc are.</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="295111920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_le%20isn%27t%20working%20even%20though%20has_add%2C%20has_mul%2C%20etc%20are./near/295111920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> kvanvels <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html#295111920">(Aug 24 2022 at 19:27)</a>:</h4>
<p>I come across a tutorial on defining mathematical classes from the use of equivalence classes <a href="https://github.com/ImperialCollegeLondon/formalising-mathematics/blob/master/src/week_7/Part_A_quotients.lean">here</a> on Dr. Buzzards web page.  I did the tutorial and as a further exercise I want to define an ordering on <code>Z</code>.  So I added the appropriate le_aux, le_aux_def, le functions/proofs.  I added the line <code>instance : has_le Z := ⟨le⟩</code> to allow me (I thought) to use the (less or equal) symbol like I could use the plus sign for addition and the star for multiplication.  </p>
<p>If anyone can tell me what I did wrong in the following code, I would appreciate it.</p>
<p>The following code is probably overkill, but I wanted to show that lean had no issue with accepting has_zero, has_one, has_add, etc.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">abbreviation</span> <span class="n">N2</span> <span class="o">:=</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span>
<span class="kn">namespace</span> <span class="n">N2</span>

<span class="kd">def</span> <span class="n">r</span> <span class="o">(</span><span class="n">ab</span> <span class="n">cd</span> <span class="o">:</span> <span class="n">N2</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">ab.1</span> <span class="bp">+</span> <span class="n">cd.2</span> <span class="bp">=</span> <span class="n">cd.1</span> <span class="bp">+</span> <span class="n">ab.2</span>

<span class="kd">lemma</span> <span class="n">r_def</span> <span class="o">(</span><span class="n">ab</span> <span class="n">cd</span> <span class="o">:</span> <span class="n">N2</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="n">ab</span> <span class="n">cd</span> <span class="bp">↔</span> <span class="n">ab.1</span> <span class="bp">+</span> <span class="n">cd.2</span> <span class="bp">=</span> <span class="n">cd.1</span> <span class="bp">+</span> <span class="n">ab.2</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>
<span class="kd">lemma</span> <span class="n">r_def'</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span><span class="n">d</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>


<span class="kd">def</span> <span class="n">r_refl</span> <span class="o">:</span> <span class="n">reflexive</span> <span class="n">r</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">r_symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">r</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">r_trans</span> <span class="o">:</span> <span class="n">transitive</span> <span class="n">r</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">instance</span> <span class="n">setoid</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">N2</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">r_refl</span><span class="o">,</span> <span class="n">r_symm</span><span class="o">,</span> <span class="n">r_trans</span><span class="o">⟩</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">N2</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≈</span> <span class="n">y</span> <span class="bp">↔</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">equiv_def</span> <span class="o">(</span><span class="n">ab</span> <span class="n">cd</span> <span class="o">:</span> <span class="n">N2</span><span class="o">)</span> <span class="o">:</span> <span class="n">ab</span> <span class="bp">≈</span> <span class="n">cd</span> <span class="bp">↔</span> <span class="n">ab.1</span> <span class="bp">+</span> <span class="n">cd.2</span> <span class="bp">=</span> <span class="n">cd.1</span> <span class="bp">+</span> <span class="n">ab.2</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">equiv_def'</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="bp">≈</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span><span class="n">d</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">iff.rfl</span>
<span class="kd">end</span> <span class="n">N2</span>

<span class="c1">-- Now we can take the quotient!</span>
<span class="kd">def</span> <span class="n">Z</span> <span class="o">:=</span> <span class="n">quotient</span> <span class="n">N2.setoid</span>

<span class="kn">namespace</span> <span class="n">Z</span>
<span class="c1">--## Giving Z a commutative ring structure</span>

<span class="kd">def</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">Z</span> <span class="o">:=</span> <span class="bp">⟦</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span><span class="bp">⟧</span>
<span class="kd">def</span> <span class="n">one</span> <span class="o">:</span> <span class="n">Z</span> <span class="o">:=</span> <span class="bp">⟦</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span><span class="bp">⟧</span>


<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">Z</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">zero</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="n">Z</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">one</span><span class="o">⟩</span>

<span class="c1">-- let's start to train the simplifier</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">zero_def</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">Z</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⟦</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span><span class="bp">⟧</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- works</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">one_def</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">Z</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⟦</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span><span class="bp">⟧</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c1">--## Addition</span>
<span class="kd">def</span> <span class="n">add_aux</span> <span class="o">(</span><span class="n">ab</span> <span class="n">cd</span> <span class="o">:</span> <span class="n">N2</span><span class="o">)</span> <span class="o">:</span> <span class="n">Z</span> <span class="o">:=</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">ab.1</span> <span class="bp">+</span> <span class="n">cd.1</span><span class="o">,</span> <span class="n">ab.2</span> <span class="bp">+</span> <span class="n">cd.2</span><span class="o">)</span><span class="bp">⟧</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">add_aux_def</span> <span class="o">(</span><span class="n">ab</span> <span class="n">cd</span> <span class="o">:</span> <span class="n">N2</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">add_aux</span> <span class="n">ab</span> <span class="n">cd</span> <span class="bp">=</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">ab.1</span> <span class="bp">+</span> <span class="n">cd.1</span><span class="o">,</span> <span class="n">ab.2</span> <span class="bp">+</span> <span class="n">cd.2</span><span class="o">)</span><span class="bp">⟧</span> <span class="o">:=</span><span class="n">rfl</span>

<span class="kd">def</span> <span class="n">add</span> <span class="o">:</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">Z</span> <span class="o">:=</span> <span class="n">quotient.lift₂</span> <span class="n">add_aux</span> <span class="gr">sorry</span>


<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">Z</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">add</span><span class="o">⟩</span>

<span class="c1">-- train the simplifier, because we have some axioms to prove about `+`</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">add_def</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⟦</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span><span class="bp">⟧</span> <span class="bp">+</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span><span class="bp">⟧</span> <span class="o">:</span> <span class="n">Z</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="bp">+</span><span class="n">d</span><span class="o">)</span><span class="bp">⟧</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c1">-- THIS IS THE STUFF I ADDED</span>
<span class="c1">-- I don't understand why has_add seemed to work but my has_le didn't.</span>

<span class="kd">def</span> <span class="n">le_aux</span> <span class="o">(</span><span class="n">ab</span> <span class="n">cd</span> <span class="o">:</span> <span class="n">N2</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">ab.fst</span> <span class="bp">+</span> <span class="n">cd.snd</span><span class="o">)</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">cd.fst</span> <span class="bp">+</span> <span class="n">ab.snd</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">le_aux_def</span> <span class="o">(</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">b0</span> <span class="n">b1</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">le_aux</span> <span class="o">(</span><span class="n">a0</span><span class="o">,</span> <span class="n">a1</span><span class="o">)</span> <span class="o">(</span><span class="n">b0</span><span class="o">,</span> <span class="n">b1</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">a0</span> <span class="bp">+</span> <span class="n">b1</span><span class="o">)</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">b0</span> <span class="bp">+</span> <span class="n">a1</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>


<span class="kd">def</span> <span class="n">le</span> <span class="o">:</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">Z</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">quotient.lift₂</span> <span class="n">le_aux</span> <span class="gr">sorry</span>


<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_le</span> <span class="n">Z</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">le</span><span class="o">⟩</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">le_def</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⟦</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span><span class="bp">⟧</span> <span class="o">:</span> <span class="n">Z</span><span class="o">)</span> <span class="bp">≤</span>  <span class="o">(</span><span class="bp">⟦</span><span class="o">(</span><span class="n">c</span><span class="o">,</span><span class="n">d</span><span class="o">)</span><span class="bp">⟧</span> <span class="o">:</span> <span class="n">Z</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>


<span class="kd">end</span> <span class="n">Z</span>
</code></pre></div>
<p>Lean tells me that it </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
 <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span>
 <span class="bp">⊢</span> <span class="n">has_le</span> <span class="o">(</span><span class="n">quotient</span> <span class="n">N2.setoid</span><span class="o">)</span> <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
</code></pre></div>
<p>on the <code>le_def</code> line.  Any help will be appreciated.  Thanks.</p>



<a name="295115488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_le%20isn%27t%20working%20even%20though%20has_add%2C%20has_mul%2C%20etc%20are./near/295115488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> kvanvels <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html#295115488">(Aug 24 2022 at 19:49)</a>:</h4>
<p>I am wondering if <code>quotient.lift</code> is inappropriate since the "return value" of the function is a proposition and not element of <code>Z</code>.</p>



<a name="295116127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_le%20isn%27t%20working%20even%20though%20has_add%2C%20has_mul%2C%20etc%20are./near/295116127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html#295116127">(Aug 24 2022 at 19:53)</a>:</h4>
<p>It's because it interprets <code>⟦(a,b)⟧</code> as having type <code>quotient N2.setoid</code>, not <code>ℤ</code>. Those are definitionally equal, but not syntactically so, and that's what typeclass inference needs. One solution is to define a specialisation of <code>quotient.mk</code> to your <code>ℤ</code>.</p>



<a name="295117027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_le%20isn%27t%20working%20even%20though%20has_add%2C%20has_mul%2C%20etc%20are./near/295117027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> kvanvels <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html#295117027">(Aug 24 2022 at 19:59)</a>:</h4>
<p>I thought that the the <code>: Z</code> made it into an element of Z.  I honestly don't know what you it would mean to define a specialization of <a href="http://quotient.mk">quotient.mk</a>.  Any pointers/links would be appreciated.  </p>
<p>I just checked, and lean has no problem if I tell it that <a href="http://Z.zero">Z.zero</a> &lt;= <a href="http://Z.one">Z.one</a>.  So what you told me makes sense.  Thanks for the response.</p>



<a name="295118235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_le%20isn%27t%20working%20even%20though%20has_add%2C%20has_mul%2C%20etc%20are./near/295118235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html#295118235">(Aug 24 2022 at 20:07)</a>:</h4>
<p>It's because a type-ascription doesn't actually mean "Make the type be this" but rather "Check that this is defeq to the type you found". And here indeed the type it found is defeq to <code>ℤ</code>.</p>



<a name="295118342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_le%20isn%27t%20working%20even%20though%20has_add%2C%20has_mul%2C%20etc%20are./near/295118342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html#295118342">(Aug 24 2022 at 20:07)</a>:</h4>
<p>What I'm talking about is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="n">quotient.mk</span>
</code></pre></div>



<a name="295118773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_le%20isn%27t%20working%20even%20though%20has_add%2C%20has_mul%2C%20etc%20are./near/295118773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> kvanvels <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html#295118773">(Aug 24 2022 at 20:10)</a>:</h4>
<p>Thanks for the response.  I will post more when I find out if I can get this to work.</p>



<a name="295121445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_le%20isn%27t%20working%20even%20though%20has_add%2C%20has_mul%2C%20etc%20are./near/295121445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html#295121445">(Aug 24 2022 at 20:28)</a>:</h4>
<p>As Yaël mentioned, type-ascription is more of a suggestion to Lean.  If you really want to force the type, a common trick is to use <code>(id a : α)</code>.  Sticking the identity in guarantees (I think) that the type will be α.</p>



<a name="295123723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_le%20isn%27t%20working%20even%20though%20has_add%2C%20has_mul%2C%20etc%20are./near/295123723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> kvanvels <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html#295123723">(Aug 24 2022 at 20:44)</a>:</h4>
<p>I think the <code>(id a : \alpha)</code> trick is working.   Thank you.</p>



<a name="295123755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_le%20isn%27t%20working%20even%20though%20has_add%2C%20has_mul%2C%20etc%20are./near/295123755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html#295123755">(Aug 24 2022 at 20:44)</a>:</h4>
<p>You can also use <code>show α, from a</code>, which is a <em>macro</em> that basically unfolds to the <code>id</code> trick.</p>



<a name="295123852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_le%20isn%27t%20working%20even%20though%20has_add%2C%20has_mul%2C%20etc%20are./near/295123852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html#295123852">(Aug 24 2022 at 20:45)</a>:</h4>
<p>The problem is that this changes the syntactic form of your lemma, which is undesirable for rewriting.</p>



<a name="295124141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_le%20isn%27t%20working%20even%20though%20has_add%2C%20has_mul%2C%20etc%20are./near/295124141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> kvanvels <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html#295124141">(Aug 24 2022 at 20:47)</a>:</h4>
<p>I was just wondering about that the fact that.  I hope the addition of (id) wont till be a problem.  Like you said, I need to use this for rewriting.  Any ideas on why the other operations worked?  I wonder if the return type helped it figure things out. </p>
<p>I will post more if I have more questions.  Thank you.</p>



<a name="295124558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_le%20isn%27t%20working%20even%20though%20has_add%2C%20has_mul%2C%20etc%20are./near/295124558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html#295124558">(Aug 24 2022 at 20:50)</a>:</h4>
<p>Yes exactly, the return type is enough for Lean to infer what you actually mean. This is not the case when you only have type-ascriptions.</p>



<a name="295124954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_le%20isn%27t%20working%20even%20though%20has_add%2C%20has_mul%2C%20etc%20are./near/295124954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> kvanvels <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html#295124954">(Aug 24 2022 at 20:53)</a>:</h4>
<p>Yeah, it isn't working with the id's.    Is there any way i could do <code>Z.le</code> or something like  <code>Z.operator&lt;=</code> like in C++?  By the way, I didn't get very far with the <a href="http://quotient.mk">quotient.mk</a> idea very far.</p>



<a name="295126678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_le%20isn%27t%20working%20even%20though%20has_add%2C%20has_mul%2C%20etc%20are./near/295126678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html#295126678">(Aug 24 2022 at 21:05)</a>:</h4>
<p>Define <code>def mk : ℕ × ℕ → ℤ := quotient.mk</code> and use it instead of the square brackets notation.</p>



<a name="295127528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_le%20isn%27t%20working%20even%20though%20has_add%2C%20has_mul%2C%20etc%20are./near/295127528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> kvanvels <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html#295127528">(Aug 24 2022 at 21:10)</a>:</h4>
<p>It works as a theorem/lemma, but I can't use it to rewrite terms in other proofs.   Maybe I could to another level and have a theorem/lemma to write things with brackets in terms of the mk.</p>



<a name="295128033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_le%20isn%27t%20working%20even%20though%20has_add%2C%20has_mul%2C%20etc%20are./near/295128033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> kvanvels <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html#295128033">(Aug 24 2022 at 21:13)</a>:</h4>
<p>THANK YOU.  I got it to work, using an extra level (another theorem to transform mk's to square bracket terms).  I really appreciate the help.</p>



<a name="295149520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/has_le%20isn%27t%20working%20even%20though%20has_add%2C%20has_mul%2C%20etc%20are./near/295149520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> kvanvels <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/has_le.20isn't.20working.20even.20though.20has_add.2C.20has_mul.2C.20etc.20are.2E.html#295149520">(Aug 25 2022 at 01:50)</a>:</h4>
<p>I turned on a bunch of "messages" (the <code>pp.universes, pp.implicit</code> ,etc. switches ) and was able to figure out that  that the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex"> \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span></span></span></span>  sign I needed can be called by the incantation <code>@has_le.le Z Z.has_le</code> so I didn't need to use the idea of (that worked great) of the <code>quotient.mk</code>.  I suppose I could run into problems later from this hack, but I am just trying to learn the library.  Again, thanks for your help.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
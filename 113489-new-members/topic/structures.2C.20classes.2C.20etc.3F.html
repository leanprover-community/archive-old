---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/structures.2C.20classes.2C.20etc.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20classes.2C.20etc.3F.html">structures, classes, etc?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="245857079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20classes%2C%20etc%3F/near/245857079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20classes.2C.20etc.3F.html#245857079">(Jul 13 2021 at 17:16)</a>:</h4>
<p>What do I use each for, and is there a good mental way to follow what I want to do when I want to construct something?</p>



<a name="245857633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20classes%2C%20etc%3F/near/245857633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20classes.2C.20etc.3F.html#245857633">(Jul 13 2021 at 17:20)</a>:</h4>
<p>What's your background? <code>group G</code> is a class because given a type <code>G</code> 99 times out 100 it will have at most one group structure. But <code>subgroup G</code> is a structure because given a group <code>G</code> 99 times out of 100 it will have more than one subgroup.</p>



<a name="245859727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20classes%2C%20etc%3F/near/245859727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20classes.2C.20etc.3F.html#245859727">(Jul 13 2021 at 17:35)</a>:</h4>
<p>My background is undergraduate mathematics student headed into fourth year. I am working on the <code>formalising-mathematics</code> tutorial mentioned in the group theory conversation, and will specifically look at the group and subgroup section because I want to attempt a proof of Euler's theorem through group theory, as well as take a look at Lagrange's theorem. I browse the new members conversations and see structures and classes come up quite a bit and want to understand them so I can use them, since they seem directly relevant, although I will obviously borrow the definitions from groups and subgroups to get started.</p>



<a name="245860124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20classes%2C%20etc%3F/near/245860124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20classes.2C.20etc.3F.html#245860124">(Jul 13 2021 at 17:37)</a>:</h4>
<p>There are several things I am trying to get my head around.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">@[ext]</span> <span class="kd">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">Hnonempty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">C</span><span class="o">,</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span>
<span class="o">(</span><span class="n">Hcover</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">C</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">Hdisjoint</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">∈</span> <span class="n">C</span><span class="o">,</span> <span class="o">(</span><span class="n">X</span> <span class="bp">∩</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">partition</span>

<span class="c1">-- let α be a type, and fix a partition P on α. Let X and Y be subsets of α.</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span>

<span class="sd">/-- If X and Y are blocks, and a is in X and Y, then X = Y. -/</span>
<span class="kd">theorem</span> <span class="n">eq_of_mem</span> <span class="o">(</span><span class="n">hX</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P.C</span><span class="o">)</span> <span class="o">(</span><span class="n">hY</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">∈</span> <span class="n">P.C</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">haX</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">X</span><span class="o">)</span>
  <span class="o">(</span><span class="n">haY</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="c1">-- Proof: follows immediately from the disjointness hypothesis.</span>
<span class="n">P.Hdisjoint</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hX</span> <span class="n">hY</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">haX</span><span class="o">,</span> <span class="n">haY</span><span class="o">⟩</span>

<span class="kd">theorem</span> <span class="n">mem_of_mem</span> <span class="o">(</span><span class="n">hX</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P.C</span><span class="o">)</span> <span class="o">(</span><span class="n">hY</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">∈</span> <span class="n">P.C</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">haX</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">haY</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">hbX</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- you might want to start with `have hXY : X = Y`</span>
  <span class="c1">-- and prove it from the previous lemma</span>
  <span class="k">have</span> <span class="n">hXY</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">eq_of_mem</span> <span class="n">hX</span> <span class="n">hY</span> <span class="n">haX</span> <span class="n">haY</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">hXY</span><span class="o">,</span>
  <span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">partition</span>

<span class="kn">section</span> <span class="n">equivalence_classes</span>

<span class="c">/-</span><span class="cm">!</span>

<span class="cm">## Definition of equivalence classes</span>

<span class="cm">-/</span>

<span class="c1">-- Notation and variables for the equivalence class section:</span>

<span class="c1">-- let α be a type, and let R be a binary relation on R.</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="sd">/-- The equivalence class of `a` is the set of `b` related to `a`. -/</span>
<span class="kd">def</span> <span class="n">cl</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">R</span> <span class="n">b</span> <span class="n">a</span><span class="o">}</span>

<span class="c">/-</span><span class="cm">!</span>

<span class="cm">## Basic lemmas about equivalence classes</span>

<span class="cm">-/</span>

<span class="sd">/-- Useful for rewriting -- `b` is in the equivalence class of `a` iff</span>
<span class="sd">`b` is related to `a`. True by definition. -/</span>
<span class="kd">theorem</span> <span class="n">mem_cl_iff</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">cl</span> <span class="n">R</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">R</span> <span class="n">b</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- true by definition</span>
  <span class="n">refl</span>
<span class="kd">end</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">hR</span> <span class="o">:</span> <span class="n">equivalence</span> <span class="n">R</span><span class="o">)</span>
<span class="kn">include</span> <span class="n">hR</span>

<span class="kd">lemma</span> <span class="n">cl_sub_cl_of_mem_cl</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">∈</span> <span class="n">cl</span> <span class="n">R</span> <span class="n">b</span> <span class="bp">→</span>
  <span class="n">cl</span> <span class="n">R</span> <span class="n">a</span> <span class="bp">⊆</span> <span class="n">cl</span> <span class="n">R</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- remember `set.subset_def` says `X ⊆ Y ↔ ∀ a, a ∈ X → a ∈ Y</span>
  <span class="n">intro</span> <span class="n">hab</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">z</span> <span class="n">hza</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mem_cl_iff</span> <span class="n">at</span> <span class="n">hab</span> <span class="n">hza</span> <span class="bp">⊢</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">hrefl</span><span class="o">,</span> <span class="n">hsymm</span><span class="o">,</span> <span class="n">htrans</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hR</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">htrans</span> <span class="n">hza</span> <span class="n">hab</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">cl_eq_cl_of_mem_cl</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">∈</span> <span class="n">cl</span> <span class="n">R</span> <span class="n">b</span> <span class="bp">→</span>
  <span class="n">cl</span> <span class="n">R</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">cl</span> <span class="n">R</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">hab</span><span class="o">,</span>
  <span class="c1">-- remember `set.subset.antisymm` says `X ⊆ Y → Y ⊆ X → X = Y`</span>
  <span class="n">apply</span> <span class="n">set.subset.antisymm</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">cl_sub_cl_of_mem_cl</span> <span class="n">hR</span> <span class="n">hab</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">cl_sub_cl_of_mem_cl</span> <span class="n">hR</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">hrefl</span><span class="o">,</span> <span class="n">hsymm</span><span class="o">,</span> <span class="n">htrans</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hR</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hsymm</span> <span class="n">hab</span> <span class="o">}</span>
<span class="kd">end</span>


<span class="kd">end</span> <span class="n">equivalence_classes</span>





<span class="kn">open</span> <span class="n">partition</span>


<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="bp">//</span> <span class="n">equivalence</span> <span class="n">R</span><span class="o">}</span> <span class="bp">≃</span> <span class="n">partition</span> <span class="n">α</span> <span class="o">:=</span>
<span class="c1">-- We define constructions (functions!) in both directions and prove that</span>
<span class="c1">-- one is a two-sided inverse of the other</span>
<span class="o">{</span> <span class="c1">-- Here is the first construction, from equivalence</span>
  <span class="c1">-- relations to partitions.</span>
  <span class="c1">-- Let R be an equivalence relation.</span>
  <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">R</span><span class="o">,</span> <span class="o">{</span>
    <span class="c1">-- Let C be the set of equivalence classes for R.</span>
    <span class="n">C</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">cl</span> <span class="n">R.1</span> <span class="n">x</span><span class="o">},</span>
    <span class="c1">-- I claim that C is a partition. We need to check the three</span>
    <span class="c1">-- hypotheses for a partition (`Hnonempty`, `Hcover` and `Hdisjoint`),</span>
    <span class="c1">-- so we need to supply three proofs.</span>
    <span class="n">Hnonempty</span> <span class="o">:=</span> <span class="kd">begin</span>
      <span class="n">cases</span> <span class="n">R</span> <span class="k">with</span> <span class="n">R</span> <span class="n">hR</span><span class="o">,</span>
      <span class="c1">-- If X is an equivalence class then X is nonempty.</span>
      <span class="k">show</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">cl</span> <span class="n">R</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span> <span class="n">X.nonempty</span><span class="o">,</span>
      <span class="n">rintros</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
      <span class="n">use</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mem_cl_iff</span><span class="o">,</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">hrefl</span><span class="o">,</span> <span class="n">hsymm</span><span class="o">,</span> <span class="n">htrans</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hR</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">hrefl</span><span class="o">,</span>
    <span class="kd">end</span><span class="o">,</span>
    <span class="n">Hcover</span> <span class="o">:=</span> <span class="kd">begin</span>
      <span class="n">cases</span> <span class="n">R</span> <span class="k">with</span> <span class="n">R</span> <span class="n">hR</span><span class="o">,</span>
      <span class="c1">-- The equivalence classes cover α</span>
      <span class="k">show</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">cl</span> <span class="n">R</span> <span class="n">b</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">X</span><span class="o">,</span>
      <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">cl</span> <span class="n">R</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">use</span> <span class="n">a</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">apply</span> <span class="n">hR.1</span> <span class="o">},</span>
    <span class="kd">end</span><span class="o">,</span>
    <span class="n">Hdisjoint</span> <span class="o">:=</span> <span class="kd">begin</span>
      <span class="n">cases</span> <span class="n">R</span> <span class="k">with</span> <span class="n">R</span> <span class="n">hR</span><span class="o">,</span>
      <span class="c1">-- If two equivalence classes overlap, they are equal.</span>
      <span class="k">show</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">cl</span> <span class="n">R</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span>
        <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">Y</span> <span class="bp">=</span> <span class="n">cl</span> <span class="n">_</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">X</span> <span class="bp">∩</span> <span class="n">Y</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span><span class="o">,</span>
      <span class="n">rintros</span> <span class="n">X</span> <span class="n">Y</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">hca</span><span class="o">,</span> <span class="n">hcb</span><span class="o">⟩,</span>
      <span class="n">apply</span> <span class="n">cl_eq_cl_of_mem_cl</span> <span class="n">hR</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">hR.2.2</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">hR.2.1</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">hca</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hcb</span><span class="o">,</span>
    <span class="kd">end</span> <span class="o">},</span>
  <span class="c1">-- Conversely, say P is an partition.</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">P</span><span class="o">,</span>
    <span class="c1">-- Let's define a binary relation `R` thus:</span>
    <span class="c1">--  `R a b` iff *every* block containing `a` also contains `b`.</span>
    <span class="c1">-- Because only one block contains a, this will work,</span>
    <span class="c1">-- and it turns out to be a nice way of thinking about it.</span>
    <span class="o">⟨</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P.C</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">X</span><span class="o">,</span> <span class="kd">begin</span>
      <span class="c1">-- I claim this is an equivalence relation.</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="c1">-- It's reflexive</span>
      <span class="k">show</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
        <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P.C</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">X</span><span class="o">,</span>
      <span class="n">intros</span> <span class="n">a</span> <span class="n">X</span> <span class="n">hXC</span> <span class="n">haX</span><span class="o">,</span>
      <span class="n">assumption</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="c1">-- it's symmetric</span>
      <span class="k">show</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span>
        <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P.C</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span>
         <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P.C</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">X</span><span class="o">,</span>
      <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span> <span class="n">X</span> <span class="n">hX</span> <span class="n">hbX</span><span class="o">,</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">Y</span><span class="o">,</span> <span class="n">hY</span><span class="o">,</span> <span class="n">haY</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">P.Hcover</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">specialize</span> <span class="n">h</span> <span class="n">Y</span> <span class="n">hY</span> <span class="n">haY</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">mem_of_mem</span> <span class="n">hY</span> <span class="n">hX</span> <span class="n">h</span> <span class="n">hbX</span> <span class="n">haY</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span> <span class="c1">-- it's transitive</span>
      <span class="n">unfold</span> <span class="n">transitive</span><span class="o">,</span>
      <span class="k">show</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span>
        <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P.C</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span>
        <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P.C</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">∈</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span>
         <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P.C</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">∈</span> <span class="n">X</span><span class="o">,</span>
      <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">hbX</span> <span class="n">hcX</span> <span class="n">X</span> <span class="n">hX</span> <span class="n">haX</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">hcX</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">hbX</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span>
      <span class="n">assumption</span><span class="o">,</span>
    <span class="o">}</span>
  <span class="kd">end</span><span class="o">⟩,</span>
  <span class="c1">-- If you start with the equivalence relation, and then make the partition</span>
  <span class="c1">-- and a new equivalence relation, you get back to where you started.</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">R</span><span class="o">,</span> <span class="n">hR</span><span class="o">⟩,</span>
    <span class="c1">-- Tidying up the mess...</span>
    <span class="k">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">cl</span> <span class="n">R</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">cl</span> <span class="n">R</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">R</span><span class="o">,</span>
      <span class="n">simpa</span><span class="o">,</span>
    <span class="c1">-- ... you have to prove two binary relations are equal.</span>
    <span class="n">ext</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
    <span class="c1">-- so you have to prove an if and only if.</span>
    <span class="k">show</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">cl</span> <span class="n">R</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">cl</span> <span class="n">R</span> <span class="n">c</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">R</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">hab</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">hR.2.1</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">hab</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">hR.1</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">hab</span> <span class="n">c</span> <span class="n">hac</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">hR.2.2</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">hR.2.1</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">hab</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hac</span><span class="o">,</span>
    <span class="o">}</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="c1">-- Similarly, if you start with the partition, and then make the</span>
  <span class="c1">-- equivalence relation, and then construct the corresponding partition</span>
  <span class="c1">-- into equivalence classes, you have the same partition you started with.</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="c1">-- Let P be a partition</span>
    <span class="n">intro</span> <span class="n">P</span><span class="o">,</span>
    <span class="c1">-- It suffices to prove that a subset X is in the original partition</span>
    <span class="c1">-- if and only if it's in the one made from the equivalence relation.</span>
    <span class="n">ext</span> <span class="n">X</span><span class="o">,</span>
    <span class="k">show</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">cl</span> <span class="n">_</span> <span class="n">a</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P.C</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="n">only</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">X</span><span class="o">,</span> <span class="n">hX</span><span class="o">,</span> <span class="n">haX</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">P.Hcover</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">convert</span> <span class="n">hX</span><span class="o">,</span>
      <span class="n">ext</span> <span class="n">b</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mem_cl_iff</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">intro</span> <span class="n">haY</span><span class="o">,</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">Y</span><span class="o">,</span> <span class="n">hY</span><span class="o">,</span> <span class="n">hbY</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">P.Hcover</span> <span class="n">b</span><span class="o">,</span>
      <span class="n">specialize</span> <span class="n">haY</span> <span class="n">Y</span> <span class="n">hY</span> <span class="n">hbY</span><span class="o">,</span>
      <span class="n">convert</span> <span class="n">hbY</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">eq_of_mem</span> <span class="n">hX</span> <span class="n">hY</span> <span class="n">haX</span> <span class="n">haY</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="o">{</span> <span class="n">intros</span> <span class="n">hbX</span> <span class="n">Y</span> <span class="n">hY</span> <span class="n">hbY</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">mem_of_mem</span> <span class="n">hX</span> <span class="n">hY</span> <span class="n">hbX</span> <span class="n">hbY</span> <span class="n">haX</span><span class="o">,</span>
      <span class="o">}</span>
    <span class="o">},</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">hX</span><span class="o">,</span>
      <span class="n">rcases</span> <span class="n">P.Hnonempty</span> <span class="n">X</span> <span class="n">hX</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩,</span>
      <span class="n">use</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">ext</span> <span class="n">b</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">intro</span> <span class="n">hbX</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">mem_cl_iff</span><span class="o">,</span>
        <span class="n">intros</span> <span class="n">Y</span> <span class="n">hY</span> <span class="n">hbY</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">mem_of_mem</span> <span class="n">hX</span> <span class="n">hY</span> <span class="n">hbX</span> <span class="n">hbY</span> <span class="n">ha</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="n">mem_cl_iff</span><span class="o">,</span>
        <span class="n">intro</span> <span class="n">haY</span><span class="o">,</span>
        <span class="n">obtain</span> <span class="o">⟨</span><span class="n">Y</span><span class="o">,</span> <span class="n">hY</span><span class="o">,</span> <span class="n">hbY</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">P.Hcover</span> <span class="n">b</span><span class="o">,</span>
        <span class="n">specialize</span> <span class="n">haY</span> <span class="n">Y</span> <span class="n">hY</span> <span class="n">hbY</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">mem_of_mem</span> <span class="n">hY</span> <span class="n">hX</span> <span class="n">haY</span> <span class="n">ha</span> <span class="n">hbY</span><span class="o">,</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>
<p>In the culmination of this exercise, in lines 226 and 236, <code>obtain</code> and <code>rcases</code> are used in the solution and I am still fighting a little bit with when these are applicable. I was happy to watch the demo on the leanprover community Youtube channel about proving there are infinitely many primes, because so far this is the structure I understood the best and will try to replicate, but there are still here big questions for me on moving forward in a proof through means like obtain.</p>



<a name="245860270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20classes%2C%20etc%3F/near/245860270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20classes.2C.20etc.3F.html#245860270">(Jul 13 2021 at 17:38)</a>:</h4>
<p><code>obtain</code> is just a glorified <code>cases</code> tactic.</p>



<a name="245860692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20classes%2C%20etc%3F/near/245860692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20classes.2C.20etc.3F.html#245860692">(Jul 13 2021 at 17:42)</a>:</h4>
<p>e.g. <code>obtain ⟨X, hX, haX⟩ := P.Hcover a</code> just means : <code>P</code> is a partition, <code>P.Hcover</code> is the proof that for all a there's a block of the partition P such that a is in the block, <code>P.Hcover a</code> is the proof that for this specific a, there's a block of the partition P such that this a is in that block, and the <code>obtain</code> tactic just lets <code>X</code> be the subset, <code>hX</code> be the proof that it's in the set <code>P.C</code> of blocks and <code>haX</code> be the proof that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">a\in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>.</p>



<a name="245860748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20classes%2C%20etc%3F/near/245860748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20classes.2C.20etc.3F.html#245860748">(Jul 13 2021 at 17:42)</a>:</h4>
<p><code>rcases</code> does the same sort of thing. You can do all of this stuff with the <code>cases</code> tactic but it's a bit longer.</p>



<a name="245860848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20classes%2C%20etc%3F/near/245860848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20classes.2C.20etc.3F.html#245860848">(Jul 13 2021 at 17:43)</a>:</h4>
<p>If you're going into 4th year then I assume you understand the maths proof of what's going on here! Looks like I got lazy with the commenting.</p>



<a name="245861189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20classes%2C%20etc%3F/near/245861189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20classes.2C.20etc.3F.html#245861189">(Jul 13 2021 at 17:46)</a>:</h4>
<p>Similarly <code>rcases P.Hnonempty X hX with ⟨a, ha⟩</code> means the following: <code>P</code> is a partition, <code>P.Hnonempty</code> is the proof that all blocks in it are nonempty, <code>X</code> is a subset of alpha, <code>hX</code> is the proof that it's a block, so <code>P.Hnonempty X hX</code> is a proof that <code>X</code> is nonempty, i.e. has an element, and <code>rcases P.Hnonempty X hX with ⟨a, ha⟩</code> just defines <code>a</code> to be such an element and lets <code>ha</code> be the proof that it's in <code>X</code>.</p>



<a name="245861988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20classes%2C%20etc%3F/near/245861988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20classes.2C.20etc.3F.html#245861988">(Jul 13 2021 at 17:51)</a>:</h4>
<p>My idea with that exercise was that you could try and fill in all the <code>sorry</code>s on your own, using the tactics you know, and then you can look at my model answer to see how I did it. I intentionally use some more high-powered tactics to make my proof shorter, but you can do all the proofs here with the ten basic tactics (i.e. the stuff in the natural number game) as long as you know a little about how subsets work, and I learnt from that workshop that I hadn't really said enough about how subsets work. Maybe you would learn more if you just tried to fill in the sorrys yourself instead of being intimidated by my solution?</p>



<a name="245862595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20classes%2C%20etc%3F/near/245862595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20classes.2C.20etc.3F.html#245862595">(Jul 13 2021 at 17:55)</a>:</h4>
<p>Perfect, I will do that. I was working through it alone but there were three places where I hit a block and checked. I will do it properly again tonight. Thank you for the explanations of obtain and rcases, they make a lot of sense, I'm sure I will reread your comments several times over time to remember long term. Cheers!</p>



<a name="245863707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20classes%2C%20etc%3F/near/245863707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20classes.2C.20etc.3F.html#245863707">(Jul 13 2021 at 18:02)</a>:</h4>
<p>I introduce <code>obtain</code> on line 96 or so</p>



<a name="245864005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20classes%2C%20etc%3F/near/245864005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20classes.2C.20etc.3F.html#245864005">(Jul 13 2021 at 18:04)</a>:</h4>
<p>I introduce <code>rcases</code> on line 153 or so</p>



<a name="245869030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/structures%2C%20classes%2C%20etc%3F/near/245869030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/structures.2C.20classes.2C.20etc.3F.html#245869030">(Jul 13 2021 at 18:42)</a>:</h4>
<p><span class="user-mention" data-user-id="422315">@Thomas Laraia</span> I just pushed a ton of comments about those proofs to the repo. You can check them out <a href="https://github.com/ImperialCollegeLondon/formalising-mathematics/blob/master/src/week_1/kb_solutions/Part_D_relations_solutions.lean">here</a>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
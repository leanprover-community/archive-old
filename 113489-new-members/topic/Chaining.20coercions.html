---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Chaining.20coercions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html">Chaining coercions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="225942760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225942760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Sullivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225942760">(Feb 11 2021 at 02:50)</a>:</h4>
<p>Hi Folks, A question about chaining of coercions. I start with three types, X, Y, and Z, and define pairwise coercions in both directions: from X to Y and Y to X and from Y to Z and Z to Y. Coercions of X-valued objects to Z then works fine, and from Z to X as well. However, if I now add a "branch" in the coercion graph, say from X to Y' and back, the automatic chaining of coercions (at least from X-Z and Z-X) now fails. What are the constraints on how complex a graph of coercions can be, in which automatic chaining will continue to work, and why? Thanks! --Kevin S</p>



<a name="225942804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225942804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225942804">(Feb 11 2021 at 02:51)</a>:</h4>
<p>X to Y and back is bad, that's a typeclass cycle and will make all typeclass inference problems fail</p>



<a name="225942861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225942861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225942861">(Feb 11 2021 at 02:52)</a>:</h4>
<p>You can have X to Y and back if you inhabit <code>has_coe_t</code> instead since it won't try to chain them</p>



<a name="225942988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225942988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Sullivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225942988">(Feb 11 2021 at 02:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Chaining.20coercions/near/225942804">said</a>:</p>
<blockquote>
<p>X to Y and back is bad, that's a typeclass cycle and will make all typeclass inference problems fail</p>
</blockquote>
<p>I see. Interesting. The use case is that I have a tree of isomorphic types, and I'd like to have automated coercions between any two types in the tree.  Any thoughts on how we might obtain such a capability?</p>



<a name="225943054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225943054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225943054">(Feb 11 2021 at 02:56)</a>:</h4>
<p>You could have a coe <code>A -&gt; X</code> and a coe_t <code>X -&gt; A</code> for all A and some chosen X</p>



<a name="225943081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225943081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Sullivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225943081">(Feb 11 2021 at 02:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Chaining.20coercions/near/225943054">said</a>:</p>
<blockquote>
<p>You could have a coe <code>A -&gt; X</code> and a coe_t <code>X -&gt; A</code> for all A and some chosen X</p>
</blockquote>
<p>I will let you know how that works out. Thanks a ton as always, Mario.</p>



<a name="225943261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225943261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225943261">(Feb 11 2021 at 03:00)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">foo</span> <span class="o">:=</span> <span class="o">(</span><span class="n">out</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">bar</span> <span class="o">:=</span> <span class="o">(</span><span class="n">out</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">baz</span> <span class="o">:=</span> <span class="o">(</span><span class="n">out</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">foo_nat</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">foo</span> <span class="n">nat</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">foo.out</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">bar_nat</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">bar</span> <span class="n">nat</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">bar.out</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">baz_nat</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">baz</span> <span class="n">nat</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">baz.out</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">nat_foo</span> <span class="o">:</span> <span class="n">has_coe_t</span> <span class="n">nat</span> <span class="n">foo</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">foo.mk</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">nat_bar</span> <span class="o">:</span> <span class="n">has_coe_t</span> <span class="n">nat</span> <span class="n">bar</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">bar.mk</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">nat_baz</span> <span class="o">:</span> <span class="n">has_coe_t</span> <span class="n">nat</span> <span class="n">baz</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">baz.mk</span><span class="o">⟩</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bar</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">baz</span><span class="o">)</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">bar</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">baz</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bar</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">baz</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">bar</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">baz</span><span class="o">)</span>
</code></pre></div>



<a name="225943625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225943625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Sullivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225943625">(Feb 11 2021 at 03:06)</a>:</h4>
<p>Basic types for tree of linear spaces .</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">abbreviation</span> <span class="n">coord</span> <span class="o">:=</span> <span class="n">ℕ</span>

<span class="kd">mutual</span> <span class="kd">inductive</span> <span class="n">space</span><span class="o">,</span> <span class="n">frame</span>
<span class="k">with</span> <span class="n">space</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">base</span>
<span class="bp">|</span> <span class="n">der</span> <span class="o">:</span> <span class="n">frame</span> <span class="bp">→</span> <span class="n">space</span>
<span class="k">with</span> <span class="n">frame</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">std</span>
<span class="bp">|</span> <span class="n">new</span> <span class="o">:</span> <span class="n">space</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">frame</span>

<span class="c1">-- open space frame</span>

<span class="kd">def</span> <span class="n">getf</span> <span class="o">:</span> <span class="n">space</span> <span class="bp">→</span> <span class="n">frame</span>
<span class="bp">|</span> <span class="n">space.base</span> <span class="o">:=</span> <span class="n">frame.std</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">space.der</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span>

<span class="kd">def</span> <span class="n">gets</span> <span class="o">:</span> <span class="n">frame</span> <span class="bp">→</span> <span class="n">space</span>
<span class="bp">|</span> <span class="n">frame.std</span> <span class="o">:=</span> <span class="n">space.base</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">frame.new</span> <span class="n">s</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">s</span>

<span class="c1">-- get coord of new frame relative to old frame</span>
<span class="kd">def</span> <span class="n">getc</span> <span class="o">:</span> <span class="n">frame</span> <span class="bp">→</span> <span class="n">coord</span>
<span class="bp">|</span> <span class="n">frame.std</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">frame.new</span> <span class="n">f</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n</span>

<span class="c1">-- get old frame on which which frame is built</span>
<span class="c1">-- std frame is built on itself</span>
<span class="kd">def</span> <span class="n">geto</span> <span class="o">:</span> <span class="n">frame</span> <span class="bp">→</span> <span class="n">frame</span>
<span class="bp">|</span> <span class="n">frame.std</span> <span class="o">:=</span> <span class="n">frame.std</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">frame.new</span> <span class="n">s</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">getf</span> <span class="n">s</span>


<span class="kd">inductive</span> <span class="n">point</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">space</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">point</span>

<span class="kd">def</span> <span class="n">getps</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">space</span><span class="o">},</span> <span class="n">point</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">space</span>
<span class="bp">|</span> <span class="n">s</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">s</span>

<span class="kd">def</span> <span class="n">getpf</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">space</span><span class="o">},</span> <span class="n">point</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">frame</span>
<span class="bp">|</span> <span class="n">s</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">getf</span> <span class="n">s</span>
</code></pre></div>
<p>A simple demo/test case. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="bp">.</span><span class="n">space_tree</span>

<span class="c1">--</span>

<span class="kd">def</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">space</span> <span class="o">:=</span> <span class="n">space.base</span>  <span class="c1">-- implicit std frame</span>
<span class="kd">def</span> <span class="n">f0</span> <span class="o">:=</span> <span class="n">getf</span> <span class="n">s0</span>             <span class="c1">-- standard frame</span>

<span class="kd">def</span> <span class="n">f1</span> <span class="o">:=</span> <span class="n">frame.new</span> <span class="n">s0</span> <span class="mi">2</span>      <span class="c1">-- new basis coord 2</span>
<span class="kd">def</span> <span class="n">s1</span> <span class="o">:=</span> <span class="n">space.der</span> <span class="n">f1</span>

<span class="kd">def</span> <span class="n">f2</span> <span class="o">:=</span> <span class="n">frame.new</span> <span class="n">s1</span> <span class="mi">3</span>      <span class="c1">-- new basis coord 3</span>
<span class="kd">def</span> <span class="n">s2</span> <span class="o">:=</span> <span class="n">space.der</span> <span class="n">f2</span>

<span class="kd">def</span> <span class="n">f1'</span> <span class="o">:=</span> <span class="n">frame.new</span> <span class="n">s0</span> <span class="mi">5</span>
<span class="kd">def</span> <span class="n">s1'</span> <span class="o">:=</span> <span class="n">space.der</span> <span class="n">f1'</span>

<span class="c1">-- forward and backward transforms</span>

<span class="kd">def</span> <span class="n">pt_0_1</span> <span class="o">:</span> <span class="n">point</span> <span class="n">s0</span> <span class="bp">→</span> <span class="n">point</span> <span class="n">s1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">point.mk</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="o">(</span><span class="n">getf</span> <span class="n">s1</span><span class="o">)</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">c</span> <span class="o">:=</span> <span class="o">(</span><span class="n">getc</span> <span class="n">f</span><span class="o">)</span> <span class="k">in</span>
      <span class="o">(</span><span class="n">point.mk</span> <span class="o">(</span><span class="n">n</span><span class="bp">/</span><span class="n">c</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">pt_1_0</span> <span class="o">:</span> <span class="n">point</span> <span class="n">s1</span> <span class="bp">→</span> <span class="n">point</span> <span class="n">s0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">point.mk</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="o">(</span><span class="n">getf</span> <span class="n">s1</span><span class="o">)</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">c</span> <span class="o">:=</span> <span class="o">(</span><span class="n">getc</span> <span class="n">f</span><span class="o">)</span> <span class="k">in</span>
      <span class="o">(</span><span class="n">point.mk</span> <span class="o">(</span><span class="n">n</span><span class="bp">*</span><span class="n">c</span><span class="o">))</span>

<span class="c1">--</span>
<span class="kd">def</span> <span class="n">pt_0_1'</span> <span class="o">:</span> <span class="n">point</span> <span class="n">s0</span> <span class="bp">→</span> <span class="n">point</span> <span class="n">s1'</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">point.mk</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="o">(</span><span class="n">getf</span> <span class="n">s1</span><span class="o">)</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">c</span> <span class="o">:=</span> <span class="o">(</span><span class="n">getc</span> <span class="n">f</span><span class="o">)</span> <span class="k">in</span>
      <span class="o">(</span><span class="n">point.mk</span> <span class="o">(</span><span class="n">n</span><span class="bp">/</span><span class="n">c</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">pt_1'_0</span> <span class="o">:</span> <span class="n">point</span> <span class="n">s1'</span> <span class="bp">→</span> <span class="n">point</span> <span class="n">s0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">point.mk</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="o">(</span><span class="n">getf</span> <span class="n">s1</span><span class="o">)</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">c</span> <span class="o">:=</span> <span class="o">(</span><span class="n">getc</span> <span class="n">f</span><span class="o">)</span> <span class="k">in</span>
      <span class="o">(</span><span class="n">point.mk</span> <span class="o">(</span><span class="n">n</span><span class="bp">*</span><span class="n">c</span><span class="o">))</span>

<span class="c1">--</span>
<span class="kd">def</span> <span class="n">pt_1_2</span> <span class="o">:</span> <span class="n">point</span> <span class="n">s1</span> <span class="bp">→</span> <span class="n">point</span> <span class="n">s2</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">point.mk</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="o">(</span><span class="n">getf</span> <span class="n">s2</span><span class="o">)</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">c</span> <span class="o">:=</span> <span class="o">(</span><span class="n">getc</span> <span class="n">f</span><span class="o">)</span> <span class="k">in</span>
      <span class="o">(</span><span class="n">point.mk</span> <span class="o">(</span><span class="n">n</span><span class="bp">/</span><span class="n">c</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">pt_2_1</span> <span class="o">:</span> <span class="n">point</span> <span class="n">s2</span> <span class="bp">→</span> <span class="n">point</span> <span class="n">s1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">point.mk</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="o">(</span><span class="n">getf</span> <span class="n">s2</span><span class="o">)</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">c</span> <span class="o">:=</span> <span class="o">(</span><span class="n">getc</span> <span class="n">f</span><span class="o">)</span> <span class="k">in</span>
      <span class="o">(</span><span class="n">point.mk</span> <span class="o">(</span><span class="n">n</span><span class="bp">*</span><span class="n">c</span><span class="o">))</span>

<span class="c1">--</span>

<span class="kd">instance</span> <span class="n">pt_1_0_coe</span> <span class="o">:</span>
<span class="n">has_coe</span> <span class="o">(</span><span class="n">point</span> <span class="n">s1</span><span class="o">)</span> <span class="o">(</span><span class="n">point</span> <span class="n">s0</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">pt_1_0</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="n">pt_0_1_coe</span> <span class="o">:</span>
<span class="n">has_coe_t</span> <span class="o">(</span><span class="n">point</span> <span class="n">s0</span><span class="o">)</span> <span class="o">(</span><span class="n">point</span> <span class="n">s1</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">pt_0_1</span><span class="o">⟩</span>

<span class="c1">--</span>

<span class="kd">instance</span> <span class="n">pt_1'_0_coe</span> <span class="o">:</span>
<span class="n">has_coe</span> <span class="o">(</span><span class="n">point</span> <span class="n">s1'</span><span class="o">)</span> <span class="o">(</span><span class="n">point</span> <span class="n">s0</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">pt_1'_0</span> <span class="o">⟩</span>


<span class="kd">instance</span> <span class="n">pt_0_1'_coe</span> <span class="o">:</span>
<span class="n">has_coe_t</span> <span class="o">(</span><span class="n">point</span> <span class="n">s0</span><span class="o">)</span> <span class="o">(</span><span class="n">point</span> <span class="n">s1'</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">pt_0_1'</span> <span class="o">⟩</span>

<span class="c1">--</span>

<span class="kd">instance</span> <span class="n">pt_2_1_coe</span> <span class="o">:</span>
<span class="n">has_coe</span> <span class="o">(</span><span class="n">point</span> <span class="n">s2</span><span class="o">)</span> <span class="o">(</span><span class="n">point</span> <span class="n">s1</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">pt_2_1</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="n">pt_1_2_coe</span> <span class="o">:</span>
<span class="n">has_coe_t</span> <span class="o">(</span><span class="n">point</span> <span class="n">s1</span><span class="o">)</span> <span class="o">(</span><span class="n">point</span> <span class="n">s2</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">pt_1_2</span><span class="o">⟩</span>

<span class="c1">--</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Hmm: Need an explicit has_coe_t from</span>
<span class="cm">point s0 to point s2.</span>
<span class="cm">-/</span>
<span class="c1">--</span>

<span class="kd">def</span> <span class="n">p0</span> <span class="o">:</span> <span class="n">point</span> <span class="n">s0</span> <span class="o">:=</span> <span class="n">point.mk</span> <span class="mi">12</span>
<span class="kd">def</span> <span class="n">p2</span> <span class="o">:</span> <span class="n">point</span> <span class="n">s2</span> <span class="o">:=</span> <span class="n">point.mk</span> <span class="mi">2</span>

<span class="kd">def</span> <span class="n">p01</span> <span class="o">:</span> <span class="n">point</span> <span class="n">s1</span> <span class="o">:=</span> <span class="n">p0</span>  <span class="c1">-- coerce</span>
<span class="kd">def</span> <span class="n">p12</span> <span class="o">:</span> <span class="n">point</span> <span class="n">s2</span> <span class="o">:=</span> <span class="n">p01</span> <span class="c1">-- coerce</span>
<span class="kd">def</span> <span class="n">p02</span> <span class="o">:</span> <span class="n">point</span> <span class="n">s2</span> <span class="o">:=</span> <span class="n">p0</span>  <span class="c1">-- coerce chain</span>

<span class="k">#reduce</span> <span class="n">p01</span>   <span class="c1">-- expect 6</span>
<span class="k">#reduce</span> <span class="n">p12</span>   <span class="c1">-- expect 2</span>
<span class="k">#reduce</span> <span class="n">p02</span>   <span class="c1">-- expect 2 (chained)</span>

<span class="kd">def</span> <span class="n">p21</span> <span class="o">:</span> <span class="n">point</span> <span class="n">s1</span> <span class="o">:=</span> <span class="n">p2</span>  <span class="c1">-- coerce</span>
<span class="kd">def</span> <span class="n">p10</span> <span class="o">:</span> <span class="n">point</span> <span class="n">s0</span> <span class="o">:=</span> <span class="n">p21</span> <span class="c1">-- coerce</span>
<span class="kd">def</span> <span class="n">p20</span> <span class="o">:</span> <span class="n">point</span> <span class="n">s0</span> <span class="o">:=</span> <span class="n">p2</span>  <span class="c1">-- coerce chain</span>

<span class="k">#reduce</span> <span class="n">p21</span>   <span class="c1">-- expect 6</span>
<span class="k">#reduce</span> <span class="n">p10</span>   <span class="c1">-- expect 12</span>
<span class="k">#reduce</span> <span class="n">p20</span>   <span class="c1">-- expect 12 (chained)</span>
</code></pre></div>



<a name="225945715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225945715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Sullivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225945715">(Feb 11 2021 at 03:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Chaining.20coercions/near/225943261">said</a>:</p>
<blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">foo</span> <span class="o">:=</span> <span class="o">(</span><span class="n">out</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">bar</span> <span class="o">:=</span> <span class="o">(</span><span class="n">out</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">baz</span> <span class="o">:=</span> <span class="o">(</span><span class="n">out</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">foo_nat</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">foo</span> <span class="n">nat</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">foo.out</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">bar_nat</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">bar</span> <span class="n">nat</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">bar.out</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">baz_nat</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">baz</span> <span class="n">nat</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">baz.out</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">nat_foo</span> <span class="o">:</span> <span class="n">has_coe_t</span> <span class="n">nat</span> <span class="n">foo</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">foo.mk</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">nat_bar</span> <span class="o">:</span> <span class="n">has_coe_t</span> <span class="n">nat</span> <span class="n">bar</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">bar.mk</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">nat_baz</span> <span class="o">:</span> <span class="n">has_coe_t</span> <span class="n">nat</span> <span class="n">baz</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">baz.mk</span><span class="o">⟩</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bar</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">baz</span><span class="o">)</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">bar</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">baz</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bar</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">baz</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">bar</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">baz</span><span class="o">)</span>
</code></pre></div>
<p>Here's more what I'm looking for. This example subsumes yours and illustrates the problem. I'm not a typeclass inferencing person, but might not an inferencer just stop when it detects a cycle, and move on if necessary? (Yeah, that's why I post in beginners.)</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">foo</span> <span class="o">:=</span> <span class="o">(</span><span class="n">out</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">bar</span> <span class="o">:=</span> <span class="o">(</span><span class="n">out</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">baz</span> <span class="o">:=</span> <span class="o">(</span><span class="n">out</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">bam</span> <span class="o">:=</span> <span class="o">(</span><span class="n">out</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">     nat</span>
<span class="cm">   ^     ^</span>
<span class="cm">   |     |</span>
<span class="cm">   v     v</span>
<span class="cm">  foo   bar</span>
<span class="cm">   ^     ^</span>
<span class="cm">   |     |</span>
<span class="cm">   v     v</span>
<span class="cm">  bam   baz</span>
<span class="cm">-/</span>

<span class="c1">-- ^ arrows</span>
<span class="kd">instance</span> <span class="n">foo_nat</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">foo</span> <span class="n">nat</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">foo.out</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">bam_foo</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">bam</span> <span class="n">foo</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">foo.mk</span> <span class="n">m.out</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">bar_nat</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">bar</span> <span class="n">nat</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">bar.out</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">baz_bar</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">baz</span> <span class="n">bar</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">bz</span><span class="o">,</span> <span class="n">bar.mk</span> <span class="n">bz.out</span><span class="o">⟩</span>

<span class="c1">-- v arrows</span>
<span class="kd">instance</span> <span class="n">nat_foo</span> <span class="o">:</span> <span class="n">has_coe_t</span> <span class="n">nat</span> <span class="n">foo</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">foo.mk</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">foo_bam</span> <span class="o">:</span> <span class="n">has_coe_t</span> <span class="n">foo</span> <span class="n">bam</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">bam.mk</span> <span class="n">f.out</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">nat_bar</span> <span class="o">:</span> <span class="n">has_coe_t</span> <span class="n">nat</span> <span class="n">bar</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">bar.mk</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">bar_baz</span> <span class="o">:</span> <span class="n">has_coe_t</span> <span class="n">bar</span> <span class="n">baz</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">baz.mk</span> <span class="n">r.out</span><span class="o">⟩</span>

<span class="c1">-- what works and what breaks?</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">bar</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">baz</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">bam</span><span class="o">)</span>

<span class="k">#check</span> <span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">bar</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">bam</span><span class="o">)</span>  <span class="c1">-- no: no downward chaining</span>
<span class="k">#check</span> <span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">baz</span><span class="o">)</span>  <span class="c1">-- no: no downward chaining</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">bar</span><span class="o">)</span>          <span class="c1">-- one coe_t at end of chain ok</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span>          <span class="c1">-- works symmetrically</span>


<span class="k">#check</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">baz</span><span class="o">)</span>          <span class="c1">-- no: at most one coe_t at end</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">bam</span><span class="o">)</span>          <span class="c1">-- no: symmetric</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Looks like I need to write an explicit</span>
<span class="cm">has_coe_t for each link in the transitive</span>
<span class="cm">closure of the down-pointing arrows minus</span>
<span class="cm">the down-pointing arrows already written.</span>
<span class="cm">Better than nothing but not great. Best we</span>
<span class="cm">can do?</span>
<span class="cm">-/</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="225945930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225945930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225945930">(Feb 11 2021 at 03:52)</a>:</h4>
<blockquote>
<p>I'm not a typeclass inferencing person, but might not an inferencer just stop when it detects a cycle, and move on if necessary?</p>
</blockquote>
<p>Yes. Lean 3's algorithm is bad, Lean 4's is better and mostly solves this problem</p>



<a name="225946063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225946063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225946063">(Feb 11 2021 at 03:55)</a>:</h4>
<p>Like I said, you need a coe from A -&gt; X and coe_t from X -&gt; A for varying A and fixed (privileged) X; this is a star graph of coercions. A general graph isn't going to cut it because you need at most one edge in every path to be a coe_t edge (and in fact the coe_t edge has to be the last in the path)</p>



<a name="225946265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225946265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Sullivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225946265">(Feb 11 2021 at 03:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Chaining.20coercions/near/225945930">said</a>:</p>
<blockquote>
<blockquote>
<p>I'm not a typeclass inferencing person, but might not an inferencer just stop when it detects a cycle, and move on if necessary?</p>
</blockquote>
<p>Yes. Lean 3's algorithm is bad, Lean 4's is better and mostly solves this problem</p>
</blockquote>
<p>I see. Do you happen to know where I can read more about the new approach?</p>
<p>Here's a more general form of the problem, I suppose:</p>
<p>Given (statically) a collection, C = { T }, of isomorphic types, and a connected tree (dag, graph, etc), S,  of pairwise bijections between types in C, generate coercions for each edge in the complete directed graph over C.</p>



<a name="225946445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225946445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225946445">(Feb 11 2021 at 04:02)</a>:</h4>
<p><a href="https://arxiv.org/abs/2001.04301">https://arxiv.org/abs/2001.04301</a></p>
<p>It's probably not especially useful to you though</p>



<a name="225946467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225946467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225946467">(Feb 11 2021 at 04:03)</a>:</h4>
<p>The problem is that typeclass resolution is far more general than your statement</p>



<a name="225946496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225946496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225946496">(Feb 11 2021 at 04:03)</a>:</h4>
<p>so we need an algorithm that solves the general case but also does the smart thing in this restricted setting</p>



<a name="225946565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225946565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225946565">(Feb 11 2021 at 04:04)</a>:</h4>
<p>The problem as posed is easy; you can use e.g. tarjan's algorithm for finding SCC's in a directed graph</p>



<a name="225946592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225946592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225946592">(Feb 11 2021 at 04:05)</a>:</h4>
<p>but it's a challenge to make that work within the constraints of lean 3 coercions</p>



<a name="225946604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225946604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225946604">(Feb 11 2021 at 04:05)</a>:</h4>
<p>if you are fine with a tactic doing the coercion you have a lot more flexibility</p>



<a name="225946613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225946613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Sullivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225946613">(Feb 11 2021 at 04:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Chaining.20coercions/near/225946445">said</a>:</p>
<blockquote>
<p><a href="https://arxiv.org/abs/2001.04301">https://arxiv.org/abs/2001.04301</a></p>
<p>It's probably not especially useful to you though</p>
</blockquote>
<p>Yes. What I'm wondering, very pragmatically, is whether Lean 4's approach solves my problem?</p>



<a name="225946669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225946669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225946669">(Feb 11 2021 at 04:06)</a>:</h4>
<p>I'm not entirely sure, you could try it</p>



<a name="225946693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225946693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Sullivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225946693">(Feb 11 2021 at 04:06)</a>:</h4>
<p>Also, yes, I could write a tactic. But I'm lazy. And yes I'll give it a try in Lean 4 and report back. Thank you for the conversation. It's clear to me now where things stand with Lean 3. Love this community.</p>



<a name="225946707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225946707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225946707">(Feb 11 2021 at 04:07)</a>:</h4>
<p>The problem with a tactic is that it's not invisible</p>



<a name="225946714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225946714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Sullivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225946714">(Feb 11 2021 at 04:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Chaining.20coercions/near/225946707">said</a>:</p>
<blockquote>
<p>The problem with a tactic is that it's not invisible</p>
</blockquote>
<p>Aye</p>



<a name="225946720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225946720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225946720">(Feb 11 2021 at 04:07)</a>:</h4>
<p>coercion does not require any syntax, tactics don't get that luxury</p>



<a name="225946774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225946774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225946774">(Feb 11 2021 at 04:08)</a>:</h4>
<p>mathlib has lots of <code>by exactI</code> in it which ideally you wouldn't have to see at all</p>



<a name="225946801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Chaining%20coercions/near/225946801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Sullivan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Chaining.20coercions.html#225946801">(Feb 11 2021 at 04:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Chaining.20coercions/near/225946720">said</a>:</p>
<blockquote>
<p>coercion does not require any syntax, tactics don't get that luxury</p>
</blockquote>
<p>Very interesting.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
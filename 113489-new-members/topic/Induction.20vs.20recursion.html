---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Induction.20vs.20recursion.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html">Induction vs recursion</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="196985536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196985536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196985536">(May 09 2020 at 10:50)</a>:</h4>
<p>I'm still struggling to get my head around how to perform proofs by induction, sadly. I've defined the set {0..n} and am trying to prove that it's an interval in N. In Agda this is extremely easy because I can perform recursive calls, but in Lean I haven't yet been able to find a proof of the following:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">list</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">prime</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">def</span> <span class="n">range</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">singleton</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">insert</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">range_closed</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">aIn</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">range</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">vLess</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">range</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">range</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">range</span> <span class="n">at</span> <span class="n">aIn</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">aIn</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">linarith</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">range</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">range</span> <span class="n">at</span> <span class="n">aIn</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">aIn</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">aIn</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="c1">-- but the inductive hypothesis doesn&#39;t apply!</span>
    <span class="n">sorry</span>
  <span class="o">},</span>
  <span class="n">right</span><span class="o">,</span>
  <span class="n">cc</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>In Agda, this is very easy; you just let it normalise your definitions, and whenever it gets stuck, you pattern-match on whatever it's stuck on, and eventually it bottoms out at a single lemma "n is in {0..n}" and a recursive call to <code>range_closed</code>; I can define the entire thing in 92 lines with no standard library and no thought required (<a href="https://gist.github.com/Smaug123/b5b2407176328756189d5f5e8918f03a" title="https://gist.github.com/Smaug123/b5b2407176328756189d5f5e8918f03a">https://gist.github.com/Smaug123/b5b2407176328756189d5f5e8918f03a</a>, actual content is lines 69 through 92), though admittedly my definition of "finite set" leaves much to be desired.</p>
<p>Presumably it is similarly easy in Lean, but it doesn't match my intuition at all. I know in theory there's a way to replace my desired recursive call with an appeal to an appropriately-constructed inductive hypothesis, and I can probably find the general method if I think hard for an hour, but what's stopping Lean from doing these structurally-decreasing recursive calls itself?</p>



<a name="196986657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196986657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196986657">(May 09 2020 at 11:18)</a>:</h4>
<p>can you give some hint about Agda <code>with</code>?</p>



<a name="196986670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196986670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196986670">(May 09 2020 at 11:19)</a>:</h4>
<p>Is this <code>match ... with ...</code>?</p>



<a name="196986678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196986678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196986678">(May 09 2020 at 11:19)</a>:</h4>
<p>Everything in your Agda code was easy to read until the last definition, where things got really weird. Maybe this is related to your problem <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="196986998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196986998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196986998">(May 09 2020 at 11:26)</a>:</h4>
<p>What happened to <code>range_contains</code>?</p>



<a name="196987085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196987085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196987085">(May 09 2020 at 11:29)</a>:</h4>
<p>I assume <code>record {}</code> is the proof of <code>True</code>?</p>



<a name="196987144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196987144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196987144">(May 09 2020 at 11:30)</a>:</h4>
<p>Things are obviously going to be somewhat harder because the definition of <code>contains</code> for an actual finite set won't compute the way it does in your code, I think</p>



<a name="196987430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196987430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196987430">(May 09 2020 at 11:37)</a>:</h4>
<p>Or much harder</p>



<a name="196987435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196987435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196987435">(May 09 2020 at 11:37)</a>:</h4>
<p>I thought for a while your Agda proof was not correct.</p>



<a name="196987495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196987495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196987495">(May 09 2020 at 11:38)</a>:</h4>
<p>The more I read it, the less I understand...</p>



<a name="196987587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196987587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196987587">(May 09 2020 at 11:40)</a>:</h4>
<p>On line 86, we know <code>n</code> is <code>0</code>, <code>a</code> is not <code>0</code>, <code>v</code> is not <code>0</code>. How can we use <code>cont</code> as the proof?</p>



<a name="196987907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196987907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196987907">(May 09 2020 at 11:48)</a>:</h4>
<p>Anyways, the tactic proof can be repaired by starting with</p>
<div class="codehilite"><pre><span></span><code>  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">IH</span> <span class="n">generalizing</span> <span class="n">a</span> <span class="n">aIn</span> <span class="n">v</span> <span class="n">vLess</span><span class="o">,</span>
</code></pre></div>


<p>(<code>with n IH</code> just gives better names to the new variables)</p>



<a name="196987935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196987935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196987935">(May 09 2020 at 11:49)</a>:</h4>
<p><code>generalizing ...</code> means basically <code>revert</code> all the variables, apply <code>induction</code>, then re-<code>intros</code> them in all the cases. That way you get an induction hypothesis that can be applied to any <code>a</code>, ....</p>



<a name="196988189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196988189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196988189">(May 09 2020 at 11:54)</a>:</h4>
<p>Also, I guess as a high-level comment, surely it's better strategy to just prove that <code>a ∈ range n</code> is equivalent to <code>a &lt;= n</code> first, rather than embark on an inductive proof of this statement that involves three variables directly</p>



<a name="196988308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196988308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196988308">(May 09 2020 at 11:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196987587" title="#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196987587">said</a>:</p>
<blockquote>
<p>On line 86, we know <code>n</code> is <code>0</code>, <code>a</code> is not <code>0</code>, <code>v</code> is not <code>0</code>. How can we use <code>cont</code> as the proof?</p>
</blockquote>
<p>Aren't <code>n</code>, <code>a</code> and <code>v</code> all <code>0</code> at that point?</p>



<a name="196988442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196988442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196988442">(May 09 2020 at 12:00)</a>:</h4>
<p>it might be my inability to read this syntax, but I thought that line 84 is the counterpart to line 82, depending on the outcome of a=0</p>



<a name="196988585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196988585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196988585">(May 09 2020 at 12:04)</a>:</h4>
<p>I think the structure is:</p>
<ul>
<li>split on a = 0 (not by pattern matching but with the <code>ℕDecideEquality</code> thing--but somehow Agda also decides that <code>a=0</code>, maybe this is what I missed later)<ul>
<li>when <code>a=0</code>, split on the proof of <code>v&lt;=a</code></li>
<li>when <code>a!=0</code>, split on <code>ℕDecideEquality v 0</code></li>
</ul>
</li>
</ul>



<a name="196988603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196988603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196988603">(May 09 2020 at 12:05)</a>:</h4>
<p>Well, this is the <code>n=0</code> case</p>



<a name="196988616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196988616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196988616">(May 09 2020 at 12:05)</a>:</h4>
<p>Like I think the <code>...</code> on line 85 corresponds to the <code>... | inr a!=0</code> on line 84, otherwise I can't make sense of it</p>



<a name="196988795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196988795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196988795">(May 09 2020 at 12:11)</a>:</h4>
<p>I get this for the translation of 79-86 to lean syntax</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">rangeClosed</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">contains</span> <span class="bp">ℕ</span><span class="n">DecideEquality</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span> <span class="n">a</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">v</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span> <span class="n">contains</span> <span class="bp">ℕ</span><span class="n">DecideEquality</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span> <span class="n">v</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="n">a</span> <span class="n">cont</span> <span class="n">v</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">a</span><span class="o">,</span> <span class="n">cont</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="bp">ℕ</span><span class="n">DecideEquality</span> <span class="n">a</span> <span class="mi">0</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="n">cont</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">inl</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">v</span><span class="bp">&lt;</span><span class="mi">0</span><span class="o">),</span> <span class="n">inl</span> <span class="n">rfl</span> <span class="o">:=</span> <span class="n">exFalso</span> <span class="o">(</span><span class="n">notLessZero</span> <span class="n">v</span> <span class="n">h</span><span class="o">)</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="n">cont</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">inr</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">inl</span> <span class="n">rfl</span> <span class="o">:=</span> <span class="bp">⟨⟩</span>
  <span class="bp">|</span> <span class="n">a</span><span class="o">,</span> <span class="n">cont</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">inr</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">inr</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">match</span> <span class="n">a</span><span class="o">,</span> <span class="n">cont</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="bp">ℕ</span><span class="n">DecideEquality</span> <span class="n">v</span> <span class="mi">0</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">a</span><span class="o">,</span> <span class="n">cont</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">inl</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨⟩</span>
    <span class="bp">|</span> <span class="n">a</span><span class="o">,</span> <span class="n">cont</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">inr</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="n">cont</span>
    <span class="kn">end</span>
  <span class="kn">end</span>
<span class="bp">...</span>
</code></pre></div>



<a name="196988959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196988959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196988959">(May 09 2020 at 12:14)</a>:</h4>
<p>Does it work?</p>



<a name="196988966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196988966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196988966">(May 09 2020 at 12:15)</a>:</h4>
<p>Or did you manage to type all this without feedback from lean?</p>



<a name="196989020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196989020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196989020">(May 09 2020 at 12:16)</a>:</h4>
<p>The only way I can imagine <code>cont : contains ℕDecideEquality (range n) a</code> has type <code>contains ℕDecideEquality (range n) v</code> here is that Agda actually decided this case is impossible</p>



<a name="196989029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196989029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196989029">(May 09 2020 at 12:17)</a>:</h4>
<p>or I guess that it reduced both of these types to <code>False</code>... that is more plausible</p>



<a name="196989038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196989038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196989038">(May 09 2020 at 12:17)</a>:</h4>
<p>No feedback</p>



<a name="196989041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196989041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196989041">(May 09 2020 at 12:17)</a>:</h4>
<p>I still don't understand how it could do that though</p>



<a name="196989046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196989046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196989046">(May 09 2020 at 12:17)</a>:</h4>
<p>I'm working on a compiling version</p>



<a name="196989097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196989097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196989097">(May 09 2020 at 12:18)</a>:</h4>
<p>but the lean definitions are different in a few places, unless I replicate the whole definition from nothing as was done in the original</p>



<a name="196989169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196989169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196989169">(May 09 2020 at 12:20)</a>:</h4>
<p>I guess I don't know how matching on <code>ℕDecideEquality a 0</code> actually works. It seems like for the Agda code to work, it needs to have already unfolded the definition of the type of <code>cont</code> to see that it contains <code>ℕDecideEquality a 0</code>, so that it can be replaced by a constructor in the branches</p>



<a name="196989186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196989186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196989186">(May 09 2020 at 12:21)</a>:</h4>
<p>I'm pretty sure that it's just like <code>obtain rfl | h := decidable.em (a = 0)</code></p>



<a name="196989258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196989258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196989258">(May 09 2020 at 12:23)</a>:</h4>
<p>But in that case, in your Lean translation, <code>    | a, cont, v, h, inr (h₂ : v ≠ 0) := cont</code> is clearly a type error right?</p>



<a name="196989311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196989311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196989311">(May 09 2020 at 12:24)</a>:</h4>
<p>Oh, actually it might not be, if that's simultaneously matching on the <code>ℕDecideEquality a 0</code> inside the definition of <code>contains</code></p>



<a name="196989318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196989318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196989318">(May 09 2020 at 12:24)</a>:</h4>
<p>in lean you would have to <code>unfold contains</code> first</p>



<a name="196989319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196989319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196989319">(May 09 2020 at 12:24)</a>:</h4>
<p>I think that must be what is happening but I don't know how Agda knows to do that</p>



<a name="196989344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196989344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196989344">(May 09 2020 at 12:25)</a>:</h4>
<p>I mean it cannot unfold everything in scope as far as possible before matching on anything, right? Or can it?</p>



<a name="196989393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196989393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196989393">(May 09 2020 at 12:26)</a>:</h4>
<p>"The user said it typechecks, so by golly I'll make it typecheck"</p>



<a name="196990462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196990462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196990462">(May 09 2020 at 12:54)</a>:</h4>
<p>Here is how I might prove the original lemma:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_succ_iff</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">nat</span><span class="bp">.</span><span class="n">of_le_succ</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span><span class="bp">.</span><span class="n">elim</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_succ_of_le</span> <span class="n">le_of_eq</span><span class="bp">⟩</span>

<span class="kn">lemma</span> <span class="n">mem_range_iff_le</span> <span class="o">(</span><span class="n">n</span> <span class="n">a</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">range</span> <span class="n">n</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">IH</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">range</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">range</span><span class="o">,</span> <span class="n">IH</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_succ_iff</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">comm</span><span class="o">]</span> <span class="o">},</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">range_closed</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">aIn</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">range</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">vLess</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">range</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">mem_range_iff_le</span> <span class="n">at</span> <span class="err">⊢</span> <span class="n">aIn</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">le_trans</span> <span class="n">vLess</span> <span class="n">aIn</span>
<span class="kn">end</span>
</code></pre></div>



<a name="196990467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196990467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196990467">(May 09 2020 at 12:54)</a>:</h4>
<p>obviously I relied a bit on the standard library, but not heavily</p>



<a name="196992350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196992350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196992350">(May 09 2020 at 13:45)</a>:</h4>
<p>I don't mind the use or not of the standard library - I'm not trying to whinge or anything, and the point wasn't "oh look I've been coding for two years in Agda after spending months getting used to it, why am I finding Lean less intuitive waaaah"</p>



<a name="196992515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196992515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196992515">(May 09 2020 at 13:49)</a>:</h4>
<p>I'm aware that Agda, like all theorem proving environments, is completely unreadable :P Agda by default automatically unfolds everything as far as possible before presenting it to you, although you don't have to fill "unfolded" holes with "unfolded" terms - you can fill a hole that Agda is showing to you as fully unfolded, using a nice compact term</p>



<a name="196992575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196992575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196992575">(May 09 2020 at 13:50)</a>:</h4>
<p>Well, I don't totally agree with the first statement. I think the proof I wrote above is a lot easier to understand, even putting concrete syntax aside--simply because it follows the correct conceptual strategy for a human</p>



<a name="196992592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196992592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196992592">(May 09 2020 at 13:51)</a>:</h4>
<p>I believe you when you say your proof was easy to write without thinking (I know the Agda emacs mode has some fancy auto refine/hole filling stuff), but it resulted in something quite difficult to understand</p>



<a name="196992603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196992603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196992603">(May 09 2020 at 13:51)</a>:</h4>
<p>It goes to show that machines producing proofs that humans cannot understand is not some science fiction thing.</p>



<a name="196992952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196992952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196992952">(May 09 2020 at 14:00)</a>:</h4>
<p>(Random aside: can it really be true that <code>le_total</code> has the most useful type signature? Surely, surely <code>a &lt;= b</code> or <code>b &lt; a</code> is a more useful phrasing?)</p>



<a name="196993054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196993054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196993054">(May 09 2020 at 14:04)</a>:</h4>
<p>Honestly I struggle to see that there's anything to prove here at all - I wouldn't say there's a "correct strategy for a human" beyond saying "induction, the rest is trivial", so I don't feel particularly moved by "it follows the correct conceptual strategy for a human". It may very well be that Lean makes for better-structured proofs on actual real problems, but then to me the structure of a formally-checked proof is dictated more by the lemmas which are chained together than by the internal structure of any particular theorem's proof. Possibly that's just my Agda heritage talking.</p>



<a name="196993158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196993158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196993158">(May 09 2020 at 14:05)</a>:</h4>
<p>But my Agda proof has a structure that is fairly clear when you get past the syntax: "induct on n; clear the base case. Check if v = n; if so, we're done straight away. If not, induct down, although booo fiddly edge case if a = n already."</p>



<a name="196993220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196993220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196993220">(May 09 2020 at 14:07)</a>:</h4>
<p>I disagree rather thoroughly with all this, but I'm not sure there is anything constructive to say. It looks like "alien mathematics" again.</p>



<a name="196993223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196993223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196993223">(May 09 2020 at 14:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="117987">Patrick Stevens</span> <a href="#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196992952" title="#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196992952">said</a>:</p>
<blockquote>
<p>(Random aside: can it really be true that <code>le_total</code> has the most useful type signature? Surely, surely <code>a &lt;= b</code> or <code>b &lt; a</code> is a more useful phrasing?)</p>
</blockquote>
<p>All of the variations on these statements exist: <code>le_or_lt</code>, <code>lt_or_le</code>, <code>lt_trichotomy</code>, etc</p>



<a name="196993314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196993314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196993314">(May 09 2020 at 14:09)</a>:</h4>
<p>I think I see where you are speaking from, it reminds me of how most list lemmas are proven. But once you have a decent nontrivial equality relation it becomes easier to prove things by <code>rw</code> and <code>simp</code> instead rather than using induction for everything</p>



<a name="196993382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196993382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196993382">(May 09 2020 at 14:10)</a>:</h4>
<p><code>data.list.basic</code> is quite large, exactly because it should be easy to pick up and use without having to resort to induction all the time</p>



<a name="196993388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196993388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196993388">(May 09 2020 at 14:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196993223" title="#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196993223">said</a>:</p>
<blockquote>
<p>All of the variations on these statements exist: <code>le_or_lt</code>, <code>lt_or_le</code>, <code>lt_trichotomy</code>, etc</p>
</blockquote>
<p>Is there a way I can find those other than by a) intuiting their names, or b) writing their type signatures and proving them with <code>library_search</code>?</p>



<a name="196993393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196993393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196993393">(May 09 2020 at 14:11)</a>:</h4>
<p>those both sound like pretty good methods to me</p>



<a name="196993426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196993426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196993426">(May 09 2020 at 14:12)</a>:</h4>
<p><code>#find</code></p>



<a name="196993447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196993447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196993447">(May 09 2020 at 14:12)</a>:</h4>
<p>another method is to write <code>#print le_total</code>, ctrl-click on <code>le_total</code> to go to its definition, and then browse around from there; I bet <code>le_or_lt</code> is within 3 statements of it</p>



<a name="196993521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196993521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196993521">(May 09 2020 at 14:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196993447" title="#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196993447">said</a>:</p>
<blockquote>
<p>another method is to write <code>#print le_total</code>, ctrl-click on <code>le_total</code> to go to its definition, and then browse around from there; I bet <code>le_or_lt</code> is within 3 statements of it</p>
</blockquote>
<p>That one I did try - but actually they're in different files from <code>le_total</code></p>



<a name="196993540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196993540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196993540">(May 09 2020 at 14:14)</a>:</h4>
<p>checking... oh, I missed, <code>le_or_gt</code> is about 20 theorems later</p>



<a name="196993550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196993550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196993550">(May 09 2020 at 14:14)</a>:</h4>
<p><code>le_or_lt</code> is in the mathlib addendum to that file</p>



<a name="196993740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196993740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196993740">(May 09 2020 at 14:19)</a>:</h4>
<p>I guess I'll just say this: as a human, what led you to come up with the statement <code>rangeClosed</code> in the first place, or why did you believe that it would be true before you tried to prove it in Agda? Wasn't it the fact that <code>range n</code> contains the numbers 0 through n, that is, those <code>a</code> that are <code>&lt;= n</code>, and if <code>a &lt;= n</code> and <code>v &lt;= a</code>, then <code>v &lt;= n</code>? Or did you imagine this inductive proof with five or six case distinctions in it?</p>



<a name="196993828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196993828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196993828">(May 09 2020 at 14:20)</a>:</h4>
<p>If the question is just "why can't the system prove this for me automatically" then I agree that any decent system ought to be able to do it, and I think there are some that can.</p>



<a name="196993840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196993840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196993840">(May 09 2020 at 14:20)</a>:</h4>
<p>By the way, "intuiting the name" is not unreasonable because of lean's fairly strict <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/contribute/naming.md" title="https://github.com/leanprover-community/mathlib/blob/master/docs/contribute/naming.md">naming conventions</a></p>



<a name="196993869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196993869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196993869">(May 09 2020 at 14:21)</a>:</h4>
<p>for a good number of basic theorems you can just stick name segments together and guess the name exactly with high probability</p>



<a name="196993937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196993937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196993937">(May 09 2020 at 14:22)</a>:</h4>
<p>An important variation of intuiting the name is guessing most of the name and using autocompletion</p>



<a name="196993952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196993952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196993952">(May 09 2020 at 14:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196993840" title="#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196993840">said</a>:</p>
<blockquote>
<p>By the way, "intuiting the name" is not unreasonable because of lean's fairly strict <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/contribute/naming.md" title="https://github.com/leanprover-community/mathlib/blob/master/docs/contribute/naming.md">naming conventions</a></p>
</blockquote>
<p>A month ago i thought guessing the name was wizard magic, and then I read that file and started guessing and it was fine</p>



<a name="196994131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196994131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196994131">(May 09 2020 at 14:26)</a>:</h4>
<p>In Lean, I came up with <code>rangeClosed</code> as follows. 1) Attempt to formulate in Lean a certain lemma in the proof of Bertrand's postulate: namely, "the product of the primes less than or equal to n, is less than 4^n". 2) Realise I need to define the collection of primes less than or equal to n, and decide to go by filtering the collection of naturals less than or equal to n. 3) Begin to induct on n to prove that lemma, discover that I need to show that something is in the range at all.</p>
<p>I think by this point I had been flapping my hands at the keyboard for a while and that was a term which would fill a hole I had in scope, so I started trying to prove it. But I already knew it would be true because "look, it's obvious" (no further reason at all, not even the justification you gave above); if you'd asked me to prove it, I'd have said "induction on n" (because that's the only thing it makes sense to induct on, because that's where the definition of <code>range</code> varies), and without pencil and paper I'd have been a bit stumped if you'd asked me for further justification. With pencil and paper I could probably have written out something like what you said.</p>



<a name="196994202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196994202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196994202">(May 09 2020 at 14:28)</a>:</h4>
<blockquote>
<p>Realise I need to define the collection of primes less than or equal to n, and decide to go by filtering the collection of naturals less than or equal to n. 3) Begin to induct on n to prove that lemma, discover that I need to show that something is in the range at all.</p>
</blockquote>
<p>It seems to me from this description that you already believed that <code>range n</code> is the set of numbers less or equal to <code>n</code></p>



<a name="196994223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196994223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196994223">(May 09 2020 at 14:29)</a>:</h4>
<p>so to my mind that indicates that this should be the first thing you prove about the definition, and hopefully the filter through which all other theorems follow</p>



<a name="196994288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196994288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196994288">(May 09 2020 at 14:30)</a>:</h4>
<p>Yes, that is precisely why I constructed <code>range n</code> - to be the object which had that property</p>



<a name="196994305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196994305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196994305">(May 09 2020 at 14:31)</a>:</h4>
<p>So then, surely, the first thing you should prove about it is that it <em>does</em> have that property</p>



<a name="196994307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196994307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196994307">(May 09 2020 at 14:31)</a>:</h4>
<p>I guess if I'd been less lazy and had been working with my software engineer's hat on, I'd have done that straight away - no code without its unit test</p>



<a name="196994354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196994354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196994354">(May 09 2020 at 14:32)</a>:</h4>
<p>Oh, Mario already said this.</p>



<a name="196994497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196994497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196994497">(May 09 2020 at 14:35)</a>:</h4>
<p>In mathlib this is set up as a simp lemma, so that by the time you are actually thinking about the problem the <code>range</code>s are gone</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">list</span><span class="bp">.</span><span class="n">range</span>

<span class="kn">lemma</span> <span class="n">range_closed</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
  <span class="o">(</span><span class="n">aIn</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">list</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">vLess</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">list</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">lt_of_le_of_lt</span> <span class="n">vLess</span> <span class="n">aIn</span>
<span class="kn">end</span>
</code></pre></div>



<a name="196994550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196994550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196994550">(May 09 2020 at 14:36)</a>:</h4>
<p>Oh, I didn't even realise there was a <code>list.range</code>, I assumed it would be a finset sort of thing</p>



<a name="196994564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196994564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196994564">(May 09 2020 at 14:36)</a>:</h4>
<p>the finset is of course defined using the list</p>



<a name="196995950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196995950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196995950">(May 09 2020 at 15:07)</a>:</h4>
<p>Anyways, <span class="user-mention" data-user-id="117987">@Patrick Stevens</span>, I'm not sure if in all the other noise, you missed the answer using <code>generalizing</code> (or equivalently <code>revert</code>).</p>



<a name="196996025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20vs%20recursion/near/196996025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20vs.20recursion.html#196996025">(May 09 2020 at 15:09)</a>:</h4>
<p>Ah, I missed that - thanks</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
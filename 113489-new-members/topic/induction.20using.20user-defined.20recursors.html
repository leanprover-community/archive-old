---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html">induction using user-defined recursors</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="207911052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207911052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207911052">(Aug 24 2020 at 23:55)</a>:</h4>
<p>I'm probably not supposed to be doing this in the first place, but I was trying to define a user-defined recursor because I thought it might help with some problem I was having (I might ask about this in another topic).  I'm observing something rather strange when I try to use it with the <code>induction</code> tactic, where it comes up with an unexpected type.  In the following, <code>elems_iff_eq</code> is proof that <code>rec'</code> is usable, and <code>elems_iff_eq'</code> is showing the strange behavior.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">sym2</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">,</span> <span class="n">recursor</span> <span class="mi">5</span><span class="o">]</span>
<span class="n">def</span> <span class="n">rec&#39;</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">v</span><span class="o">}</span>
   <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">),</span> <span class="n">β</span> <span class="err">⟦</span><span class="n">a</span><span class="err">⟧</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≈</span> <span class="n">b</span><span class="o">),</span>
      <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">rec</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">quotient</span><span class="bp">.</span><span class="n">sound</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="err">⟦</span><span class="n">b</span><span class="err">⟧</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span>
   <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="n">q</span> <span class="o">:=</span>
<span class="n">quot</span><span class="bp">.</span><span class="n">rec</span> <span class="n">f</span> <span class="n">h</span> <span class="n">q</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="kn">lemma</span> <span class="n">elems_iff_eq</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hne</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="err">∈</span> <span class="n">z</span> <span class="bp">∧</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">z</span> <span class="bp">=</span> <span class="err">⟦</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span><span class="err">⟧</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="bp">⟨</span><span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">rec&#39;</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span><span class="n">z₁</span><span class="o">,</span> <span class="n">z₂</span><span class="bp">⟩</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span> <span class="n">sym2</span><span class="bp">.</span><span class="n">eq_iff</span><span class="bp">.</span><span class="n">mpr</span> <span class="k">begin</span>
  <span class="n">cases</span> <span class="n">sym2</span><span class="bp">.</span><span class="n">mem_iff</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hx</span> <span class="k">with</span> <span class="n">hx</span> <span class="n">hx</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">sym2</span><span class="bp">.</span><span class="n">mem_iff</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hy</span> <span class="k">with</span> <span class="n">hy</span> <span class="n">hy</span><span class="bp">;</span> <span class="n">cc</span><span class="o">,</span>
<span class="kn">end</span><span class="o">)</span> <span class="o">(</span><span class="k">by</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">refl</span> <span class="o">})</span> <span class="n">z</span> <span class="n">hx</span> <span class="n">hy</span>

<span class="kn">lemma</span> <span class="n">elems_iff_eq&#39;</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hne</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="err">∈</span> <span class="n">z</span> <span class="bp">∧</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">z</span> <span class="bp">=</span> <span class="err">⟦</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span><span class="err">⟧</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">z</span> <span class="kn">using</span> <span class="n">rec&#39;</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>


<p>At the point of the sorry, the primary goal becomes</p>
<div class="codehilite"><pre><span></span><code><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">hne</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">,</span>
<span class="n">z</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)</span> <span class="bp">×</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">,</span>
<span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="err">⟦</span><span class="n">z</span><span class="err">⟧</span><span class="o">,</span>
<span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="err">∈</span> <span class="err">⟦</span><span class="n">z</span><span class="err">⟧</span>
<span class="err">⊢</span> <span class="err">⟦</span><span class="n">z</span><span class="err">⟧</span> <span class="bp">=</span> <span class="err">⟦</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span><span class="err">⟧</span>
</code></pre></div>


<p>That <code>z</code> should be of type <code>α × α</code>, and nothing after that line is well-typed.</p>



<a name="207911158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207911158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207911158">(Aug 24 2020 at 23:56)</a>:</h4>
<p>I've also seen an ill-typed proof state when using <code>induction</code> with <code>quotient</code></p>



<a name="207911186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207911186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207911186">(Aug 24 2020 at 23:57)</a>:</h4>
<p>I never looked into the cause though, since it was back in the dark ages</p>



<a name="207911827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207911827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207911827">(Aug 25 2020 at 00:06)</a>:</h4>
<p>What I had been running into was that <code>induction z using quotient.rec</code> gives un-rewritable terms, and the reason seemed to be that the same setoid was being described in different ways (but I'm not completely certain).  So, I thought maybe a new recursor that ensured I got exactly the setoid instance I wanted would help, but then I got behavior that was even more peculiar!</p>
<p>Here's an example where a rewrite fails even though it seems like it should work:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">sym2</span>

<span class="n">universes</span> <span class="n">u</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="kn">lemma</span> <span class="n">elems_iff_eq</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hne</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="err">∈</span> <span class="n">z</span> <span class="bp">∧</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">z</span> <span class="bp">=</span> <span class="err">⟦</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span><span class="err">⟧</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">z</span> <span class="kn">using</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">rec</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">z</span> <span class="k">with</span> <span class="n">z₁</span> <span class="n">z₂</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sym2</span><span class="bp">.</span><span class="n">eq_iff</span><span class="o">,</span> <span class="c1">-- rewrite tactic failed</span>
<span class="kn">end</span>
</code></pre></div>



<a name="207911871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207911871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207911871">(Aug 25 2020 at 00:07)</a>:</h4>
<p>usually that means that a previous tactic left an instantiated metavariable in the state</p>



<a name="207912029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207912029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207912029">(Aug 25 2020 at 00:09)</a>:</h4>
<p>It looks like the first goal's context has no metavariables, but the second goal does have one because the construction hasn't been completed yet.</p>



<a name="207912108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207912108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207912108">(Aug 25 2020 at 00:10)</a>:</h4>
<p>I'm just basing this off looking at <code>set_option pp.all true</code>.  The first goal:</p>
<div class="codehilite"><pre><span></span><code><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">hne</span> <span class="o">:</span> <span class="bp">@</span><span class="n">ne</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">α</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="n">z₁</span> <span class="n">z₂</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">hx</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">has_mem</span><span class="bp">.</span><span class="n">mem</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">u</span><span class="o">}</span> <span class="n">α</span> <span class="o">(</span><span class="n">sym2</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">sym2</span><span class="bp">.</span><span class="n">has_mem</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">α</span><span class="o">)</span> <span class="n">x</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">quotient</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">u</span><span class="o">}</span> <span class="n">α</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">setoid</span><span class="bp">.</span><span class="n">r</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">u</span><span class="o">}</span> <span class="n">α</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">sym2</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">setoid</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">α</span><span class="o">))</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">prod</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">u</span><span class="o">}</span> <span class="n">α</span> <span class="n">α</span> <span class="n">z₁</span> <span class="n">z₂</span><span class="o">)),</span>
<span class="n">hy</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">has_mem</span><span class="bp">.</span><span class="n">mem</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">u</span><span class="o">}</span> <span class="n">α</span> <span class="o">(</span><span class="n">sym2</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">sym2</span><span class="bp">.</span><span class="n">has_mem</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">α</span><span class="o">)</span> <span class="n">y</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">quotient</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">u</span><span class="o">}</span> <span class="n">α</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">setoid</span><span class="bp">.</span><span class="n">r</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">u</span><span class="o">}</span> <span class="n">α</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">sym2</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">setoid</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">α</span><span class="o">))</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">prod</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">u</span><span class="o">}</span> <span class="n">α</span> <span class="n">α</span> <span class="n">z₁</span> <span class="n">z₂</span><span class="o">))</span>
<span class="err">⊢</span> <span class="bp">@</span><span class="n">eq</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">sym2</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">α</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">quotient</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">u</span><span class="o">}</span> <span class="n">α</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">setoid</span><span class="bp">.</span><span class="n">r</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">u</span><span class="o">}</span> <span class="n">α</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">sym2</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">setoid</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">α</span><span class="o">))</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">prod</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">u</span><span class="o">}</span> <span class="n">α</span> <span class="n">α</span> <span class="n">z₁</span> <span class="n">z₂</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">quotient</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">u</span><span class="o">}</span> <span class="n">α</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">sym2</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">setoid</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">prod</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">u</span><span class="o">}</span> <span class="n">α</span> <span class="n">α</span> <span class="n">x</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div>



<a name="207912130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207912130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207912130">(Aug 25 2020 at 00:11)</a>:</h4>
<p>whoa, that mwe has a really weird bug in it. Put your cursor at the end of the <code>cases</code> line. You should see this:</p>
<div class="codehilite"><pre><span></span><code><span class="mi">2</span> <span class="n">goals</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">hne</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">,</span>
<span class="n">z₁</span> <span class="n">z₂</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="err">⟦</span><span class="o">(</span><span class="n">z₁</span><span class="o">,</span> <span class="n">z₂</span><span class="o">)</span><span class="err">⟧</span><span class="o">,</span>
<span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="err">∈</span> <span class="err">⟦</span><span class="o">(</span><span class="n">z₁</span><span class="o">,</span> <span class="n">z₂</span><span class="o">)</span><span class="err">⟧</span>
<span class="err">⊢</span> <span class="err">⟦</span><span class="o">(</span><span class="n">z₁</span><span class="o">,</span> <span class="n">z₂</span><span class="o">)</span><span class="err">⟧</span> <span class="bp">=</span> <span class="err">⟦</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span><span class="err">⟧</span>

<span class="n">case</span> <span class="n">h</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">hne</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">,</span>
<span class="n">z</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">≈</span> <span class="n">b</span>
<span class="err">⊢</span> <span class="bp">_</span> <span class="bp">=</span> <span class="bp">_</span>
</code></pre></div>


<p>Now move the cursor to the start of the line and then back to the end, and now the second goal will say <code>_ = )_</code> (yes, an unclosed parenthesis). Repeating the cursor motion results in <code>_ = ) )_</code> and so on.</p>



<a name="207912167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207912167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207912167">(Aug 25 2020 at 00:11)</a>:</h4>
<p>This may involve an interaction with the rich goal view</p>



<a name="207912342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207912342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207912342">(Aug 25 2020 at 00:14)</a>:</h4>
<p>emacs has only well-matched parentheses here.  Maybe the react-like diff algorithm isn't updating the goal view correctly. (I'm under the impression that's how it's set up.)</p>



<a name="207912470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207912470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207912470">(Aug 25 2020 at 00:16)</a>:</h4>
<p>the bug also goes away if I switch to plain goal view, so I'm sure it's a factor</p>



<a name="207912471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207912471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207912471">(Aug 25 2020 at 00:16)</a>:</h4>
<p>Oh, this seems like a good place to ask: what does <code>?m_1[b, hx, hy]</code> mean?  I've just assumed it meant a metavariable that somehow depends on its lexical context, but I haven't been able to look it up.</p>



<a name="207912491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207912491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207912491">(Aug 25 2020 at 00:17)</a>:</h4>
<p>it's called a delayed abstraction. It represents a metavariable applied to concrete arguments</p>



<a name="207912507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207912507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207912507">(Aug 25 2020 at 00:17)</a>:</h4>
<p>it's like <code>?f (2+2)</code> where <code>?f</code> is a metavariable</p>



<a name="207912568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207912568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207912568">(Aug 25 2020 at 00:18)</a>:</h4>
<p>Basically these are not available for unification, they are only constraints, i.e. if you find <code>?f (2+2) =?= 4</code> you aren't allowed to assume that <code>?f</code> is the identity</p>



<a name="207912595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207912595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207912595">(Aug 25 2020 at 00:19)</a>:</h4>
<p>cc: <span class="user-mention" data-user-id="121918">@Edward Ayers</span> regarding the widget bug <a href="#narrow/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors/near/207912130">above</a>.</p>



<a name="207912954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207912954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207912954">(Aug 25 2020 at 00:25)</a>:</h4>
<p>Anyway, here's how I suggest you proceed, assuming you aren't specifically trying to use <code>induction using</code>, which I don't think has ever worked well</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">elems_iff_eq</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hne</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="err">∈</span> <span class="n">z</span> <span class="bp">∧</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">z</span> <span class="bp">=</span> <span class="err">⟦</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span><span class="err">⟧</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">rec_on_subsingleton</span> <span class="n">z</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">z₁</span><span class="o">,</span> <span class="n">z₂</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sym2</span><span class="bp">.</span><span class="n">eq_iff</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="207913291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207913291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207913291">(Aug 25 2020 at 00:31)</a>:</h4>
<p>I'll keep <code>quotient.rec_on_subsingleton</code> in mind.  What I had been doing before is <code>induction</code> without <code>using</code>, then possibly fixing up the <code>quot.mk</code>'s that would appear with <code>change</code> before doing rewrites.  In this case, I had used <code>apply</code> rather than <code>rw</code> to avoid needing <code>change</code>: <a href="https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/data/sym2.lean#L145">https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/data/sym2.lean#L145</a></p>
<p><code>induction</code> is nice because it updates the types of everything that depends on the thing being inducted on, so it would be nice if it worked properly.</p>



<a name="207913627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207913627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207913627">(Aug 25 2020 at 00:36)</a>:</h4>
<p>You can still get most of that functionality with plain <code>refine</code></p>



<a name="207913642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207913642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207913642">(Aug 25 2020 at 00:36)</a>:</h4>
<p>you have to include the things to be reverted manually in the term but the motive generalization is done automatically</p>



<a name="207913661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207913661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207913661">(Aug 25 2020 at 00:37)</a>:</h4>
<p>You can also use regular <code>quotient.rec_on</code> but in this case you are proving a proposition so there is no need</p>



<a name="207913851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20using%20user-defined%20recursors/near/207913851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20using.20user-defined.20recursors.html#207913851">(Aug 25 2020 at 00:40)</a>:</h4>
<p>like this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">elems_iff_eq</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hne</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="err">∈</span> <span class="n">z</span> <span class="bp">∧</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">z</span> <span class="bp">=</span> <span class="err">⟦</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span><span class="err">⟧</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">ind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span> <span class="bp">_</span><span class="o">)</span> <span class="n">z</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">z</span> <span class="k">with</span> <span class="n">z₁</span> <span class="n">z₂</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sym2</span><span class="bp">.</span><span class="n">eq_iff</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
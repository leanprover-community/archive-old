---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Frustration.20with.20finset.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html">Frustration with finset</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="202693896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202693896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202693896">(Jul 02 2020 at 14:14)</a>:</h4>
<p>Hi all,</p>
<p>Noob question: I am trying to prove some elementary results in number theory to get more practice with Lean proof writing. I feel that some generic tactic should kill this MWE, but I can't seem to find it:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">subgroup</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">big_operators</span>

<span class="kn">lemma</span> <span class="n">blah</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]:</span>
<span class="o">(</span><span class="err">∏</span> <span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="err">∏</span> <span class="n">g</span> <span class="k">in</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">true</span><span class="o">}</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">g</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>Thanks in advance for any help...</p>



<a name="202695480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202695480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202695480">(Jul 02 2020 at 14:26)</a>:</h4>
<p><code>congr, ext, simp</code></p>



<a name="202695519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202695519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202695519">(Jul 02 2020 at 14:27)</a>:</h4>
<p><span class="user-mention" data-user-id="254058">@Marc Masdeu</span> Hi, welcome back. (Have you seen <a href="https://leanprover-community.github.io/lftcm2020/">https://leanprover-community.github.io/lftcm2020/</a>)<br>
Ooh, Mario is faster with answering the actual question <span aria-label="oops" class="emoji emoji-1f643" role="img" title="oops">:oops:</span></p>



<a name="202696382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202696382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202696382">(Jul 02 2020 at 14:33)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="254058">Marc Masdeu</span> Hi, welcome back. (Have you seen <a href="https://leanprover-community.github.io/lftcm2020/">https://leanprover-community.github.io/lftcm2020/</a>)</p>
</blockquote>
<p>Thanks <span class="user-mention" data-user-id="112680">@Johan Commelin</span>, I've been following everything Lean, just not posting to here... I know about the workshop, but sadly I'll be "away" next week...</p>



<a name="202696514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202696514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202696514">(Jul 02 2020 at 14:34)</a>:</h4>
<p>Ok, no worries!</p>



<a name="202698689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202698689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202698689">(Jul 02 2020 at 14:50)</a>:</h4>
<p>OK, turns out that the MWE I constructed was too M (but thanks <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> ! I did learn about congr!). Here's an updated one, hopefully it is enough now:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">some_subgroup</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)[</span><span class="n">comm_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">lemma</span> <span class="n">blah2</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]:</span>
<span class="o">(</span><span class="err">∏</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="k">in</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">some_subgroup</span> <span class="n">G</span><span class="o">}</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span>
    <span class="err">∏</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">some_subgroup</span> <span class="n">G</span><span class="o">)),</span> <span class="err">↑</span><span class="n">g</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="202699051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202699051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202699051">(Jul 02 2020 at 14:53)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">apply</span> <span class="n">finset</span><span class="bp">.</span><span class="n">prod_congr</span> <span class="c1">--?</span>
</code></pre></div>



<a name="202699543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202699543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202699543">(Jul 02 2020 at 14:57)</a>:</h4>
<p>It complains with</p>
<div class="codehilite"><pre><span></span><code><span class="n">invalid</span> <span class="n">apply</span> <span class="n">tactic</span><span class="o">,</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">unify</span>
  <span class="err">∏</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="k">in</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">some_subgroup</span> <span class="n">G</span><span class="o">}</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="err">∏</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">some_subgroup</span> <span class="n">G</span><span class="o">)),</span> <span class="err">↑</span><span class="n">g</span>
<span class="k">with</span>
  <span class="err">?</span><span class="n">m_4</span><span class="bp">.</span><span class="n">prod</span> <span class="err">?</span><span class="n">m_5</span> <span class="bp">=</span> <span class="err">?</span><span class="n">m_6</span><span class="bp">.</span><span class="n">prod</span> <span class="err">?</span><span class="n">m_7</span>
</code></pre></div>



<a name="202699597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202699597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202699597">(Jul 02 2020 at 14:57)</a>:</h4>
<p>Aah, of course</p>



<a name="202699620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202699620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202699620">(Jul 02 2020 at 14:58)</a>:</h4>
<p>The rhs is over some subgroup.</p>



<a name="202699676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202699676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202699676">(Jul 02 2020 at 14:58)</a>:</h4>
<p><code>rw finset.prod_subtype</code>?</p>



<a name="202699739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202699739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202699739">(Jul 02 2020 at 14:58)</a>:</h4>
<p>If all else fails, there is <code>finset.prod_bij</code> but I would try to avoid that.</p>



<a name="202699968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202699968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202699968">(Jul 02 2020 at 15:00)</a>:</h4>
<p><code>finset.prod_subtype</code> does not seem to exists...</p>



<a name="202700011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202700011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202700011">(Jul 02 2020 at 15:00)</a>:</h4>
<p><code>import data.fintype.card</code>? I think</p>



<a name="202700424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202700424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202700424">(Jul 02 2020 at 15:04)</a>:</h4>
<p>This has worked:</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">prod_subtype</span><span class="o">,</span>
    <span class="n">tauto</span><span class="o">,</span>
    <span class="n">finish</span><span class="o">,</span>
</code></pre></div>


<p>Leaving me with no idea of what's going on, of course...</p>



<a name="202700668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202700668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202700668">(Jul 02 2020 at 15:05)</a>:</h4>
<p><code>prod_subtype</code> is missing</p>



<a name="202701438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202701438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202701438">(Jul 02 2020 at 15:11)</a>:</h4>
<p>oops, misread Johan's suggestion. This proof might be a little clearer:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">blah2</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]:</span>
<span class="o">(</span><span class="err">∏</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="k">in</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">some_subgroup</span> <span class="n">G</span><span class="o">}</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span>
    <span class="err">∏</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">some_subgroup</span> <span class="n">G</span><span class="o">)),</span> <span class="err">↑</span><span class="n">g</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">finset</span><span class="bp">.</span><span class="n">prod_subtype</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">iff</span><span class="bp">.</span><span class="n">rfl</span>
<span class="kn">end</span>
</code></pre></div>



<a name="202701636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202701636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202701636">(Jul 02 2020 at 15:13)</a>:</h4>
<p>Unfortunately the unification problem leaves <code>has_coe_t_aux.coe</code> in the term, and <code>simp</code> doesn't know how to simplify it, so we have to finish with <code>iff.rfl</code> instead</p>



<a name="202718881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202718881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202718881">(Jul 02 2020 at 17:25)</a>:</h4>
<p>Here is what I have managed to prove: given a finite commutative group G, the product of all its elements equals the product of its elements of order 2. This could be seen as some sort of generalization of Wilson's theorem on the factorial of p-1 modulo p.</p>
<p>Now I know that this is terrible coding style, especially the proof of <code>prod_all_eq_prod_two_torsion</code>. I would appreciate a constructive critique of it. I am not looking for anything mathlib-ready at all, and in fact I'm happy with expensive tactics (to prove mathematically obvious statements) as long as it stays somewhat readable...</p>
<p>Thanks!</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">subgroup</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">finite</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">big_operators</span>

<span class="kn">lemma</span> <span class="n">prod_finset_distinct_inv</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">≠</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="err">∏</span> <span class="n">x</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">apply</span> <span class="n">finset</span><span class="bp">.</span><span class="n">case_strong_induction_on</span> <span class="n">s</span><span class="o">,</span> <span class="k">by</span> <span class="n">tauto</span><span class="o">,</span>
<span class="n">intros</span> <span class="n">a</span> <span class="n">s</span> <span class="n">a_notin_s</span> <span class="n">H</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
<span class="n">specialize</span> <span class="n">H</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">erase</span> <span class="n">s</span> <span class="n">a</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">erase_subset</span> <span class="o">(</span><span class="n">a</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="n">s</span><span class="o">),</span>
<span class="k">have</span> <span class="n">r</span> <span class="o">:</span> <span class="o">(</span><span class="err">∏</span> <span class="n">x</span> <span class="k">in</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">erase</span> <span class="n">s</span> <span class="n">a</span><span class="bp">⁻¹</span><span class="o">),</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
<span class="o">{</span>
  <span class="n">apply</span> <span class="n">H</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">x</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="k">by</span> <span class="n">simpa</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="n">clarify</span><span class="o">,</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">≠</span> <span class="n">a</span><span class="o">,</span> <span class="k">by</span> <span class="n">finish</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">x_not_ainv</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">ne_of_mem_erase</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">by_contradiction</span> <span class="n">hh</span><span class="o">,</span>
    <span class="n">push_neg</span> <span class="n">at</span> <span class="n">hh</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">hh</span><span class="o">,</span>
    <span class="n">finish</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_insert_of_mem</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_of_mem_erase</span> <span class="n">h</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">},</span>
<span class="o">{</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">prod_insert</span> <span class="n">a_notin_s</span><span class="o">,</span>
  <span class="n">suffices</span> <span class="n">hkey</span> <span class="o">:</span> <span class="o">(</span><span class="err">∏</span> <span class="n">x</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span><span class="bp">⁻¹</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">mul_eq_one_iff_inv_eq</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="n">hkey</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">ainv_notin_s1</span> <span class="o">:</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="err">∉</span> <span class="n">finset</span><span class="bp">.</span><span class="n">erase</span> <span class="n">s</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">not_mem_erase</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="n">s</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">ainv_in_s</span> <span class="o">:</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="k">have</span> <span class="n">ainv_in_s1</span> <span class="o">:</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="err">∈</span> <span class="n">insert</span> <span class="n">a</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">h1</span> <span class="n">a</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_insert_self</span> <span class="n">a</span> <span class="n">s</span><span class="o">),</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">≠</span> <span class="n">a</span><span class="o">,</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_of_mem_insert_of_ne</span> <span class="n">ainv_in_s1</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h2</span> <span class="n">a</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_insert_self</span> <span class="n">a</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">finset</span><span class="bp">.</span><span class="n">insert_erase</span> <span class="n">ainv_in_s</span><span class="o">,</span><span class="n">finset</span><span class="bp">.</span><span class="n">prod_insert</span> <span class="n">ainv_notin_s1</span><span class="o">,</span><span class="n">r</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">mul_one</span> <span class="n">a</span><span class="bp">⁻¹</span>
  <span class="o">},</span>
<span class="o">},</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">two_torsion_subgroup</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)[</span><span class="n">comm_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">z</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">},</span>
  <span class="n">one_mem&#39;</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">mul_mem&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">),</span>
  <span class="k">begin</span>
    <span class="n">tidy</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">mul_mul_mul_comm</span> <span class="n">a</span> <span class="n">b</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">],</span>
    <span class="n">refine</span> <span class="n">mul_one</span> <span class="mi">1</span><span class="o">,</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">inv_mem&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">),</span> <span class="k">by</span> <span class="o">{</span><span class="n">tidy</span><span class="o">,</span> <span class="n">rw</span> <span class="n">mul_inv_eq_one</span><span class="o">,</span> <span class="n">refine</span> <span class="n">inv_eq_of_mul_eq_one</span> <span class="n">ha</span><span class="o">}</span>
<span class="o">}</span>

<span class="kn">lemma</span> <span class="n">prod_all_eq_prod_two_torsion</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]:</span>
<span class="o">(</span><span class="err">∏</span> <span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="err">∏</span> <span class="n">g</span> <span class="o">:</span> <span class="n">two_torsion_subgroup</span> <span class="n">G</span><span class="o">,</span> <span class="n">g</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="k">have</span> <span class="n">hdisj</span> <span class="o">:</span> <span class="n">disjoint</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">two_torsion_subgroup</span> <span class="n">G</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="o">},</span>
    <span class="o">{</span>
        <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
        <span class="n">cases</span> <span class="n">hx</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
        <span class="n">norm_num</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">hA</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span> <span class="k">by</span> <span class="n">assumption</span><span class="o">,</span>
        <span class="n">suffices</span> <span class="n">hB</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">,</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">h2</span> <span class="o">(</span><span class="n">false</span><span class="bp">.</span><span class="n">rec</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="n">hA</span><span class="o">)),</span>
        <span class="n">clear</span> <span class="n">hA</span> <span class="n">h1</span><span class="o">,</span>
        <span class="n">simp</span> <span class="o">[</span><span class="err">←</span> <span class="n">mul_eq_one_iff_eq_inv</span><span class="o">]</span> <span class="n">at</span> <span class="n">h2</span><span class="o">,</span>
        <span class="n">assumption</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="err">∏</span> <span class="n">g</span> <span class="k">in</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="o">}</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">apply</span> <span class="n">prod_finset_distinct_inv</span><span class="bp">;</span>
        <span class="n">finish</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="o">(</span><span class="err">∏</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="err">∏</span> <span class="n">x</span> <span class="k">in</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">two_torsion_subgroup</span> <span class="n">G</span><span class="o">}</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
            <span class="bp">*</span> <span class="o">(</span><span class="err">∏</span> <span class="n">x</span> <span class="k">in</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="o">}</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">x</span><span class="o">),</span>
    <span class="o">{</span>
        <span class="c1">--simp [finset.prod_union],</span>
        <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
        <span class="n">rw</span> <span class="err">←</span> <span class="n">finset</span><span class="bp">.</span><span class="n">prod_union</span><span class="o">,</span>
        <span class="o">{</span>
            <span class="n">congr</span><span class="o">,</span>
            <span class="n">ext1</span><span class="o">,</span>
            <span class="n">simp</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">coe_inj</span><span class="o">],</span>
            <span class="n">safe</span><span class="o">,</span>
            <span class="n">suffices</span> <span class="n">hh</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">two_torsion_subgroup</span> <span class="n">G</span><span class="o">,</span> <span class="n">tauto</span><span class="o">,</span>
            <span class="k">have</span> <span class="n">a2</span><span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">eq_inv_iff_mul_eq_one</span><span class="bp">.</span><span class="n">mp</span> <span class="n">h_1</span><span class="o">,</span>
            <span class="n">tauto</span><span class="o">,</span>
        <span class="o">},</span>
        <span class="o">{</span>
            <span class="n">simp</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">disjoint_iff_disjoint_coe</span><span class="o">],</span>
            <span class="n">exact</span> <span class="n">hdisj</span><span class="o">,</span>
        <span class="o">}</span>
    <span class="o">},</span>
    <span class="o">{</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">H</span><span class="o">,</span> <span class="n">h</span><span class="o">],</span>
        <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">finset</span><span class="bp">.</span><span class="n">prod_subtype</span><span class="o">,</span>
        <span class="n">finish</span><span class="o">,</span>
    <span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="202742147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202742147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202742147">(Jul 02 2020 at 20:41)</a>:</h4>
<p>Its a nice result, I'd say we should have (some version) it in mathlib!<br>
I made some comments inline: it looks pretty good to me, maybe more lemmas and less long proofs would be more manageable though, like for the last statement you could have a lemma that<br>
prod of elements of G is prod of the two torsion times prod of things not their own inverse.<br>
then a lemma that the prod of things that are not their own inverse of any group is one, all as separate lemmas which are combined at the end (basically all of the have's in the last proof could be lemmas)</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">subgroup</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">finite</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">big_operators</span>
<span class="c">/-</span><span class="cm"> General comments</span>
<span class="cm"> 1. You can add @[to_additive] to generate additive versions of these lemmas if you like</span>
<span class="cm"> 2. you use tactics like clarify, finish, safe, a lot, these things can be a little slow, but they</span>
<span class="cm">    are convenient, so might be best to separate out some of the times they are used as separate lemmas</span>
<span class="cm">    whose proof is just by finish or whatever, so that they don&#39;t get re-run all the time -/</span>

<span class="kn">set_option</span> <span class="n">profiler</span> <span class="n">true</span> <span class="c1">-- you can use this too see time spent on proofs</span>

<span class="kn">lemma</span> <span class="n">prod_finset_distinct_inv</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">≠</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="err">∏</span> <span class="n">x</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">apply</span> <span class="n">finset</span><span class="bp">.</span><span class="n">case_strong_induction_on</span> <span class="n">s</span><span class="o">,</span>  <span class="k">by</span> <span class="n">tauto</span><span class="o">,</span>
<span class="n">intros</span> <span class="n">a</span> <span class="n">s</span> <span class="n">a_notin_s</span> <span class="n">H</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
<span class="n">specialize</span> <span class="n">H</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">erase</span> <span class="n">s</span> <span class="n">a</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">erase_subset</span> <span class="o">(</span><span class="n">a</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="n">s</span><span class="o">),</span>
<span class="k">have</span> <span class="n">r</span> <span class="o">:</span> <span class="o">(</span><span class="err">∏</span> <span class="n">x</span> <span class="k">in</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">erase</span> <span class="n">s</span> <span class="n">a</span><span class="bp">⁻¹</span><span class="o">),</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
<span class="o">{</span>
  <span class="n">apply</span> <span class="n">H</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">x</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="k">by</span> <span class="n">simpa</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="k">begin</span> <span class="n">finish</span><span class="o">,</span> <span class="kn">end</span><span class="o">,</span> <span class="c1">-- this takes ages</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">≠</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_of_mem_insert_of_ne</span> <span class="o">(</span><span class="n">h1</span> <span class="n">x</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_insert_of_mem</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_of_mem_erase</span> <span class="n">h</span><span class="o">)))</span> <span class="n">this</span><span class="o">,</span>
    <span class="c1">-- replaced finish with an explicit proof,</span>
    <span class="n">by_contradiction</span> <span class="n">hh</span><span class="o">,</span>
    <span class="n">push_neg</span> <span class="n">at</span> <span class="n">hh</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">hh</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="kn">using</span> <span class="n">finset</span><span class="bp">.</span><span class="n">ne_of_mem_erase</span> <span class="n">h</span><span class="o">,</span>
    <span class="c1">-- replaced finish with an explicit proof and don&#39;t name a short term that is only used once now</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_insert_of_mem</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_of_mem_erase</span> <span class="n">h</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">},</span>
<span class="o">{</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">prod_insert</span> <span class="n">a_notin_s</span><span class="o">,</span>
  <span class="n">suffices</span> <span class="n">hkey</span> <span class="o">:</span> <span class="o">(</span><span class="err">∏</span> <span class="n">x</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span><span class="bp">⁻¹</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">mul_eq_one_iff_inv_eq</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="n">hkey</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">ainv_notin_s1</span> <span class="o">:</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="err">∉</span> <span class="n">finset</span><span class="bp">.</span><span class="n">erase</span> <span class="n">s</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">not_mem_erase</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="n">s</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">ainv_in_s</span> <span class="o">:</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="k">have</span> <span class="n">ainv_in_s1</span> <span class="o">:</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="err">∈</span> <span class="n">insert</span> <span class="n">a</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">h1</span> <span class="n">a</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_insert_self</span> <span class="n">a</span> <span class="n">s</span><span class="o">),</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">≠</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_of_mem_insert_of_ne</span> <span class="n">ainv_in_s1</span> <span class="n">this</span><span class="o">,</span> <span class="c1">-- by exact can almost always be removed!</span>
    <span class="c1">-- as it is just openening tactic mode then returning to term mode</span>
    <span class="n">exact</span> <span class="n">h2</span> <span class="n">a</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_insert_self</span> <span class="n">a</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">finset</span><span class="bp">.</span><span class="n">insert_erase</span> <span class="n">ainv_in_s</span><span class="o">,</span><span class="n">finset</span><span class="bp">.</span><span class="n">prod_insert</span> <span class="n">ainv_notin_s1</span><span class="o">,</span><span class="n">r</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">mul_one</span> <span class="n">a</span><span class="bp">⁻¹</span>
  <span class="o">},</span>
<span class="o">},</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">two_torsion_subgroup</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">z</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">},</span>
  <span class="n">one_mem&#39;</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">mul_mem&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">),</span>
  <span class="k">begin</span>
    <span class="n">dsimp</span><span class="o">,</span> <span class="c1">-- use tidy? and tidy will tell you what it did in this case it only did dsimp at *, and we can just change it to dsimp</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">mul_mul_mul_comm</span> <span class="n">a</span> <span class="n">b</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">mul_one</span> <span class="mi">1</span><span class="o">,</span> <span class="c1">-- exact instead of refine</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">inv_mem&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">),</span> <span class="k">by</span> <span class="o">{</span><span class="n">dsimp</span><span class="o">,</span> <span class="n">rw</span> <span class="n">mul_inv_eq_one</span><span class="o">,</span> <span class="n">refine</span> <span class="n">inv_eq_of_mul_eq_one</span> <span class="n">ha</span><span class="o">}</span> <span class="c1">--same with tidy</span>
<span class="o">}</span>

<span class="kn">lemma</span> <span class="n">prod_all_eq_prod_two_torsion</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]:</span>
<span class="err">∏</span> <span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">g</span> <span class="bp">=</span> <span class="err">∏</span> <span class="n">g</span> <span class="o">:</span> <span class="n">two_torsion_subgroup</span> <span class="n">G</span><span class="o">,</span> <span class="n">g</span> <span class="o">:=</span> <span class="c1">-- don&#39;t need brackets</span>
<span class="k">begin</span>
    <span class="k">have</span> <span class="n">hdisj</span> <span class="o">:</span> <span class="n">disjoint</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">two_torsion_subgroup</span> <span class="n">G</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="o">},</span>
    <span class="o">{</span>
        <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
        <span class="n">cases</span> <span class="n">hx</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
        <span class="n">norm_num</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">hA</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span> <span class="k">by</span> <span class="n">assumption</span><span class="o">,</span>
        <span class="n">suffices</span> <span class="n">hB</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">,</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">h2</span> <span class="o">(</span><span class="n">false</span><span class="bp">.</span><span class="n">rec</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="n">hA</span><span class="o">)),</span>
        <span class="n">clear</span> <span class="n">hA</span> <span class="n">h1</span><span class="o">,</span>
        <span class="n">simpa</span> <span class="o">[</span><span class="err">←</span> <span class="n">mul_eq_one_iff_eq_inv</span><span class="o">]</span> <span class="kn">using</span> <span class="n">h2</span><span class="o">,</span> <span class="c1">-- simpa .. using instead of simp .. at .., assumption</span>
    <span class="o">},</span>
    <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="err">∏</span> <span class="n">g</span> <span class="k">in</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="o">}</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">apply</span> <span class="n">prod_finset_distinct_inv</span><span class="bp">;</span>
        <span class="n">finish</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="o">(</span><span class="err">∏</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="err">∏</span> <span class="n">x</span> <span class="k">in</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">two_torsion_subgroup</span> <span class="n">G</span><span class="o">}</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
            <span class="bp">*</span> <span class="o">(</span><span class="err">∏</span> <span class="n">x</span> <span class="k">in</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="o">}</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">x</span><span class="o">),</span>
    <span class="o">{</span>
        <span class="c1">--simp [finset.prod_union],</span>
        <span class="c1">-- using squeeze_simp we see that simp only used one lemma here, which was ne.def</span>
        <span class="c1">-- didn&#39;t seem like this was really changing anything so remove it!</span>
        <span class="n">rw</span> <span class="err">←</span> <span class="n">finset</span><span class="bp">.</span><span class="n">prod_union</span><span class="o">,</span>
        <span class="o">{</span>
            <span class="n">congr</span><span class="o">,</span>
            <span class="n">ext1</span><span class="o">,</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">true_iff</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_univ</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_to_finset</span><span class="o">,</span> <span class="n">ne</span><span class="bp">.</span><span class="n">def</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_union</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_set_of_eq</span><span class="o">],</span>
            <span class="n">rw</span> <span class="o">[</span><span class="n">two_torsion_subgroup</span><span class="o">,</span> <span class="n">eq_inv_iff_mul_eq_one</span><span class="o">],</span> <span class="c1">--neater proof</span>
            <span class="n">exact</span> <span class="n">classical</span><span class="bp">.</span><span class="n">em</span> <span class="bp">_</span><span class="o">,</span>
        <span class="o">},</span>
        <span class="o">{</span>
            <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">disjoint_iff_disjoint_coe</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">coe_to_finset</span><span class="o">],</span>
            <span class="c1">-- simp then exact (hypothesis) can be written as simpa</span>
        <span class="o">}</span>
    <span class="o">},</span>
    <span class="o">{</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">H</span><span class="o">,</span> <span class="n">h</span><span class="o">],</span>
        <span class="n">simp</span><span class="o">,</span> <span class="c1">-- once again simp wasnt doing much to most goals</span>
        <span class="n">apply</span> <span class="n">finset</span><span class="bp">.</span><span class="n">prod_subtype</span><span class="o">,</span>
        <span class="n">finish</span><span class="o">,</span>
    <span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="202742425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202742425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202742425">(Jul 02 2020 at 20:45)</a>:</h4>
<p>Probably relevant: <code>prod_involution</code></p>



<a name="202789566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202789566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202789566">(Jul 03 2020 at 10:35)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="127136">@Alex J. Best</span> for the review! I have incorporated your suggestions, although I see no way of coming up with this</p>
<div class="codehilite"><pre><span></span><code><span class="n">suffices</span> <span class="o">:</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">≠</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_of_mem_insert_of_ne</span> <span class="o">(</span><span class="n">h1</span> <span class="n">x</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_insert_of_mem</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_of_mem_erase</span> <span class="n">h</span><span class="o">)))</span> <span class="n">this</span><span class="o">,</span>
</code></pre></div>


<p>on my own without spending half an hour trying different things. Would be nice if the <code>finish</code> tactic gave something back as a hint!</p>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> : I was aware of <code>prod_involution</code> (this is the one that wilson's theorem uses, right?), but wanted to prove the version that I needed using tactics.</p>
<p>Next step (we have a "summer project" with <span class="user-mention" data-user-id="315546">@Xavier Xarles</span>) will be to prove that the product of all the elements of a finite elementary abelian 2-group of order &gt; 2 is 1...</p>



<a name="202805882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/202805882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#202805882">(Jul 03 2020 at 13:54)</a>:</h4>
<p>To expand on Johan's point, applying <code>prod_involution</code> reduces the problem to four much easier sorries.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">finite</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">big_operators</span>
<span class="kn">open</span> <span class="n">finset</span>

<span class="kn">lemma</span> <span class="n">prod_finset_distinct_inv</span>
<span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span>
<span class="o">(</span><span class="n">hs1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span>
<span class="o">(</span><span class="n">hs2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">≠</span> <span class="n">x</span><span class="o">)</span>
<span class="o">:</span> <span class="err">∏</span> <span class="n">x</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="bp">@</span><span class="n">prod_involution</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span> <span class="n">a</span><span class="bp">⁻¹</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">rw</span> <span class="n">mul_inv_self</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">apply</span> <span class="n">hs2</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">apply</span> <span class="n">hs1</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span> <span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="203070357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/203070357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#203070357">(Jul 07 2020 at 06:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="254058">Marc Masdeu</span> <a href="#narrow/stream/113489-new-members/topic/Frustration.20with.20finset/near/202789566">said</a>:</p>
<blockquote>
<p>Would be nice if the <code>finish</code> tactic gave something back as a hint!</p>
</blockquote>
<p>I asked about this once and was told more or less that the output would be unreadable and no quicker than just running finish again unfortunately: <a href="https://github.com/leanprover-community/mathlib/issues/1451#issuecomment-533151071">https://github.com/leanprover-community/mathlib/issues/1451#issuecomment-533151071</a></p>



<a name="203485008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/203485008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#203485008">(Jul 10 2020 at 09:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/113489-new-members/topic/Frustration.20with.20finset/near/202805882">said</a>:</p>
<blockquote>
<p>To expand on Johan's point, applying <code>prod_involution</code> reduces the problem to four much easier sorries.</p>
</blockquote>
<p>Thanks <span class="user-mention" data-user-id="252300">@Jalex Stark</span> , we knew about this but it seemed like killing flies with cannons, so we set to prove directly what we exactly wanted. But in the long run, I agree your approach is the right one.</p>



<a name="203485263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/203485263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#203485263">(Jul 10 2020 at 09:13)</a>:</h4>
<p>And now I can't even start the next lemma:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span>

<span class="c1">-- given G two torsion and 1 ≠ g ∈ G, there is H &lt; G of index 2 with g ∉ H</span>
<span class="kn">lemma</span> <span class="n">element_avoidance</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">):</span>
 <span class="bp">∃</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">,</span> <span class="o">(</span><span class="n">g</span> <span class="err">∉</span> <span class="n">H</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">H</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">}</span> <span class="bp">=</span> <span class="n">H</span> <span class="err">∪</span> <span class="o">(</span><span class="n">left_coset</span> <span class="n">g</span> <span class="n">H</span><span class="o">)):=</span>
<span class="k">begin</span>
    <span class="n">apply</span> <span class="n">nat</span><span class="bp">.</span><span class="n">case_strong_induction_on</span> <span class="o">(</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">G</span><span class="o">),</span>
<span class="kn">end</span>
</code></pre></div>


<p>I want to do a proof by induction on the size of G, but it complains at the first step. I can't quite make sense of the error. In trying to debug what was going on, I went for a much stupider lemma, which I can't do either!</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">stupid</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">):</span>
 <span class="bp">∃</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">,</span>  <span class="n">H</span> <span class="bp">=</span> <span class="n">H</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">use</span> <span class="err">↑</span><span class="n">G</span><span class="o">,</span> <span class="c1">-- Complains!</span>
<span class="kn">end</span>
</code></pre></div>



<a name="203488036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/203488036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#203488036">(Jul 10 2020 at 09:45)</a>:</h4>
<p>One way to get <code>G</code> as a subgroup of itself is to think of the ordering on subgroups by inclusion, <code>G</code> is then tthe maximal, or top element, so lean understands the symbol <code>\top</code> for <code>G</code> as a sub of itself.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">stupid</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">):</span>
 <span class="bp">∃</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">,</span>  <span class="n">H</span> <span class="bp">=</span> <span class="n">H</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">use</span> <span class="err">⊤</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="203488304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/203488304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#203488304">(Jul 10 2020 at 09:49)</a>:</h4>
<p>Also, be cautious using the arrow directly, if you want to coerce something try <code>(thing : Type)</code> to tell lean which type to coerce it to, lean will print the up arrow but it can be underdetermined what you want the arrow to mean so just putting the type you want can save headaches.</p>



<a name="203488494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/203488494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#203488494">(Jul 10 2020 at 09:50)</a>:</h4>
<p>Yes but isn't this like cheating? I would expect that there would be some kind of coertion mechanism that would work in this case. In particular, <code>use (G : subgroup G)</code> is more like what I'd like to work, and it doesn't. Recall that I want to really do the non-stupid lemma by induction...</p>



<a name="203488752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/203488752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#203488752">(Jul 10 2020 at 09:54)</a>:</h4>
<p>As for your first question lean gets a bit confused because it doesn't see the cardinality of <code>G</code>, or even <code>G</code> really in your goal, maybe its possible to make it work, but it seems less hassle to set this up more explicitly as a statement parameterised by the caridinality of the group</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">element_avoidance_aux</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">G</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">),</span>
 <span class="bp">∃</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">,</span> <span class="o">(</span><span class="n">g</span> <span class="err">∉</span> <span class="n">H</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">H</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">}</span> <span class="bp">=</span> <span class="n">H</span> <span class="err">∪</span> <span class="o">(</span><span class="n">left_coset</span> <span class="n">g</span> <span class="n">H</span><span class="o">)):=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">nat</span><span class="bp">.</span><span class="n">case_strong_induction_on</span> <span class="n">n</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>your original statement is then obtained as <code>element_avoidance_aux (rfl _)</code> or something like that.</p>



<a name="203489157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/203489157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#203489157">(Jul 10 2020 at 09:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="254058">Marc Masdeu</span> <a href="#narrow/stream/113489-new-members/topic/Frustration.20with.20finset/near/203488494">said</a>:</p>
<blockquote>
<p>Yes but isn't this like cheating? I would expect that there would be some kind of coertion mechanism that would work in this case. In particular, <code>use (G : subgroup G)</code> is more like what I'd like to work, and it doesn't. Recall that I want to really do the non-stupid lemma by induction...</p>
</blockquote>
<p>I agree some automatic coercion would be nice, I'm just not sure how the setup would go. It doesn't seem to me to fit the coercion model: <code>G</code> is a type and you can't make a coercion from any random type to <code>subgroup G</code>, only from <code>G</code> itself.</p>
<p>Top is a bit weird to look at at first, but its short to type, and you get all the lemmas about order (every subgroup is contained in top, nothing contains top, etc for free.</p>



<a name="203491429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/203491429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#203491429">(Jul 10 2020 at 10:26)</a>:</h4>
<p>I was confused but: Ohhh I get it <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span> is index 2 only in the 2-torsion.</p>



<a name="203509774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/203509774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#203509774">(Jul 10 2020 at 14:01)</a>:</h4>
<p>Coercing G into subgroup G is a dependent coercion which I don't think is possible</p>



<a name="205092342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205092342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205092342">(Jul 27 2020 at 08:35)</a>:</h4>
<p>OK so I'm Leaning again, and managed to prove the element_avoidance lemma, modulo proving the "obvious" fact that a finite subgroup has finitely many subgroups:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">subgroup</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">finite</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">basic</span>

<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">big_operators</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">finite_subgroups_of_finite_group</span> <span class="o">:</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">true</span><span class="o">}</span><span class="bp">.</span><span class="n">finite</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>


<p>Is this something easy to do?</p>



<a name="205092357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205092357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205092357">(Jul 27 2020 at 08:36)</a>:</h4>
<p>it injects to <code>set G</code></p>



<a name="205092407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205092407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205092407">(Jul 27 2020 at 08:36)</a>:</h4>
<p>also instead of that you want to say <code>fintype (subgroup G)</code>?</p>



<a name="205092447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205092447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205092447">(Jul 27 2020 at 08:37)</a>:</h4>
<p>The exact statement that  I need in my proof is this one, but maybe what you suggest is also OK?</p>



<a name="205092546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205092546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205092546">(Jul 27 2020 at 08:38)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">subgroup</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">finite</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">big_operators</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">fintype</span><span class="bp">.</span><span class="n">of_injective</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">subgroup</span><span class="bp">.</span><span class="n">ext&#39;</span>

<span class="kn">lemma</span> <span class="n">finite_subgroups_of_finite_group</span> <span class="o">:</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">true</span><span class="o">}</span><span class="bp">.</span><span class="n">finite</span> <span class="o">:=</span>
<span class="n">set</span><span class="bp">.</span><span class="n">finite</span><span class="bp">.</span><span class="n">of_fintype</span> <span class="bp">_</span>
</code></pre></div>



<a name="205092573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205092573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205092573">(Jul 27 2020 at 08:39)</a>:</h4>
<p>(edited)</p>



<a name="205092917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205092917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205092917">(Jul 27 2020 at 08:44)</a>:</h4>
<p>Wow!! I am trying to make sense of what just happened there... I have trouble understanding finset, fintype,... And also the <code>instance</code> thingy. But thanks so much <span class="user-mention" data-user-id="110064">@Kenny Lau</span> !</p>



<a name="205096706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205096706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205096706">(Jul 27 2020 at 09:36)</a>:</h4>
<p>After minimal cleaning, this is what I got:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">of_injective</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">subgroup</span><span class="bp">.</span><span class="n">ext&#39;</span>

<span class="c1">-- given a finite group G  and g ∈ G of order 2, there is H &lt; G  with g ∉ H and such that G[2] = H \cup g H.</span>
<span class="kn">lemma</span> <span class="n">element_avoidance</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">}</span>  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">):</span>
 <span class="bp">∃</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">,</span>
  <span class="o">(</span><span class="n">g</span> <span class="err">∉</span> <span class="n">H</span> <span class="bp">∧</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">H</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">∧</span>
  <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">}</span> <span class="bp">=</span> <span class="n">H</span> <span class="err">∪</span> <span class="o">(</span><span class="n">left_coset</span> <span class="n">g</span> <span class="n">H</span><span class="o">))</span>
  <span class="o">:=</span>
<span class="k">begin</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">g</span> <span class="err">∉</span> <span class="n">X</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">x</span><span class="bp">*</span><span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)},</span>
    <span class="k">have</span> <span class="n">sfin</span> <span class="o">:</span> <span class="n">s</span><span class="bp">.</span><span class="n">finite</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite</span><span class="bp">.</span><span class="n">of_fintype</span> <span class="bp">_</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">snonempty</span> <span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">nonempty</span> <span class="n">s</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">use</span> <span class="err">⊥</span><span class="o">,</span>
        <span class="n">split</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">h₁</span><span class="o">,</span>
        <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">subgroup</span><span class="bp">.</span><span class="n">mem_bot</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">hx</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">mul_one</span> <span class="mi">1</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="k">let</span> <span class="n">existsH</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite</span><span class="bp">.</span><span class="n">exists_maximal_wrt</span> <span class="n">id</span> <span class="n">s</span> <span class="n">sfin</span> <span class="n">snonempty</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">and_imp</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">id</span><span class="bp">.</span><span class="n">def</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_set_of_eq</span><span class="o">]</span> <span class="n">at</span> <span class="n">existsH</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">existsH</span> <span class="k">with</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">ha</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">ha</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
    <span class="c1">-- We have defined a as the maximal subgroup of G satisfying</span>
    <span class="c1">-- 1) g ∉ a</span>
    <span class="c1">-- 2) ∀ x ∈ a, x*x = 1</span>
    <span class="c1">-- Now we must show that a ∪ ga = twotorsion(G)</span>
    <span class="n">apply</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">antisymm</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="c1">-- Prove that twotorsion(G) ⊆ a u ga</span>
        <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
        <span class="n">dsimp</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
        <span class="n">rcases</span> <span class="n">ha</span> <span class="k">with</span> <span class="bp">⟨</span>  <span class="n">ha1</span><span class="o">,</span> <span class="n">hmax</span> <span class="bp">⟩</span> <span class="o">,</span>
        <span class="n">cases</span> <span class="n">ha1</span> <span class="k">with</span> <span class="n">hga</span> <span class="n">hatwotors</span><span class="o">,</span>

        <span class="n">by_contradiction</span> <span class="n">h</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">x_eq_xinv</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="o">:=</span> <span class="n">eq_inv_of_mul_eq_one</span> <span class="n">hx</span><span class="o">,</span>
        <span class="k">let</span> <span class="n">xua</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span> <span class="o">:=</span>
        <span class="o">{</span>
            <span class="n">carrier</span> <span class="o">:=</span> <span class="err">↑</span><span class="n">a</span> <span class="err">∪</span> <span class="n">left_coset</span> <span class="n">x</span> <span class="n">a</span><span class="o">,</span>
            <span class="n">one_mem&#39;</span> <span class="o">:=</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="o">(</span><span class="n">subgroup</span><span class="bp">.</span><span class="n">one_mem</span> <span class="n">a</span><span class="o">),</span>
            <span class="n">mul_mem&#39;</span> <span class="o">:=</span>
            <span class="k">begin</span>
            <span class="n">intros</span> <span class="n">u</span> <span class="n">v</span> <span class="n">hu</span> <span class="n">hv</span><span class="o">,</span>
            <span class="n">cases</span> <span class="n">hv</span> <span class="k">with</span> <span class="n">hv1</span> <span class="n">hv2</span><span class="o">,</span>
            <span class="o">{</span>
                <span class="n">cases</span> <span class="n">hu</span> <span class="k">with</span> <span class="n">hu1</span> <span class="n">hu2</span><span class="o">,</span>
                <span class="o">{</span>
                    <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="o">(</span><span class="n">subgroup</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">a</span> <span class="n">hu1</span> <span class="n">hv1</span><span class="o">),</span>
                <span class="o">},</span>
                <span class="o">{</span>
                    <span class="n">right</span><span class="o">,</span>
                    <span class="n">rw</span> <span class="o">[</span><span class="n">mem_left_coset_iff</span><span class="o">,</span> <span class="err">←</span><span class="n">mul_assoc</span><span class="o">],</span>
                    <span class="n">rw</span> <span class="n">mem_left_coset_iff</span> <span class="n">at</span> <span class="n">hu2</span><span class="o">,</span>
                    <span class="n">exact</span> <span class="n">is_submonoid</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">hu2</span> <span class="n">hv1</span><span class="o">,</span>
                <span class="o">}</span>
            <span class="o">},</span>
            <span class="o">{</span>
                <span class="n">cases</span> <span class="n">hu</span> <span class="k">with</span> <span class="n">hu1</span> <span class="n">hu2</span><span class="o">,</span>
                <span class="o">{</span>
                    <span class="n">right</span><span class="o">,</span>
                    <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">,</span> <span class="n">mem_left_coset_iff</span><span class="o">,</span> <span class="err">←</span><span class="n">mul_assoc</span><span class="o">],</span>
                    <span class="n">rw</span> <span class="n">mem_left_coset_iff</span> <span class="n">at</span> <span class="n">hv2</span><span class="o">,</span>
                    <span class="n">exact</span> <span class="n">is_submonoid</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">hv2</span> <span class="n">hu1</span><span class="o">,</span>
                <span class="o">},</span>
                <span class="o">{</span>
                    <span class="n">left</span><span class="o">,</span>
                    <span class="n">rw</span> <span class="n">mem_left_coset_iff</span> <span class="n">at</span> <span class="n">hu2</span> <span class="n">hv2</span><span class="o">,</span>
                    <span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">u</span> <span class="bp">*</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">a</span><span class="o">,</span>
                    <span class="o">{</span>
                        <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">hu2</span> <span class="n">hv2</span> <span class="err">⊢</span><span class="o">,</span>
                        <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="err">←</span><span class="n">mul_assoc</span> <span class="n">v</span> <span class="bp">_</span><span class="o">,</span> <span class="n">mul_comm</span> <span class="n">v</span> <span class="bp">_</span><span class="o">],</span>
                        <span class="n">exact</span> <span class="n">subgroup</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">a</span> <span class="n">hv2</span> <span class="n">hu2</span><span class="o">,</span>
                    <span class="o">},</span>
                    <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">x_eq_xinv</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">]</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
                    <span class="n">exact</span> <span class="n">H</span><span class="o">,</span>
                <span class="o">},</span>
            <span class="o">},</span>
            <span class="kn">end</span><span class="o">,</span>
            <span class="n">inv_mem&#39;</span> <span class="o">:=</span>
            <span class="k">begin</span>
                <span class="n">intros</span> <span class="n">u</span> <span class="n">hu</span><span class="o">,</span>
                <span class="n">cases</span> <span class="n">hu</span> <span class="k">with</span> <span class="n">hu1</span> <span class="n">hu2</span><span class="o">,</span>
                <span class="o">{</span>
                    <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="o">(</span><span class="n">is_subgroup</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">hu1</span><span class="o">),</span>
                <span class="o">},</span>
                <span class="o">{</span>
                    <span class="n">right</span><span class="o">,</span>
                    <span class="n">rw</span> <span class="n">mem_left_coset_iff</span> <span class="n">at</span> <span class="n">hu2</span> <span class="err">⊢</span><span class="o">,</span>
                    <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">hu2</span> <span class="err">⊢</span><span class="o">,</span>
                    <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">subgroup</span><span class="bp">.</span><span class="n">inv_mem_iff</span><span class="o">,</span> <span class="n">mul_inv</span><span class="o">,</span> <span class="n">inv_inv</span><span class="o">,</span> <span class="n">inv_inv</span><span class="o">],</span>
                    <span class="n">rw</span> <span class="err">←</span><span class="n">x_eq_xinv</span> <span class="n">at</span> <span class="n">hu2</span><span class="o">,</span>
                    <span class="n">exact</span> <span class="n">hu2</span><span class="o">,</span>
                <span class="o">}</span>
            <span class="kn">end</span>
        <span class="o">},</span>
        <span class="k">have</span> <span class="n">hxinxua</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">xua</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">y</span> <span class="err">∈</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">∨</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">left_coset</span> <span class="n">x</span> <span class="n">a</span><span class="o">),</span> <span class="k">by</span> <span class="n">apply</span> <span class="n">subgroup</span><span class="bp">.</span><span class="n">mem_coe</span><span class="o">,</span>
        <span class="n">specialize</span> <span class="n">hmax</span> <span class="n">xua</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">g_notin_xua</span> <span class="o">:</span> <span class="n">g</span> <span class="err">∉</span> <span class="n">xua</span><span class="o">,</span>
        <span class="o">{</span>
            <span class="n">clear</span> <span class="n">hmax</span><span class="o">,</span>
            <span class="n">by_contradiction</span> <span class="n">cont</span><span class="o">,</span>
            <span class="n">cases</span> <span class="n">cont</span> <span class="k">with</span> <span class="n">c1</span> <span class="n">c2</span><span class="o">,</span>
            <span class="o">{</span>
                <span class="n">solve_by_elim</span><span class="o">,</span>
            <span class="o">},</span>
            <span class="o">{</span>
                <span class="n">rw</span> <span class="n">mem_left_coset_iff</span> <span class="n">at</span> <span class="n">c2</span><span class="o">,</span>
                <span class="k">have</span> <span class="n">h2</span><span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">left_coset</span> <span class="n">g</span> <span class="err">↑</span><span class="n">a</span><span class="o">,</span>
                <span class="o">{</span>
                    <span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_union_eq</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
                    <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
                    <span class="n">exact</span> <span class="n">h</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
                <span class="o">},</span>
                <span class="n">rw</span> <span class="n">mem_left_coset_iff</span> <span class="n">at</span> <span class="n">h2</span><span class="o">,</span>
                <span class="n">suffices</span> <span class="n">h3</span><span class="o">:</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span> <span class="err">∈</span> <span class="err">↑</span><span class="n">a</span><span class="o">,</span> <span class="k">by</span> <span class="n">solve_by_elim</span><span class="o">,</span>
                <span class="n">norm_cast</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
                <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">subgroup</span><span class="bp">.</span><span class="n">inv_mem_iff</span><span class="o">,</span> <span class="n">mul_inv</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="n">inv_inv</span><span class="o">],</span>
                <span class="n">exact</span> <span class="n">c2</span><span class="o">,</span>
            <span class="o">}</span>
        <span class="o">},</span>
        <span class="n">specialize</span> <span class="n">hmax</span> <span class="n">g_notin_xua</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">h_twotors</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">xua</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">),</span>
        <span class="o">{</span>
            <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
            <span class="n">rw</span> <span class="n">hxinxua</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span>
            <span class="n">cases</span> <span class="n">hy</span><span class="o">,</span>
            <span class="o">{</span>
                <span class="n">apply</span> <span class="n">hatwotors</span><span class="o">,</span>
                <span class="n">exact</span> <span class="n">subgroup</span><span class="bp">.</span><span class="n">mem_coe</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hy</span><span class="o">,</span>
            <span class="o">},</span>
            <span class="o">{</span>
                <span class="n">rw</span> <span class="n">mem_left_coset_iff</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span>
                <span class="k">have</span> <span class="n">HH</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">w</span> <span class="err">∈</span> <span class="n">a</span><span class="o">,</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">w</span><span class="o">,</span> <span class="k">by</span> <span class="n">tauto</span><span class="o">,</span>
                <span class="n">cases</span> <span class="n">HH</span> <span class="k">with</span> <span class="n">w</span> <span class="n">hw</span><span class="o">,</span>
                <span class="n">cases</span> <span class="n">hw</span> <span class="k">with</span> <span class="n">hw1</span> <span class="n">hw2</span><span class="o">,</span>
                <span class="k">have</span> <span class="n">hhy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">w</span> <span class="o">:=</span> <span class="n">eq_mul_of_inv_mul_eq</span> <span class="n">hw2</span><span class="o">,</span>
                <span class="k">calc</span>
                <span class="n">y</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">w</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">w</span><span class="o">):</span> <span class="n">congr</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">has_mul</span><span class="bp">.</span><span class="n">mul</span> <span class="n">hhy</span><span class="o">)</span> <span class="n">hhy</span>
                <span class="bp">...</span>   <span class="bp">=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">w</span> <span class="bp">*</span> <span class="n">w</span><span class="o">):</span> <span class="n">mul_mul_mul_comm</span> <span class="n">x</span> <span class="n">w</span> <span class="n">x</span> <span class="n">w</span>
                <span class="bp">...</span>   <span class="bp">=</span> <span class="n">w</span> <span class="bp">*</span> <span class="n">w</span> <span class="o">:</span> <span class="n">mul_left_eq_self</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">hx</span>
                <span class="bp">...</span>   <span class="bp">=</span> <span class="mi">1</span>      <span class="o">:</span> <span class="n">hatwotors</span> <span class="n">w</span> <span class="n">hw1</span><span class="o">,</span>
            <span class="o">}</span>
        <span class="o">},</span>
        <span class="n">specialize</span> <span class="n">hmax</span> <span class="n">h_twotors</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">htriv</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">xua</span><span class="o">,</span>
        <span class="o">{</span>
            <span class="n">rw</span> <span class="n">subgroup</span><span class="bp">.</span><span class="n">le_def</span><span class="o">,</span>
            <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
            <span class="n">rw</span> <span class="n">hxinxua</span><span class="o">,</span>
            <span class="n">left</span><span class="o">,</span>
            <span class="n">exact</span> <span class="n">hy</span><span class="o">,</span>
        <span class="o">},</span>
        <span class="n">specialize</span> <span class="n">hmax</span> <span class="n">htriv</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">hc</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">a</span><span class="o">,</span>
        <span class="o">{</span>
            <span class="n">norm_cast</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
            <span class="n">rw</span> <span class="n">hmax</span><span class="o">,</span>
            <span class="n">clear</span> <span class="n">sfin</span> <span class="n">snonempty</span> <span class="n">s</span> <span class="n">hga</span> <span class="n">hatwotors</span> <span class="n">h</span> <span class="n">g_notin_xua</span> <span class="n">htriv</span> <span class="n">h_twotors</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">hmax</span><span class="o">,</span>
            <span class="n">dsimp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
            <span class="n">rw</span> <span class="n">hxinxua</span><span class="o">,</span>
            <span class="n">right</span><span class="o">,</span>
            <span class="n">rw</span> <span class="n">mem_left_coset_iff</span><span class="o">,</span>
            <span class="n">exact</span> <span class="n">quotient_group</span><span class="bp">.</span><span class="n">eq</span><span class="bp">.</span><span class="n">mp</span> <span class="n">rfl</span><span class="o">,</span>
        <span class="o">},</span>
        <span class="k">have</span> <span class="n">hl</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">a</span><span class="o">,</span>
        <span class="o">{</span>
            <span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_union</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
            <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
            <span class="n">exact</span> <span class="n">h</span><span class="bp">.</span><span class="n">left</span>
        <span class="o">},</span>
        <span class="n">solve_by_elim</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
        <span class="c1">-- prove that twotorsion(G) ⊇ a u ga</span>
        <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
        <span class="n">by_cases</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">a</span><span class="o">),</span>
        <span class="n">tauto</span><span class="o">,</span>
        <span class="o">{</span>
            <span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">left_coset</span> <span class="n">g</span> <span class="n">a</span><span class="o">),</span>
            <span class="o">{</span>
                <span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_union</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
                <span class="n">tauto</span><span class="o">,</span>
            <span class="o">},</span>
            <span class="n">suffices</span> <span class="n">x_is_twotors</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span> <span class="k">by</span> <span class="n">tauto</span><span class="o">,</span>
            <span class="n">clear</span> <span class="n">hx</span> <span class="n">h</span><span class="o">,</span>
            <span class="k">have</span> <span class="n">H2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span> <span class="k">by</span> <span class="n">tauto</span><span class="o">,</span>
            <span class="n">rw</span> <span class="n">mem_left_coset_iff</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
            <span class="n">specialize</span> <span class="n">H2</span>  <span class="o">(</span><span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="n">H</span><span class="o">,</span>
            <span class="k">have</span> <span class="n">H3</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="o">:=</span> <span class="n">eq_inv_of_mul_eq_one</span> <span class="n">h₂</span><span class="o">,</span>
            <span class="k">by</span> <span class="k">calc</span>
            <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h₂</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">]</span>
            <span class="bp">...</span>   <span class="bp">=</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">H3</span>
            <span class="bp">...</span>   <span class="bp">=</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">mul_right_comm</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="n">x</span>
            <span class="bp">...</span>   <span class="bp">=</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">*</span> <span class="o">(</span><span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">mul_assoc</span> <span class="o">(</span><span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="n">x</span>
            <span class="bp">...</span>   <span class="bp">=</span> <span class="mi">1</span> <span class="o">:</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">H2</span><span class="o">,</span>
        <span class="o">}</span>
    <span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="205098166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205098166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205098166">(Jul 27 2020 at 09:52)</a>:</h4>
<p>Please please turn that into 10 separate lemmas. :-)</p>



<a name="205121206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205121206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205121206">(Jul 27 2020 at 14:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/Frustration.20with.20finset/near/205098166">said</a>:</p>
<blockquote>
<p>Please please turn that into 10 separate lemmas. :-)</p>
</blockquote>
<p>Have 6 so far...and done for the day :-).</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">of_injective</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">subgroup</span><span class="bp">.</span><span class="n">ext&#39;</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">If a is a subgroup of G[2] and x ∈ G[2], then a ∪ x *l a is a subgroup.</span>
<span class="cm">-/</span>
<span class="n">def</span> <span class="n">insert_twotors_to_twotors</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">g</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">carrier</span> <span class="o">:=</span> <span class="err">↑</span><span class="n">a</span> <span class="err">∪</span> <span class="n">left_coset</span> <span class="n">x</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">one_mem&#39;</span> <span class="o">:=</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="o">(</span><span class="n">subgroup</span><span class="bp">.</span><span class="n">one_mem</span> <span class="n">a</span><span class="o">),</span>
  <span class="n">mul_mem&#39;</span> <span class="o">:=</span>
  <span class="k">begin</span>
    <span class="n">intros</span> <span class="n">u</span> <span class="n">v</span> <span class="n">hu</span> <span class="n">hv</span><span class="o">,</span>
    <span class="c1">--rcases? hu hv,-- with ⟨ hu1, hu2⟩ | ⟨  hv1, hv2⟩ ,</span>
    <span class="n">cases</span> <span class="n">hv</span> <span class="k">with</span> <span class="n">hv1</span> <span class="n">hv2</span><span class="o">,</span>
    <span class="n">repeat</span> <span class="o">{</span><span class="n">cases</span> <span class="n">hu</span> <span class="k">with</span> <span class="n">hu1</span> <span class="n">hu2</span><span class="o">},</span>
    <span class="o">{</span>
      <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="o">(</span><span class="n">subgroup</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">a</span> <span class="n">hu1</span> <span class="n">hv1</span><span class="o">),</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">right</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">mem_left_coset_iff</span><span class="o">,</span> <span class="err">←</span><span class="n">mul_assoc</span><span class="o">],</span>
      <span class="n">rw</span> <span class="n">mem_left_coset_iff</span> <span class="n">at</span> <span class="n">hu2</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">is_submonoid</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">hu2</span> <span class="n">hv1</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">right</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">,</span> <span class="n">mem_left_coset_iff</span><span class="o">,</span> <span class="err">←</span><span class="n">mul_assoc</span><span class="o">],</span>
      <span class="n">rw</span> <span class="n">mem_left_coset_iff</span> <span class="n">at</span> <span class="n">hv2</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">is_submonoid</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">hv2</span> <span class="n">hu1</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">left</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mem_left_coset_iff</span> <span class="n">at</span> <span class="n">hu2</span> <span class="n">hv2</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">u</span> <span class="bp">*</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">a</span><span class="o">,</span>
      <span class="o">{</span>
          <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">hu2</span> <span class="n">hv2</span> <span class="err">⊢</span><span class="o">,</span>
          <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="err">←</span><span class="n">mul_assoc</span> <span class="n">v</span> <span class="bp">_</span><span class="o">,</span> <span class="n">mul_comm</span> <span class="n">v</span> <span class="bp">_</span><span class="o">],</span>
          <span class="n">exact</span> <span class="n">subgroup</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">a</span> <span class="n">hv2</span> <span class="n">hu2</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="k">have</span> <span class="n">x_eq_xinv</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="o">:=</span> <span class="n">eq_inv_of_mul_eq_one</span> <span class="n">hx</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">x_eq_xinv</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">]</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">H</span><span class="o">,</span>
    <span class="o">}</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">inv_mem&#39;</span> <span class="o">:=</span>
  <span class="k">begin</span>
      <span class="n">intros</span> <span class="n">u</span> <span class="n">hu</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">hu</span> <span class="k">with</span> <span class="n">hu1</span> <span class="n">hu2</span><span class="o">,</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="o">(</span><span class="n">is_subgroup</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">hu1</span><span class="o">),</span>
      <span class="o">{</span>
          <span class="n">right</span><span class="o">,</span>
          <span class="n">rw</span> <span class="n">mem_left_coset_iff</span> <span class="n">at</span> <span class="n">hu2</span> <span class="err">⊢</span><span class="o">,</span>
          <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">hu2</span> <span class="err">⊢</span><span class="o">,</span>
          <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">subgroup</span><span class="bp">.</span><span class="n">inv_mem_iff</span><span class="o">,</span> <span class="n">mul_inv</span><span class="o">,</span> <span class="n">inv_inv</span><span class="o">,</span> <span class="n">inv_inv</span><span class="o">],</span>
          <span class="k">have</span> <span class="n">x_eq_xinv</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="o">:=</span> <span class="n">eq_inv_of_mul_eq_one</span> <span class="n">hx</span><span class="o">,</span>
          <span class="n">rw</span> <span class="err">←</span><span class="n">x_eq_xinv</span> <span class="n">at</span> <span class="n">hu2</span><span class="o">,</span>
          <span class="n">exact</span> <span class="n">hu2</span><span class="o">,</span>
      <span class="o">}</span>
  <span class="kn">end</span>
<span class="o">}</span>
<span class="c">/-</span><span class="cm">-</span>
<span class="cm">If g ∈ G[2] and a ≤ G[2], then a ∪ g l* a ⊆ G[2].</span>
<span class="cm">--/</span>
<span class="kn">lemma</span> <span class="n">twotorsion_contains_a_and_ga</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
    <span class="err">↑</span><span class="n">a</span> <span class="err">∪</span> <span class="n">left_coset</span> <span class="n">g</span> <span class="err">↑</span><span class="n">a</span> <span class="err">⊆</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">}</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="c1">-- prove that twotorsion(G) ⊇ a u ga</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">a</span><span class="o">),</span> <span class="n">tauto</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">left_coset</span> <span class="n">g</span> <span class="n">a</span><span class="o">),</span>
  <span class="o">{</span>
      <span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_union</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
      <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
      <span class="n">tauto</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="n">suffices</span> <span class="n">x_is_twotors</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span> <span class="k">by</span> <span class="n">tauto</span><span class="o">,</span>
  <span class="n">clear</span> <span class="n">hx</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span> <span class="k">by</span> <span class="n">tauto</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mem_left_coset_iff</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">H2</span>  <span class="o">(</span><span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="n">H</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H3</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="o">:=</span> <span class="n">eq_inv_of_mul_eq_one</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="k">by</span> <span class="k">calc</span>
  <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h₁</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">]</span>
  <span class="bp">...</span>   <span class="bp">=</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">H3</span>
  <span class="bp">...</span>   <span class="bp">=</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">mul_right_comm</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="n">x</span>
  <span class="bp">...</span>   <span class="bp">=</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">*</span> <span class="o">(</span><span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">mul_assoc</span> <span class="o">(</span><span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="n">x</span>
  <span class="bp">...</span>   <span class="bp">=</span> <span class="mi">1</span> <span class="o">:</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">H2</span><span class="o">,</span>
<span class="kn">end</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">Suppose a ≤ G[2], and g ∉ a.</span>
<span class="cm">Then if x ∈ G[2] and x ∉ g l* a,</span>
<span class="cm">then g ∉ ⟨ x, a ⟩.</span>
<span class="cm">--/</span>
<span class="kn">lemma</span> <span class="n">g_notin_xua</span> <span class="o">{</span><span class="n">x</span> <span class="n">g</span><span class="o">:</span> <span class="n">G</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">g</span> <span class="err">∉</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hgx</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">left_coset</span> <span class="n">g</span> <span class="err">↑</span><span class="n">a</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">g</span> <span class="err">∉</span> <span class="n">insert_twotors_to_twotors</span> <span class="n">hx</span> <span class="n">ha</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">by_contradiction</span> <span class="n">cont</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">cont</span><span class="o">,</span>
  <span class="k">by</span> <span class="n">contradiction</span><span class="o">,</span>
  <span class="o">{</span>
      <span class="n">rw</span> <span class="n">mem_left_coset_iff</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
      <span class="n">suffices</span> <span class="o">:</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span> <span class="err">∈</span> <span class="err">↑</span><span class="n">a</span><span class="o">,</span> <span class="k">by</span> <span class="n">solve_by_elim</span><span class="o">,</span>
      <span class="n">norm_cast</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">subgroup</span><span class="bp">.</span><span class="n">inv_mem_iff</span><span class="o">,</span> <span class="n">mul_inv</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="n">inv_inv</span><span class="o">],</span>
      <span class="n">exact</span> <span class="n">cont</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kn">end</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">If x ∈ G[2] and a ≤ G[2], then ⟨ x, a ⟩ ≤ G[2].</span>
<span class="cm">--/</span>
<span class="kn">lemma</span> <span class="n">xua_twotors</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">y</span> <span class="err">∈</span> <span class="o">(</span><span class="n">insert_twotors_to_twotors</span> <span class="n">hx</span> <span class="n">ha</span><span class="o">)</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">xua</span> <span class="o">:=</span> <span class="n">insert_twotors_to_twotors</span> <span class="n">hx</span> <span class="n">ha</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hxinxua</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">xua</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">y</span> <span class="err">∈</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">∨</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">left_coset</span> <span class="n">x</span> <span class="n">a</span><span class="o">),</span> <span class="k">by</span> <span class="n">apply</span> <span class="n">subgroup</span><span class="bp">.</span><span class="n">mem_coe</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hxinxua</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">hy</span><span class="o">,</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">ha</span> <span class="n">y</span> <span class="o">(</span><span class="n">subgroup</span><span class="bp">.</span><span class="n">mem_coe</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hy</span><span class="o">),</span>
  <span class="o">{</span>
    <span class="n">rw</span> <span class="n">mem_left_coset_iff</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">HH</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">w</span> <span class="err">∈</span> <span class="n">a</span><span class="o">,</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">w</span><span class="o">,</span> <span class="k">by</span> <span class="n">tauto</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">HH</span> <span class="k">with</span> <span class="bp">⟨</span> <span class="n">w</span> <span class="o">,</span><span class="bp">⟨</span> <span class="n">hw1</span><span class="o">,</span> <span class="n">hw2</span><span class="bp">⟩⟩</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hhy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">w</span> <span class="o">:=</span> <span class="n">eq_mul_of_inv_mul_eq</span> <span class="n">hw2</span><span class="o">,</span>
    <span class="k">calc</span>
    <span class="n">y</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">w</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">w</span><span class="o">):</span> <span class="n">congr</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">has_mul</span><span class="bp">.</span><span class="n">mul</span> <span class="n">hhy</span><span class="o">)</span> <span class="n">hhy</span>
    <span class="bp">...</span>   <span class="bp">=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">w</span> <span class="bp">*</span> <span class="n">w</span><span class="o">):</span> <span class="n">mul_mul_mul_comm</span> <span class="n">x</span> <span class="n">w</span> <span class="n">x</span> <span class="n">w</span>
    <span class="bp">...</span>   <span class="bp">=</span> <span class="n">w</span> <span class="bp">*</span> <span class="n">w</span> <span class="o">:</span> <span class="n">mul_left_eq_self</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">hx</span>
    <span class="bp">...</span>   <span class="bp">=</span> <span class="mi">1</span>      <span class="o">:</span> <span class="n">ha</span> <span class="n">w</span> <span class="n">hw1</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kn">end</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">G[2] ≤ ⟨g, a⟩</span>
<span class="cm">--/</span>
<span class="kn">lemma</span> <span class="n">twotorsion_containedin_a_union_ga</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">}</span>
      <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
      <span class="o">(</span><span class="n">hga</span> <span class="o">:</span> <span class="n">g</span> <span class="err">∉</span> <span class="n">a</span><span class="o">)</span>
      <span class="o">(</span><span class="n">hmax</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a&#39;</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">),</span> <span class="n">g</span> <span class="err">∉</span> <span class="n">a&#39;</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">a&#39;</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">a&#39;</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a&#39;</span><span class="o">)</span> <span class="o">:</span>
      <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">}</span> <span class="err">⊆</span> <span class="err">↑</span><span class="n">a</span> <span class="err">∪</span> <span class="n">left_coset</span> <span class="n">g</span> <span class="err">↑</span><span class="n">a</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="c1">-- Prove that twotorsion(G) ⊆ a u ga</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">by_contradiction</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_union</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">xua</span> <span class="o">:=</span> <span class="n">insert_twotors_to_twotors</span> <span class="n">hx</span> <span class="n">h₂</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hxinxua</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">xua</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">y</span> <span class="err">∈</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">∨</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">left_coset</span> <span class="n">x</span> <span class="n">a</span><span class="o">),</span> <span class="k">by</span> <span class="n">apply</span> <span class="n">subgroup</span><span class="bp">.</span><span class="n">mem_coe</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">g_notin_xua</span> <span class="o">:</span> <span class="n">g</span> <span class="err">∉</span> <span class="n">xua</span><span class="o">,</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">g_notin_xua</span> <span class="n">hga</span> <span class="n">hx</span> <span class="n">h₂</span> <span class="n">h</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h_twotors</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">xua</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">),</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">xua_twotors</span> <span class="n">hx</span> <span class="n">h₂</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">a_eq_xua</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">xua</span> <span class="o">:=</span> <span class="n">hmax</span> <span class="n">xua</span> <span class="n">g_notin_xua</span> <span class="n">h_twotors</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">hy</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">x_in_a</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">a</span><span class="o">,</span>
  <span class="o">{</span>
      <span class="n">norm_cast</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">a_eq_xua</span><span class="o">,</span> <span class="n">hxinxua</span><span class="o">,</span> <span class="n">mem_left_coset_iff</span><span class="o">],</span>
      <span class="n">right</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subgroup</span><span class="bp">.</span><span class="n">mem_coe</span><span class="o">,</span> <span class="n">mul_left_inv</span><span class="o">],</span>
      <span class="n">exact</span> <span class="n">subgroup</span><span class="bp">.</span><span class="n">one_mem</span> <span class="n">a</span>
  <span class="o">},</span>
  <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hl</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span>
  <span class="n">trivial</span><span class="o">,</span>
<span class="kn">end</span>

<span class="c1">-- given G two torsion and 1 ≠ g ∈ G, there is H &lt; G of index 2 with g ∉ H</span>
<span class="kn">lemma</span> <span class="n">element_avoidance</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">}</span>  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">):</span>
 <span class="bp">∃</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">,</span>
  <span class="o">(</span><span class="n">g</span> <span class="err">∉</span> <span class="n">H</span> <span class="bp">∧</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">H</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">∧</span>
  <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">}</span> <span class="bp">=</span> <span class="n">H</span> <span class="err">∪</span> <span class="o">(</span><span class="n">left_coset</span> <span class="n">g</span> <span class="n">H</span><span class="o">))</span>
  <span class="o">:=</span>
<span class="k">begin</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">g</span> <span class="err">∉</span> <span class="n">X</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">x</span><span class="bp">*</span><span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)},</span>
    <span class="k">have</span> <span class="n">sfin</span> <span class="o">:</span> <span class="n">s</span><span class="bp">.</span><span class="n">finite</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite</span><span class="bp">.</span><span class="n">of_fintype</span> <span class="bp">_</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">snonempty</span> <span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">nonempty</span> <span class="n">s</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">use</span> <span class="err">⊥</span><span class="o">,</span>
        <span class="n">split</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">h₁</span><span class="o">,</span>
        <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">subgroup</span><span class="bp">.</span><span class="n">mem_bot</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">hx</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">mul_one</span> <span class="mi">1</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="k">let</span> <span class="n">existsH</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite</span><span class="bp">.</span><span class="n">exists_maximal_wrt</span> <span class="n">id</span> <span class="n">s</span> <span class="n">sfin</span> <span class="n">snonempty</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">and_imp</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">id</span><span class="bp">.</span><span class="n">def</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_set_of_eq</span><span class="o">]</span> <span class="n">at</span> <span class="n">existsH</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">existsH</span> <span class="k">with</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">repeat</span> <span class="o">{</span><span class="n">split</span><span class="o">},</span>
    <span class="n">exact</span> <span class="n">ha</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">ha</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
    <span class="c1">-- We have defined a as the maximal subgroup of G satisfying</span>
    <span class="c1">-- 1) g ∉ a</span>
    <span class="c1">-- 2) ∀ x ∈ a, x*x = 1</span>
    <span class="c1">-- Now we must show that a ∪ ga = twotorsion(G)</span>
    <span class="n">apply</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">antisymm</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">twotorsion_containedin_a_union_ga</span> <span class="n">h₂</span> <span class="n">ha</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">2</span> <span class="n">ha</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">1</span> <span class="n">ha</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">twotorsion_contains_a_and_ga</span> <span class="n">h₂</span> <span class="n">ha</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="205378082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205378082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205378082">(Jul 29 2020 at 16:13)</a>:</h4>
<p>And I still don't see the need to change the topic title... Here's another place that I've got stuck:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">two_torsion_subgroup</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)[</span><span class="n">comm_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">z</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">},</span>
  <span class="n">one_mem&#39;</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">mul_mem&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">),</span>
  <span class="k">begin</span>
    <span class="n">tidy</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">mul_mul_mul_comm</span> <span class="n">a</span> <span class="n">b</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">],</span>
    <span class="n">refine</span> <span class="n">mul_one</span> <span class="mi">1</span><span class="o">,</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">inv_mem&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">),</span> <span class="k">by</span> <span class="o">{</span><span class="n">tidy</span><span class="o">,</span> <span class="n">rw</span> <span class="n">mul_inv_eq_one</span><span class="o">,</span> <span class="n">refine</span> <span class="n">inv_eq_of_mul_eq_one</span> <span class="n">ha</span><span class="o">}</span>
<span class="o">}</span>

<span class="kn">lemma</span> <span class="n">two_prods_are_equal</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]:</span>
<span class="o">((</span><span class="err">∏</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">two_torsion_subgroup</span> <span class="n">G</span><span class="o">)),</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="err">∏</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="k">in</span> <span class="o">(</span><span class="n">two_torsion_subgroup</span> <span class="n">G</span><span class="o">)</span><span class="bp">.</span><span class="n">carrier</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">g</span> <span class="o">):=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>


<p>I don't manage to prove the lemma, which to me is just two different ways of writing in Lean the same exact product. I also don't see why I can't apply finset.prod_congr...</p>
<p>Thanks Lean community!</p>



<a name="205380257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205380257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205380257">(Jul 29 2020 at 16:30)</a>:</h4>
<p>This is exactly the sort of thing which makes lean hard for mathematicians to use</p>



<a name="205380552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205380552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205380552">(Jul 29 2020 at 16:32)</a>:</h4>
<p>The official answer is probably that this is <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> and you should decide once and for all how you want to talk about this subset instead of switching between different ways of talking about it</p>



<a name="205380734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205380734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205380734">(Jul 29 2020 at 16:34)</a>:</h4>
<p>It wouldn't surprise me if you ended up with two different witnesses to finiteness of the set you're taking a product over and then nothing will work anyway and you'll have to get the forensic experts in</p>



<a name="205380816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205380816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205380816">(Jul 29 2020 at 16:35)</a>:</h4>
<p>Did you try library_search?</p>



<a name="205380908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205380908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205380908">(Jul 29 2020 at 16:36)</a>:</h4>
<p><span class="user-mention" data-user-id="254058">@Marc Masdeu</span> Sorry for the pain...</p>



<a name="205381018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205381018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205381018">(Jul 29 2020 at 16:36)</a>:</h4>
<p>The reason that <code>finset.prod_congr</code> doesn't work is because it assumes you are taking products indexed by the same type. But in your case the LHS is a subtype of the type on the right.</p>



<a name="205381074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205381074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205381074">(Jul 29 2020 at 16:37)</a>:</h4>
<p>So you probably need to <code>rw</code> the LHS using something like <code>finset.prod_subtype</code>.</p>



<a name="205381142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205381142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205381142">(Jul 29 2020 at 16:37)</a>:</h4>
<p>PS unrelated -- <code>tidy</code> is only supposed to be used at the end of a proof. You might want to replace it with <code>tidy?</code> and then with the output of what it says it's doing. It might not be doing much at all.</p>



<a name="205381145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205381145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205381145">(Jul 29 2020 at 16:37)</a>:</h4>
<p>I agree that we shouldn't need to experience this pain. But I don't know how to solve it.</p>



<a name="205381212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205381212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205381212">(Jul 29 2020 at 16:38)</a>:</h4>
<p>Maybe better simp-lemmas?</p>



<a name="205382745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205382745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205382745">(Jul 29 2020 at 16:50)</a>:</h4>
<p>Delete fintype ;-)</p>



<a name="205382757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205382757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205382757">(Jul 29 2020 at 16:50)</a>:</h4>
<p>Or at least don't tell mathematicians about it</p>



<a name="205382949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205382949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205382949">(Jul 29 2020 at 16:52)</a>:</h4>
<p>I don't know how to solve this. We offer several ways of doing a product over a finite set and this is problematic</p>



<a name="205383035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205383035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205383035">(Jul 29 2020 at 16:53)</a>:</h4>
<p>The problem is even more basic than this, we offer three ways to take the intersection of a bunch of sets</p>



<a name="205383180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205383180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205383180">(Jul 29 2020 at 16:54)</a>:</h4>
<p>Oh well. I understand that if I choose different ways of writing the same, then I'll have to deal with coercions and the like. I'm very surprised though that this is so hard!</p>
<p>I got into this because I am trying to prove some lemmas about products of elements of a finite abelian multiplicative group G. Which way should I be using? I'm happy to redo parts of what I already have.</p>



<a name="205383487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205383487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205383487">(Jul 29 2020 at 16:57)</a>:</h4>
<p>This should be generalized to a lemma about prod</p>



<a name="205383688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205383688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205383688">(Jul 29 2020 at 16:58)</a>:</h4>
<p>The issue of course Marc is that if you only prove the result about one of them, then sooner or later someone will need it for the other variant :-)</p>



<a name="205383698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205383698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205383698">(Jul 29 2020 at 16:58)</a>:</h4>
<p>I think something like <code>prod (g : S), f g = prod g in T, f g</code> if <code>S = T</code></p>



<a name="205383753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205383753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205383753">(Jul 29 2020 at 16:59)</a>:</h4>
<p>where <code>S = T</code> needs some coe or to_finset or something</p>



<a name="205383869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205383869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205383869">(Jul 29 2020 at 17:00)</a>:</h4>
<p>Here's my real problem (to avoid xy): I have proven this lemma</p>
<div class="codehilite"><pre><span></span><code>(∏ g : G, g) = (∏ g : two_torsion_subgroup G, g)
</code></pre></div>


<p>and this one:</p>
<div class="codehilite"><pre><span></span><code> ∃ (H : subgroup G) ,
  (g ∉ H ∧
  (∀ (x : G), x ∈ H → x * x = 1) ∧
  {x : G | x * x = 1} = H ∪ (left_coset g H))
</code></pre></div>


<p>The one that I'd like to prove next is:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">prod_identity</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">):</span>
 <span class="o">(</span><span class="err">∏</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span><span class="bp">^</span><span class="o">((</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">G</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
</code></pre></div>


<p>and along the way I thought that I would easily be able to prove</p>
<div class="codehilite"><pre><span></span><code><span class="o">((</span><span class="err">∏</span> <span class="n">x</span> <span class="o">:</span> <span class="n">two_torsion_subgroup</span> <span class="n">G</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="bp">=</span> <span class="o">((</span><span class="err">∏</span> <span class="n">x</span> <span class="o">:</span> <span class="n">H</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="err">∏</span> <span class="n">x</span> <span class="o">:</span> <span class="n">left_coset</span> <span class="n">g</span> <span class="err">↑</span><span class="n">H</span><span class="o">,</span> <span class="n">x</span> <span class="o">)</span>
</code></pre></div>


<p>for the subgroup H given by the previous lemma. I have already proven that the two sets (H and g *l H) are disjoint, so it seemed easy...</p>



<a name="205384082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205384082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205384082">(Jul 29 2020 at 17:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Frustration.20with.20finset/near/205383698">said</a>:</p>
<blockquote>
<p>I think something like <code>prod (g : S), f g = prod g in T, f g</code> if <code>S = T</code></p>
</blockquote>
<p>I'll try to see if I can write a proof for this...</p>



<a name="205384573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205384573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205384573">(Jul 29 2020 at 17:04)</a>:</h4>
<p>That looks messy and unmathematical (but important)</p>



<a name="205384829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205384829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205384829">(Jul 29 2020 at 17:06)</a>:</h4>
<p>You look like you're on the right track but now things are going to get a bit nasty.</p>



<a name="205385010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205385010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205385010">(Jul 29 2020 at 17:08)</a>:</h4>
<p>I've never used these finite products before but it looks to me like you're taking a product over a finite type and I think you'd be much better off taking a product over a finite subset of a type</p>



<a name="205385112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205385112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205385112">(Jul 29 2020 at 17:09)</a>:</h4>
<p>Because then the proof that a product over H union gH equals the product over H times the product over gH will be much easier</p>



<a name="205385264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205385264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205385264">(Jul 29 2020 at 17:10)</a>:</h4>
<p>Well for me the most confusing thing is that I deal at the same time with a group and a subgroup of it, and then the product may run over subsets of either. I don't know whether I should first coerce everything as elements of the big group, and then take the corresponding set (finset?) or take the set corresponding to the element of the subgroup.</p>



<a name="205385680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205385680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205385680">(Jul 29 2020 at 17:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Frustration.20with.20finset/near/205385010">said</a>:</p>
<blockquote>
<p>I've never used these finite products before but it looks to me like you're taking a product over a finite type and I think you'd be much better off taking a product over a finite subset of a type</p>
</blockquote>
<p>Yup, I suggest trying to avoid the subtype</p>



<a name="205385692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205385692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205385692">(Jul 29 2020 at 17:14)</a>:</h4>
<p>My gut feeling is that you'd be better off always working with subsets of the big group</p>



<a name="205385703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205385703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205385703">(Jul 29 2020 at 17:14)</a>:</h4>
<p>(Sometimes they are useful... but most of the time I would avoid them.)</p>



<a name="205386902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205386902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205386902">(Jul 29 2020 at 17:25)</a>:</h4>
<p>I'm affraid this is not what <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> was asking for, right?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">two_products</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">t</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span>
<span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">t</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="err">∏</span> <span class="n">g</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="err">∏</span> <span class="n">g</span> <span class="k">in</span> <span class="n">t</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="o">:=</span> <span class="n">congr_fun</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">finset</span><span class="bp">.</span><span class="n">prod</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span>
</code></pre></div>



<a name="205387019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205387019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205387019">(Jul 29 2020 at 17:26)</a>:</h4>
<p>You want <code>t</code> to be a finset</p>



<a name="205387068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205387068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205387068">(Jul 29 2020 at 17:26)</a>:</h4>
<p>and <code>h</code> could be for example <code>\forall x, x \in s &lt;-&gt; x \in t</code></p>



<a name="205387115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205387115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205387115">(Jul 29 2020 at 17:27)</a>:</h4>
<p>and <code>s</code> should be a <code>set</code>, with <code>g : s</code> on the left</p>



<a name="205387147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205387147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205387147">(Jul 29 2020 at 17:27)</a>:</h4>
<p>That's just <code>prod_congr</code>, right?</p>



<a name="205387174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205387174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205387174">(Jul 29 2020 at 17:27)</a>:</h4>
<p>if you have <code>prod g in s</code> on both sides it's just <code>congr</code></p>



<a name="205387210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205387210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205387210">(Jul 29 2020 at 17:27)</a>:</h4>
<p>Sure, but there is a lemma <code>prod_congr</code></p>



<a name="205387216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205387216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205387216">(Jul 29 2020 at 17:27)</a>:</h4>
<p>the point here is that it's two different kinds of summations on each side</p>



<a name="205387283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205387283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205387283">(Jul 29 2020 at 17:28)</a>:</h4>
<p><code>g : s</code> on the left and <code>g in t</code> on the right</p>



<a name="205387291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205387291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205387291">(Jul 29 2020 at 17:28)</a>:</h4>
<p>Oh I see. Yes, it's also confusing because the symbol is the same...If s is a finset then one can abbreviate g in s with g : s, according to what's written in big_operators.lean</p>



<a name="205387341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205387341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205387341">(Jul 29 2020 at 17:28)</a>:</h4>
<p><code>prod g : s</code> is really <code>prod (g:s) in univ</code></p>



<a name="205387446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205387446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205387446">(Jul 29 2020 at 17:29)</a>:</h4>
<p><code>prod g in s</code> is therefore not the same (syntactically) as <code>prod g : s</code> even if <code>s</code> is a finset (the latter being <code>prod g in (univ : finset s)</code>)</p>



<a name="205387563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205387563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205387563">(Jul 29 2020 at 17:30)</a>:</h4>
<p>but there should be a theorem proving they are equal</p>



<a name="205387566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205387566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205387566">(Jul 29 2020 at 17:30)</a>:</h4>
<p>OK now trying to prove this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">two_products</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">s</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">t</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span>
 <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="err">∏</span> <span class="n">g</span> <span class="o">:</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="err">∏</span> <span class="n">g</span> <span class="k">in</span> <span class="n">t</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span>
</code></pre></div>



<a name="205387595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205387595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205387595">(Jul 29 2020 at 17:30)</a>:</h4>
<p>still drop the <code>to_finset</code></p>



<a name="205387633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205387633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205387633">(Jul 29 2020 at 17:31)</a>:</h4>
<p><code>t : finset A</code></p>



<a name="205387681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205387681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205387681">(Jul 29 2020 at 17:31)</a>:</h4>
<p>and no <code>fintype t</code> assumption</p>



<a name="205387813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205387813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205387813">(Jul 29 2020 at 17:32)</a>:</h4>
<p><code>rw ← finset.prod_subtype, apply finset.prod_congr</code> should get you moving again</p>



<a name="205388180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205388180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205388180">(Jul 29 2020 at 17:35)</a>:</h4>
<p>Not for me, <span class="user-mention" data-user-id="112680">@Johan Commelin</span> ... I am trying this, as Mario suggested:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">two_products</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">s</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span>
 <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="err">∏</span> <span class="n">g</span> <span class="o">:</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="err">∏</span> <span class="n">g</span> <span class="k">in</span> <span class="n">t</span><span class="o">,</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>


<p>and the first rw gives me 4 goals...</p>



<a name="205388500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205388500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205388500">(Jul 29 2020 at 17:37)</a>:</h4>
<p>So now we have to start hunting through the finset and big_operator API to prove this</p>



<a name="205388732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205388732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205388732">(Jul 29 2020 at 17:38)</a>:</h4>
<p>It helps to understand what the theorem actually says, without all the nice notations. The left product is<br>
<code>(finset.univ {x // x \in s}).prod (\lam x, f x.1)</code>, and the right is <code>t.prod (\lam x : A, f x)</code></p>



<a name="205388935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205388935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205388935">(Jul 29 2020 at 17:40)</a>:</h4>
<p>so you need something that talks about applying an injection (in this case <code>x.1</code>) to change the index type</p>



<a name="205389478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205389478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205389478">(Jul 29 2020 at 17:44)</a>:</h4>
<p>I'm surprised this or something like it hasn't been proved yet. Anyway the general theorem about index changes is <code>prod_bij</code></p>



<a name="205389560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205389560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205389560">(Jul 29 2020 at 17:45)</a>:</h4>
<p>Do mem_to_finset or coe_to_finset help? I don't know if you are trying a socratic dialogue here...</p>



<a name="205389662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205389662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205389662">(Jul 29 2020 at 17:46)</a>:</h4>
<p>You should start the proof by applying <code>prod_bij</code>, which has a ton of assumptions that you can fill in</p>



<a name="205389751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205389751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205389751">(Jul 29 2020 at 17:47)</a>:</h4>
<p>OK, I'll try.</p>



<a name="205390009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205390009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205390009">(Jul 29 2020 at 17:48)</a>:</h4>
<p>You won't need <code>mem_to_finset</code> and such because <code>to_finset</code> doesn't appear in the statement anymore</p>



<a name="205390456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205390456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205390456">(Jul 29 2020 at 17:52)</a>:</h4>
<p>When I apply prod_bij, some of the goals contain a m_1. This means that it couldn't figure out what I really was applying, right?</p>



<a name="205390493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205390493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205390493">(Jul 29 2020 at 17:53)</a>:</h4>
<p>This is the first goal:</p>
<div class="codehilite"><pre><span></span><code><span class="err">⊢</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="err">↥</span><span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="o">),</span> <span class="err">?</span><span class="n">m_1</span> <span class="n">a</span> <span class="n">ha</span> <span class="err">∈</span> <span class="n">t</span>
</code></pre></div>



<a name="205390661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205390661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205390661">(Jul 29 2020 at 17:54)</a>:</h4>
<p>If you use <code>refine prod_bij _ _ _ _ _ _ _,</code> you can give the functions in the first few underscores, so that you don't get any <code>?m_1 a ha</code> business</p>



<a name="205391009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205391009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205391009">(Jul 29 2020 at 17:57)</a>:</h4>
<p>I think the function is <code>\lam x _, x.1</code></p>



<a name="205393157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205393157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205393157">(Jul 29 2020 at 18:12)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">two_products</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">s</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span>
 <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="err">∏</span> <span class="n">g</span> <span class="o">:</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="err">∏</span> <span class="n">g</span> <span class="k">in</span> <span class="n">t</span><span class="o">,</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">refine</span> <span class="n">finset</span><span class="bp">.</span><span class="n">prod_bij</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="bp">_</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
<span class="o">{</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">h</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h</span><span class="bp">.</span><span class="n">mp</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">mem</span> <span class="n">a</span><span class="o">,</span>
<span class="o">},</span>
<span class="o">{</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="o">},</span>
<span class="o">{</span>
  <span class="n">intros</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span><span class="o">,</span>
<span class="o">},</span>
<span class="o">{</span>
  <span class="n">intros</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">h</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hb</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_univ</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>
<span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="205394050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205394050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205394050">(Jul 29 2020 at 18:19)</a>:</h4>
<p>This all sounds like issues that were obviously solved in mathcomp before formalizing the odd order theorem, but this observation is taboo here.</p>



<a name="205394282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205394282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205394282">(Jul 29 2020 at 18:21)</a>:</h4>
<p>This is a hole in the library. Of course the proof isn't nice</p>



<a name="205394313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205394313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205394313">(Jul 29 2020 at 18:21)</a>:</h4>
<p>the correct proof is to cite this theorem</p>



<a name="205394329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205394329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205394329">(Jul 29 2020 at 18:21)</a>:</h4>
<p>but the theorem didn't exist</p>



<a name="205394489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205394489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205394489">(Jul 29 2020 at 18:22)</a>:</h4>
<p>Is anyone working in improving the user experience with sets/finsets/fintypes and the like? It is basic enough that it can cause problems in many places...</p>



<a name="205394558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205394558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205394558">(Jul 29 2020 at 18:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/Frustration.20with.20finset/near/205394050">said</a>:</p>
<blockquote>
<p>This all sounds like issues that were obviously solved in mathcomp before formalizing the odd order theorem, but this observation is taboo here.</p>
</blockquote>
<p>Please elaborate, the story sounds potentially interesting!</p>



<a name="205394976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205394976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205394976">(Jul 29 2020 at 18:26)</a>:</h4>
<p>The best way to solve these problems is to have a really complete library of basic lemmas</p>



<a name="205395063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205395063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205395063">(Jul 29 2020 at 18:27)</a>:</h4>
<p>finset itself has a fairly complete API, and big_operators do too, for the most part. Like I said I'm surprised this was missed</p>



<a name="205395215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205395215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205395215">(Jul 29 2020 at 18:28)</a>:</h4>
<p>I see that <code>algebra.big_operators.basic</code> doesn't import <code>fintype</code> so it's impossible to state this theorem in that file. So maybe it is in another file and I missed it</p>



<a name="205395267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205395267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205395267">(Jul 29 2020 at 18:28)</a>:</h4>
<p>Marc, the story is: some very smart people spend six years working on how to do finite groups in a proof assistant very close to Lean. They wrote several papers about the clever tricks they found the most useful. Sentences like "Well for me the most confusing thing is that I deal at the same time with a group and a subgroup of it," were at the heart of those papers. So we ignore them.</p>



<a name="205395275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205395275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205395275">(Jul 29 2020 at 18:28)</a>:</h4>
<p>I didn't watch closely when <code>algebra.big_operators</code> got split into pieces</p>



<a name="205395629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205395629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205395629">(Jul 29 2020 at 18:31)</a>:</h4>
<p>eh, found it</p>



<a name="205395641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205395641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205395641">(Jul 29 2020 at 18:31)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/finset.prod_subtype/src">src#finset.prod_subtype</a></p>



<a name="205395752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205395752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205395752">(Jul 29 2020 at 18:32)</a>:</h4>
<p>In the same way, there is a huge subgroup refactor going on. Those Coq people told us repeatedly that they found a very simple criterion to see whether we get this right: painlessly state and prove the <a href="https://groupprops.subwiki.org/wiki/Third_isomorphism_theorem">third isomorphism theorem</a>. So we invest a lot of time in the refactor and never discuss how this test will go once the refactor will be done (I asked the question several time and never got any answer).</p>



<a name="205396982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205396982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205396982">(Jul 29 2020 at 18:41)</a>:</h4>
<p>Do you think that the 3rd iso theorem will go bad after this, then??</p>



<a name="205397363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205397363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205397363">(Jul 29 2020 at 18:44)</a>:</h4>
<p>Patrick, my impression in the odd order work is that they solve this by never talking about the cardinality of a type. Every group is a subgroup of a large ambient group and they only have one notion of cardinality, that of a subset of a group.</p>
<p>As for refactoring subgroups, I think that the third isomorphism theorem should be easy with bundled subgroups but I can't check until Friday. We have a really nice <code>map</code> and <code>comap</code> for group homs. We have N and K normal in G and N a subset of K, we have a construction making a subgroup a group. I don't envisage any problems</p>



<a name="205401917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205401917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205401917">(Jul 29 2020 at 19:23)</a>:</h4>
<p>Here's the statement</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">quotient_group</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">mul_add</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">α</span><span class="o">]</span>

<span class="n">def</span> <span class="n">image_normal</span> <span class="o">{</span><span class="n">G</span> <span class="n">H</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">H</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">H</span><span class="o">)</span> <span class="o">[</span><span class="n">is_group_hom</span> <span class="n">f</span><span class="o">]</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">surjective</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">normal_subgroup</span> <span class="n">s</span><span class="o">]</span> <span class="o">:</span> <span class="n">normal_subgroup</span> <span class="o">(</span><span class="n">f</span> <span class="err">&#39;&#39;</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="k">begin</span>
  <span class="n">rintro</span> <span class="bp">_</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="n">b</span><span class="o">,</span>
  <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">hf</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">refine</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">normal_subgroup</span><span class="bp">.</span><span class="n">normal</span> <span class="n">a</span> <span class="n">h</span> <span class="n">b</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">is_mul_hom</span><span class="bp">.</span><span class="n">map_mul</span> <span class="n">f</span><span class="o">,</span> <span class="n">is_mul_hom</span><span class="bp">.</span><span class="n">map_mul</span> <span class="n">f</span><span class="o">,</span> <span class="n">is_group_hom</span><span class="bp">.</span><span class="n">map_inv</span> <span class="n">f</span><span class="o">],</span>
<span class="kn">end</span><span class="bp">⟩</span>

<span class="kn">structure</span> <span class="n">normal_subgroup&#39;</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">is_normal</span> <span class="o">:</span> <span class="n">normal_subgroup</span> <span class="n">carrier</span><span class="o">]</span>

<span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">normal_subgroup&#39;</span><span class="bp">.</span><span class="n">is_normal</span>

<span class="n">def</span> <span class="n">to_subgroup</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">normal_subgroup&#39;</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">subgroup</span><span class="bp">.</span><span class="n">of</span> <span class="n">s</span><span class="bp">.</span><span class="n">carrier</span>

<span class="kn">instance</span> <span class="n">normal_subgroup&#39;</span><span class="bp">.</span><span class="n">coe_subgroup</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">normal_subgroup&#39;</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">to_subgroup</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="n">normal_subgroup&#39;</span><span class="bp">.</span><span class="n">coe_normal_subgroup</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">normal_subgroup&#39;</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">normal_subgroup</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">normal_subgroup&#39;</span><span class="bp">.</span><span class="n">is_normal</span> <span class="bp">_</span>

<span class="kn">instance</span> <span class="n">normal_subgroup&#39;</span><span class="bp">.</span><span class="n">coe_coe_normal_subgroup</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">normal_subgroup&#39;</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">normal_subgroup</span> <span class="o">((</span><span class="n">s</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">normal_subgroup&#39;</span><span class="bp">.</span><span class="n">is_normal</span> <span class="bp">_</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">preorder</span> <span class="o">(</span><span class="n">normal_subgroup&#39;</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">preorder</span><span class="bp">.</span><span class="n">lift</span> <span class="n">normal_subgroup&#39;</span><span class="bp">.</span><span class="n">carrier</span>

<span class="n">def</span> <span class="n">normal_subgroup&#39;</span><span class="bp">.</span><span class="n">image</span> <span class="o">{</span><span class="n">G</span> <span class="n">H</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">H</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">surjective</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">normal_subgroup&#39;</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">normal_subgroup&#39;</span> <span class="n">H</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">image_normal</span> <span class="n">f</span> <span class="n">hf</span> <span class="n">s</span><span class="bp">;</span> <span class="n">exact</span> <span class="bp">⟨</span><span class="n">f</span> <span class="err">&#39;&#39;</span> <span class="n">s</span><span class="bp">⟩</span>

<span class="kn">namespace</span> <span class="n">quotient_group</span>

<span class="n">def</span> <span class="n">quotient&#39;</span> <span class="o">[</span><span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">normal_subgroup&#39;</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="n">quotient</span> <span class="o">((</span><span class="n">s</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>

<span class="kn">variables</span> <span class="o">[</span><span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">normal_subgroup&#39;</span> <span class="n">α</span><span class="o">}</span>

<span class="kn">instance</span> <span class="n">quotient_group</span><span class="bp">.</span><span class="n">group&#39;</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">normal_subgroup&#39;</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">group</span> <span class="o">(</span><span class="n">quotient&#39;</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">quotient_group</span><span class="bp">.</span><span class="n">group</span> <span class="n">s</span>

<span class="n">def</span> <span class="n">mk&#39;</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">quotient&#39;</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">mk&#39;</span>

<span class="kn">instance</span> <span class="n">mk&#39;</span><span class="bp">.</span><span class="n">is_group_hom</span> <span class="o">:</span> <span class="n">is_group_hom</span> <span class="o">(</span><span class="n">mk&#39;</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">quotient&#39;</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="n">quotient_group</span><span class="bp">.</span><span class="n">is_group_hom</span> <span class="bp">_</span>

<span class="n">def</span> <span class="n">mk_hom</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→*</span> <span class="n">quotient&#39;</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">monoid_hom</span><span class="bp">.</span><span class="n">of</span> <span class="n">mk&#39;</span>

<span class="kn">variable</span> <span class="o">(</span><span class="n">s</span><span class="o">)</span>
<span class="n">def</span> <span class="n">below</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">normal_subgroup&#39;</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">normal_subgroup&#39;</span> <span class="o">(</span><span class="n">quotient&#39;</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">t</span><span class="bp">.</span><span class="n">image</span> <span class="n">mk_hom</span> <span class="err">$</span> <span class="k">by</span> <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">i</span><span class="bp">⟩;</span> <span class="n">exact</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>

<span class="kn">end</span> <span class="n">quotient_group</span>

<span class="kn">theorem</span> <span class="n">third_isomorphism_thm</span> <span class="o">{</span><span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">{</span><span class="n">H</span> <span class="n">K</span> <span class="o">:</span> <span class="n">normal_subgroup&#39;</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">≤</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">quotient_group</span><span class="bp">.</span><span class="n">quotient&#39;</span> <span class="o">(</span><span class="n">quotient_group</span><span class="bp">.</span><span class="n">below</span> <span class="n">H</span> <span class="n">K</span><span class="o">)</span> <span class="err">≃</span><span class="bp">*</span> <span class="n">quotient_group</span><span class="bp">.</span><span class="n">quotient&#39;</span> <span class="n">H</span> <span class="o">:=</span>
<span class="n">sorry</span>
</code></pre></div>



<a name="205402063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205402063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205402063">(Jul 29 2020 at 19:25)</a>:</h4>
<p>the proof is easier if you have all the hom functions doing equalizer tricks</p>



<a name="205407597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205407597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205407597">(Jul 29 2020 at 20:11)</a>:</h4>
<p>is_group_hom is deprecated</p>



<a name="205408618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205408618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205408618">(Jul 29 2020 at 20:20)</a>:</h4>
<p>I know?</p>



<a name="205408671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205408671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205408671">(Jul 29 2020 at 20:20)</a>:</h4>
<p>For the purpose of simplifying the proof, I'm using the deprecated lemmas to prove the bundled ones. In a proper refactor you would rewrite the proofs</p>



<a name="205408787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205408787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205408787">(Jul 29 2020 at 20:22)</a>:</h4>
<p>The hard part here, as ever, is just setting up statements - ignore the proofs, which are all trivial anyway</p>



<a name="205408897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205408897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205408897">(Jul 29 2020 at 20:22)</a>:</h4>
<p>I only had to prove one theorem about <code>is_group_hom</code> which was missing from the library (<code>image_normal</code>)</p>



<a name="205409843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205409843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205409843">(Jul 29 2020 at 20:30)</a>:</h4>
<p>In the bundling subgroup refactor we still don't bundle normal subgroups. I don't know what I feel about this. In the group theory game we're going to bundle them</p>



<a name="205410068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205410068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205410068">(Jul 29 2020 at 20:32)</a>:</h4>
<p>I know, I wondered about this as well. I think there is a good argument for bundling them - <code>quotient</code> is naturally a function on it, and the whole family <code>ker</code>/<code>im</code>/<code>map</code>/<code>comap</code>/ complete lattice structure exists for them</p>



<a name="205410146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205410146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205410146">(Jul 29 2020 at 20:33)</a>:</h4>
<p>the downside is that now we have a more complicated coercion graph</p>



<a name="205463913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205463913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205463913">(Jul 30 2020 at 10:46)</a>:</h4>
<p>OK, back to finsets... Here's a puzzle which doesn't involve unions and the such:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">fintype_card_eq_finset_card&#39;</span> <span class="o">:</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">G</span> <span class="bp">=</span>
       <span class="n">finset</span><span class="bp">.</span><span class="n">card</span> <span class="o">(((</span><span class="err">⊤</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">):=</span>
<span class="k">begin</span>
    <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>



<a name="205464111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205464111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205464111">(Jul 30 2020 at 10:49)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">subgroup</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">lemma</span> <span class="n">fintype_card_eq_finset_card&#39;</span> <span class="o">:</span>
  <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">G</span> <span class="bp">=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card</span> <span class="o">(((</span><span class="err">⊤</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">):=</span>
<span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span><span class="o">,</span> <span class="n">congr</span><span class="o">,</span> <span class="n">rw</span> <span class="n">subgroup</span><span class="bp">.</span><span class="n">coe_top</span><span class="o">,</span> <span class="n">convert</span> <span class="n">set</span><span class="bp">.</span><span class="n">to_finset_univ</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="205464121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205464121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205464121">(Jul 30 2020 at 10:49)</a>:</h4>
<p>we need <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> 's <code>fincard</code></p>



<a name="205464594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205464594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205464594">(Jul 30 2020 at 10:55)</a>:</h4>
<p>Thanks for teaching me the <code>convert</code> tactic, <span class="user-mention" data-user-id="110064">@Kenny Lau</span> !</p>



<a name="205464600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205464600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205464600">(Jul 30 2020 at 10:55)</a>:</h4>
<p>cheers</p>



<a name="205465936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205465936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205465936">(Jul 30 2020 at 11:15)</a>:</h4>
<p>I don't know if I pushed it to the group theory game repo. If I didn't then it's inaccessible until Friday evening</p>



<a name="205596636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205596636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205596636">(Jul 31 2020 at 14:29)</a>:</h4>
<p>Thanks to <span class="user-mention" data-user-id="112680">@Johan Commelin</span>, <span class="user-mention" data-user-id="110064">@Kenny Lau</span> , <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> (and probably others that on Zulip that I am forgetting) I have managed to formalize (the proof of) a non-trivial group-theory statement:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">prod_identity_general</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
 <span class="o">(</span><span class="err">∏</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span><span class="bp">^</span><span class="o">(</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">two_torsion_subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span>
</code></pre></div>


<p>I'll try next to apply it to (Z/nZ)^*...</p>



<a name="205657358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Frustration%20with%20finset/near/205657358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Carl Friedrich Bolz-Tereick <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Frustration.20with.20finset.html#205657358">(Aug 01 2020 at 01:26)</a>:</h4>
<p>Awesome! Is your code online somewhere?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
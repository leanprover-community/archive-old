---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html">cumbersome typeclass in theorem statement</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="307341623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307341623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307341623">(Nov 01 2022 at 15:45)</a>:</h4>
<p>I am trying to prove a lemma of the following form.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.cover</span>
<span class="kn">import</span> <span class="n">ring_theory.simple_module</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">lattice</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="kd">lemma</span> <span class="n">covby_iff_simple_order_Icc</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">⋖</span> <span class="n">y</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">hxy</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span>
  <span class="n">letI</span> <span class="o">:=</span> <span class="n">Icc.bounded_order</span> <span class="n">hxy</span><span class="o">,</span> <span class="n">exact</span> <span class="n">is_simple_order</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">covby_iff_lt_and_eq_or_eq</span><span class="o">,</span>
  <span class="n">split</span><span class="bp">;</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">hxy</span><span class="o">,</span><span class="n">h</span><span class="o">⟩,</span> <span class="o">{</span>
    <span class="n">use</span> <span class="n">hxy.le</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">x'</span> <span class="o">:</span> <span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">le_refl</span> <span class="n">x</span><span class="o">,</span> <span class="n">hxy.le</span><span class="o">⟩⟩,</span>
    <span class="k">let</span> <span class="n">y'</span> <span class="o">:</span> <span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="o">⟨</span><span class="n">hxy.le</span><span class="o">,</span> <span class="n">le_refl</span> <span class="n">y</span><span class="o">⟩⟩,</span>
    <span class="n">letI</span> <span class="o">:=</span> <span class="n">Icc.bounded_order</span> <span class="n">hxy.le</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hx'</span> <span class="o">:</span> <span class="n">x'</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span> <span class="n">refl</span> <span class="n">x'</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hy'</span> <span class="o">:</span> <span class="n">y'</span> <span class="bp">=</span> <span class="bp">⊤</span> <span class="o">:=</span> <span class="n">refl</span> <span class="n">y'</span><span class="o">,</span>
    <span class="n">haveI</span> <span class="o">:</span> <span class="n">nontrivial</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨⟨</span><span class="bp">⊥</span><span class="o">,</span> <span class="bp">⊤</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">hxy.ne</span> <span class="o">(</span><span class="n">subtype.mk_eq_mk.mp</span> <span class="n">i</span><span class="o">)⟩⟩,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="o">⟨</span><span class="n">z</span><span class="o">,</span><span class="n">hz</span><span class="o">⟩,</span> <span class="kd">begin</span>
      <span class="n">apply</span> <span class="o">(</span><span class="n">h</span> <span class="n">z</span> <span class="n">hz.1</span> <span class="n">hz.2</span><span class="o">)</span><span class="bp">.</span><span class="n">cases_on</span><span class="o">,</span>
      <span class="n">exact</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">or.inl</span> <span class="kd">begin</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">hx'</span><span class="o">,</span> <span class="n">subtype.mk_eq_mk</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span> <span class="kd">end</span><span class="o">,</span>
      <span class="n">exact</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">or.inr</span> <span class="kd">begin</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">hy'</span><span class="o">,</span> <span class="n">subtype.mk_eq_mk</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span> <span class="kd">end</span><span class="o">,</span>
      <span class="kd">end</span> <span class="o">⟩,</span>
  <span class="o">},</span> <span class="o">{</span>
    <span class="n">dsimp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">letI</span> <span class="o">:=</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">letI</span> <span class="o">:=</span> <span class="n">Icc.bounded_order</span> <span class="n">hxy</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">x'</span> <span class="o">:</span> <span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">le_refl</span> <span class="n">x</span><span class="o">,</span> <span class="n">hxy</span><span class="o">⟩⟩,</span>
    <span class="k">let</span> <span class="n">y'</span> <span class="o">:</span> <span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="o">⟨</span><span class="n">hxy</span><span class="o">,</span> <span class="n">le_refl</span> <span class="n">y</span><span class="o">⟩⟩,</span>
    <span class="k">have</span> <span class="n">hx'</span> <span class="o">:</span> <span class="n">x'</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span> <span class="n">refl</span> <span class="n">x'</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hy'</span> <span class="o">:</span> <span class="n">y'</span> <span class="bp">=</span> <span class="bp">⊤</span> <span class="o">:=</span> <span class="n">refl</span> <span class="n">y'</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span> <span class="o">{</span>
      <span class="n">apply</span> <span class="n">lt_of_le_of_ne</span> <span class="n">hxy</span><span class="o">,</span>
      <span class="n">intro</span> <span class="n">hxy</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">i</span> <span class="o">:</span> <span class="n">x'</span> <span class="bp">≠</span> <span class="n">y'</span> <span class="o">:=</span> <span class="n">bot_ne_top</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">i</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">subtype.mk_eq_mk</span><span class="o">,</span> <span class="n">hxy</span><span class="o">],</span>
    <span class="o">},</span> <span class="o">{</span>
      <span class="n">intros</span> <span class="n">z</span> <span class="n">hxz</span> <span class="n">hzy</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">eq_bot_or_eq_top</span> <span class="o">(⟨</span><span class="n">z</span><span class="o">,⟨</span><span class="n">hxz</span><span class="o">,</span><span class="n">hzy</span><span class="o">⟩⟩</span> <span class="o">:</span> <span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="k">with</span> <span class="n">h</span> <span class="n">h</span><span class="o">,</span> <span class="o">{</span>
        <span class="n">left</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">subtype.mk.inj</span> <span class="n">h</span><span class="o">,</span>
      <span class="o">},</span> <span class="o">{</span>
        <span class="n">right</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">subtype.mk.inj</span> <span class="n">h</span><span class="o">,</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>Besides the usual question of whether this is already in mathlib (<code>#print instances is_simple_order</code> gives no results), I wonder how to properly deal with the typeclasses in the theorem statement. It feels incorrect to go into tactics mode like this. Similarly, in the proof I need to construct the same typeclass instance. It forces me to duplicate the <code>x'</code> and <code>hx'</code> statements. Could you give me some style hints.</p>



<a name="307348616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307348616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307348616">(Nov 01 2022 at 16:18)</a>:</h4>
<p><code>#print instances</code> will only check the current environment, so unless you have <code>import all</code> (using <code>leanproject mk-all</code>) you won't find all of them.<br>
Fortunately there is an easier way to find all instances: on the website: <a href="https://leanprover-community.github.io/mathlib_docs/find/is_simple_order">docs#is_simple_order</a> you can click the arrow to show "instances of this typeclass"</p>



<a name="307351210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307351210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307351210">(Nov 01 2022 at 16:29)</a>:</h4>
<p>It seems I was lucky, and my <code>#print instances</code> returned the same list as the docs. The question remains what the <del>pythonic</del> leanic way is to state this lemma.</p>



<a name="307361343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307361343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307361343">(Nov 01 2022 at 17:13)</a>:</h4>
<p>One way to improve the statement would be if we refactor <code>is_simple_order α</code> to mean <code>nat.card α = 2</code>.</p>



<a name="307361446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307361446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307361446">(Nov 01 2022 at 17:14)</a>:</h4>
<p>My short answer is: "don't". The reason it's a bit weird is that <code>bounded_order</code> is a data-carrying class (the data are <code>⊤ ⊥ : Icc x y</code>), whereas <code>x ⋖ y</code> is a <code>Prop</code>. This is the reason you must have an existential.</p>
<p>But if you must you can make the statement without tactic mode by providing the terms directly.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">covby_iff_simple_order_Icc'</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">⋖</span> <span class="n">y</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">hxy</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">,</span>
  <span class="bp">@</span><span class="n">is_simple_order</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">_</span> <span class="o">(</span><span class="n">Icc.bounded_order</span> <span class="n">hxy</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>
<p>However, I would instead suggest creating the following instance and lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">Icc.is_simple_order</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">⋖</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">is_simple_order</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">_</span> <span class="o">(</span><span class="n">Icc.bounded_order</span> <span class="n">h.le</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">covby_of_Icc_is_simple_order</span> <span class="o">[</span><span class="n">bounded_order</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)]</span> <span class="o">[</span><span class="n">is_simple_order</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)]</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">⋖</span> <span class="n">y</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="307361478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307361478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307361478">(Nov 01 2022 at 17:14)</a>:</h4>
<p>Lemmas about simple orders can still assume that <code>bounded_order</code> is present, but the defn wouldn't need it.</p>



<a name="307379335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307379335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307379335">(Nov 01 2022 at 18:38)</a>:</h4>
<p>I know the context for this and my answer is: don't</p>



<a name="307379481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307379481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307379481">(Nov 01 2022 at 18:39)</a>:</h4>
<p>The blueprint I gave you carefully dodges trap statements like this one</p>



<a name="307380621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307380621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307380621">(Nov 01 2022 at 18:45)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> Nevertheless, what do you think of making <code>is_simple_order</code> a synonym for <code>nat.card X = 2</code>?</p>



<a name="307383994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307383994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307383994">(Nov 01 2022 at 19:03)</a>:</h4>
<p>It seems a bit weird to use <code>is_simple_order</code> as the name if we define it without reference to orders</p>



<a name="307385903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307385903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307385903">(Nov 01 2022 at 19:15)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>, that's wrong. For example, <code>bool</code> with the discrete order (<code>tt</code> and <code>ff</code> are incomparable) is <em>not</em> a simple order.</p>



<a name="307386103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307386103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307386103">(Nov 01 2022 at 19:16)</a>:</h4>
<p>To be fair, the docstring of <a href="https://leanprover-community.github.io/mathlib_docs/find/is_simple_order">docs#is_simple_order</a> is misleading.</p>



<a name="307386195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307386195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307386195">(Nov 01 2022 at 19:17)</a>:</h4>
<p>I don't know much about order theory...</p>



<a name="307386280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307386280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307386280">(Nov 01 2022 at 19:17)</a>:</h4>
<p>Using the word "simple" seems strange to me in this case.</p>



<a name="307386394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307386394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307386394">(Nov 01 2022 at 19:18)</a>:</h4>
<p>Technically, the current definition is wrong too...</p>



<a name="307386567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307386567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307386567">(Nov 01 2022 at 19:19)</a>:</h4>
<p>According to its definition, we could have a preorder where both <code>⊥</code> and <code>⊤</code> are less than each other (indistinguishable).</p>



<a name="307386729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307386729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307386729">(Nov 01 2022 at 19:20)</a>:</h4>
<p>Does this notion agree with <a href="https://ncatlab.org/nlab/show/simple+object">nlab#simple+object</a> ?</p>



<a name="307386979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307386979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307386979">(Nov 01 2022 at 19:21)</a>:</h4>
<p>I would need to think it through. I think the correct interpretation for it would be in <a href="https://leanprover-community.github.io/mathlib_docs/find/Lattice">docs#Lattice</a></p>



<a name="307387200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307387200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307387200">(Nov 01 2022 at 19:22)</a>:</h4>
<p>I guess if you have a simple object <code>X</code> then its lattice of quotients will be "simple" with this definition. But I don't know if that means the lattice itself is simple!</p>



<a name="307387205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307387205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307387205">(Nov 01 2022 at 19:22)</a>:</h4>
<p>I'm confused.</p>



<a name="307387594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307387594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307387594">(Nov 01 2022 at 19:25)</a>:</h4>
<p>Hello confused, I'm confused too!</p>



<a name="307390862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307390862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307390862">(Nov 01 2022 at 19:44)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/is_simple_module">docs#is_simple_module</a> unfolds to <code>is_simple_order</code>. <a href="https://leanprover-community.github.io/mathlib_docs/find/is_simple_group">docs#is_simple_group</a> is definitionally the same as <code>is_simple_order (subgroup G)</code> except for the <code>is_normal</code> condition. I guess it could be defined to be <code>is_simple_order {H : subgroup G // H.is_normal}</code>.</p>



<a name="307391285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307391285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307391285">(Nov 01 2022 at 19:47)</a>:</h4>
<p>yeah exactly.</p>



<a name="307391824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307391824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307391824">(Nov 01 2022 at 19:50)</a>:</h4>
<blockquote>
<p>According to its definition, we could have a preorder where both ⊥ and ⊤ are less than each other (indistinguishable).</p>
</blockquote>
<p>Your comment amounts to </p>
<blockquote>
<p><code>[preorder T] [bounded_order T] [is_simple_order T]</code> is meaningless, only <code>[partial_order T] [bounded_order T] [is_simple_order T]</code> has mathematical content</p>
</blockquote>
<p>right? I don't think redefining <code>is_simple_order</code> in terms of <code>nat.card</code> changes that</p>



<a name="307400473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307400473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307400473">(Nov 01 2022 at 20:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement/near/307386729">said</a>:</p>
<blockquote>
<p>Does this notion agree with <a href="https://ncatlab.org/nlab/show/simple+object">nlab#simple+object</a> ?</p>
</blockquote>
<p>I have not checked what the appropriate morphisms are. But in general (aka "universal") algebra, we treat categories that usually do not have a zero object, and still we call <em>simple</em> those objects with exactly two "congruences" (which is essentially, two quotients).</p>



<a name="307400788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307400788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307400788">(Nov 01 2022 at 20:47)</a>:</h4>
<p>Yeah that's essentially what I was saying above. The congruences form a lattice (w.r.t. implication, say), and the lattice of congruences of a simple object is the a simple lattice w.r.t. <a href="https://leanprover-community.github.io/mathlib_docs/find/is_simple_order">docs#is_simple_order</a></p>



<a name="307401376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307401376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307401376">(Nov 01 2022 at 20:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement/near/307379481">said</a>:</p>
<blockquote>
<p>The blueprint I gave you carefully dodges trap statements like this one</p>
</blockquote>
<p>You are right about what context I am using it, but it is actually for something else. I prove for modules that <code>x ⋖ y</code> iff the quotient is a simple module. However, I think that statement should go (1) <code>x ⋖ y</code> iff <code>Icc x y</code> is simple for lattices and then (2) <code>Icc x y</code> is order isomorphic to the quotient in the case of modules.</p>



<a name="307402052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307402052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307402052">(Nov 01 2022 at 20:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement/near/307385903">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span>, that's wrong. For example, <code>bool</code> with the discrete order (<code>tt</code> and <code>ff</code> are incomparable) is <em>not</em> a simple order.</p>
</blockquote>
<p><del><a href="https://leanprover-community.github.io/mathlib_docs/order/atoms.html#bool.is_simple_order">Isn't it?</a></del> My bad I missed the discrete part.</p>



<a name="307403240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307403240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307403240">(Nov 01 2022 at 21:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement/near/307390862">said</a>:</p>
<blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/is_simple_module">docs#is_simple_module</a> unfolds to <code>is_simple_order</code>. <a href="https://leanprover-community.github.io/mathlib_docs/find/is_simple_group">docs#is_simple_group</a> is definitionally the same as <code>is_simple_order (subgroup G)</code> except for the <code>is_normal</code> condition. I guess it could be defined to be <code>is_simple_order {H : subgroup G // H.is_normal}</code>.</p>
</blockquote>
<p>Working with the 'lattice of normal subgroups' feels unnatural, mostly because  <code>Icc x y</code> is not order isomorphic with <code>y / x</code>.</p>



<a name="307408356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307408356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307408356">(Nov 01 2022 at 21:43)</a>:</h4>
<p>At the risk of throwing oil at the fire: Is this better? I am also trying to improve my Lean. I have managed to eliminate code duplication.</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">covby_iff_simple_order_Icc'</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">⋖</span> <span class="n">y</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">hxy</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">,</span>
  <span class="bp">@</span><span class="n">is_simple_order</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">_</span> <span class="o">(</span><span class="n">Icc.bounded_order</span> <span class="n">hxy</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">covby_iff_lt_and_eq_or_eq</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">work_on_goal</span> <span class="mi">1</span> <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">hxy'</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span> <span class="k">have</span> <span class="n">hxy</span> <span class="o">:=</span> <span class="n">hxy'.le</span> <span class="o">},</span>
  <span class="n">work_on_goal</span> <span class="mi">2</span> <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">hxy</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="n">all_goals</span>
  <span class="o">{</span> <span class="n">letI</span> <span class="o">:=</span> <span class="n">Icc.bounded_order</span> <span class="n">hxy</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hx</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⊥</span> <span class="o">:</span> <span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">le_refl</span> <span class="n">x</span><span class="o">,</span> <span class="n">hxy</span><span class="o">⟩⟩</span> <span class="o">:=</span> <span class="n">refl</span> <span class="n">_</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hy</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⊤</span> <span class="o">:</span> <span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="o">⟨</span><span class="n">hxy</span><span class="o">,</span> <span class="n">le_refl</span> <span class="n">y</span><span class="o">⟩⟩</span> <span class="o">:=</span> <span class="n">refl</span> <span class="n">_</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">use</span> <span class="n">hxy</span><span class="o">,</span>
    <span class="n">haveI</span> <span class="o">:</span> <span class="n">nontrivial</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨⟨</span><span class="bp">⊥</span><span class="o">,</span> <span class="bp">⊤</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">hxy'.ne</span> <span class="o">(</span><span class="n">subtype.mk_eq_mk.mp</span> <span class="n">i</span><span class="o">)⟩⟩,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="o">⟨</span><span class="n">z</span><span class="o">,</span><span class="n">hz</span><span class="o">⟩,</span> <span class="kd">begin</span>
      <span class="n">apply</span> <span class="o">(</span><span class="n">h</span> <span class="n">z</span> <span class="n">hz.1</span> <span class="n">hz.2</span><span class="o">)</span><span class="bp">.</span><span class="n">cases_on</span><span class="o">,</span>
      <span class="n">exact</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">or.inl</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hx</span><span class="o">,</span><span class="n">subtype.mk_eq_mk</span><span class="o">,</span> <span class="n">h</span><span class="o">]),</span>
      <span class="n">exact</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">or.inr</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hy</span><span class="o">,</span> <span class="n">subtype.mk_eq_mk</span><span class="o">,</span> <span class="n">h</span><span class="o">]),</span>
      <span class="kd">end</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">lt_of_le_of_ne</span> <span class="n">hxy</span><span class="o">,</span>
      <span class="n">intro</span> <span class="n">hxy</span><span class="o">,</span>
      <span class="n">apply</span> <span class="bp">@</span><span class="n">bot_ne_top</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">),</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">subtype.mk_eq_mk</span><span class="o">,</span> <span class="n">hxy</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">z</span> <span class="n">hxz</span> <span class="n">hzy</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">eq_bot_or_eq_top</span> <span class="o">(⟨</span><span class="n">z</span><span class="o">,</span> <span class="o">⟨</span><span class="n">hxz</span><span class="o">,</span> <span class="n">hzy</span><span class="o">⟩⟩</span> <span class="o">:</span> <span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="k">with</span> <span class="n">h</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">or.inl</span> <span class="o">(</span><span class="n">subtype.mk.inj</span> <span class="n">h</span><span class="o">),</span>
      <span class="n">exact</span> <span class="n">or.inr</span> <span class="o">(</span><span class="n">subtype.mk.inj</span> <span class="n">h</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="307410736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307410736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307410736">(Nov 01 2022 at 22:00)</a>:</h4>
<p>Yael's comment above still applies; that lemma permits a more pleasant statement if you state the two directions separately (as this eliminates the <code>exists</code>). You can of course still prove the <code>iff</code>, but you can do so in terms of the separate directions.</p>



<a name="307410848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307410848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307410848">(Nov 01 2022 at 22:01)</a>:</h4>
<p><del>Wrong thread <span class="user-mention" data-user-id="387244">@Yaël Dillies</span>?</del> (fixed)</p>



<a name="307410895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307410895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307410895">(Nov 01 2022 at 22:01)</a>:</h4>
<p>Uh yes <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span></p>



<a name="307414902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307414902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307414902">(Nov 01 2022 at 22:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement/near/307410736">said</a>:</p>
<blockquote>
<p>Yael's comment above still applies; that lemma permits a more pleasant statement if you state the two directions separately (as this eliminates the <code>exists</code>). You can of course still prove the <code>iff</code>, but you can do so in terms of the separate directions.</p>
</blockquote>
<p>Fair point, I will do that.</p>



<a name="307415328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307415328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307415328">(Nov 01 2022 at 22:35)</a>:</h4>
<p>Should a lemma like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Icc_equiv_quot</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="bp">≃</span><span class="n">o</span> <span class="n">submodule</span> <span class="n">R</span> <span class="o">(</span><span class="n">B</span> <span class="bp">⧸</span> <span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>be added to mathlib? Does it exist? Or does anyone have a better idea for proving that  <code>A ⋖ B</code> iff <code>B/A</code> is a simple module?</p>



<a name="307422517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307422517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307422517">(Nov 01 2022 at 23:36)</a>:</h4>
<p>At least this one wasn't hard</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.jordan_holder</span>
<span class="kn">import</span> <span class="n">order.cover</span>
<span class="kn">import</span> <span class="n">ring_theory.simple_module</span>

<span class="kn">open</span> <span class="n">set</span>
<span class="kn">open</span> <span class="n">submodule</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">comap_map_subtype</span> <span class="o">{</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">comap</span> <span class="n">B.subtype</span> <span class="o">(</span><span class="n">map</span> <span class="n">B.subtype</span> <span class="n">A</span><span class="o">)</span> <span class="bp">=</span> <span class="n">A</span> <span class="o">:=</span>
<span class="n">comap_map_eq_of_injective</span> <span class="n">subtype.coe_injective</span> <span class="n">A</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">map_comap_subtype'</span> <span class="o">{</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">B</span> <span class="n">A</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">}</span>
<span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">map</span> <span class="n">B.subtype</span> <span class="o">(</span><span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">A</span><span class="o">)</span> <span class="bp">=</span> <span class="n">A</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">map_comap_subtype</span><span class="o">,</span> <span class="n">inf_eq_right</span><span class="o">],</span> <span class="n">exact</span> <span class="n">hab</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">Iic_equiv_submodule</span> <span class="o">(</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">Iic</span> <span class="n">C</span> <span class="bp">≃</span><span class="n">o</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">C</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">to_fun</span>       <span class="o">:=</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span> <span class="n">hA</span><span class="o">⟩,</span> <span class="n">comap</span> <span class="n">C.subtype</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">inv_fun</span>      <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span><span class="o">,</span> <span class="o">⟨</span><span class="n">map</span> <span class="n">C.subtype</span> <span class="n">A</span><span class="o">,</span> <span class="n">map_subtype_le</span> <span class="n">C</span> <span class="n">A</span><span class="o">⟩,</span>
  <span class="n">left_inv</span>     <span class="o">:=</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span> <span class="n">hA</span><span class="o">⟩,</span> <span class="n">subtype.mk_eq_mk.mpr</span> <span class="o">(</span><span class="n">map_comap_subtype'</span> <span class="n">hA</span><span class="o">),</span>
  <span class="n">right_inv</span>    <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span><span class="o">,</span> <span class="n">comap_map_subtype</span> <span class="n">C</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">map_rel_iff'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintros</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span> <span class="n">hA</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span> <span class="n">hB</span><span class="o">⟩,</span>
    <span class="n">change</span> <span class="n">comap</span> <span class="n">C.subtype</span> <span class="n">A</span> <span class="bp">≤</span> <span class="n">comap</span> <span class="n">C.subtype</span> <span class="n">B</span> <span class="bp">↔</span> <span class="n">A</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">,</span>
    <span class="n">split</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">map_comap_subtype'</span> <span class="n">hA</span><span class="o">,</span> <span class="bp">←</span><span class="n">map_comap_subtype'</span> <span class="n">hB</span><span class="o">],</span>
      <span class="n">exact</span> <span class="n">map_mono</span> <span class="n">h</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">comap_mono</span> <span class="n">h</span> <span class="o">}</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="307467189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307467189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307467189">(Nov 02 2022 at 07:41)</a>:</h4>
<p>It would be better to avoid the <code>⟨⟩</code> when defining <code>to_fun</code></p>



<a name="307467302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307467302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307467302">(Nov 02 2022 at 07:42)</a>:</h4>
<p>Because when defining data this trick can lead to some pretty nasty defeqs under the hood</p>



<a name="307467445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307467445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307467445">(Nov 02 2022 at 07:44)</a>:</h4>
<p>I guess the statement above is also true as <code>(C : set X) : Iic C ≃o set C</code></p>



<a name="307498483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307498483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307498483">(Nov 02 2022 at 11:06)</a>:</h4>
<p>So I am trying to prove the <code>Icc</code> version, and I run into some very verbose goals in <code>left_inv</code>, <code>right_inv</code> and <code>map_rel_iff'</code>. Trying to <code>change</code> or <code>dsimp</code> them is very slow, to the point that it gives a deterministic timeout. Any suggestions?</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.jordan_holder</span>
<span class="kn">import</span> <span class="n">order.cover</span>
<span class="kn">import</span> <span class="n">ring_theory.simple_module</span>

<span class="kn">open</span> <span class="n">set</span>
<span class="kn">open</span> <span class="n">submodule</span>
<span class="kn">open</span> <span class="n">subtype</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">comap_map_subtype</span> <span class="o">{</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">comap</span> <span class="n">B.subtype</span> <span class="o">(</span><span class="n">map</span> <span class="n">B.subtype</span> <span class="n">A</span><span class="o">)</span> <span class="bp">=</span> <span class="n">A</span> <span class="o">:=</span>
<span class="n">comap_map_eq_of_injective</span> <span class="n">subtype.coe_injective</span> <span class="n">A</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">map_comap_subtype'</span> <span class="o">{</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">map</span> <span class="n">B.subtype</span> <span class="o">(</span><span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">A</span><span class="o">)</span> <span class="bp">=</span> <span class="n">A</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">map_comap_subtype</span><span class="o">,</span> <span class="n">inf_eq_right</span><span class="o">],</span> <span class="n">exact</span> <span class="n">hab</span> <span class="o">}</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">comap_map_mkq'</span> <span class="o">{</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">comap</span> <span class="n">A.mkq</span> <span class="o">(</span><span class="n">map</span> <span class="n">A.mkq</span> <span class="n">B</span><span class="o">)</span> <span class="bp">=</span> <span class="n">B</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">comap_map_mkq</span><span class="o">,</span> <span class="n">sup_eq_right</span><span class="o">],</span> <span class="n">exact</span> <span class="n">hab</span> <span class="o">}</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">map_comap_mkq</span> <span class="o">{</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span>
  <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="o">(</span><span class="n">M</span> <span class="bp">⧸</span> <span class="n">A</span><span class="o">))</span> <span class="o">:</span> <span class="n">map</span> <span class="n">A.mkq</span> <span class="o">(</span><span class="n">comap</span> <span class="n">A.mkq</span> <span class="n">B</span><span class="o">)</span> <span class="bp">=</span> <span class="n">B</span> <span class="o">:=</span>
<span class="n">map_comap_eq_of_surjective</span> <span class="n">A.mkq_surjective</span> <span class="n">B</span>

<span class="kd">def</span> <span class="n">Icc_equiv_quot</span> <span class="o">(</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hAB</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="bp">≃</span><span class="n">o</span> <span class="n">submodule</span> <span class="n">R</span> <span class="o">(</span><span class="n">B</span> <span class="bp">⧸</span> <span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">C</span><span class="o">,</span> <span class="n">map</span> <span class="o">(</span><span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">mkq</span> <span class="o">(</span><span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">C.val</span><span class="o">),</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">C</span><span class="o">,</span> <span class="o">⟨</span><span class="n">map</span> <span class="n">B.subtype</span> <span class="o">(</span><span class="n">comap</span> <span class="o">(</span><span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">mkq</span> <span class="n">C</span><span class="o">),</span> <span class="o">⟨</span>
    <span class="n">le_trans</span> <span class="o">(</span><span class="n">map_comap_subtype'</span> <span class="n">hAB</span><span class="o">)</span><span class="bp">.</span><span class="n">symm.le</span> <span class="o">(</span><span class="n">map_mono</span> <span class="o">(</span><span class="n">le_comap_mkq</span> <span class="n">_</span> <span class="n">C</span><span class="o">)),</span>
    <span class="n">map_subtype_le</span> <span class="n">B</span> <span class="n">_</span> <span class="o">⟩⟩,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">C</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mk_eq_mk</span><span class="o">,</span> <span class="n">comap_map_mkq'</span> <span class="o">(</span><span class="n">comap_mono</span> <span class="n">h.1</span><span class="o">),</span> <span class="n">map_comap_subtype'</span> <span class="n">h.2</span><span class="o">],</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">C</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">change</span> <span class="n">map</span> <span class="o">(</span><span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">mkq</span> <span class="o">(</span><span class="n">comap</span> <span class="n">B.subtype</span> <span class="o">(</span><span class="n">map</span> <span class="n">B.subtype</span> <span class="o">(</span><span class="n">comap</span> <span class="o">(</span><span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">mkq</span> <span class="n">C</span><span class="o">)))</span> <span class="bp">=</span> <span class="n">C</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">comap_map_subtype</span><span class="o">,</span> <span class="n">map_comap_mkq</span><span class="o">],</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">map_rel_iff'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">C</span> <span class="n">D</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">split</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="o">{</span>
      <span class="n">change</span> <span class="n">map</span> <span class="o">(</span><span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">mkq</span> <span class="o">(</span><span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">C.val</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">map</span> <span class="o">(</span><span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">mkq</span> <span class="o">(</span><span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">D.val</span><span class="o">)</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="o">}</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>
</div></div>



<a name="307507932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307507932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307507932">(Nov 02 2022 at 12:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement/near/307467445">said</a>:</p>
<blockquote>
<p>I guess the statement above is also true as <code>(C : set X) : Iic C ≃o set C</code></p>
</blockquote>
<p>My statement does not follow from that one right? Certainly a submodule <code>C</code> is a <code>set X</code>, but  <code>set C</code> is not equal to <code>submodule R C</code>. Or am I missing your point?</p>



<a name="307610947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307610947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307610947">(Nov 02 2022 at 20:17)</a>:</h4>
<p><del><code>dsimp at h,</code> does the <code>change</code> and it seems to do it much more quickly.</del> Wait -- why are you changing C to C.val?</p>



<a name="307611262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307611262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307611262">(Nov 02 2022 at 20:19)</a>:</h4>
<p>If you do <code>dsimp at h</code> first then the <code>change</code> might work more quickly?</p>



<a name="307625370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307625370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307625370">(Nov 02 2022 at 21:59)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">comap_map_mkq'</span> <span class="o">{</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">comap</span> <span class="n">A.mkq</span> <span class="o">(</span><span class="n">map</span> <span class="n">A.mkq</span> <span class="n">B</span><span class="o">)</span> <span class="bp">=</span> <span class="n">B</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">comap_map_mkq</span><span class="o">,</span> <span class="n">sup_eq_right</span><span class="o">]</span>
</code></pre></div>
<p><code>rwa</code> is <code>rw</code>, then <code>assumption</code></p>



<a name="307630717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307630717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307630717">(Nov 02 2022 at 22:45)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">map_rel_iff'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">C</span><span class="o">,</span> <span class="n">hAC</span><span class="o">,</span> <span class="n">hCB</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">D</span><span class="o">,</span> <span class="n">hAD</span><span class="o">,</span> <span class="n">hDB</span><span class="o">⟩,</span>
    <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">map_le_iff_le_comap</span><span class="o">,</span> <span class="n">comap_map_mkq</span><span class="o">],</span>
    <span class="n">rw</span> <span class="n">sup_eq_right.2</span> <span class="o">(</span><span class="n">comap_mono</span> <span class="n">hAD</span> <span class="o">:</span> <span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">A</span> <span class="bp">≤</span> <span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">D</span><span class="o">),</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span> <span class="n">x</span> <span class="n">hxC</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">comap_mono</span><span class="o">⟩,</span>
    <span class="n">specialize</span> <span class="n">h</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">B.subtype</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hCB</span> <span class="n">hxC</span><span class="o">⟩</span> <span class="bp">∈</span> <span class="n">C</span><span class="o">),</span>
    <span class="n">exacts</span> <span class="o">[</span><span class="n">hxC</span><span class="o">,</span> <span class="n">h</span><span class="o">],</span>
  <span class="kd">end</span>
</code></pre></div>



<a name="307632233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307632233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307632233">(Nov 02 2022 at 23:01)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">C</span><span class="o">,</span> <span class="n">hAC</span><span class="o">,</span> <span class="n">hCB</span><span class="o">⟩,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="bp">*</span><span class="o">,</span>
</code></pre></div>



<a name="307632446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307632446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307632446">(Nov 02 2022 at 23:03)</a>:</h4>
<p>Probably yours is faster though. Note that your <code>h</code> is defeq to <code>A &lt;= C \and C \le B</code>.</p>



<a name="307632617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307632617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307632617">(Nov 02 2022 at 23:04)</a>:</h4>
<p>Oh -- I changed your <code>to_fun</code> to <code>to_fun := λ C, map (comap B.subtype A).mkq (comap B.subtype (C : submodule R M)),</code> -- my guess is that the coercion is the <code>simp</code> normal form rather than <code>C.val</code>.</p>



<a name="307634316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307634316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307634316">(Nov 02 2022 at 23:23)</a>:</h4>
<p>To avoid confusion let me just post my version of the full code. It's still slow though and I don't really know why.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Icc_equiv_quot</span> <span class="o">(</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hAB</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≤</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="bp">≃</span><span class="n">o</span> <span class="n">submodule</span> <span class="n">R</span> <span class="o">(</span><span class="n">B</span> <span class="bp">⧸</span> <span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">C</span><span class="o">,</span> <span class="n">map</span> <span class="o">(</span><span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">mkq</span> <span class="o">(</span><span class="n">comap</span> <span class="n">B.subtype</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)),</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">C</span><span class="o">,</span> <span class="o">⟨</span><span class="n">map</span> <span class="n">B.subtype</span> <span class="o">(</span><span class="n">comap</span> <span class="o">(</span><span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">mkq</span> <span class="n">C</span><span class="o">),</span> <span class="o">⟨</span>
    <span class="n">le_trans</span> <span class="o">(</span><span class="n">map_comap_subtype'</span> <span class="n">hAB</span><span class="o">)</span><span class="bp">.</span><span class="n">symm.le</span> <span class="o">(</span><span class="n">map_mono</span> <span class="o">(</span><span class="n">le_comap_mkq</span> <span class="n">_</span> <span class="n">C</span><span class="o">)),</span>
    <span class="n">map_subtype_le</span> <span class="n">B</span> <span class="n">_</span> <span class="o">⟩⟩,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">C</span><span class="o">,</span> <span class="n">hAC</span><span class="o">,</span> <span class="n">hCB</span><span class="o">⟩,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">C</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">map_rel_iff'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">C</span><span class="o">,</span> <span class="n">hAC</span><span class="o">,</span> <span class="n">hCB</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">D</span><span class="o">,</span> <span class="n">hAD</span><span class="o">,</span> <span class="n">hDB</span><span class="o">⟩,</span>
    <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">map_le_iff_le_comap</span><span class="o">,</span> <span class="n">comap_map_mkq</span><span class="o">],</span>
    <span class="n">rw</span> <span class="n">sup_eq_right.2</span> <span class="o">(</span><span class="n">comap_mono</span> <span class="n">hAD</span> <span class="o">:</span> <span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">A</span> <span class="bp">≤</span> <span class="n">comap</span> <span class="n">B.subtype</span> <span class="n">D</span><span class="o">),</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span> <span class="n">x</span> <span class="n">hxC</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">comap_mono</span><span class="o">⟩,</span>
    <span class="n">specialize</span> <span class="n">h</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">B.subtype</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hCB</span> <span class="n">hxC</span><span class="o">⟩</span> <span class="bp">∈</span> <span class="n">C</span><span class="o">),</span>
    <span class="n">exacts</span> <span class="o">[</span><span class="n">hxC</span><span class="o">,</span> <span class="n">h</span><span class="o">],</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="307688611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307688611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307688611">(Nov 03 2022 at 09:46)</a>:</h4>
<p>Thanks for your effort! I was really struggling with val/coe/etc. Do you mind if I pull request this to mathlib?</p>



<a name="307688978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307688978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307688978">(Nov 03 2022 at 09:49)</a>:</h4>
<p>I did some experimenting by moving to_fun and inv_fun to separate definitions, and it becomes way faster. It seems like inv_fun is somewhat slow, and if we leave it inline as in your code it seems like it has to 'parse' (for lack of a better word) that multiple times.</p>



<a name="307712892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307712892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307712892">(Nov 03 2022 at 12:08)</a>:</h4>
<p>I am now at the final stages of my proofs. I only require the following instance. However, I seem unable to tell Lean that beta is a bounded_order. Any hints?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.cover</span> <span class="n">order.atoms</span>

<span class="kd">instance</span> <span class="n">is_simple_order_of_equiv</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">bounded_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">bounded_order</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_simple_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">≃</span><span class="n">o</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_simple_order</span> <span class="n">β</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">exists_pair_ne</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rcases</span> <span class="n">h.exists_pair_ne</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">y</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">h</span> <span class="o">((</span><span class="n">order_iso.apply_eq_iff_eq</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">i</span><span class="o">)⟩,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">eq_bot_or_eq_top</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">cases</span> <span class="n">h.eq_bot_or_eq_top</span> <span class="o">(</span><span class="n">f.symm</span> <span class="n">z</span><span class="o">),</span> <span class="o">{</span>
      <span class="n">left</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">h_1</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">f.apply_symm_apply</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
      <span class="c1">--letI : order_bot β := bounded_order.to_order_bot β,</span>
      <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">order_iso.map_bot</span> <span class="n">α</span> <span class="n">β</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
    <span class="o">}</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="307715001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307715001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307715001">(Nov 03 2022 at 12:18)</a>:</h4>
<p>Nevermind, I figured it out. <code>has_le</code> and <code>partial_order</code> conflict, so it should be <code>{α : Type*} [partial_order α] [bounded_order α]</code>.</p>



<a name="307718136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307718136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307718136">(Nov 03 2022 at 12:34)</a>:</h4>
<p><code>is_simple_order_of_equiv</code>  can't be an instance as lean can't find <code>f</code>, but it should be a <code>@[reducible] def</code>.</p>



<a name="307718268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cumbersome%20typeclass%20in%20theorem%20statement/near/307718268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement.html#307718268">(Nov 03 2022 at 12:35)</a>:</h4>
<p>You should be able to golf that by using <a href="https://leanprover-community.github.io/mathlib_docs/find/function.injective.nontrivial">docs#function.injective.nontrivial</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
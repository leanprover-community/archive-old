---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html">How to use mem_set_of_eq with  ¬A</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="297182234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297182234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Palm <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297182234">(Sep 05 2022 at 08:07)</a>:</h4>
<p>I am trying to prove <code>{x | A x} = compl {x | ¬A x}</code> without matlib (core library only). However I am not capable of using <code>mem_set_of_eq</code> correctly in conjunction with ¬A and the rewrite tactic. I appreciate any help.</p>
<p>Since the definitions of <code>compl</code> et al have been removed from the core library in the <a href="https://github.com/leanprover-community/lean/commit/ab343ab4edc491dbd02bed7b70295a0bb88be06f">last commit</a> (I don't know, if by accident or intent), I have to implement my own. Also, I like to implement the extensionality axiom by myself:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">set</span>

<span class="kd">constant</span> <span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kd">notation</span> <span class="bp">`</span><span class="n">Pred</span><span class="bp">`</span> <span class="o">:=</span> <span class="bp">Ω</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kd">notation</span> <span class="bp">`</span><span class="n">Set</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">set</span> <span class="bp">Ω</span>

<span class="kd">variables</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Pred</span>
<span class="kd">variables</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">Set</span>
<span class="kd">variables</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="bp">Ω</span>

<span class="kd">axiom</span> <span class="n">not.not_iff</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬¬</span><span class="n">A</span> <span class="bp">↔</span> <span class="n">A</span>
<span class="kd">axiom</span> <span class="n">set_eq.intro</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Set</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span><span class="n">z</span><span class="o">,</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">X</span> <span class="bp">↔</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span>
<span class="kd">axiom</span> <span class="n">set_eq.elim</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Set</span><span class="o">}</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span><span class="n">z</span><span class="o">,</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">X</span> <span class="bp">↔</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">Y</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">compl</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Set</span><span class="o">)</span> <span class="o">:</span> <span class="n">Set</span> <span class="o">:=</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="n">z</span> <span class="bp">∉</span> <span class="n">X</span><span class="o">}</span>


<span class="kd">theorem</span> <span class="n">t₁</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">Pred</span><span class="o">}</span> <span class="o">:</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">A</span> <span class="n">y</span><span class="o">}</span> <span class="bp">=</span> <span class="n">compl</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">¬</span><span class="n">A</span> <span class="n">y</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="bp">∈</span><span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">A</span> <span class="n">y</span><span class="o">}</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">compl</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">¬</span><span class="n">A</span> <span class="n">y</span><span class="o">},</span>
  <span class="k">show</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">A</span> <span class="n">y</span><span class="o">}</span> <span class="bp">=</span> <span class="n">compl</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">¬</span><span class="n">A</span> <span class="n">y</span><span class="o">},</span> <span class="k">from</span> <span class="n">set_eq.intro</span> <span class="n">this</span><span class="o">,</span>

  <span class="k">show</span> <span class="bp">∀</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="bp">∈</span><span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">A</span> <span class="n">y</span><span class="o">}</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">compl</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">¬</span><span class="n">A</span> <span class="n">y</span><span class="o">},</span> <span class="k">from</span>
  <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">x</span><span class="bp">∈</span><span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">A</span> <span class="n">y</span><span class="o">}</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">compl</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">¬</span><span class="n">A</span> <span class="n">y</span><span class="o">},</span> <span class="k">from</span> <span class="k">calc</span>
      <span class="n">x</span><span class="bp">∈</span><span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">A</span> <span class="n">y</span><span class="o">}</span> <span class="bp">↔</span>   <span class="n">A</span> <span class="n">x</span>                       <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
              <span class="bp">...</span> <span class="bp">↔</span> <span class="bp">¬¬</span><span class="n">A</span> <span class="n">x</span>                       <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">not.not_iff</span>
              <span class="bp">...</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="bp">¬¬</span><span class="n">A</span> <span class="n">z</span><span class="o">}</span>             <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">mem_set_of_eq</span>
              <span class="bp">...</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="bp">¬</span><span class="o">(</span><span class="n">z</span> <span class="bp">∈</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">¬</span><span class="n">A</span> <span class="n">y</span><span class="o">})}</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="bp">←@</span><span class="n">mem_set_of_eq</span> <span class="bp">Ω</span> <span class="n">_</span> <span class="o">(</span><span class="n">not</span> <span class="bp">∘</span> <span class="n">A</span><span class="o">)</span> <span class="c1">-- this does not work!</span>
              <span class="bp">...</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="n">z</span> <span class="bp">∉</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">¬</span><span class="n">A</span> <span class="n">y</span><span class="o">}}</span>    <span class="o">:</span> <span class="kd">by</span> <span class="n">assumption</span>
              <span class="bp">...</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">compl</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">¬</span><span class="n">A</span> <span class="n">y</span><span class="o">}</span>        <span class="o">:</span> <span class="kd">by</span> <span class="n">assumption</span>
  <span class="kd">end</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>I have no idea, how to correctly call <code>mem_set_of_eq</code>. I tried<br>
<code>rw ←@mem_set_of_eq Ω _ (¬A)</code><br>
<code>rw ←@mem_set_of_eq Ω _ (λ x : Ω, ¬A x)</code><br>
<code>rw ←@mem_set_of_eq Ω _ (not ∘ A)</code><br>
and all different kinds of other approaches.<br>
<code>(not ∘ A)</code> at least has the correct type. But it says that it cannot find an instance of the pattern <code>(not ∘ A) ?m_1</code>.</p>
<p>Any help is appreciated.</p>



<a name="297183064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297183064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297183064">(Sep 05 2022 at 08:14)</a>:</h4>
<p><code>by refl</code> works fine.</p>



<a name="297183295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297183295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297183295">(Sep 05 2022 at 08:15)</a>:</h4>
<p><code>rw</code> works up to syntactic equality not definitional equality, so it can't see through things like <code>∘</code>.</p>



<a name="297183457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297183457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297183457">(Sep 05 2022 at 08:16)</a>:</h4>
<p>Many other tactics work up to definitional equality (for example <code>example : Pred = Set := rfl</code> works fine) but for rewrite you need a syntactic match.</p>



<a name="297183630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297183630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297183630">(Sep 05 2022 at 08:18)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="k">show</span> <span class="n">x</span><span class="bp">∈</span><span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">A</span> <span class="n">y</span><span class="o">}</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">compl</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">¬</span><span class="n">A</span> <span class="n">y</span><span class="o">},</span> <span class="k">from</span> <span class="k">calc</span>
      <span class="n">x</span><span class="bp">∈</span><span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">A</span> <span class="n">y</span><span class="o">}</span> <span class="bp">↔</span>   <span class="n">A</span> <span class="n">x</span>                       <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
              <span class="bp">...</span> <span class="bp">↔</span> <span class="bp">¬¬</span><span class="n">A</span> <span class="n">x</span>                       <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">not.not_iff</span>
              <span class="bp">...</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">compl</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">¬</span><span class="n">A</span> <span class="n">y</span><span class="o">}</span>        <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
</code></pre></div>



<a name="297215567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297215567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Palm <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297215567">(Sep 05 2022 at 12:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Thank you for your answer and the great content you provide. I have read your explanations on the different kinds of equality <a href="https://www.ma.imperial.ac.uk/~buzzard/xena/formalising-mathematics-2022/Part_B/equality.html">here</a>. However I would like to explicitly state all the syntactic transformations which are necessary in the proof. How can I do that?<br>
Using <code>refl</code> hides the necessary syntactic transformations.</p>



<a name="297215929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297215929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297215929">(Sep 05 2022 at 12:11)</a>:</h4>
<p>You can add a lemma (whose proof is <code>rfl</code>) saying <code>x∈{y | A y} ↔   A x</code>, and then rewrite that.</p>



<a name="297216044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297216044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297216044">(Sep 05 2022 at 12:12)</a>:</h4>
<p>In mathlib there is <a href="https://leanprover-community.github.io/mathlib_docs/find/set.mem_set_of">docs#set.mem_set_of</a></p>



<a name="297217120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297217120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Palm <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297217120">(Sep 05 2022 at 12:18)</a>:</h4>
<p><span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> <span class="user-mention" data-user-id="127136">@Alex J. Best</span>  I am trying to use <code>mem_set_of_eq</code> from the <a href="https://github.com/leanprover-community/lean/blob/master/library/init/data/set.lean">core lib</a> (Line 24), which seems to be exactly what you propose? But I keep failing using it.</p>



<a name="297217235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297217235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297217235">(Sep 05 2022 at 12:19)</a>:</h4>
<p>Just a tip: you can write <a href="https://leanprover-community.github.io/mathlib_docs/find/set.mem_set_of_eq">docs#set.mem_set_of_eq</a> (docs # set.mem_set_of_eq without spaces) and you get a link to the lemma you want.</p>



<a name="297217528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297217528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297217528">(Sep 05 2022 at 12:21)</a>:</h4>
<p>In <a href="https://leanprover-community.github.io/mathlib_docs/find/set.mem_set_of_eq">docs#set.mem_set_of_eq</a> there is <code>=</code> instead of <code>↔</code>, maybe that's the problem.</p>



<a name="297218109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297218109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297218109">(Sep 05 2022 at 12:25)</a>:</h4>
<p>You can try to use <a href="https://leanprover-community.github.io/mathlib_docs/find/eq.to_iff">docs#eq.to_iff</a>, that is also in core.</p>



<a name="297218188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297218188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297218188">(Sep 05 2022 at 12:25)</a>:</h4>
<p>Here's one way to do it with conv:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">set</span>


<span class="kd">constant</span> <span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kd">notation</span> <span class="bp">`</span><span class="n">Pred</span><span class="bp">`</span> <span class="o">:=</span> <span class="bp">Ω</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kd">notation</span> <span class="bp">`</span><span class="n">Set</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">set</span> <span class="bp">Ω</span>

<span class="kd">variables</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Pred</span>
<span class="kd">variables</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">Set</span>
<span class="kd">variables</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="bp">Ω</span>

<span class="kd">axiom</span> <span class="n">not.not_iff</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬¬</span><span class="n">A</span> <span class="bp">↔</span> <span class="n">A</span>
<span class="kd">axiom</span> <span class="n">set_eq.intro</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Set</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span><span class="n">z</span><span class="o">,</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">X</span> <span class="bp">↔</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span>
<span class="kd">axiom</span> <span class="n">set_eq.elim</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Set</span><span class="o">}</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span><span class="n">z</span><span class="o">,</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">X</span> <span class="bp">↔</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">Y</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">compl</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Set</span><span class="o">)</span> <span class="o">:</span> <span class="n">Set</span> <span class="o">:=</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="n">z</span> <span class="bp">∉</span> <span class="n">X</span><span class="o">}</span>


<span class="kd">theorem</span> <span class="n">t₁</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">Pred</span><span class="o">}</span> <span class="o">:</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">A</span> <span class="n">y</span><span class="o">}</span> <span class="bp">=</span> <span class="n">compl</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">¬</span><span class="n">A</span> <span class="n">y</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="bp">∈</span><span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">A</span> <span class="n">y</span><span class="o">}</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">compl</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">¬</span><span class="n">A</span> <span class="n">y</span><span class="o">},</span>
  <span class="k">show</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">A</span> <span class="n">y</span><span class="o">}</span> <span class="bp">=</span> <span class="n">compl</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">¬</span><span class="n">A</span> <span class="n">y</span><span class="o">},</span> <span class="k">from</span> <span class="n">set_eq.intro</span> <span class="n">this</span><span class="o">,</span>

  <span class="k">show</span> <span class="bp">∀</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="bp">∈</span><span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">A</span> <span class="n">y</span><span class="o">}</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">compl</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">¬</span><span class="n">A</span> <span class="n">y</span><span class="o">},</span> <span class="k">from</span>
  <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">x</span><span class="bp">∈</span><span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">A</span> <span class="n">y</span><span class="o">}</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">compl</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">¬</span><span class="n">A</span> <span class="n">y</span><span class="o">},</span> <span class="k">from</span> <span class="k">calc</span>
      <span class="n">x</span><span class="bp">∈</span><span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">A</span> <span class="n">y</span><span class="o">}</span> <span class="bp">↔</span>   <span class="n">A</span> <span class="n">x</span>                       <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
              <span class="bp">...</span> <span class="bp">↔</span> <span class="bp">¬¬</span><span class="n">A</span> <span class="n">x</span>                       <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">not.not_iff</span>
              <span class="bp">...</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="bp">¬¬</span><span class="n">A</span> <span class="n">z</span><span class="o">}</span>             <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">mem_set_of_eq</span>
              <span class="bp">...</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="bp">¬</span><span class="o">(</span><span class="n">z</span> <span class="bp">∈</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">¬</span><span class="n">A</span> <span class="n">y</span><span class="o">})}</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">conv</span> <span class="k">in</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">_</span> <span class="bp">∈</span> <span class="n">_</span><span class="o">)</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">mem_set_of_eq</span> <span class="o">}</span> <span class="c1">-- this does not work!</span>
              <span class="bp">...</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">compl</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">¬</span><span class="n">A</span> <span class="n">y</span><span class="o">}</span>        <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
  <span class="kd">end</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="297221889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297221889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Palm <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297221889">(Sep 05 2022 at 12:52)</a>:</h4>
<p><span class="user-mention" data-user-id="127136">@Alex J. Best</span> This is nice. Thank you. This is very helpful. I have not known <code>conv</code> before. But why is that necessary? What is the <code>p : Ω → Prop</code> that <code>mem_set_of_eq</code> has inferred here?  <code>¬A</code> and <code>¬A _</code> obviously do not work.</p>



<a name="297222916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297222916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297222916">(Sep 05 2022 at 13:00)</a>:</h4>
<p>The issue isn't that rw isn't inferring the right argument (as you saw you could force the arguments with the @ symbol), it is because rewrite doesn't work "under binders", for example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">add_comm</span><span class="o">,</span> <span class="c1">--fails</span>
<span class="kd">end</span>
</code></pre></div>
<p>here there are a few ways around the issue</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">lemma</span> <span class="n">a</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">add_comm</span><span class="o">,</span>
<span class="kd">end</span>


<span class="kd">lemma</span> <span class="n">b</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">conv</span> <span class="k">in</span> <span class="o">(</span><span class="n">_</span> <span class="bp">+</span> <span class="n">_</span><span class="o">)</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">add_comm</span><span class="o">,</span> <span class="o">}</span>
<span class="kd">end</span>
<span class="k">#print</span> <span class="n">b</span>

<span class="kd">lemma</span> <span class="n">c</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">add_comm</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="297223029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297223029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297223029">(Sep 05 2022 at 13:00)</a>:</h4>
<p>Using simp with the right arguments would probably also work in your case too</p>



<a name="297223133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297223133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297223133">(Sep 05 2022 at 13:01)</a>:</h4>
<p>We also have a nice doc page on conv mode if you havent seen it already: <a href="https://leanprover-community.github.io/extras/conv.html">https://leanprover-community.github.io/extras/conv.html</a></p>



<a name="297223343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297223343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Palm <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297223343">(Sep 05 2022 at 13:03)</a>:</h4>
<p>Thanks! That's exactly the piece of information I needed!</p>



<a name="297276368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297276368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297276368">(Sep 05 2022 at 20:43)</a>:</h4>
<p><span class="user-mention" data-user-id="528193">@Michael Palm</span> not sure if someone mentioned this already but you can also use <code>simp_rw</code>, which acts like <code>rw</code> except it <em>can</em> work under binders</p>



<a name="297342748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297342748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alberto Navarro Garmendia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297342748">(Sep 06 2022 at 10:41)</a>:</h4>
<p>Hello! I have an Apple M1 laptop and I am trying to install LEAN following the instructions of <a href="https://leanprover-community.github.io/install/macos.html">https://leanprover-community.github.io/install/macos.html</a> </p>
<p>Unfortunately, I made the mistake of  first trying the Intel instructions <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span> <br>
When I tryed to follow the M1 instructions it gets stucked at point 3.   Can someone help?</p>
<p>More info, following the instructions just mean copy-paste in the terminal window all commands from the instructions. I do not know what they actually mean. More concretely:</p>
<p>1.1) I copy-paste at the terminal "xcode-select --install" at terminal. It says "error: tools are already installed"<br>
1.2) I copy-paste at the terminal "softwareupdate --install-rosetta", agree, and then the console says "install of Rosetta 2 finished succesfully"<br>
2.1) I copy-paste at the terminal "arch -x86_64 zsh", it doesn't say anything at all<br>
3.1) I copy-paste at the terminal " /bin/bash -c "$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh">https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh</a>)" "<br>
3.1.1) I introduce at the terminal my administrator password. The terminal says "this script will install blablabla... please RETURN/ENTER to continuo or any other key to abort"<br>
3.1.2) I press RETURN<br>
3.1.3) The terminal does its thing for a while (says "Downloading and installing Homebrew... blablabla..."  and then gets stucked while showing<br>
"error: Not a valid ref: refs/remotes/origin/master<br>
fatal: ambiguous argument 'refs/remotes/origin/master': unknown revision or path not in the working tree.<br>
Use '--' to separate paths from revisions, like this:<br>
'git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]'<br>
"</p>
<p>Any help?</p>



<a name="297344240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297344240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alberto Navarro Garmendia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297344240">(Sep 06 2022 at 10:53)</a>:</h4>
<p>Wait, the problem was myself for not waiting enough. It now says "Installation successful" </p>
<p>4.1) I copy paste at the terminal <br>
" /usr/local/bin/brew install elan-init mathlibtools<br>
elan toolchain install stable <br>
elan default stable  "<br>
the terminal answers <br>
"Running <code>brew update --auto-update</code>...<br>
fatal: Could not resolve HEAD to a revision<br>
Warning: No available formula with the name "elan-init".<br>
==&gt; Searching for similarly named formulae...<br>
Error: No similarly named formulae found.<br>
==&gt; Searching for a previously deleted formula (in the last month)...<br>
Error: No previously deleted formula found.<br>
==&gt; Searching taps on GitHub...<br>
Error: No formulae found in taps.<br>
zsh: command not found: elan<br>
zsh: command not found: elan<br>
"<br>
4.2) I copy paste only the first line. It returns<br>
"Warning: No available formula with the name "elan-init".<br>
==&gt; Searching for similarly named formulae...<br>
Error: No similarly named formulae found.<br>
==&gt; Searching for a previously deleted formula (in the last month)...<br>
Error: No previously deleted formula found.<br>
==&gt; Searching taps on GitHub...<br>
Error: No formulae found in taps."</p>
<p>4.2) I copy paste the second line "elan toolchain install stable". The terminal does nothing</p>
<p>4.3) I copy paste the third line "elan default stable " it returns, "zsh: command not found: elan"</p>
<p>I think this is broken now. In any case I continue</p>
<p>5) I copy paste "brew install --cask visual-studio-code &amp;&amp; code --install-extension jroesch.lean". It returns</p>
<p>"==&gt; Downloading <a href="https://update.code.visualstudio.com/1.71.0/darwin/stable">https://update.code.visualstudio.com/1.71.0/darwin/stable</a><br>
==&gt; Downloading from <a href="https://az764295.vo.msecnd.net/stable/784b0177c56c607789f96">https://az764295.vo.msecnd.net/stable/784b0177c56c607789f96</a><br>
######################################################################## 100.0%<br>
==&gt; Installing Cask visual-studio-code<br>
==&gt; Moving App 'Visual Studio <a href="http://Code.app">Code.app</a>' to '/Applications/Visual Studio <a href="http://Code.app">Code.app</a><br>
==&gt; Linking Binary 'code' to '/usr/local/bin/code'<br>
<span aria-label="beer" class="emoji emoji-1f37a" role="img" title="beer">:beer:</span>  visual-studio-code was successfully installed!<br>
Installing extensions...<br>
Installing extension 'jroesch.lean'...<br>
(node:18998) [DEP0005] DeprecationWarning: Buffer() is deprecated due to security and usability issues. Please use the Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() methods instead.<br>
(Use <code>Electron --trace-deprecation ...</code> to show where the warning was created)<br>
Extension 'jroesch.lean' v0.16.54 was successfully installed."</p>
<p>Am I finished? Is it correctly installed? <br>
I don't think so. I dont find LEAN anywhere in my laptop</p>



<a name="297395949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297395949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297395949">(Sep 06 2022 at 14:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="380294">Matt Diamond</span> <a href="#narrow/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA/near/297276368">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="528193">Michael Palm</span> not sure if someone mentioned this already but you can also use <code>simp_rw</code>, which acts like <code>rw</code> except it <em>can</em> work under binders</p>
</blockquote>
<p>Though <code>simp_rw</code> has the occasionally undesirable (though mostly desirable) behaviour that it will repeat things until they stabilize, which <code>rw</code> won't do. Which occasionally leaves one in an odd position.</p>



<a name="297523186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/297523186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#297523186">(Sep 07 2022 at 05:23)</a>:</h4>
<p><code>simp only [lemma] {single_pass := tt}</code> avoids that</p>



<a name="299187714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/299187714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#299187714">(Sep 16 2022 at 15:41)</a>:</h4>
<p>Oh that's cool, didn't know that was a thing.</p>



<a name="299187800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/299187800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#299187800">(Sep 16 2022 at 15:41)</a>:</h4>
<p>What is the difference between <code>simp_rw</code> and <code>simp only</code>?</p>



<a name="299220234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/299220234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#299220234">(Sep 16 2022 at 18:37)</a>:</h4>
<p>nobody knows :-) I think sometimes one works and the other doesn't? They both in theory do the same thing. Chris Hughes once told me that he didn't understand why <code>simp_rw</code> was even added to mathlib, given that <code>simp only</code> was already there.</p>



<a name="299243889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/299243889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#299243889">(Sep 16 2022 at 21:28)</a>:</h4>
<p>The former is implemented in terms of the latter</p>



<a name="299254079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/299254079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#299254079">(Sep 16 2022 at 23:08)</a>:</h4>
<p>Weird... the docs say:</p>
<blockquote>
<p>For example, neither <code>simp</code> nor <code>rw</code> can solve the following, but <code>simp_rw</code> can:</p>
</blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="bp">''</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp_rw</span> <span class="o">[</span><span class="n">set.image_subset_iff</span><span class="o">,</span> <span class="n">set.subset_def</span><span class="o">]</span>
</code></pre></div>
<p>But if you replace <code>simp_rw</code> with <code>simp</code>, it still works fine. Maybe <code>simp</code> used to be weaker?</p>



<a name="299254280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/299254280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#299254280">(Sep 16 2022 at 23:11)</a>:</h4>
<p>well, this is the PR where it was added (and it has a Zulip link for context), so if anyone's actually curious, the answer is here: <a href="https://github.com/leanprover-community/mathlib/pull/1900">https://github.com/leanprover-community/mathlib/pull/1900</a></p>



<a name="299254521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/299254521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#299254521">(Sep 16 2022 at 23:14)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> you were there when <span class="user-mention" data-user-id="238446">@Anne Baanen</span> came up with it! "nobody knows :-)" lol</p>



<a name="299254689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/299254689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#299254689">(Sep 16 2022 at 23:16)</a>:</h4>
<p>in your defense it was 2.5 years ago</p>



<a name="299527967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20mem_set_of_eq%20with%20%20%C2%ACA/near/299527967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20use.20mem_set_of_eq.20with.20.20.C2.ACA.html#299527967">(Sep 19 2022 at 09:12)</a>:</h4>
<p><code>simp_rw</code> actually has the advantage that it does its re-writes in order and you can click midway through to see how far it gets (like <code>rw</code>). That is something I do find useful sometimes, to work out how a simplification is happening.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
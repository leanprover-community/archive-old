---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/lean4.20newbie.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html">lean4 newbie</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="275071449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/275071449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#275071449">(Mar 12 2022 at 02:23)</a>:</h4>
<p>There's a theorem <code>absurd : ∀ {a b : Prop}, a → ¬a → b</code>. For decidable equality (like <code>Nat</code>), you can use <code>by decide</code> as in <code>example : ¬1 = 2 := by decide</code>. There are also <code>noConfusion</code> declarations for inductive types, which you might need elsewhere. <code>&lt;type&gt;.noConfusion</code> is the primitive for showing that an inductive type's constructors are injective and disjoint:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">¬</span><span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">Nat.noConfusion</span> <span class="n">h</span>
<span class="c1">-- or just this, but it might be less clear.</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">¬</span><span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">Nat.noConfusion</span>
</code></pre></div>



<a name="275071581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/275071581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#275071581">(Mar 12 2022 at 02:26)</a>:</h4>
<p>In the future, you're probably better off posting in the <code>new members</code> stream and not the <code>rss</code> stream.</p>



<a name="275072273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/275072273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#275072273">(Mar 12 2022 at 02:44)</a>:</h4>
<p>This topic was moved here from <a class="stream-topic" data-stream-id="116290" href="/#narrow/stream/116290-rss/topic/lean4.20newbie">#rss &gt; lean4 newbie</a> by <span class="user-mention silent" data-user-id="306601">Kyle Miller</span>.</p>



<a name="275075489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/275075489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#275075489">(Mar 12 2022 at 04:06)</a>:</h4>
<p>A question about lean 4 syntax. I'd like to illustrate this with a basic example of a vector.<br>
For starters the following type checks correctly as it should:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Vector</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">Empty</span> <span class="o">:</span> <span class="n">Vector</span> <span class="n">α</span> <span class="n">zero</span>
  <span class="bp">|</span> <span class="n">Cons</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Vector</span> <span class="n">α</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">Vector</span> <span class="n">α</span> <span class="o">(</span><span class="n">succ</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>When replacing the <code>Nat</code> in the first line with <code>\N</code>, it still typechecks, which makes sense because <code>\N</code> is synonymous with <code>Nat</code>(<a href="https://leanprover.github.io/logic_and_proof/the_natural_numbers_and_induction_in_lean.html">https://leanprover.github.io/logic_and_proof/the_natural_numbers_and_induction_in_lean.html</a>) (I am aware this isn't specific to lean 4 but I couldn't find anything equivalent) </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Vector</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">Empty</span> <span class="o">:</span> <span class="n">Vector</span> <span class="n">α</span> <span class="n">zero</span>
  <span class="bp">|</span> <span class="n">Cons</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Vector</span> <span class="n">α</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">Vector</span> <span class="n">α</span> <span class="o">(</span><span class="n">succ</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>However replacing the Nat inside Cons with <code>\N</code> yields a type error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Vector</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">Empty</span> <span class="o">:</span> <span class="n">Vector</span> <span class="n">α</span> <span class="n">zero</span>
  <span class="bp">|</span> <span class="n">Cons</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Vector</span> <span class="n">α</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">Vector</span> <span class="n">α</span> <span class="o">(</span><span class="n">succ</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>The error is </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">application</span> <span class="n">type</span> <span class="n">mismatch</span>
  <span class="n">succ</span> <span class="n">x</span>
<span class="n">argument</span>
  <span class="n">x</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">ℕ</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">Nat</span> <span class="o">:</span> <span class="kt">Type</span>
</code></pre></div>
<p>which must mean <code>\N</code> and <code>Nat</code>are not seen as synonymous here. Why is this happening, has something changed in lean 4 and <code>\N</code> and <code>Nat</code> are no longer synonymous? If so, why did the second example type check correctly?</p>



<a name="275109456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/275109456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#275109456">(Mar 12 2022 at 18:08)</a>:</h4>
<p>The <code>ℕ</code> is no longer associated with <code>Nat</code> by default (it still is in Mathlib). The second example doesn't type check for me on milestone 3 so I assume we're using different versions, but I think the rest of what you're seeing is a consequence of the <code>autoImplicit</code> feature and some of the relaxed error reporting around that.</p>



<a name="277921806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/277921806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chiyoku <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#277921806">(Apr 05 2022 at 18:18)</a>:</h4>
<p>Hi, i'm trying to make a simple mutual recursion but i'm getting an strange error with the assumption tatic. <a href="/user_uploads/3121/MpDVaLBJLrOhFYE_cku027Hh/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/MpDVaLBJLrOhFYE_cku027Hh/image.png" title="image.png"><img src="/user_uploads/3121/MpDVaLBJLrOhFYE_cku027Hh/image.png"></a></div>



<a name="277927304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/277927304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#277927304">(Apr 05 2022 at 18:52)</a>:</h4>
<p><span class="user-mention" data-user-id="481858">@Chiyoku</span> That doesn't look like a newbie issue. You might want to post it in the <a class="stream" data-stream-id="270676" href="/#narrow/stream/270676-lean4">#lean4</a> stream.<br>
Also, please post text using <a href="https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks">#backticks</a> instead of a screenshot</p>



<a name="278846247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/278846247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> chensc <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#278846247">(Apr 13 2022 at 15:43)</a>:</h4>
<p>Hey guys, just some silly question from a completely newbie. Naively, I expect the code </p>
<p>def W : Type := Nat<br>
def n : W := 4</p>
<p>to behave just like</p>
<p>def n : Nat := 4</p>
<p>But it returns error, so I suppose something is wrong regarding my understanding of the Type object.<br>
Can someone explain it?</p>



<a name="278846590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/278846590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#278846590">(Apr 13 2022 at 15:45)</a>:</h4>
<p>If you do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[reducible]</span> <span class="kd">def</span> <span class="n">W</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">Nat</span>
<span class="kd">def</span> <span class="n">n</span> <span class="o">:</span> <span class="n">W</span> <span class="o">:=</span> <span class="mi">4</span>
</code></pre></div>
<p>then yes it will behave almost exactly the same.</p>



<a name="278847021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/278847021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#278847021">(Apr 13 2022 at 15:48)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks">#backticks</a><br>
This also works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">abbrev</span> <span class="n">W</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">Nat</span>
<span class="kd">def</span> <span class="n">n</span> <span class="o">:</span> <span class="n">W</span> <span class="o">:=</span> <span class="mi">4</span>
</code></pre></div>



<a name="278847373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/278847373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#278847373">(Apr 13 2022 at 15:50)</a>:</h4>
<p>Note that the reason it doesnt work per default is that lean will not per default eagerly unfold the definition of W to see that its actually a Nat, that is what the abbrev/reducible do</p>



<a name="278847413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/278847413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> chensc <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#278847413">(Apr 13 2022 at 15:51)</a>:</h4>
<p>Thanks! However, </p>
<p>@[reducible] def W : Type := Nat<br>
#check W.add</p>
<p>still returns an error.</p>



<a name="278847658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/278847658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#278847658">(Apr 13 2022 at 15:52)</a>:</h4>
<p>That's for a different reason. you see Lean is not an object oriented language so the function <code>add</code> is not defined on the type <code>Nat</code> but rather in a namespace named <code>Nat</code> which can (in theory) exist without a type <code>Nat</code> so this wont just magically carry over to <code>W</code></p>



<a name="278847804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/278847804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#278847804">(Apr 13 2022 at 15:53)</a>:</h4>
<p>You can however:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">W</span>

<span class="kd">def</span> <span class="n">add</span> <span class="o">:</span> <span class="n">W</span> <span class="bp">→</span> <span class="n">W</span> <span class="bp">→</span> <span class="n">W</span> <span class="o">:=</span> <span class="n">Nat.add</span>

<span class="kd">end</span> <span class="n">W</span>
</code></pre></div>
<p>or:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">W.add</span> <span class="o">:</span> <span class="n">W</span> <span class="bp">→</span> <span class="n">W</span> <span class="bp">→</span> <span class="n">W</span> <span class="o">:=</span> <span class="n">Nat.add</span>
</code></pre></div>



<a name="278847907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/278847907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> chensc <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#278847907">(Apr 13 2022 at 15:54)</a>:</h4>
<p>I see. So there is an automatic self-identification between the apriori non-connected "Nat" as a type and the namespace "Nat"?</p>



<a name="278848198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/278848198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#278848198">(Apr 13 2022 at 15:56)</a>:</h4>
<p>Yes Lean 4 does have some mechanisms to figure out that a certain function is hidden behind a namespace when called on a type, example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">abbrev</span> <span class="n">W</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">Nat</span>

<span class="kd">def</span> <span class="n">W.add</span> <span class="o">:</span> <span class="n">W</span> <span class="bp">→</span> <span class="n">W</span> <span class="bp">→</span> <span class="n">W</span> <span class="o">:=</span> <span class="n">Nat.add</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">W</span> <span class="o">:=</span> <span class="mi">2</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">foo.add</span> <span class="mi">12</span> <span class="bp">=</span> <span class="n">W.add</span> <span class="n">foo</span> <span class="mi">12</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rfl</span>
</code></pre></div>



<a name="278857567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/278857567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> chensc <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#278857567">(Apr 13 2022 at 16:59)</a>:</h4>
<p>Another question: if natural numbers are defined inductively  in an unary basis, is it the case that expressions like " 5 + 5" are computed like the mathematical definition of natural numbers\ordinal arithmetic? As it would be highly inefficient, I guess there is some distinction between computational arithmetic of LEAN as programing language and mathematical numbers? But is so, then what is the correlation between "5 + 5" and "Nat.add 5 5"?</p>



<a name="278858097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/278858097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#278858097">(Apr 13 2022 at 17:02)</a>:</h4>
<p>5 + 5 is indeed turned into Nat.add 5 5 by means of notation and type class inference, however while the lean implementation would indeed be highly inefficient the compiled version of Lean 4 does rely on a more efficient internal representation of natural numbers which allows them to be computed basically as efficient as integers in languages like python.</p>



<a name="278858194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/278858194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#278858194">(Apr 13 2022 at 17:03)</a>:</h4>
<p>This is indicated by the extern attribute on the implementation here: <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.add#doc">docs4#Nat.add</a> which points to the C implementation using the efficient internal representation</p>



<a name="278858895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/278858895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> chensc <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#278858895">(Apr 13 2022 at 17:08)</a>:</h4>
<p>I see, thank you!</p>



<a name="278939472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/278939472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> chensc <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#278939472">(Apr 14 2022 at 08:57)</a>:</h4>
<p>One more question from the TPIL4, regarding the following code:</p>
<p>universe u v</p>
<p>def f (α : Type u) (β : α → Type v) (a : α) (b : β a) : (a : α) × β a :=<br>
  ⟨a, b⟩</p>
<p>def h1 (x : Nat) : Nat :=<br>
  (f Type (fun α =&gt; α) Nat x).2</p>
<p>Is the expression "(f Type (fun α =&gt; α) Nat x).2" supposed to be the second coordinate of a generalized ordered pair? And if so, why does the equivalent "(f Type (fun α =&gt; α) Nat x).1" return error?</p>



<a name="278943749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/278943749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#278943749">(Apr 14 2022 at 09:42)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks">#backticks</a> will help you format your texts better here on Zulip.<br>
What's the error message?</p>



<a name="278943982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/278943982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> chensc <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#278943982">(Apr 14 2022 at 09:45)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span>
  <span class="o">(</span><span class="n">f</span> <span class="kt">Type</span> <span class="o">(</span><span class="k">fun</span> <span class="n">α</span> <span class="bp">=&gt;</span> <span class="n">α</span><span class="o">)</span> <span class="n">Nat</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">fst</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="kt">Type</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">1</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">Nat</span> <span class="o">:</span> <span class="kt">Type</span>
</code></pre></div>



<a name="278944342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/278944342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#278944342">(Apr 14 2022 at 09:49)</a>:</h4>
<p>There you go. The code says that <code>h1</code> should output a term of type <code>Nat</code>. Look: <code>def H1 ... : Nat</code>. But the first coordinate of what <code>f</code> returns is of type <code>Type</code>.</p>



<a name="278944543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/278944543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#278944543">(Apr 14 2022 at 09:52)</a>:</h4>
<p>You can remove that part that explicitly states the output type of <code>h1</code> and let Lean infer it. Then you can use <code>#check h1</code> and you should see the difference between those two alternatives</p>



<a name="278945015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20newbie/near/278945015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> chensc <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20newbie.html#278945015">(Apr 14 2022 at 09:57)</a>:</h4>
<p>Cool, thanks a lot!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
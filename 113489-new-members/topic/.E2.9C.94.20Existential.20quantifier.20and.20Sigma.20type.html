---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html">✔ Existential quantifier and Sigma type</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="264694748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/264694748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#264694748">(Dec 13 2021 at 11:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> has marked this topic as resolved.</p>



<a name="268436402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268436402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268436402">(Jan 18 2022 at 18:37)</a>:</h4>
<p>TPIL chapter 7.3.<br>
<a href="/user_uploads/3121/GaJN5uyDIzfY4qx0rMMhqoj1/image.png">image.png</a> <br>
This inaccuracy (<code>{α : Type*}</code> instead of <code>{α : Sort*}</code> or <code>{α : Sort u}</code>) is intentional, right?</p>
<div class="message_inline_image"><a href="/user_uploads/3121/GaJN5uyDIzfY4qx0rMMhqoj1/image.png" title="image.png"><img src="/user_uploads/3121/GaJN5uyDIzfY4qx0rMMhqoj1/image.png"></a></div>



<a name="268437316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268437316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268437316">(Jan 18 2022 at 18:44)</a>:</h4>
<p>Actually, is there any good use case for an existential quantifier with <code>{α : Prop}</code> as the type of the quantified object?<br>
"There is a proof of proposition P such that (...)"</p>



<a name="268437671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268437671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268437671">(Jan 18 2022 at 18:47)</a>:</h4>
<p>We cannot extract any information from inside the proof, right?</p>



<a name="268437804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268437804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268437804">(Jan 18 2022 at 18:48)</a>:</h4>
<p>So, would it restrict us in anything if the existential quantifier were defined really for <code>{α : Type*}</code> as TPIL says?</p>



<a name="268437850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268437850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268437850">(Jan 18 2022 at 18:48)</a>:</h4>
<p>Yes, it is sometimes useful, if you need to pass the proof of P to a function that appears in the second part (e.g. <a href="https://leanprover-community.github.io/mathlib_docs/find/list.nth_le">docs#list.nth_le</a>)</p>



<a name="268437892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268437892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268437892">(Jan 18 2022 at 18:48)</a>:</h4>
<p>It also automatically shows up with "collection binders":</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>That's short for</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="268438451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268438451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268438451">(Jan 18 2022 at 18:52)</a>:</h4>
<p>Note that <code>∃ (p : P), Q</code> is equivalent to <code>P ∧ Q</code>.</p>



<a name="268440517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268440517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268440517">(Jan 18 2022 at 19:08)</a>:</h4>
<p>Right, so <code>∃</code> on a proposition is a kind of "dependent AND".</p>



<a name="268440752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268440752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268440752">(Jan 18 2022 at 19:09)</a>:</h4>
<p>Why cannot the code above be translated simply to ?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">/\</span> <span class="o">(</span><span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="268441153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268441153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268441153">(Jan 18 2022 at 19:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type/near/268440517">said</a>:</p>
<blockquote>
<p>Right, so <code>∃</code> on a proposition is a kind of "dependent AND".</p>
</blockquote>
<p>Every existential quantification is afaik a dependent sum type which is a generalization of the product type. Curry-Howard correspondence says that the product type models AND so yes.</p>



<a name="268441238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268441238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268441238">(Jan 18 2022 at 19:13)</a>:</h4>
<p>Probably easier to understand it is when you replace "dependent sum type" by "dependent tuple" and "product type" by "tuple".</p>



<a name="268441815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268441815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268441815">(Jan 18 2022 at 19:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type/near/268440517">said</a>:</p>
<blockquote>
<p>Right, so <code>∃</code> on a proposition is a kind of "dependent AND".</p>
</blockquote>
<p>TLDR: <code>∃</code> on anything is a dependent tuple; AND is a tuple. You are right.</p>



<a name="268451472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268451472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268451472">(Jan 18 2022 at 20:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type/near/268440752">said</a>:</p>
<blockquote>
<p>Why cannot the code above be translated simply to ?</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">/\</span> <span class="o">(</span><span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Except for the fact it should be <code>x ∈ s</code> rather than <code>s x</code> since it's a <code>set</code>, it <em>could</em> be translated to that (and in fact, once you <code>simp</code> it the inner exists becomes a conjunction), but from the Lean parser's point of view, it's simpler to do it the first way.</p>
<p>This does not explain <em>why</em> <code>Exists</code> is the way it is. I looked into the history, and the collection binders feature was added July 2016 by Leo (who called them "cute binders" in the commit message). Even after this feature was introduced, the definition of <code>Exists</code> was</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Exists</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">intro</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">P</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">Exists</span> <span class="n">P</span>
</code></pre></div>
<p>(<a href="https://github.com/leanprover-community/lean/blob/f461b53a7fa7477c367edddb386252b261c2014e/library/init/logic.lean#L530">link</a>)</p>
<p>It wouldn't be until Sep 2016 that <code>Exists</code> got universe variables</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Exists</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">P</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">Exists</span>
</code></pre></div>
<p>(<a href="https://github.com/leanprover-community/lean/blob/5e8f2add8439226027cc9df186f3f7442f038e05/library/init/logic.lean#L574">link</a>)</p>
<p>I believe this is back when <code>Type 0</code> was <code>Prop</code>. Perhaps this explains the inaccuracy in TPIL?</p>



<a name="268453092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268453092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268453092">(Jan 18 2022 at 20:46)</a>:</h4>
<p>So why is there the variable <code>(H : x ∈ s)</code> if I can write it the simpler way?</p>



<a name="268453360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268453360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268453360">(Jan 18 2022 at 20:49)</a>:</h4>
<p>Would it be still relevant if there was the existential quantifier only?</p>



<a name="268456493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268456493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268456493">(Jan 18 2022 at 21:13)</a>:</h4>
<p>I think the intention was to have a quantifier-polymoprhic pattern. For example, <code>(∃ (x ∈ s), P x)</code> is logically equivalent to <code>(∃ x, x ∈ s ∧ P x)</code>, and <code>(∀ (x ∈ s), P x)</code> is logically equivalent to <code>(∀ x, x ∈ s → P x)</code>. So, you would need to handle them separately when implementing the pattern (and you would already have to define conjunction to use it). On the other hand, you can write the first one as <code>(∃ x, ∃ (H : x ∈ s), P x)</code> and the second one as <code>(∀ x, ∀ (H : x ∈ s), P x)</code>. So, in general, it is translated to <code>(? x, ? (H : x ∈ s), P x)</code> for some binder <code>?</code>. So, for example, Lean can translate <code>(∃! (x ∈ s), P x)</code> to <code>(∃! x, ∃! (H : x ∈ s), P x)</code> without knowing anything about how <code>∃!</code> is implemented.</p>



<a name="268456518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268456518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268456518">(Jan 18 2022 at 21:13)</a>:</h4>
<p>I don't know whether this works for any binder, though.</p>



<a name="268457083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268457083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268457083">(Jan 18 2022 at 21:18)</a>:</h4>
<p>it doesn't really work for <code>∃!</code> (in the sense that this isn't what multiple <code>∃!</code> is supposed to mean usually)</p>



<a name="268457179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268457179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268457179">(Jan 18 2022 at 21:19)</a>:</h4>
<p>but the desugaring does work in this way uniformly for any binder, and surprisingly often it gets the mathematically right answer</p>



<a name="268457690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268457690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268457690">(Jan 18 2022 at 21:23)</a>:</h4>
<p>Actually, <code>∃! (x ∈ s), P x</code> does basically work because <code>∃! (H : p), q</code> is also equivalent to <code>p /\ q</code>, but <code>∃! x y : A, P x y</code> does not work as one would expect</p>



<a name="268458848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268458848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268458848">(Jan 18 2022 at 21:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type/near/268457083">said</a>:</p>
<blockquote>
<p>it doesn't really work for <code>∃!</code> (in the sense that this isn't what multiple <code>∃!</code> is supposed to mean usually)</p>
</blockquote>
<p>Wait. Was multiple <code>∃!</code> actually supposed to mean _anything_?</p>



<a name="268460688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268460688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268460688">(Jan 18 2022 at 21:49)</a>:</h4>
<p>If you say "there exists a unique x, y such that P(x,y)" in mathematics it usually means what you would write as <code>∃! p : A × A, P p.1 p.2</code> in lean</p>



<a name="268460798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268460798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268460798">(Jan 18 2022 at 21:50)</a>:</h4>
<p>"there exists a unique x such that there exists a unique y such that P(x, y)" is a very weird thing that I don't think ever comes up</p>



<a name="268461142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268461142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268461142">(Jan 18 2022 at 21:53)</a>:</h4>
<p>This is an accurate depiction of me today:<br>
<a href="/user_uploads/3121/A1g0TCag2qr35KoDUwW_LPUK/I_fear_no_quantifier.png">I_fear_no_quantifier.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/A1g0TCag2qr35KoDUwW_LPUK/I_fear_no_quantifier.png" title="I_fear_no_quantifier.png"><img src="/user_uploads/3121/A1g0TCag2qr35KoDUwW_LPUK/I_fear_no_quantifier.png"></a></div>



<a name="268463043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268463043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268463043">(Jan 18 2022 at 22:08)</a>:</h4>
<p>ORIGINAL IMAGE:<br>
Team Fortress 2 [teamfortress]. (2012, June 27). Meet the Pyro [Digital image / screen capture]. YouTube. Retrieved January 18, 2022, from <a href="https://ahseeit.com/?qa=16537/i-fear-no-man-meme">https://ahseeit.com/?qa=16537/i-fear-no-man-meme</a></p>



<a name="268467114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268467114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268467114">(Jan 18 2022 at 22:46)</a>:</h4>
<p>I've never seen a meme come with a citation before <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="268467248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268467248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268467248">(Jan 18 2022 at 22:48)</a>:</h4>
<p>Clear difference between discord and zulip.</p>



<a name="268472332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268472332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268472332">(Jan 18 2022 at 23:37)</a>:</h4>
<p>Indeed, <code>(∃! (x y : α), P x y)</code> is not the same thing as <code>(∃! (xy : α × α), P xy.fst xy.snd)</code>. Can you actually construct a counterexample where they differ?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">¬Π</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span>
  <span class="o">(</span><span class="bp">∃!</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">↔</span>
  <span class="o">(</span><span class="bp">∃!</span> <span class="o">(</span><span class="n">xy</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">),</span> <span class="n">P</span> <span class="n">xy.fst</span> <span class="n">xy.snd</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<div class="spoiler-block"><div class="spoiler-header">
<p>Solution</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">¬Π</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span>
  <span class="o">(</span><span class="bp">∃!</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">↔</span>
  <span class="o">(</span><span class="bp">∃!</span> <span class="o">(</span><span class="n">xy</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">),</span> <span class="n">P</span> <span class="n">xy.fst</span> <span class="n">xy.snd</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">generalize</span> <span class="n">hd</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">bool</span><span class="o">),</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">P</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">},</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">ff</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">ff</span><span class="o">)</span> <span class="bp">∨</span>
    <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">tt</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">ff</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">tt</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">tt</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">subst</span> <span class="n">hd</span><span class="o">,</span> <span class="n">cases</span> <span class="n">x</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">y</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">_</span><span class="o">)</span> <span class="o">((</span><span class="n">h</span> <span class="n">P</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">simp_rw</span> <span class="n">exists_unique</span><span class="o">,</span> <span class="n">push_neg</span><span class="o">,</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">⟩</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">dsimp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hp</span> <span class="n">at</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">rcases</span> <span class="n">h₁</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">h₁</span><span class="o">,</span> <span class="n">h₂</span><span class="o">⟩</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">h₁</span><span class="o">,</span> <span class="n">h₂</span><span class="o">⟩</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">h₁</span><span class="o">,</span> <span class="n">h₂</span><span class="o">⟩</span><span class="bp">;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">h₁</span><span class="o">,</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">hp</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">use</span> <span class="o">[</span><span class="n">ff</span><span class="o">,</span> <span class="n">ff</span><span class="o">]</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hp</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">h₂</span><span class="o">⟩,</span> <span class="n">cases</span> <span class="n">y</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">h₂</span> <span class="n">_</span> <span class="o">(</span><span class="n">or.inr</span> <span class="n">rfl</span><span class="o">),</span> <span class="n">cases</span> <span class="n">h₂</span> <span class="n">_</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">rfl</span><span class="o">)</span> <span class="o">}},</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="268472762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268472762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268472762">(Jan 18 2022 at 23:43)</a>:</h4>
<p>Metamath has a fascinating series of theorems about this, see <a href="http://us.metamath.org/mpeuni/mmtheorems26.html#2eu1">2eu1</a> and other theorems around it</p>



<a name="268473072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268473072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268473072">(Jan 18 2022 at 23:47)</a>:</h4>
<p>The only way I know to reliably write n-ary existential uniqueness without product types is</p>
<p><code>∃ x1 ... xn, ∀ y1 ... yn, P y1 ... yn &lt;-&gt; x1 = y1 /\ ... /\ xn = yn</code></p>



<a name="268473153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268473153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268473153">(Jan 18 2022 at 23:48)</a>:</h4>
<p>which does not lend itself well to a compositional formulation</p>



<a name="268474834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268474834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268474834">(Jan 19 2022 at 00:07)</a>:</h4>
<p>Reminds me of Euler's 36 officer problem (aka orthogonal Latin squares) whose quantum version is recently in the news is basically about finding 4-ary predicate P on <code>fin 6</code> such that <br>
<code>P x1 x2 x3 x4 /\ P y1 y2 y3 y4 /\ x1 = y1 /\ x2 = y2 -&gt; x3 = y3 /\ x4 = y4</code> for all <code>xi, yi</code> and the same for all permutations of 1,2,3,4. Wondering whether an impossibility proof has been formalized (not sure about the least amount of computation required among proofs now known).<br>
(edit: this isn't quite right, needs some condition to ensure there are at least 36 elements that evaluates to true.)</p>



<a name="268482750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268482750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268482750">(Jan 19 2022 at 01:55)</a>:</h4>
<p>golfed Patrick Johnson's example using <code>bor</code>, and provided a proof that the latter always implies the former, intuitionistically:</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>Solution</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">¬Π</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span>
  <span class="o">(</span><span class="bp">∃!</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃!</span> <span class="o">(</span><span class="n">xy</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">),</span> <span class="n">P</span> <span class="n">xy.fst</span> <span class="n">xy.snd</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="n">cases</span> <span class="bp">@</span><span class="n">unique_of_exists_unique</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">||</span> <span class="n">y</span><span class="o">)</span> <span class="o">⟨</span><span class="n">ff</span><span class="o">,</span> <span class="o">⟨</span><span class="n">tt</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">id</span><span class="o">⟩,</span>
  <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span><span class="n">cases</span> <span class="n">x</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="n">exact</span> <span class="n">unique_of_exists_unique</span> <span class="n">hx</span> <span class="n">rfl</span> <span class="n">rfl</span><span class="o">}⟩)</span> <span class="o">(</span><span class="n">tt</span><span class="o">,</span><span class="n">tt</span><span class="o">)</span> <span class="o">(</span><span class="n">tt</span><span class="o">,</span><span class="n">ff</span><span class="o">)</span> <span class="n">rfl</span> <span class="n">rfl</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∃!</span> <span class="o">(</span><span class="n">xy</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">),</span> <span class="n">P</span> <span class="n">xy.fst</span> <span class="n">xy.snd</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃!</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">⟨</span><span class="n">xy</span><span class="o">,</span><span class="n">he</span><span class="o">,</span><span class="n">hu</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">xy.fst</span><span class="o">,</span> <span class="o">⟨</span><span class="n">xy.snd</span><span class="o">,</span> <span class="n">he</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">y</span> <span class="n">h</span><span class="o">,</span> <span class="n">congr_arg</span> <span class="n">prod.snd</span> <span class="o">(</span><span class="n">hu</span> <span class="o">(</span><span class="n">xy.fst</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="n">h</span><span class="o">)⟩,</span>
  <span class="bp">λ</span> <span class="n">x</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span><span class="n">hy</span><span class="o">⟩,</span> <span class="n">congr_arg</span> <span class="n">prod.fst</span> <span class="o">(</span><span class="n">hu</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="n">hy.1</span><span class="o">)⟩</span>
</code></pre></div>
</div></div>
<p>Observations: if <code>bool</code> is replaced by <code>Prop</code>, the example won't work without excluded middle.<br>
If <code>example</code> is replaced by <code>lemma</code>, then it seems the statement become universe polymorphic, and one would have to write <code>{α : Type}</code>.</p>



<a name="268482866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268482866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268482866">(Jan 19 2022 at 01:57)</a>:</h4>
<p>I would guess that you can still prove the example over <code>Prop</code> without excluded middle</p>



<a name="268483560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268483560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268483560">(Jan 19 2022 at 02:08)</a>:</h4>
<p>Hmm, I think you're right.</p>



<a name="268485571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268485571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268485571">(Jan 19 2022 at 02:45)</a>:</h4>
<p>Now this only depends on propext:</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>Solution</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">¬Π</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span>
  <span class="o">(</span><span class="bp">∃!</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃!</span> <span class="o">(</span><span class="n">xy</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">),</span> <span class="n">P</span> <span class="n">xy.fst</span> <span class="n">xy.snd</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">cast</span> <span class="n">eq_true</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">prod.snd</span> <span class="o">(</span><span class="bp">@</span><span class="n">unique_of_exists_unique</span> <span class="n">_</span> <span class="n">_</span>
  <span class="o">(</span><span class="n">h</span> <span class="n">or</span> <span class="o">⟨</span><span class="n">false</span><span class="o">,</span> <span class="o">⟨</span><span class="n">true</span><span class="o">,</span> <span class="n">or.inr</span> <span class="n">trivial</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">y.elim</span> <span class="n">false.elim</span> <span class="n">eq_true_intro</span><span class="o">⟩,</span>
    <span class="bp">λ</span> <span class="n">y</span> <span class="n">heu</span><span class="o">,</span> <span class="n">cast</span> <span class="n">eq_false.symm</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">hy</span><span class="o">,</span> <span class="n">cast</span> <span class="o">(</span><span class="n">unique_of_exists_unique</span> <span class="n">heu</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">hy</span><span class="o">)</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">hy</span><span class="o">))</span> <span class="n">hy</span><span class="o">)⟩)</span>
    <span class="o">(</span><span class="n">true</span><span class="o">,</span><span class="n">false</span><span class="o">)</span> <span class="o">(</span><span class="n">true</span><span class="o">,</span><span class="n">true</span><span class="o">)</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">trivial</span><span class="o">)</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">trivial</span><span class="o">)))</span>
</code></pre></div>
</div></div>



<a name="268487420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268487420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268487420">(Jan 19 2022 at 03:16)</a>:</h4>
<p>It was tricky to find a proof not using propext, but it's possible:</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>Solution</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">T</span> <span class="o">:</span> <span class="bp">¬Π</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span>
  <span class="o">(</span><span class="bp">∃!</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃!</span> <span class="o">(</span><span class="n">xy</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="bp">×</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">P</span> <span class="n">xy.fst</span> <span class="n">xy.snd</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">H</span><span class="o">,</span> <span class="kd">begin</span>
  <span class="k">let</span> <span class="n">P</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">true</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">true</span><span class="o">),</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">true</span><span class="o">,</span> <span class="o">⟨</span><span class="n">true</span><span class="o">,</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">hy.2</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">cases</span> <span class="n">hx</span> <span class="k">with</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">hy.1.1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hq</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">H'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span> <span class="o">(</span><span class="n">hy.2</span> <span class="n">_</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h'</span><span class="o">,</span> <span class="o">(</span><span class="n">h'</span> <span class="n">hq</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span> <span class="n">hz</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">y</span><span class="o">),</span>
    <span class="n">exact</span> <span class="n">true_ne_false</span> <span class="o">((</span><span class="n">H'</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">))</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">H'</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h'</span><span class="o">,</span> <span class="o">(</span><span class="n">hq</span> <span class="n">h'</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">))</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span> <span class="o">},</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">unique_of_exists_unique</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">H</span> <span class="n">P</span> <span class="n">this</span><span class="o">)</span> <span class="o">(</span><span class="n">true</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="o">(</span><span class="n">false</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span>
    <span class="o">⟨</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="bp">$</span> <span class="n">ne.symm</span> <span class="n">true_ne_false</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">exact</span> <span class="n">true_ne_false</span> <span class="o">(</span><span class="n">prod.mk.inj</span> <span class="n">this</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
<span class="kd">end</span>
<span class="k">#print</span> <span class="kd">axioms</span> <span class="n">T</span> <span class="c1">-- no axioms</span>
</code></pre></div>
</div></div>



<a name="268492188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/268492188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#268492188">(Jan 19 2022 at 04:52)</a>:</h4>
<p>If you want an example in <code>Prop</code> without propext you can simply do this, which is a more direct translation of the <code>bor</code> example:</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>Solution</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">T</span> <span class="o">:</span> <span class="bp">¬Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span>
  <span class="o">(</span><span class="bp">∃!</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃!</span> <span class="o">(</span><span class="n">xy</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">),</span> <span class="n">P</span> <span class="n">xy.fst</span> <span class="n">xy.snd</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">true_ne_false</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">prod.snd</span> <span class="o">(</span><span class="bp">@</span><span class="n">unique_of_exists_unique</span> <span class="n">_</span> <span class="n">_</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">true</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">false</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">true</span><span class="o">))</span>
    <span class="o">⟨</span><span class="n">false</span><span class="o">,</span> <span class="o">⟨</span><span class="n">true</span><span class="o">,</span> <span class="n">or.inr</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩,</span>
      <span class="bp">λ</span> <span class="n">y</span> <span class="n">hu</span><span class="o">,</span> <span class="n">hu.elim</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">he</span><span class="o">,</span> <span class="o">(</span><span class="n">true_ne_false</span> <span class="n">he.symm</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">)</span> <span class="n">and.right</span><span class="o">⟩,</span>
      <span class="bp">λ</span> <span class="n">x</span> <span class="n">heu</span><span class="o">,</span> <span class="k">let</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span><span class="n">hs</span><span class="o">,</span><span class="n">hu</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">heu</span> <span class="k">in</span>
        <span class="n">hs.elim</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">ht</span><span class="o">,</span> <span class="n">unique_of_exists_unique</span> <span class="n">heu</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">ht</span><span class="o">)</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">ht</span><span class="o">))</span> <span class="n">and.left</span><span class="o">⟩)</span>
    <span class="o">(</span><span class="n">true</span><span class="o">,</span><span class="n">true</span><span class="o">)</span> <span class="o">(</span><span class="n">true</span><span class="o">,</span><span class="n">false</span><span class="o">)</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">rfl</span><span class="o">)</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">rfl</span><span class="o">)))</span>
</code></pre></div>
</div></div>
<p>My last example translating <code>bor</code> to <code>or</code> is the most direct translation IMO, and I'm glad it works intuitionistically, thanks to your hint.</p>



<a name="269941042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/269941042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#269941042">(Jan 30 2022 at 16:11)</a>:</h4>
<p>With propext, I've been able to show or, implication, and reverse implication are all binary predicates on Prop that serve as counterexamples: <a href="https://gist.github.com/alreadydone/0d8c00290751e1d20c6eefeb6040430e">https://gist.github.com/alreadydone/0d8c00290751e1d20c6eefeb6040430e</a><br>
However, it seems NAND can't be shown to be a counterexample intuitionistically: not(x and y) is equivalent to y-&gt;not x, which is true when y=not x and when y=false. If there is a unique y such that y-&gt;not x, then false=not x, which is equivalent to not(not x), which doesn't imply x=true intuitionistically.<br>
Since Prop with propext is a Heyting algebra (and maybe every Heyting algebra can serve as a model for intuitionistic Prop), this is a problem about whether a binary operation P satisfies ∃! (x y : α), P x y = ⊤ for all Heyting algebra α, where P is defined in terms of the operations of Heyting algebras (join, meet, implication, top, bot) so it makes sense for any Heyting algebra. And it would be a fun problem to classify all operations satisfying <code>eu_eu_and_not_eu_prod</code>. I don't know if anything changes if <code>(∃! (x y : α), P x y) ∧ ¬(∃! (xy : α × α), P xy.fst xy.snd)</code> is changed to <code>¬((∃! (x y : α), P x y) → (∃! (xy : α × α), P xy.fst xy.snd))</code>; the former implies the latter but not vice versa.</p>



<a name="269944923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%E2%9C%94%20Existential%20quantifier%20and%20Sigma%20type/near/269944923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type.html#269944923">(Jan 30 2022 at 17:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type/near/269941042">said</a>:</p>
<blockquote>
<p>maybe every Heyting algebra can serve as a model for intuitionistic Prop</p>
</blockquote>
<p>That was precisely Heyting's motivation!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
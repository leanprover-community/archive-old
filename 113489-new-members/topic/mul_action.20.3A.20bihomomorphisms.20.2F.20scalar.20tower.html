---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html">mul_action : bihomomorphisms / scalar tower</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="279973352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/279973352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#279973352">(Apr 24 2022 at 09:59)</a>:</h4>
<p>Assume <code>M</code> and <code>N</code> are monoids, with actions of <code>M</code> on <code>α</code> and of <code>N</code> on <code>β</code>,<br>
I wish to consider pairs <code>(φ : M →*N , f : α → β)</code> such that <code>φ(m) • f(a) = f(m • a)</code> for all <code>m</code>, <code>a</code>.<br>
Obviously, this can be implemented by a variant of <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_action_hom">docs#mul_action_hom</a>, <br>
but I guess that a more idiomatic version exists that uses <a href="https://leanprover-community.github.io/mathlib_docs/find/is_scalar_tower">docs#is_scalar_tower</a> and the like.<br>
What do you think?</p>



<a name="279973480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/279973480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#279973480">(Apr 24 2022 at 10:01)</a>:</h4>
<p>Aren't these exactly semilinear maps?</p>



<a name="279973537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/279973537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#279973537">(Apr 24 2022 at 10:02)</a>:</h4>
<p>Except that your monoids are multiplicative</p>



<a name="279973728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/279973728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#279973728">(Apr 24 2022 at 10:07)</a>:</h4>
<p><span class="user-mention" data-user-id="238446">@Anne Baanen</span>, how would such multiplicative semilinear maps fit in the current refactor?</p>



<a name="279973796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/279973796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#279973796">(Apr 24 2022 at 10:08)</a>:</h4>
<p>And there is no law on <code>α</code>, <code>β</code>, so that <code>f: α → β</code> is not required to satisfy anything.</p>



<a name="279973878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/279973878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#279973878">(Apr 24 2022 at 10:10)</a>:</h4>
<p>The interest of such a structure appeared when I had <code>mul_action M α</code> and <code>mul_action N β</code>where <code>M</code> and <code>N</code>happened (by computation) be equal but I couldn't <code>rw</code>the equality…</p>



<a name="279973899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/279973899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#279973899">(Apr 24 2022 at 10:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower/near/279973728">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span>, how would such multiplicative semilinear maps fit in the current refactor?</p>
</blockquote>
<p>I don't think they would have anything special to them compared with semilinear maps. Those are a bit of an issue since the elaborator isn't always smart enough to work with a completely generic <code>map_smul_sl</code> (<code>map_smul</code> works fine now). I haven't had an opportunity to completely figure out why this is.</p>



<a name="279974135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/279974135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#279974135">(Apr 24 2022 at 10:16)</a>:</h4>
<p>I guess we could have (up to <code>to_additive</code>) an ancestor of these semi-mul_action_hom and semilinear maps, if we define it along the lines of:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">semi_mul_action_hom</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fun_like</span> <span class="n">F</span> <span class="n">α</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">β</span><span class="o">)]</span> <span class="kd">extends</span> <span class="n">M</span> <span class="bp">→*</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map_smul_sl</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">m</span> <span class="bp">•</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">φ</span> <span class="n">m</span> <span class="bp">•</span> <span class="n">to_fun</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div>
<p>and then restrict the <code>fun_like F</code> parameter to <code>ring_hom_class F</code> in semilinear maps.</p>



<a name="279974205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/279974205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#279974205">(Apr 24 2022 at 10:18)</a>:</h4>
<p>Or we could even have <code>φ : α → β</code> in the type, and require in the lemma statements that <code>φ = coe_fn (φ' : α →+* β)</code></p>



<a name="279974502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/279974502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#279974502">(Apr 24 2022 at 10:26)</a>:</h4>
<p>Ah, sorry, I misread the question</p>



<a name="279975640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/279975640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#279975640">(Apr 24 2022 at 10:54)</a>:</h4>
<p>I would assume the thing to do here is generalize <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_action_hom">docs#mul_action_hom</a> to take a <code>φ</code> argument, matching how we generalized <code>linear_map</code></p>



<a name="279975670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/279975670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#279975670">(Apr 24 2022 at 10:55)</a>:</h4>
<p>Since <code>mul_action_hom</code> only requires <code>has_scalar</code>, probably it should only require <code>φ : M → N</code> not <code>φ : M →* N</code></p>



<a name="280820337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/280820337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#280820337">(May 01 2022 at 23:43)</a>:</h4>
<p>It's hard to propose a really minimal mwe, so let's me try to state where this story brought me into.<br>
My main goal for the moment was to prove, given a global <code>mul_action G X</code>, a few instances of <code>semi_mul_action_hom</code> relative to appropriate subgroups <code>H</code>of <code>G</code> which preserve subsets <code>Y</code>of <code>X</code>,<br>
which means that the relevant maps are totally trivial, they map <code>x</code> to <code>x</code>, the only issue is to furnishing the appropriate coercions which, mathematically, are essentially obvious.<br>
The real nightmare begins when I need to prove that these obvious maps have obvious properties such as being injective or surjective. Because for many proofs, I need to <em>reprove</em> the kind of belonging coercions that I had already proven to construct the maps.</p>
<p>I don't know whether these comments will ring a bell, you can have a look in <a href="https://github.com/leanprover-community/mathlib/tree/acl-Wielandt">branch#acl-Wielandt</a> (files ad_sub_mul_action, or mul_action_bihom) if you wish.</p>



<a name="280822915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/280822915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#280822915">(May 02 2022 at 00:51)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mem_sub_mul_action_of_fixing_subgroup_iff</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">∈</span> <span class="n">sub_mul_action_of_fixing_subgroup</span> <span class="n">M</span> <span class="n">s</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">iff.rfl</span>
</code></pre></div>



<a name="280823208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/280823208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#280823208">(May 02 2022 at 00:58)</a>:</h4>
<p>Is this progress</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx1</span><span class="o">⟩,</span> <span class="n">hx2</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="o">⟨⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="c1">-- ⊢ x ∈ sub_mul_action_of_fixing_subgroup M (insert a (coe '' s))</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="o">},</span>
</code></pre></div>
<p>with the <code>sorry</code> on line 650 or so of <code>ad_sub_mul_actions.lean</code>?</p>



<a name="280823411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/280823411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#280823411">(May 02 2022 at 01:02)</a>:</h4>
<p>On line 600 or so:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">↑</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">sub_mul_action_of_stabilizer</span> <span class="n">M</span> <span class="n">α</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
<span class="bp">...</span>
</code></pre></div>
<p>is not good style. You're defining data here so you should not be in tactic mode (your goal is not a Prop, and tactic mode can make lousy definitions).</p>



<a name="280824274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/280824274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#280824274">(May 02 2022 at 01:24)</a>:</h4>
<p>Here's your proof written in this format:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨⟨(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">mem_sub_mul_action_of_stabilizer_iff</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">mem_sub_mul_action_of_fixing_subgroup_iff</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">x.prop</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">apply</span> <span class="n">set.mem_insert</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">⟩,</span>
  <span class="kd">begin</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">mem_sub_mul_action_of_fixing_subgroup_iff</span> <span class="o">(</span><span class="n">stabilizer</span> <span class="n">M</span> <span class="n">a</span><span class="o">),</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">apply</span> <span class="o">(</span><span class="n">mem_sub_mul_action_of_fixing_subgroup_iff</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">x.prop</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">set.mem_insert_of_mem</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨⟨(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">_</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩⟩,</span> <span class="o">}</span>
  <span class="kd">end</span><span class="o">⟩,</span>
</code></pre></div>
<p>Note that the proof of <code>mem_sub_mul_action_of_fixing_subgroup_iff</code> is <code>refl</code> so can be skipped (try deleting it!), meaning that there is lot of intro, apply, exact stuff which can be hence golfed into term mode. Here's that second proof with all the <code>apply</code>s changed to <code>refine</code>s:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="kd">begin</span> <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">(</span><span class="n">mem_sub_mul_action_of_fixing_subgroup_iff</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">x.prop</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">set.mem_insert_of_mem</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨⟨(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">_</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩⟩,</span> <span class="o">}</span>
  <span class="kd">end</span><span class="o">⟩,</span>
</code></pre></div>
<p>and now we see that this golfs to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨⟨(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="kd">begin</span>
  <span class="n">rintro</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span><span class="o">),</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">mem_sub_mul_action_of_fixing_subgroup_iff</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">x.prop</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">apply</span> <span class="n">set.mem_insert</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">⟩,</span>
  <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="n">mem_sub_mul_action_of_fixing_subgroup_iff</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">x.prop</span> <span class="bp">$</span>
    <span class="n">set.mem_insert_of_mem</span> <span class="n">_</span> <span class="o">⟨⟨(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">_</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩⟩⟩,</span>
</code></pre></div>



<a name="280824772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/280824772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#280824772">(May 02 2022 at 01:37)</a>:</h4>
<p>You've made this a <code>def</code> but <code>function.bijective</code> is a <code>Prop</code> so this is a theorem. The <code>def</code> is an <code>equiv</code> presumably, which is often nicer to make in general. I tidied up your other proof. Is this sorry fillable? I don't know what the maths means (your definitions don't have docstrings ;-) ).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">sub_mul_action_of_fixing_subgroup_of_stabilizer_bihom_bijective</span>
  <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sub_mul_action_of_stabilizer</span> <span class="n">M</span> <span class="n">α</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">function.bijective</span> <span class="o">(</span><span class="n">sub_mul_action_of_fixing_subgroup_of_stabilizer_bihom</span> <span class="n">M</span> <span class="n">a</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx1</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy1</span><span class="o">⟩</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="o">[</span><span class="n">sub_mul_action_of_fixing_subgroup_of_stabilizer_bihom</span><span class="o">]</span> <span class="n">using</span> <span class="n">h</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx1</span><span class="o">⟩,</span> <span class="n">hx2</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="o">⟨⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="c1">-- ⊢ x ∈ sub_mul_action_of_fixing_subgroup M (insert a (coe '' s))</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="280825027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/280825027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#280825027">(May 02 2022 at 01:42)</a>:</h4>
<p>I don't know what the question is in <code>mul_action_bihom</code>. Here's some golfing of the last lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mul_of_preimage_eq</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mul_action_bihom</span> <span class="n">M</span> <span class="n">X</span> <span class="n">N</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">m</span> <span class="bp">•</span> <span class="n">f.to_fun</span> <span class="bp">⁻¹'</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">f.to_fun</span> <span class="bp">⁻¹'</span> <span class="o">((</span><span class="n">f.to_monoid_hom</span> <span class="n">m</span><span class="o">)</span> <span class="bp">•</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_preimage</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="c1">-- combine `intro` and `obtain`</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_preimage</span><span class="o">]</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">f.map_smul'</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">set.smul_mem_smul_set</span> <span class="n">hy</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">hbx</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">m</span><span class="bp">⁻¹</span> <span class="bp">•</span> <span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="c1">-- combine `use` and `split`</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="bp">←</span> <span class="n">f.map_smul'</span><span class="o">,</span> <span class="bp">←</span> <span class="n">hbx</span><span class="o">]</span> <span class="n">using</span> <span class="n">hb</span> <span class="o">},</span> <span class="c1">-- simp, rewrite, simp, just do it all in one go</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">smul_inv_smul</span><span class="o">],</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="280875549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/mul_action%20%3A%20bihomomorphisms%20/%20scalar%20tower/near/280875549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/mul_action.20.3A.20bihomomorphisms.20.2F.20scalar.20tower.html#280875549">(May 02 2022 at 13:48)</a>:</h4>
<p>Thank you, <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> , this has been very helpful.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
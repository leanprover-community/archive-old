---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/turing.20machine.20proof.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html">turing machine proof</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="259147004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/259147004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Harold Cooper <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#259147004">(Oct 26 2021 at 19:15)</a>:</h4>
<p>Hi all! I'm learning Lean, and playing around with <code>computability.turing_machine</code></p>
<p>I made the simplest possible machine <code>M1</code> which just immediately halts (i.e. returns <code>none</code>).</p>
<p>It was easy for me to prove the theorem <code>M1_halts_immediately</code> that it halts after a single call to <code>step</code>, but I'd also like to prove the theorem <code>M1_halts</code> that the higher-level <code>eval</code> also halts, since I want to play with more complicated machines next.</p>
<p>Anyway here's my code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">computability.turing_machine</span>

<span class="kd">inductive</span> <span class="bp">Λ</span> <span class="c1">-- states</span>
<span class="bp">|</span> <span class="n">initial</span> <span class="o">:</span> <span class="bp">Λ</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:</span> <span class="bp">Λ</span>
<span class="bp">|</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">Λ</span>
<span class="kd">instance</span> <span class="bp">Λ.</span><span class="n">inhabited</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="bp">Λ</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">Λ.</span><span class="n">initial</span><span class="o">⟩</span>

<span class="kd">inductive</span> <span class="bp">Γ</span> <span class="c1">-- symbols</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="bp">Γ</span>
<span class="bp">|</span> <span class="n">one</span> <span class="o">:</span> <span class="bp">Γ</span>
<span class="kd">instance</span> <span class="bp">Γ.</span><span class="n">inhabited</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="bp">Γ</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">Γ.</span><span class="n">zero</span><span class="o">⟩</span>

<span class="c1">-- initial state and empty tape:</span>
<span class="kd">def</span> <span class="n">initial_cfg</span> <span class="o">:</span> <span class="n">turing.TM0.cfg</span> <span class="bp">Γ</span> <span class="bp">Λ</span> <span class="o">:=</span> <span class="n">turing.TM0.init</span> <span class="o">[]</span>

<span class="c1">-- machine that halts immediately:</span>
<span class="kd">def</span> <span class="n">M1</span> <span class="o">:</span> <span class="n">turing.TM0.machine</span> <span class="bp">Γ</span> <span class="bp">Λ</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">none</span>

<span class="kd">theorem</span> <span class="n">M1_halts_immediately</span> <span class="o">:</span> <span class="n">turing.TM0.step</span> <span class="n">M1</span> <span class="n">initial_cfg</span> <span class="bp">=</span> <span class="n">none</span> <span class="o">:=</span>
<span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">M1_halts</span> <span class="o">:</span> <span class="n">turing.TM0.eval</span> <span class="n">M1</span> <span class="o">[]</span> <span class="bp">≠</span> <span class="n">part.none</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>How can I replace the <code>sorry</code> at the end? I have no idea what tactics are relevant here.</p>
<p>And am I even trying to prove the correct statement? I also considered <code>∃ x, turing.TM0.eval M1 [] = part.some x</code></p>



<a name="259147809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/259147809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Harold Cooper <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#259147809">(Oct 26 2021 at 19:22)</a>:</h4>
<p>(<a href="https://leanprover-community.github.io/mathlib_docs/find/turing.TM0.eval">docs#turing.TM0.eval</a> is implemented on top of <a href="https://leanprover-community.github.io/mathlib_docs/find/turing.eval">docs#turing.eval</a> which uses <a href="https://leanprover-community.github.io/mathlib_docs/find/pfun.fix">docs#pfun.fix</a> and I have no idea what tactics can run/reduce <code>pfun.fix</code> to get to a <code>part.some</code> result)</p>



<a name="259148977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/259148977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#259148977">(Oct 26 2021 at 19:31)</a>:</h4>
<p>The main theorem for proving things about <code>pfun.fix</code> is <a href="https://leanprover-community.github.io/mathlib_docs/find/pfun.mem_fix_iff">docs#pfun.mem_fix_iff</a></p>



<a name="259149073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/259149073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#259149073">(Oct 26 2021 at 19:32)</a>:</h4>
<p>at least for "positive" statements, i.e. "this program halts and returns x". For negative statements you need <a href="https://leanprover-community.github.io/mathlib_docs/find/pfun.fix_induction">docs#pfun.fix_induction</a></p>



<a name="259150433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/259150433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Harold Cooper <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#259150433">(Oct 26 2021 at 19:43)</a>:</h4>
<p>okay thanks, I'll try that!</p>



<a name="259151095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/259151095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#259151095">(Oct 26 2021 at 19:47)</a>:</h4>
<p>Here's one way to state and prove the theorem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">M1_halts</span> <span class="o">:</span> <span class="o">(</span><span class="n">turing.TM0.eval</span> <span class="n">M1</span> <span class="o">[])</span><span class="bp">.</span><span class="n">dom</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">turing.TM0.eval</span><span class="o">,</span> <span class="n">part.map_dom</span><span class="o">,</span> <span class="n">part.dom_iff_mem</span><span class="o">],</span>
  <span class="n">existsi</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">turing.mem_eval</span><span class="o">],</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">relation.refl_trans_gen.refl</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="259151611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/259151611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Harold Cooper <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#259151611">(Oct 26 2021 at 19:52)</a>:</h4>
<p>oh awesome, I think this will teach me a lot.</p>
<p>so is the theorem<code>(…).dom</code> saying that the partial function has a non-empty domain, and thus halts?</p>



<a name="259153030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/259153030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#259153030">(Oct 26 2021 at 20:01)</a>:</h4>
<p><code>part A</code> is actually a "partial value", kind of like a partial function but over just one point. So if <code>p : part A</code> then <code>p.dom</code> is a proposition that says whether the value exists, and <code>p.get : p.dom -&gt; A</code> is either the empty function or a function on a singleton returning a single value of type <code>A</code></p>



<a name="259153187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/259153187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#259153187">(Oct 26 2021 at 20:02)</a>:</h4>
<p>So <code>turing.TM0.eval M1 []</code> is "the value that results from executing M1 on <code>[]</code>, if it exists", and <code>(turing.TM0.eval M1 []).dom</code> is asserting that the value exists, i.e. the machine halts</p>



<a name="259153343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/259153343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#259153343">(Oct 26 2021 at 20:03)</a>:</h4>
<p>A partial function <code>A -&gt;. B</code> is defined as <code>A -&gt; part B</code></p>



<a name="259153624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/259153624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Harold Cooper <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#259153624">(Oct 26 2021 at 20:05)</a>:</h4>
<p>ah okay got it, that makes sense</p>



<a name="259159174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/259159174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> YJ <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#259159174">(Oct 26 2021 at 20:52)</a>:</h4>
<p>Hello all! I am new to Lean and am currently following the tutorials from the theorem proving in lean 3, are there any published solutions with the questions?</p>



<a name="259161896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/259161896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#259161896">(Oct 26 2021 at 21:09)</a>:</h4>
<p>You're in the wrong thread (hint: start a new one) but the answer to your question is that as far as I know there aren't; however if you're stuck on something you could ask in a new thread in <a class="stream" data-stream-id="113489" href="/#narrow/stream/113489-new-members">#new members</a></p>



<a name="263181982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/263181982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Harold Cooper <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#263181982">(Nov 30 2021 at 17:48)</a>:</h4>
<p>I did a bit more with this recently, including proving that a simple looping machine <em>doesn't</em> halt which was more fun than proving that things do halt :p</p>
<p>However, I was only able to do that using an alternative formulation of halting, which I'm pretty sure is equivalent to what we used earlier in this thread, but now I would like to prove that it is!</p>
<p>Specifically, the two definitions of halting which I want to prove are equivalent are:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">halts</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">turing.TM0.machine</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">multistep</span> <span class="n">M</span> <span class="n">n</span> <span class="o">[]</span> <span class="bp">=</span> <span class="n">none</span>

<span class="kd">def</span> <span class="n">halts'''</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">turing.TM0.machine</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">turing.TM0.eval</span> <span class="n">M</span> <span class="o">[]</span> <span class="bp">=</span> <span class="n">part.some</span> <span class="n">x</span>
</code></pre></div>
<p>(<code>multistep M n</code> just steps the machine <code>n</code> times—I'll include the full code below.)</p>



<a name="263182006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/263182006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Harold Cooper <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#263182006">(Nov 30 2021 at 17:49)</a>:</h4>
<p>In the following code, I started an attempt at the proof <code>halts_iff'''</code>, where the <code>sorry</code> statements are. Based on <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>'s tips above, I'm guessing I need to do something with <a href="https://leanprover-community.github.io/mathlib_docs/find/pfun.mem_fix_iff">docs#pfun.mem_fix_iff</a> or <a href="https://leanprover-community.github.io/mathlib_docs/find/pfun.fix_induction">docs#pfun.fix_induction</a> ?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">computability.turing_machine</span>

<span class="kd">inductive</span> <span class="bp">Λ</span> <span class="c1">-- states</span>
<span class="bp">|</span> <span class="n">A</span> <span class="o">:</span> <span class="bp">Λ</span>
<span class="bp">|</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Λ</span>
<span class="bp">|</span> <span class="n">C</span> <span class="o">:</span> <span class="bp">Λ</span>
<span class="kd">instance</span> <span class="bp">Λ.</span><span class="n">inhabited</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="bp">Λ</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">Λ.</span><span class="n">A</span><span class="o">⟩</span>

<span class="kd">inductive</span> <span class="bp">Γ</span> <span class="c1">-- symbols</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="bp">Γ</span>
<span class="bp">|</span> <span class="n">one</span> <span class="o">:</span> <span class="bp">Γ</span>
<span class="kd">instance</span> <span class="bp">Γ.</span><span class="n">inhabited</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="bp">Γ</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">Γ.</span><span class="n">zero</span><span class="o">⟩</span>

<span class="c1">-- initial state and empty tape:</span>
<span class="kd">def</span> <span class="n">cfg₀</span> <span class="o">:</span> <span class="n">turing.TM0.cfg</span> <span class="bp">Γ</span> <span class="bp">Λ</span> <span class="o">:=</span> <span class="n">turing.TM0.init</span> <span class="o">[]</span>

<span class="c1">-- chainable step function:</span>
<span class="kd">def</span> <span class="n">step'</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">turing.TM0.machine</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">turing.TM0.cfg</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">option</span> <span class="o">(</span><span class="n">turing.TM0.cfg</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">x.bind</span> <span class="o">(</span><span class="n">turing.TM0.step</span> <span class="n">M</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">multistep</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">turing.TM0.machine</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">option</span> <span class="o">(</span><span class="n">turing.TM0.cfg</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">option</span> <span class="o">(</span><span class="n">turing.TM0.cfg</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">nat.repeat</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">step'</span> <span class="n">M</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">multistep_none_add</span> <span class="o">{</span><span class="n">cfg</span> <span class="n">M</span> <span class="n">n</span> <span class="n">m</span><span class="o">}</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="n">multistep</span> <span class="n">M</span> <span class="n">n</span> <span class="n">cfg</span> <span class="bp">=</span> <span class="n">none</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">multistep</span> <span class="n">M</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="n">cfg</span> <span class="bp">=</span> <span class="n">none</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">m</span> <span class="k">with</span> <span class="n">m</span> <span class="n">hm</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">hn</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">multistep</span><span class="o">,</span> <span class="n">nat.add_succ</span><span class="o">,</span> <span class="n">nat.repeat</span><span class="o">,</span> <span class="bp">←</span> <span class="n">multistep</span><span class="o">,</span> <span class="n">hm</span><span class="o">],</span>
    <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">multistep_none_ge</span> <span class="o">{</span><span class="n">cfg</span> <span class="n">M</span> <span class="n">n</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="bp">≥</span> <span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="n">multistep</span> <span class="n">M</span> <span class="n">n</span> <span class="n">cfg</span> <span class="bp">=</span> <span class="n">none</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">multistep</span> <span class="n">M</span> <span class="n">m</span> <span class="n">cfg</span> <span class="bp">=</span> <span class="n">none</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">nat.add_sub_of_le</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">multistep_none_add</span> <span class="n">hn</span><span class="o">,</span>
<span class="kd">end</span>


<span class="c1">-- equivalent definitions of halting:</span>

<span class="kd">def</span> <span class="n">halts</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">turing.TM0.machine</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">multistep</span> <span class="n">M</span> <span class="n">n</span> <span class="n">cfg₀</span> <span class="bp">=</span> <span class="n">none</span>

<span class="kd">def</span> <span class="n">halts'</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">turing.TM0.machine</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">turing.TM0.eval</span> <span class="n">M</span> <span class="o">[])</span><span class="bp">.</span><span class="n">dom</span>

<span class="kd">def</span> <span class="n">halts''</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">turing.TM0.machine</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">turing.TM0.eval</span> <span class="n">M</span> <span class="o">[]</span> <span class="bp">≠</span> <span class="n">part.none</span>

<span class="kd">def</span> <span class="n">halts'''</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">turing.TM0.machine</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">turing.TM0.eval</span> <span class="n">M</span> <span class="o">[]</span> <span class="bp">=</span> <span class="n">part.some</span> <span class="n">x</span>

<span class="kd">theorem</span> <span class="n">halts'_iff''</span> <span class="o">{</span><span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="n">halts'</span> <span class="n">M</span> <span class="bp">↔</span> <span class="n">halts''</span> <span class="n">M</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">halts''</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">part.eq_none_iff'</span><span class="o">,</span> <span class="bp">←</span> <span class="n">halts'</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">not_not.symm</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">halts''_iff'''</span> <span class="o">{</span><span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="n">halts''</span> <span class="n">M</span> <span class="bp">↔</span> <span class="n">halts'''</span> <span class="n">M</span> <span class="o">:=</span>
<span class="n">part.ne_none_iff</span>

<span class="kd">theorem</span> <span class="n">halts_iff'''</span> <span class="o">{</span><span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="n">halts</span> <span class="n">M</span> <span class="bp">↔</span> <span class="n">halts'''</span> <span class="n">M</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">halts</span><span class="o">,</span> <span class="n">halts'''</span><span class="o">],</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
    <span class="o">{</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
    <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>


<span class="c1">-- machine that halts immediately:</span>
<span class="kd">def</span> <span class="n">M₁</span> <span class="o">:</span> <span class="n">turing.TM0.machine</span> <span class="bp">Γ</span> <span class="bp">Λ</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">none</span>

<span class="kd">theorem</span> <span class="n">M₁_halts_immediately</span> <span class="o">:</span> <span class="n">turing.TM0.step</span> <span class="n">M₁</span> <span class="n">cfg₀</span> <span class="bp">=</span> <span class="n">none</span> <span class="o">:=</span>
<span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">M₁_halts</span> <span class="o">:</span> <span class="n">halts</span> <span class="n">M₁</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>

<span class="kd">theorem</span> <span class="n">M₁_halts'</span> <span class="o">:</span> <span class="n">halts'</span> <span class="n">M₁</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">halts'</span><span class="o">,</span> <span class="n">turing.TM0.eval</span><span class="o">,</span> <span class="n">part.map_dom</span><span class="o">,</span> <span class="n">part.dom_iff_mem</span><span class="o">],</span>
  <span class="n">existsi</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">turing.mem_eval</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">relation.refl_trans_gen.refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">M₁_halts''</span> <span class="o">:</span> <span class="n">halts''</span> <span class="n">M₁</span> <span class="o">:=</span>
<span class="n">halts'_iff''.mp</span> <span class="n">M₁_halts'</span>

<span class="kd">theorem</span> <span class="n">M₁_halts'''</span> <span class="o">:</span> <span class="n">halts'''</span> <span class="n">M₁</span> <span class="o">:=</span>
<span class="n">halts''_iff'''.mp</span> <span class="n">M₁_halts''</span>


<span class="c1">-- machine that goes A → B → halt:</span>
<span class="kd">def</span> <span class="n">M₂</span> <span class="o">:</span> <span class="n">turing.TM0.machine</span> <span class="bp">Γ</span> <span class="bp">Λ</span>
<span class="bp">|</span> <span class="bp">Λ.</span><span class="n">A</span> <span class="n">symbol</span> <span class="o">:=</span> <span class="n">some</span> <span class="o">⟨</span><span class="bp">Λ.</span><span class="n">B</span><span class="o">,</span> <span class="n">turing.TM0.stmt.write</span> <span class="n">symbol</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">none</span>

<span class="kd">theorem</span> <span class="n">M₂_halts</span> <span class="o">:</span> <span class="n">halts</span> <span class="n">M₂</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="mi">2</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>

<span class="kd">theorem</span> <span class="n">M₂_halts'</span> <span class="o">:</span> <span class="n">halts'</span> <span class="n">M₂</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">halts'</span><span class="o">,</span> <span class="n">turing.TM0.eval</span><span class="o">,</span> <span class="n">part.map_dom</span><span class="o">,</span> <span class="n">part.dom_iff_mem</span><span class="o">],</span>
  <span class="n">existsi</span> <span class="n">turing.TM0.cfg.mk</span> <span class="bp">Λ.</span><span class="n">B</span> <span class="o">(</span><span class="n">turing.tape.mk₁</span> <span class="o">[]),</span>
  <span class="n">rw</span> <span class="n">turing.mem_eval</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>


<span class="c1">-- machine that loops A → B → A → B → ⋯:</span>
<span class="kd">def</span> <span class="n">M₃</span> <span class="o">:</span> <span class="n">turing.TM0.machine</span> <span class="bp">Γ</span> <span class="bp">Λ</span>
<span class="bp">|</span> <span class="bp">Λ.</span><span class="n">A</span> <span class="n">symbol</span> <span class="o">:=</span> <span class="n">some</span> <span class="o">⟨</span><span class="bp">Λ.</span><span class="n">B</span><span class="o">,</span> <span class="n">turing.TM0.stmt.write</span> <span class="n">symbol</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="bp">Λ.</span><span class="n">B</span> <span class="n">symbol</span> <span class="o">:=</span> <span class="n">some</span> <span class="o">⟨</span><span class="bp">Λ.</span><span class="n">A</span><span class="o">,</span> <span class="n">turing.TM0.stmt.write</span> <span class="n">symbol</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">none</span>

<span class="kd">lemma</span> <span class="n">M₃_AB_only</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">tape</span><span class="o">,</span>
  <span class="n">multistep</span> <span class="n">M₃</span> <span class="n">n</span> <span class="n">cfg₀</span> <span class="bp">=</span> <span class="n">some</span> <span class="o">⟨</span><span class="bp">Λ.</span><span class="n">A</span><span class="o">,</span> <span class="n">tape</span><span class="o">⟩</span> <span class="bp">∨</span> <span class="n">multistep</span> <span class="n">M₃</span> <span class="n">n</span> <span class="n">cfg₀</span> <span class="bp">=</span> <span class="n">some</span> <span class="o">⟨</span><span class="bp">Λ.</span><span class="n">B</span><span class="o">,</span> <span class="n">tape</span><span class="o">⟩</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">existsi</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">left</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">hn</span> <span class="k">with</span> <span class="n">tape_n</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hn</span><span class="bp">;</span> <span class="n">existsi</span> <span class="n">_</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">right</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">multistep</span><span class="o">,</span> <span class="n">nat.repeat</span><span class="o">,</span> <span class="bp">←</span> <span class="n">multistep</span><span class="o">,</span> <span class="n">hn</span><span class="o">,</span> <span class="n">step'</span><span class="o">,</span> <span class="n">option.bind</span><span class="o">,</span> <span class="n">turing.TM0.step</span><span class="o">],</span>
      <span class="n">simp</span><span class="o">,</span>
      <span class="n">existsi</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">existsi</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">split</span><span class="bp">;</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">left</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">multistep</span><span class="o">,</span> <span class="n">nat.repeat</span><span class="o">,</span> <span class="bp">←</span> <span class="n">multistep</span><span class="o">,</span> <span class="n">hn</span><span class="o">,</span> <span class="n">step'</span><span class="o">,</span> <span class="n">option.bind</span><span class="o">,</span> <span class="n">turing.TM0.step</span><span class="o">],</span>
      <span class="n">simp</span><span class="o">,</span>
      <span class="n">existsi</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">existsi</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">split</span><span class="bp">;</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">M₃_not_halts</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">halts</span> <span class="n">M₃</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">M₃_AB_only</span> <span class="k">with</span> <span class="n">tape</span> <span class="n">h_tape</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h_tape</span><span class="bp">;</span> <span class="o">{</span>
    <span class="n">rw</span> <span class="n">h_tape</span> <span class="n">at</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">option.no_confusion</span> <span class="n">hn</span><span class="o">,</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>(There's also an unfinished proof <code>M₂_halts'</code> of a machine halting in two steps, just because I felt like I should be able to figure it out after proving <code>M₁_halts'</code> that a machine halts in one step, but I couldn't… am curious to learn what I'm missing)</p>



<a name="263182048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/263182048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Harold Cooper <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#263182048">(Nov 30 2021 at 17:49)</a>:</h4>
<p>Sorry this is a bit long, any tips appreciated!</p>



<a name="263352917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/263352917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Harold Cooper <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#263352917">(Dec 01 2021 at 20:26)</a>:</h4>
<p>Here's a much more concise version of what I'm trying to prove in case anyone has some tips:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">computability.turing_machine</span>

<span class="kd">inductive</span> <span class="bp">Λ</span> <span class="c1">-- states</span>
<span class="bp">|</span> <span class="n">A</span> <span class="o">:</span> <span class="bp">Λ</span>
<span class="bp">|</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Λ</span>
<span class="bp">|</span> <span class="n">C</span> <span class="o">:</span> <span class="bp">Λ</span>
<span class="kd">instance</span> <span class="bp">Λ.</span><span class="n">inhabited</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="bp">Λ</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">Λ.</span><span class="n">A</span><span class="o">⟩</span>

<span class="kd">inductive</span> <span class="bp">Γ</span> <span class="c1">-- symbols</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="bp">Γ</span>
<span class="bp">|</span> <span class="n">one</span> <span class="o">:</span> <span class="bp">Γ</span>
<span class="kd">instance</span> <span class="bp">Γ.</span><span class="n">inhabited</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="bp">Γ</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">Γ.</span><span class="n">zero</span><span class="o">⟩</span>

<span class="c1">-- initial state and empty tape:</span>
<span class="kd">def</span> <span class="n">cfg₀</span> <span class="o">:</span> <span class="n">turing.TM0.cfg</span> <span class="bp">Γ</span> <span class="bp">Λ</span> <span class="o">:=</span> <span class="n">turing.TM0.init</span> <span class="o">[]</span>

<span class="c1">-- chainable step function (since both its input and output have the same option type):</span>
<span class="kd">def</span> <span class="n">step'</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">turing.TM0.machine</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">turing.TM0.cfg</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">option</span> <span class="o">(</span><span class="n">turing.TM0.cfg</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">x.bind</span> <span class="o">(</span><span class="n">turing.TM0.step</span> <span class="n">M</span><span class="o">)</span>

<span class="c1">-- step a given number of times:</span>
<span class="kd">def</span> <span class="n">multistep</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">turing.TM0.machine</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">option</span> <span class="o">(</span><span class="n">turing.TM0.cfg</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">option</span> <span class="o">(</span><span class="n">turing.TM0.cfg</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">nat.repeat</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">step'</span> <span class="n">M</span><span class="o">)</span>


<span class="c1">-- I'm trying to prove this:</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">multistep</span> <span class="n">M</span> <span class="n">n</span> <span class="n">cfg₀</span> <span class="bp">=</span> <span class="n">none</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">turing.TM0.eval</span> <span class="n">M</span> <span class="o">[]</span> <span class="bp">=</span> <span class="n">part.some</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>


<span class="c1">-- or this if it's easier, since I've already proven (turing.TM0.eval M []).dom ↔ (∃ x, turing.TM0.eval M [] = part.some x)</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">multistep</span> <span class="n">M</span> <span class="n">n</span> <span class="n">cfg₀</span> <span class="bp">=</span> <span class="n">none</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">turing.TM0.eval</span> <span class="n">M</span> <span class="o">[])</span><span class="bp">.</span><span class="n">dom</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>Thanks!</p>



<a name="263357558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/263357558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#263357558">(Dec 01 2021 at 21:04)</a>:</h4>
<p>Sorry, I forgot to respond to this one. I made some minor tweaks but it's essentially the same theorem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">multistep</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">turing.TM0.machine</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">option</span> <span class="o">(</span><span class="n">turing.TM0.cfg</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">option</span> <span class="o">(</span><span class="n">turing.TM0.cfg</span> <span class="bp">Γ</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">nat.iterate</span> <span class="o">(</span><span class="n">step'</span> <span class="n">M</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">multistep</span> <span class="n">M</span> <span class="n">n</span> <span class="o">(</span><span class="n">some</span> <span class="n">cfg₀</span><span class="o">)</span> <span class="bp">=</span> <span class="n">none</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">turing.TM0.eval</span> <span class="n">M</span> <span class="o">[])</span><span class="bp">.</span><span class="n">dom</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">turing.TM0.eval</span><span class="o">,</span> <span class="n">cfg₀</span><span class="o">,</span> <span class="n">multistep</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">e</span><span class="o">⟩,</span>
    <span class="n">generalize_hyp</span> <span class="o">:</span> <span class="n">turing.TM0.init</span> <span class="o">[]</span> <span class="bp">=</span> <span class="n">k</span> <span class="n">at</span> <span class="n">e</span> <span class="bp">⊢</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">IH</span> <span class="n">generalizing</span> <span class="n">k</span><span class="o">,</span> <span class="o">{</span><span class="n">cases</span> <span class="n">e</span><span class="o">},</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">nat.iterate</span><span class="o">,</span> <span class="n">step'</span><span class="o">,</span> <span class="n">option.bind</span><span class="o">]</span> <span class="n">at</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">e'</span> <span class="o">:</span> <span class="n">turing.TM0.step</span> <span class="n">M</span> <span class="n">k</span><span class="bp">;</span> <span class="n">rw</span> <span class="n">e'</span> <span class="n">at</span> <span class="n">e</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">part.dom_iff_mem.2</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">turing.mem_eval.2</span> <span class="o">⟨</span><span class="n">relation.refl_trans_gen.refl</span><span class="o">,</span> <span class="n">e'</span><span class="o">⟩⟩</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">turing.reaches_eval</span> <span class="o">(</span><span class="n">relation.refl_trans_gen.single</span> <span class="n">e'</span><span class="o">),</span>
      <span class="n">exact</span> <span class="n">IH</span> <span class="n">_</span> <span class="n">e</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">part.dom_iff_mem.1</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">turing.eval_induction</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">k</span> <span class="n">h</span> <span class="n">IH</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">cases</span> <span class="n">e</span> <span class="o">:</span> <span class="n">turing.TM0.step</span> <span class="n">M</span> <span class="n">k</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">e</span><span class="o">⟩</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">hn</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">IH</span> <span class="n">_</span> <span class="n">_</span> <span class="n">e</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">nat.iterate</span><span class="o">,</span> <span class="n">step'</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">hn</span><span class="o">]⟩</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">rwa</span> <span class="bp">←</span> <span class="n">turing.reaches_eval</span> <span class="o">(</span><span class="n">relation.refl_trans_gen.single</span> <span class="n">e</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="263358585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/263358585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Harold Cooper <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#263358585">(Dec 01 2021 at 21:14)</a>:</h4>
<p>Oh awesome, thanks as always <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>!</p>
<p>I'll step through this and likely learn quite a few things</p>



<a name="263359458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/turing%20machine%20proof/near/263359458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Harold Cooper <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/turing.20machine.20proof.html#263359458">(Dec 01 2021 at 21:22)</a>:</h4>
<p>oh and good call on <code>nat.iterate</code>, I didn't know about that</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
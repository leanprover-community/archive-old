---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html">Comm ring for `fin n`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="216893687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216893687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216893687">(Nov 16 2020 at 16:17)</a>:</h4>
<p>I've been working on some things that use addition in <code>fin n</code> to keep count of a known finite set. As part of that, I found that I needed <code>zero_add</code> etc. I thought I would add the simple lemmas to <code>data/fin</code> at <a href="https://github.com/leanprover-community/mathlib/issues/5010">#5010</a>. But the linter then informed me that the <code>comm_ring</code> definitions do exist, but aren't provided globally as instanced. Why is that? If <code>add</code> and <code>mul</code> are defined for <code>fin</code>, should at least the <code>monoid</code> and <code>add_monoid</code> instanced be made global?</p>



<a name="216895488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216895488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216895488">(Nov 16 2020 at 16:29)</a>:</h4>
<p>I don't think you're supposed to use <code>+</code> on <code>fin n</code>--but it exists in order to make numerals work</p>



<a name="216896163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216896163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216896163">(Nov 16 2020 at 16:34)</a>:</h4>
<p>if you want mod <code>n</code> arithmetic, there's another type for that; if you want to think of numbers that you know are less than <code>n</code>, then the definition of <code>+</code> isn't really appropriate</p>



<a name="216896305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216896305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216896305">(Nov 16 2020 at 16:35)</a>:</h4>
<p>I appreciate the fact that <code>+</code> and even more so <code>*</code> aren't supposed to be used for <code>fin n</code>. But seemingly basic things like <code>0 + k = k</code> for some <code>k : fin (n + 1)</code> seem to me to be part of what makes numerals work. If one had a statement <code>0 + 1 = 1</code> where those numerals were in <code>fin (n + 2)</code>, the current way to prove that is to operate on the coercion into <code>nat</code>.</p>



<a name="216896338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216896338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216896338">(Nov 16 2020 at 16:35)</a>:</h4>
<p>Is it not true by <code>rfl</code>?</p>



<a name="216896352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216896352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216896352">(Nov 16 2020 at 16:35)</a>:</h4>
<p>oh in a variable type, perhaps not</p>



<a name="216896406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216896406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216896406">(Nov 16 2020 at 16:36)</a>:</h4>
<p>but why did you have <code>0 + 1</code> in the first place?</p>



<a name="216896699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216896699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216896699">(Nov 16 2020 at 16:38)</a>:</h4>
<p>It seems like you could avoid that by not adding <code>0</code>, or using <code>fin.succ</code></p>



<a name="216896718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216896718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216896718">(Nov 16 2020 at 16:38)</a>:</h4>
<p>I see what you mean about not "counting" using <code>fin n</code>. That's where I got the addition from.</p>



<a name="216896764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216896764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216896764">(Nov 16 2020 at 16:38)</a>:</h4>
<p>Using <code>fin.succ</code> makes a chain of non-equal types.</p>



<a name="216896803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216896803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216896803">(Nov 16 2020 at 16:38)</a>:</h4>
<p>in that case, how about just using <code>nat</code></p>



<a name="216896843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216896843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216896843">(Nov 16 2020 at 16:39)</a>:</h4>
<p>It's good for counting things <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="216896913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216896913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216896913">(Nov 16 2020 at 16:39)</a>:</h4>
<p>it seems to me that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{0, 1, \ldots, n-1\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span> isn't something that has an addition that's suitable for counting</p>



<a name="216896981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216896981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216896981">(Nov 16 2020 at 16:40)</a>:</h4>
<p>You're right. It was an exploration of first encoding that the maximum of countable elements is <code>n</code>, then counting them, instead of first counting them, then showing there are at most <code>n</code> of them.</p>



<a name="216897016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216897016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216897016">(Nov 16 2020 at 16:40)</a>:</h4>
<p>If you use <code>+</code> on <code>fin</code>, then  you've introduced some <code>mod</code> which are artificial for the problem you're trying to solve</p>



<a name="216897026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216897026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216897026">(Nov 16 2020 at 16:40)</a>:</h4>
<p>And asking, at position <code>i</code>, how many elements have I seen so far?</p>



<a name="216897046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216897046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216897046">(Nov 16 2020 at 16:40)</a>:</h4>
<p><code>foldl (+) 0 ...</code></p>



<a name="216897148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216897148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216897148">(Nov 16 2020 at 16:41)</a>:</h4>
<p>And as you're explaining, everything I'm doing will still make sense in <code>nat</code>, just deferring the boundedness check to the end.</p>



<a name="216897391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216897391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216897391">(Nov 16 2020 at 16:43)</a>:</h4>
<p>Basically you have to prove a bound at some point, and you can do it in three ways: at the end; along the way (with a type that changes); or by forcing it with <code>mod</code>, but then it will be hard to reason about the value you defined (and in particular, why <code>mod</code> "never did anything")</p>



<a name="216906576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Comm%20ring%20for%20%60fin%20n%60/near/216906576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Comm.20ring.20for.20.60fin.20n.60.html#216906576">(Nov 16 2020 at 17:48)</a>:</h4>
<p>IIRC <code>zmod n</code> is defined to be a type alias for <code>fin n</code> if n&gt;0, and there you have all the ring structure you expect. <code>fin 0</code> is not a ring which makes doing ringy things on <code>fin n</code> messy.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html">nat as a canonically_linear_ordered_add_monoid</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="225782503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225782503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225782503">(Feb 10 2021 at 01:13)</a>:</h4>
<p>I was writing the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nat.min_add_distrib</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">min</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">min</span> <span class="n">a</span> <span class="o">(</span><span class="n">min</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">min</span> <span class="n">a</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">le_total</span> <span class="n">a</span> <span class="n">b</span> <span class="k">with</span> <span class="n">hb</span> <span class="n">hb</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hb</span><span class="o">,</span> <span class="n">le_add_right</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">le_total</span> <span class="n">a</span> <span class="n">c</span> <span class="k">with</span> <span class="n">hc</span> <span class="n">hc</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hc</span><span class="o">,</span> <span class="n">le_add_left</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hb</span><span class="o">,</span> <span class="n">hc</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>and thought to generalize. But here is a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> of variants of the proof with different generalizations. What makes the <code>nat</code> one work, and what's wrong with the broken ones?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.cast</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">canonically_linear_ordered_add_monoid</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">canonically_ordered_add_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">min_add_distrib</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">min</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">min</span> <span class="n">a</span> <span class="o">(</span><span class="n">min</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">min</span> <span class="n">a</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">le_total</span> <span class="n">a</span> <span class="n">b</span> <span class="k">with</span> <span class="n">hb</span> <span class="n">hb</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hb</span><span class="o">,</span> <span class="n">le_add_right</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">le_total</span> <span class="n">a</span> <span class="n">c</span> <span class="k">with</span> <span class="n">hc</span> <span class="n">hc</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hc</span><span class="o">,</span> <span class="n">le_add_left</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hb</span><span class="o">,</span> <span class="n">hc</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">min_add_distrib_rw</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">min</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">min</span> <span class="n">a</span> <span class="o">(</span><span class="n">min</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">min</span> <span class="n">a</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">le_total</span> <span class="n">a</span> <span class="n">b</span> <span class="k">with</span> <span class="n">hb</span> <span class="n">hb</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">min_eq_left</span> <span class="n">hb</span><span class="o">,</span> <span class="n">min_eq_left</span><span class="o">,</span> <span class="n">min_eq_left</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">le_add_right</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">a</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">le_add_right</span> <span class="n">hb</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">le_total</span> <span class="n">a</span> <span class="n">c</span> <span class="k">with</span> <span class="n">hc</span> <span class="n">hc</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">min_eq_left</span><span class="o">,</span> <span class="n">min_eq_left</span><span class="o">],</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">min_eq_left</span> <span class="n">hc</span><span class="o">],</span>
        <span class="n">exact</span> <span class="n">le_add_left</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">a</span><span class="o">)</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">le_add_left</span> <span class="n">hc</span> <span class="o">}</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">min_eq_right</span> <span class="n">hc</span><span class="o">,</span> <span class="n">min_eq_right</span> <span class="n">hb</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">min_add_distrib_broken</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">min</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">min</span> <span class="n">a</span> <span class="o">(</span><span class="n">min</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">min</span> <span class="n">a</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">le_total</span> <span class="n">a</span> <span class="n">b</span> <span class="k">with</span> <span class="n">hb</span> <span class="n">hb</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">min_eq_left</span> <span class="n">hb</span><span class="o">,</span> <span class="n">min_eq_left</span><span class="o">,</span> <span class="n">min_eq_left</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">le_add_right</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">a</span><span class="o">)</span> <span class="o">},</span> <span class="c1">-- breaks here. different orders?</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">le_add_right</span> <span class="n">hb</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">le_total</span> <span class="n">a</span> <span class="n">c</span> <span class="k">with</span> <span class="n">hc</span> <span class="n">hc</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">min_eq_left</span><span class="o">,</span> <span class="n">min_eq_left</span><span class="o">],</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">min_eq_left</span> <span class="n">hc</span><span class="o">],</span>
        <span class="n">exact</span> <span class="n">le_add_left</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">a</span><span class="o">)</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">le_add_left</span> <span class="n">hc</span> <span class="o">}</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">min_eq_right</span> <span class="n">hc</span><span class="o">,</span> <span class="n">min_eq_right</span> <span class="n">hb</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">nat.min_add_distrib_broken</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">min</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">min</span> <span class="n">a</span> <span class="o">(</span><span class="n">min</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">min</span> <span class="n">a</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">min_add_distrib</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="c1">-- does not work</span>

<span class="kd">lemma</span> <span class="n">nat.min_add_distrib</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">min</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">min</span> <span class="n">a</span> <span class="o">(</span><span class="n">min</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">min</span> <span class="n">a</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">le_total</span> <span class="n">a</span> <span class="n">b</span> <span class="k">with</span> <span class="n">hb</span> <span class="n">hb</span><span class="o">,</span> <span class="c1">-- same proof as above</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hb</span><span class="o">,</span> <span class="n">le_add_right</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">le_total</span> <span class="n">a</span> <span class="n">c</span> <span class="k">with</span> <span class="n">hc</span> <span class="n">hc</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hc</span><span class="o">,</span> <span class="n">le_add_left</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hb</span><span class="o">,</span> <span class="n">hc</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="225782890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225782890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225782890">(Feb 10 2021 at 01:19)</a>:</h4>
<p>Aren't you putting two different preorders on \B, since both typeclasses have the same base?</p>



<a name="225782985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225782985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225782985">(Feb 10 2021 at 01:20)</a>:</h4>
<p>Yes, that's what breaks it. But what makes the <code>nat</code> version work then? The fact that the underlying order is the same?</p>



<a name="225782997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225782997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225782997">(Feb 10 2021 at 01:20)</a>:</h4>
<p>And if so, why is <code>nat</code> not a <code>canonically_linear_ordered_add_monoid</code>?</p>



<a name="225783131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225783131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225783131">(Feb 10 2021 at 01:23)</a>:</h4>
<p>Yes, the elaborator(?) will deduce the two preorder structures are the same for nat, by unfolding both</p>



<a name="225783480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225783480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225783480">(Feb 10 2021 at 01:28)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/canonically_linear_ordered_add_monoid">docs#canonically_linear_ordered_add_monoid</a> doesn't have an "instances" section at all. Maybe we just haven't gotten around to declaring any in mathlib yet?</p>



<a name="225783694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225783694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225783694">(Feb 10 2021 at 01:32)</a>:</h4>
<p>I'd be happy to add it -- but my vscode decided to break all the webview plugins, including the Lean one...</p>



<a name="225783882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225783882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225783882">(Feb 10 2021 at 01:34)</a>:</h4>
<p>Heh, it doesn't look like any instances were added when the class was added in <a href="https://github.com/leanprover-community/mathlib/issues/3335">#3335</a>, nor in any of the commits afterwards.</p>



<a name="225784042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225784042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225784042">(Feb 10 2021 at 01:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid/near/225783694">said</a>:</p>
<blockquote>
<p>I'd be happy to add it -- but my vscode decided to break all the webview plugins, including the Lean one...</p>
</blockquote>
<p>I updated VS Code a bit earlier today but I haven't seen any breakage yet. What OS are you on?</p>



<a name="225784199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225784199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225784199">(Feb 10 2021 at 01:38)</a>:</h4>
<p>Windows, using via WSL</p>



<a name="225784211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225784211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225784211">(Feb 10 2021 at 01:39)</a>:</h4>
<p>Git Graph is also not working, which suggests a webview problem</p>



<a name="225784438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225784438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225784438">(Feb 10 2021 at 01:42)</a>:</h4>
<p>Ah, I see. I couldn't find any relevant-looking recent issues at <a href="https://github.com/microsoft/vscode/issues">https://github.com/microsoft/vscode/issues</a> so it might be worth reporting there.</p>



<a name="225784610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225784610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225784610">(Feb 10 2021 at 01:45)</a>:</h4>
<p>A lot of older issues referencing this from around June though =C</p>



<a name="225784640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225784640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225784640">(Feb 10 2021 at 01:45)</a>:</h4>
<p>In any case: <a href="https://github.com/leanprover-community/mathlib/issues/6144">#6144</a></p>



<a name="225791308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225791308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225791308">(Feb 10 2021 at 03:49)</a>:</h4>
<p>What's the best solution for this sort of thing? I just made <a href="https://github.com/leanprover-community/mathlib/pull/6145#issuecomment-776406785">a suggestion</a> in another of Yakov's PRs which ran into the same problem, where now the instances for <code>linear_ordered_comm_monoid_with_zero</code> and <code>ordered_cancel_add_comm_monoid</code> have orders that don't necessarily agree.</p>



<a name="225802114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225802114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225802114">(Feb 10 2021 at 07:34)</a>:</h4>
<p>Any time you need the properties of two different typeclasses with the same base, you have to introduce a third typeclass extending both</p>



<a name="225803802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225803802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225803802">(Feb 10 2021 at 08:00)</a>:</h4>
<p>I had a branch in which I added a <code>canonically_linear_ordered_add_monoid</code> instance to nnreal, which works fine, as well as<br>
<code>instance with_top.canonically_linear_ordered_add_monoid  </code> as done in <a href="https://github.com/leanprover-community/mathlib/issues/6144">#6144</a>, with the idea of applying that to ennreal. But then the orders on ennreal conflict. ennreal would need a typeclass which is also a complete lattice (if I remember correctly). I was hoping for another solution because I did not want to add a <code>complete_canonically_linear_ordered_add_monoid</code> which would only apply to ennreal. Eric, you say that adding that other class is the only way?</p>



<a name="225803975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225803975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225803975">(Feb 10 2021 at 08:02)</a>:</h4>
<p>Two different typeclasses which provide the same order on the same type don't conflict</p>



<a name="225804065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225804065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225804065">(Feb 10 2021 at 08:03)</a>:</h4>
<p>It's only when you define a lemma taking two typeclasses that _could_ conflict that you have a problem, because without a concrete type to look at, the two instances can't just be unfolded and checked for equality</p>



<a name="225804296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225804296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225804296">(Feb 10 2021 at 08:06)</a>:</h4>
<p>Ok. Then I don't remember it correctly, or don't describe it correctly. I think it had to do with the lattice, which can come from <code>canonically_linear_ordered_monoid.semilattice_sup_bot</code> or from the <code>complete_linear_order</code> on ennreal, but I'll test that branch again rather than conjecture based on old impressions.</p>



<a name="225806002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225806002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225806002">(Feb 10 2021 at 08:28)</a>:</h4>
<p>When I add <code>[derive canonically_linear_ordered_add_monoid]</code> to ennreal (without removing/changing any of the other derived instances), the lemma <code>diam_triple</code> in <code>topology/metric_space/emetric_space.lean</code> fails, because of <code>ennreal.sup_eq_max</code>. The issue seems to be that there are two different <code>has_sup</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">type</span> <span class="n">ascription</span><span class="o">,</span> <span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">eq</span> <span class="n">ennreal</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">has_sup.sup</span> <span class="n">ennreal</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">semilattice_sup.to_has_sup</span> <span class="n">ennreal</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">semilattice_sup_bot.to_semilattice_sup</span> <span class="n">ennreal</span>
             <span class="o">(</span><span class="bp">@</span><span class="n">canonically_linear_ordered_add_monoid.semilattice_sup_bot</span> <span class="n">ennreal</span>
                <span class="n">ennreal.canonically_linear_ordered_add_monoid</span><span class="o">)))</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">has_edist.edist</span> <span class="n">α</span> <span class="o">(</span><span class="bp">@</span><span class="n">emetric_space.to_has_edist</span> <span class="n">α</span> <span class="n">_inst_1</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">has_edist.edist</span> <span class="n">α</span> <span class="o">(</span><span class="bp">@</span><span class="n">emetric_space.to_has_edist</span> <span class="n">α</span> <span class="n">_inst_1</span><span class="o">)</span> <span class="n">x</span> <span class="n">z</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">max</span> <span class="n">ennreal</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">conditionally_complete_linear_order.to_linear_order</span> <span class="n">ennreal</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">conditionally_complete_linear_order_of_complete_linear_order</span> <span class="n">ennreal</span> <span class="n">ennreal.complete_linear_order</span><span class="o">))</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">has_edist.edist</span> <span class="n">α</span> <span class="o">(</span><span class="bp">@</span><span class="n">emetric_space.to_has_edist</span> <span class="n">α</span> <span class="n">_inst_1</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">has_edist.edist</span> <span class="n">α</span> <span class="o">(</span><span class="bp">@</span><span class="n">emetric_space.to_has_edist</span> <span class="n">α</span> <span class="n">_inst_1</span><span class="o">)</span> <span class="n">x</span> <span class="n">z</span><span class="o">))</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">eq</span> <span class="n">ennreal</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">has_sup.sup</span> <span class="n">ennreal</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">semilattice_sup.to_has_sup</span> <span class="n">ennreal</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">semilattice_sup_bot.to_semilattice_sup</span> <span class="n">ennreal</span>
             <span class="o">(</span><span class="bp">@</span><span class="n">semilattice_sup_bot_of_bounded_lattice</span> <span class="n">ennreal</span>
                <span class="o">(</span><span class="bp">@</span><span class="n">complete_lattice.to_bounded_lattice</span> <span class="n">ennreal</span>
                   <span class="o">(</span><span class="bp">@</span><span class="n">complete_linear_order.to_complete_lattice</span> <span class="n">ennreal</span> <span class="n">ennreal.complete_linear_order</span><span class="o">)))))</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">has_edist.edist</span> <span class="n">α</span> <span class="o">(</span><span class="bp">@</span><span class="n">emetric_space.to_has_edist</span> <span class="n">α</span> <span class="n">_inst_1</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">has_edist.edist</span> <span class="n">α</span> <span class="o">(</span><span class="bp">@</span><span class="n">emetric_space.to_has_edist</span> <span class="n">α</span> <span class="n">_inst_1</span><span class="o">)</span> <span class="n">x</span> <span class="n">z</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">max</span> <span class="n">ennreal</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">conditionally_complete_linear_order.to_linear_order</span> <span class="n">ennreal</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">conditionally_complete_linear_order_of_complete_linear_order</span> <span class="n">ennreal</span> <span class="n">ennreal.complete_linear_order</span><span class="o">))</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">has_edist.edist</span> <span class="n">α</span> <span class="o">(</span><span class="bp">@</span><span class="n">emetric_space.to_has_edist</span> <span class="n">α</span> <span class="n">_inst_1</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">has_edist.edist</span> <span class="n">α</span> <span class="o">(</span><span class="bp">@</span><span class="n">emetric_space.to_has_edist</span> <span class="n">α</span> <span class="n">_inst_1</span><span class="o">)</span> <span class="n">x</span> <span class="n">z</span><span class="o">))</span>
</code></pre></div>
<p>Is it true that the <code>with_top</code> of a <code>canonically_linear_ordered_add_monoid</code> is a <code>complete_lattice</code>? We could remove the <code>[derive complete_linear_order]</code> on ennreal and it would remove the issue.</p>



<a name="225806148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225806148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225806148">(Feb 10 2021 at 08:30)</a>:</h4>
<p>It is certainly a bounded lattice, but I don't know about complete</p>



<a name="225807954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225807954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225807954">(Feb 10 2021 at 08:51)</a>:</h4>
<p>and the answer is no, if I am not mistaken. A counterexample would be the non-negative rational numbers (with top).</p>



<a name="225808461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225808461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225808461">(Feb 10 2021 at 08:56)</a>:</h4>
<p>Can you make a branch to demo the problem?</p>



<a name="225810021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225810021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225810021">(Feb 10 2021 at 09:12)</a>:</h4>
<p>I created the branch ennreal_lattice_issue, in which I started from <a href="https://github.com/leanprover-community/mathlib/issues/6144">#6144</a> and added a <code>canonically_linear_ordered_add_monoid</code> instance to ennreal. It is still building so I don't know yet if the issue I am trying to replicate is visible. I'll update this thread when it is done.</p>



<a name="225810542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225810542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225810542">(Feb 10 2021 at 09:17)</a>:</h4>
<p>Yes, that <code>derive</code> was reverted in my last commit, because of this exact issue. You identified the lemma that breaks.</p>



<a name="225814445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225814445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225814445">(Feb 10 2021 at 09:58)</a>:</h4>
<p>The branch ennreal_lattice_issue finished building (the build failed). There is an issue with the use of <code>ennreal.sup_eq_max</code> in the proof of <code>diam_triple</code> in topology/metric_space/emetric_space.</p>



<a name="225822221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225822221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225822221">(Feb 10 2021 at 11:21)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/tree/ennreal_lattice_issue">branch#ennreal_lattice_issue</a></p>



<a name="225830563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225830563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225830563">(Feb 10 2021 at 12:48)</a>:</h4>
<p>I think that I found a fix: removing <code>instance canonically_linear_ordered_monoid.semilattice_sup_bot</code>.</p>



<a name="225830615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/nat%20as%20a%20canonically_linear_ordered_add_monoid/near/225830615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/nat.20as.20a.20canonically_linear_ordered_add_monoid.html#225830615">(Feb 10 2021 at 12:49)</a>:</h4>
<p>I am waiting for the build to succeed, to be sure that it did not break anything else.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
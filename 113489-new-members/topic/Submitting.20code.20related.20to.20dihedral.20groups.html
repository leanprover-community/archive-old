---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Submitting.20code.20related.20to.20dihedral.20groups.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Submitting.20code.20related.20to.20dihedral.20groups.html">Submitting code related to dihedral groups</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="238833423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Submitting%20code%20related%20to%20dihedral%20groups/near/238833423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Griffin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Submitting.20code.20related.20to.20dihedral.20groups.html#238833423">(May 14 2021 at 21:39)</a>:</h4>
<p>As some of you could probably guess from my repeated questions about dihedral groups, I've been working with them in Lean. I have a few results that I think would be good additions to mathlib's dihedral group file. Specifically, I have work related to which elements can and cannot be central in a (non-degenerate) dihedral group, since this is a result not already contained in mathlib's dihedral group file that would be commonly desired among people working with them. Now, before I officially ask for permission to make a pull request, I have uploaded the code I wrote in a standalone Lean file to my GitHub page (I am <code>Fontkodo</code> on GitHub), so that it could be reviewed, in case there is something wrong with it. The file can be found <a href="https://github.com/Fontkodo/dihedral-center-suggestion/blob/main/dihedral_github.lean">here</a>. Note that while the code is contained in a standalone file, this is just for presentation purposes, because the intent is that these result would be added to the existing file. Please let me know if there is something that should be improved upon before I submit a pull request.</p>



<a name="238834846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Submitting%20code%20related%20to%20dihedral%20groups/near/238834846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Submitting.20code.20related.20to.20dihedral.20groups.html#238834846">(May 14 2021 at 21:53)</a>:</h4>
<p>I've sent you an invite: <a href="https://github.com/leanprover-community/mathlib/invitations">https://github.com/leanprover-community/mathlib/invitations</a></p>
<p>Your code looks ready enough to PR (though I can't guarantee that what you've proved isn't hidden somewhere else). It's generally easiest for us to review contributions in the form of a PR since we can easily add comments and suggestions and also have our scripts check whether the code builds, etc.</p>



<a name="238836048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Submitting%20code%20related%20to%20dihedral%20groups/near/238836048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Submitting.20code.20related.20to.20dihedral.20groups.html#238836048">(May 14 2021 at 22:06)</a>:</h4>
<p>Hi Alex,</p>
<p>I have not looked at the groups part of mathlib.  However, if you are interested, below is a golfed version of your lemmas.</p>
<p>I changed the existential lemmas with the explicit element used, since it seemed stronger to actually have a witness, rather than a mere existential statement.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">sr_not_mem_center</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">2</span><span class="o">)]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">):</span> <span class="n">sr</span> <span class="n">i</span> <span class="bp">*</span> <span class="o">(</span><span class="n">r</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">≠</span> <span class="o">(</span><span class="n">r</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="n">r</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span>

<span class="sd">/--</span>
<span class="sd">Rotations with order greater than 2 are not central.</span>
<span class="sd">`i` is any `zmod n` term satisfying `2 * i ≠ 0`.</span>
<span class="sd">-/</span>
<span class="kd">theorem</span> <span class="n">r_not_mem_center</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="n">i</span> <span class="bp">*</span> <span class="o">(</span><span class="n">sr</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">≠</span> <span class="o">(</span><span class="n">sr</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="n">r</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">sub_eq_add_neg</span><span class="o">,</span> <span class="bp">←</span> <span class="n">add_eq_zero_iff_neg_eq</span><span class="o">,</span> <span class="bp">←</span> <span class="n">two_mul</span><span class="o">]</span>

<span class="sd">/--</span>
<span class="sd">Rotations with order at most 2 commute with all rotations.</span>
<span class="sd">`i` is any `zmod n` term satisfying `2 * i = 0`.</span>
<span class="sd">-/</span>
<span class="kd">theorem</span> <span class="n">r_mem_center_r</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">r</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">r</span> <span class="n">j</span> <span class="bp">*</span> <span class="n">r</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">add_comm</span><span class="o">]</span>

<span class="sd">/--</span>
<span class="sd">Rotations with order at most 2 commute with all reflections.</span>
<span class="sd">`i` is any `zmod n` term satisfying `2 * i = 0`.</span>
<span class="sd">-/</span>
<span class="kd">theorem</span> <span class="n">r_mem_center_sr</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">sr</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">sr</span> <span class="n">j</span> <span class="bp">*</span> <span class="n">r</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">sub_eq_add_neg</span><span class="o">,</span> <span class="bp">←</span> <span class="n">add_eq_zero_iff_neg_eq</span><span class="o">,</span> <span class="bp">←</span> <span class="n">two_mul</span><span class="o">]</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
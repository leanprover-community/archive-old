---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Probability.20theory.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html">Probability theory</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="233038577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/233038577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#233038577">(Apr 03 2021 at 22:45)</a>:</h4>
<p>I definitely agree that it would be great to have much of <a href="https://github.com/google/formal-ml">formal ML</a> in mathlib. It seems like a fantastic addition to probability theory and I wasn't aware of it before. Thank you Joao for pointing it out! And of course thanks to Martin Zinkevich for the whole thing!</p>
<p>(Btw, I think it might be best to rename this discussion's topic to something more accurately descriptive, e.g. "probability theory", maybe starting from Floris' message. Renaming topics seems to require admin rights, though.)</p>



<a name="233039521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/233039521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#233039521">(Apr 03 2021 at 23:03)</a>:</h4>
<p>(I've renamed the thread.)</p>



<a name="233039682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/233039682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#233039682">(Apr 03 2021 at 23:07)</a>:</h4>
<p>I think <span class="user-mention" data-user-id="116448">@Koundinya Vajjha</span>'s repo at <a href="https://github.com/jtristan/stump-learnable">https://github.com/jtristan/stump-learnable</a> has some material on probability theory as well.</p>



<a name="233265945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/233265945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#233265945">(Apr 06 2021 at 04:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/113489-new-members/topic/Probability.20theory/near/233031296">said</a>:</p>
<blockquote>
<p>I am not sure what the etiquette here is, not to mention the ethics and the law -- if a person writes a Lean package under an open-source license (as Martin did with FormalML), is it ok for someone else to PR parts of it, keeping the copyright and authorship intact?</p>
</blockquote>
<p>As far as ethics and law is concerned, the answer is yes and this is common practice in software.</p>
<p>It's necessary that the licenses be compatible -- that is, the original license and that of the project the material is then contributed to must not have conditions that conflict with each other -- but it looks like Formal ML uses exactly the same license as mathlib, so that's not an issue here.</p>
<p>(And of course it's essential to be explicit about the original authorship, essential ethically and also legally under typical open-source licenses.)</p>



<a name="233265964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/233265964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#233265964">(Apr 06 2021 at 04:42)</a>:</h4>
<p>That doesn't answer the question of etiquette. I think the central question there is usually how the original author is likely to feel about it.</p>



<a name="234999681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/234999681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#234999681">(Apr 17 2021 at 16:19)</a>:</h4>
<p>I just sent an email to Martin Zinkevich asking his permission to integrate FormalML into mathlib. Attached is a first attempt to integrate his file probability_space.lean into mathlib. Here is an immediate issue. He defines a probability space (see <a href="https://github.com/google/formal-ml/blob/master/src/formal_ml/probability_space.lean">https://github.com/google/formal-ml/blob/master/src/formal_ml/probability_space.lean</a>) as follows:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">probability_space</span> <span class="o">(</span><span class="n">α</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">measure_theory.measure_space</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">univ_one</span><span class="o">:</span><span class="n">volume.measure_of</span> <span class="o">(</span><span class="n">set.univ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>whereas mathlib already has </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">probability_measure</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="n">measure_univ</span> <span class="o">:</span> <span class="n">μ</span> <span class="n">univ</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>How should these be reconciled? <a href="/user_uploads/3121/w_CHwPYslseOGK1DxDn3cazu/probability_space.lean">probability_space.lean</a> Also measurable_setB needs a better name.</p>



<a name="234999799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/234999799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#234999799">(Apr 17 2021 at 16:20)</a>:</h4>
<p>Those are the same? A probability space is a measure space where the designated "<code>volume</code>" measure is a probability measure</p>



<a name="235000525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/235000525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#235000525">(Apr 17 2021 at 16:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  Repeating "=1" seems redundant--one definition could rely on the other, i.e., a probability_space is a measure_space with a measure that is a probability_measure.</p>



<a name="235000540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/235000540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#235000540">(Apr 17 2021 at 16:32)</a>:</h4>
<p>That's what I just said</p>



<a name="235000719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/235000719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#235000719">(Apr 17 2021 at 16:34)</a>:</h4>
<p>I don't think it matters too much whether the field is <code>  (univ_one:volume.measure_of (set.univ) = 1)</code> or <code>[prob : probability_measure volume]</code></p>



<a name="235000740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/235000740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#235000740">(Apr 17 2021 at 16:35)</a>:</h4>
<p>the former is probably a bit more convenient when constructing probability spaces</p>



<a name="235000754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/235000754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#235000754">(Apr 17 2021 at 16:35)</a>:</h4>
<p>but you can have constructors for both versions</p>



<a name="235064742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/235064742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#235064742">(Apr 18 2021 at 11:19)</a>:</h4>
<p>Judging by your first PR to attempt to integrate formalML into mathlib, it may make sense to first integrate mathlib into formalML; despite depending on mathlib, the library seems to repeat lots of our lemmas.</p>



<a name="235064812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/235064812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#235064812">(Apr 18 2021 at 11:20)</a>:</h4>
<p>I guess how viable that is depends on whether Martin has the time to accept pull requests.</p>



<a name="235065258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/235065258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#235065258">(Apr 18 2021 at 11:28)</a>:</h4>
<p>Or simply fork.</p>



<a name="239769634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/239769634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#239769634">(May 21 2021 at 15:33)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span>  <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I have created a branch probability_theory with the new file probability_space.lean based on <span class="user-mention" data-user-id="247798">@Martin Zinkevich</span>'s  formal-ml (<a href="https://github.com/leanprover-community/mathlib/blob/probability_theory/src/probability_theory/probability_theory.lean">https://github.com/leanprover-community/mathlib/blob/probability_theory/src/probability_theory/probability_theory.lean</a>). This has nearly 700 lines of code, as a first step, from 3300 in the formal-ml file. I wanted to touch base before I submit a pull request. There are no repeated lemmas from mathlib that I could see.  How does this look?</p>



<a name="239772660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/239772660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#239772660">(May 21 2021 at 15:52)</a>:</h4>
<p>A quick skim:</p>
<ul>
<li><code>probability_space.to_measurable_space</code> should be automatic; in general, when adding an instance you can check if it's needed by first trying to define it with <code>by apply_instance</code></li>
<li><code>measurable_set_sub</code> looks like a bad idea to me. Why not skip straight to <code>event</code>, and define it as <code>abbreviation event : Type* := {x : set Ω // measurable_set  x}</code>. That's likely to remove the need for most of the lemmas in the first 100 lines.</li>
<li><code>to_ennreal_monotonic </code> exists already as <a href="https://leanprover-community.github.io/mathlib_docs/find/ennreal.coe_mono">docs#ennreal.coe_mono</a>. <code>library_search</code> tells me that. In general, if you put all the arguments before the colon, <code>library_search</code> will have an easier time finding it. If you write a lemma <code>lemma foo : A  → B := begin intro a, ... end</code> then really you should have written <code>lemma foo (a : A) : B := begin ... end</code></li>
</ul>



<a name="239772950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/239772950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#239772950">(May 21 2021 at 15:54)</a>:</h4>
<ul>
<li>I don't think you should even be writing <code>volume.measure_of x</code> - the canonical spelling should be <code>volume x</code></li>
</ul>



<a name="239775638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/239775638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#239775638">(May 21 2021 at 16:10)</a>:</h4>
<ul>
<li>Instead of <code>{Ω : Type*} {P : probability_space Ω} (X : event P)</code> you probably want <code>{Ω : Type*} [probability_space Ω] (X : event Ω)</code></li>
</ul>



<a name="239776174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/239776174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#239776174">(May 21 2021 at 16:14)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, thoughts on renaming <a href="https://leanprover-community.github.io/mathlib_docs/find/measurable_set">docs#measurable_set</a> to <code>is_measurable</code> so that <code>measurable_set</code> can be used to instead mean <code>subtype is_measurable</code>?</p>



<a name="239778931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/239778931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#239778931">(May 21 2021 at 16:34)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> thanks. If I skip straight to <code>abbreviation event : Type* := {x : set Ω // measurable_set  x}</code>, how do I address the error 'unknown identifier Ω'--does that not require a def? How would I modify the code to use the automatic instance? When I drop <code>measure_of</code>, how do I address the error "invalid field notation, volume does not have explicit argument with type ...". Your patience is appreciated.</p>



<a name="239779169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/239779169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#239779169">(May 21 2021 at 16:36)</a>:</h4>
<p>See my edited message</p>



<a name="239779173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/239779173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#239779173">(May 21 2021 at 16:36)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">event</span> <span class="o">(</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">Ω</span> <span class="bp">//</span> <span class="n">measurable_set</span> <span class="n">x</span><span class="o">}</span>
</code></pre></div>



<a name="239779267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/239779267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#239779267">(May 21 2021 at 16:37)</a>:</h4>
<p>Then your lemmas below become something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">Pr_le_one</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="n">event</span> <span class="bp">Ω</span><span class="o">}</span> <span class="o">:</span> <span class="n">Pr</span><span class="o">[</span><span class="n">E</span><span class="o">]</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span>
</code></pre></div>



<a name="239779299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/239779299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#239779299">(May 21 2021 at 16:37)</a>:</h4>
<blockquote>
<p>invalid field notation, volume does not have explicit argument with type ...</p>
</blockquote>
<p>Change it from <code>P.volume.measure_of x</code> to <code>volume x</code>. You need to drop the <code>P.</code> too</p>



<a name="239781174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/239781174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#239781174">(May 21 2021 at 16:52)</a>:</h4>
<p>I made a start on a very rough start on some of those changes here, which should be enough to answer some of your questions: <a href="https://gist.github.com/eric-wieser/1f119d6c22a9d14f5200f2be7b7ce511">https://gist.github.com/eric-wieser/1f119d6c22a9d14f5200f2be7b7ce511</a></p>



<a name="240019444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240019444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240019444">(May 24 2021 at 08:13)</a>:</h4>
<p>I am not really convinced by the design choice to try to hide as much as measure theory as possible, because I have the impression it will lead to a lot of code duplication. The branch uses <code>event</code> for a measurable set, and then formulates everything in terms of events. But this means that you will need to recreate all the set API for events (unions, intersections, diffs, Unions, sum over a finite event, and so on), and also all measure theory library (Lebesgue dominated convergence theorem, Fatou's lemma, and so on, and so on. It would feel to me much more economical to use standard terminology with measurability assumptions. And ideally one would craft a <code>measurability</code> tactic that one would use as a default tactic to fill all measurability fields when one applies lemmas.</p>



<a name="240020665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240020665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240020665">(May 24 2021 at 08:26)</a>:</h4>
<p>To me it seems the key change being proposed by this code is "a bundled version of<code>measurable_set</code> would be useful"</p>



<a name="240020672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240020672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240020672">(May 24 2021 at 08:26)</a>:</h4>
<p>Along with lots of noise duplicating API</p>



<a name="240024739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240024739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240024739">(May 24 2021 at 09:07)</a>:</h4>
<p>I made a PR providing some instances in <a href="https://github.com/leanprover-community/mathlib/issues/7702">#7702</a></p>



<a name="240024797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240024797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240024797">(May 24 2021 at 09:07)</a>:</h4>
<p>Also, we already have <code>probability_measure</code>, so I don't think <code>probability_space</code> is useful. Just using <code>(Pr : measure \alpha) [probability_measure Pr]</code> should be enough.</p>



<a name="240024805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240024805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240024805">(May 24 2021 at 09:07)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/measure_theory.probability_measure">docs#measure_theory.probability_measure</a> <del>seems not to exist</del></p>



<a name="240025087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240025087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240025087">(May 24 2021 at 09:10)</a>:</h4>
<p>Presumably <code>[probability_measure (volume : measure_theory.measure α)]</code> would also work? (and be a direct substitution for the typeclass Hunter is proposing)</p>



<a name="240025267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240025267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240025267">(May 24 2021 at 09:13)</a>:</h4>
<p>Thinking of standard probability measure changes arguments à la Girsanov, I think keeping the probability measure explicit can only help.</p>



<a name="240025661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240025661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240025661">(May 24 2021 at 09:16)</a>:</h4>
<p>The only drawback of this is that a measure is <code>ennreal</code>-valued, while here we would want to use mainly the real-valued version. We should probably introduce something like <code>measure.fin \mu (A) = (\mu A).to_real</code>, and use <code>Pr_ennreal</code> for the full measure and a notation for <code>Pr = Pr_ennreal.fin</code>.</p>



<a name="240039848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240039848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240039848">(May 24 2021 at 11:47)</a>:</h4>
<p>Another issue I have with the <code>event</code> idea is that very often there are several sigma-algebras playing together (martingales are a basic probabilistic object built precisely around this idea, but it also shows up all the time in Markov chains). So one would need to define a bunch of "events" for these different sigma-algebras, but it is well known that doing operations on bundled objects is painful (like, if you have <code>A</code> which is an event for the sigma algebra <code>B</code>, and <code>A'</code> which is an event for the sigma algebra <code>B'</code>, then what is <code>A \cap A'</code>? With plain sets, you just have a set, and then depending on the relationships between <code>B</code> and <code>B'</code> you can argue that this intersection belongs to <code>B</code>, or to <code>B'</code>, or maybe to yet another natural sigma-algebra, depending on the situation at hand).</p>



<a name="240040096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240040096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240040096">(May 24 2021 at 11:49)</a>:</h4>
<blockquote>
<p>but it is well known that doing operations on bundled objects is painful</p>
</blockquote>
<p>Sure, but also mathlib seems to have fallen into a convention of bundling them anyway. A similar case comes up with "what is <code>x + y</code>" when <code>x</code> and <code>y</code> are from different add_subgroups. You can always escape to unbundled land with coercions, and an API around <code>event</code> (aka <code>subtype measuable_set</code>) could behave just the same</p>



<a name="240040676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240040676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240040676">(May 24 2021 at 11:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/Probability.20theory/near/240040096">said</a>:</p>
<blockquote>
<blockquote>
<p>but it is well known that doing operations on bundled objects is painful</p>
</blockquote>
<p>Sure, but also mathlib seems to have fallen into a convention of bundling them anyway.</p>
</blockquote>
<p>I am not so sure about that: I'd rather say that mathlib is pragmatic, and tries to make the most common operation the easiest possible. Adding elements of different add_subgroups is not really common, while intersecting measurable sets coming from different sigma-algebras will happen all the time.</p>



<a name="240041061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240041061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240041061">(May 24 2021 at 11:59)</a>:</h4>
<p>Maybe a difficulty here is that elementary probability theory, as taught to undergrads say, is mostly taking finite intersections of sets within a fixed sigma-algebra, and never needs anything fancy in measure theory. While more advanced probability theory is very different from this naive point of view.</p>



<a name="240041252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240041252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240041252">(May 24 2021 at 12:00)</a>:</h4>
<p>I think I can see the argument for why you need the unbundled approach, but it's not clear to me why you can't also have the bundled approach for convenience in the simple cases. Ignoring the "more accessible to undergrads" argument, the "does boring book-keeping for you" argument still holds</p>



<a name="240041390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240041390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240041390">(May 24 2021 at 12:02)</a>:</h4>
<p>Any by "have the bundled approach for convenience", I guess I really just mean "provide a <code>[measurable_space α] : boolean_algebra (subtype (measurable_set : set α → Prop))</code> instance somewhere".</p>



<a name="240042321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240042321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240042321">(May 24 2021 at 12:11)</a>:</h4>
<p>Except that one also takes a lot of countable intersections, preimages under measurable functions, and so on. That's why a tactic seems to me to be more suited for the job (there is such a tactic in Isabelle, and 99% of the time you don't need to mention measurability, it's just taken care of transparently).</p>



<a name="240043481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240043481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240043481">(May 24 2021 at 12:23)</a>:</h4>
<p>Preimages don't sound like aren't a major obstacle, we have <a href="https://leanprover-community.github.io/mathlib_docs/find/submonoid.comap">docs#submonoid.comap</a> etc. Countable intersections I guess are problematic as mathlib only has lemmas about countable intersections of sets, not on arbitrary lattices?</p>



<a name="240072473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240072473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240072473">(May 24 2021 at 16:06)</a>:</h4>
<p>My inexperienced but interested user's opinion so far matches well with many of the things Sebastien has said here. But I don't intend that as an opinion about implementation (I am not yet in a position to have one).</p>
<p>I have played a bit with Lean's probability theory (i.e., measure theory) as a first formalization exercise for myself after some tutorials (NNG of course, Kevin's "Formalizing math" course, and some parts of "Lean together"). I feel parts of the library are quite mature, and I can (painfully slowly) do things I would hope to.</p>
<p>I in particular agreed with Sebastien about all of the following:</p>
<ul>
<li>One very often wants to use many probability measures; whether in coupling arguments, or convergence in distribution, or in change-of-measure arguments (e.g., Girsanov's theorem).</li>
<li>It seems essential in probability theory and stochastic processes to be able to work with many (sub)sigma-algebras on the same set; conditional expected values and martingales being probably the most prominent cases.</li>
<li>Every now and then coercions between <code>ennreal</code>s and either <code>nnreal</code>s or <code>ℝ</code> get me stuck quite badly. For probabilities, these difficulties feel like they should not be there, but for expected values they are essentially as unavoidable as with integrals against general measures.</li>
<li>Settling measurability questions by hand is sometimes indeed a pain (in Lean and to some extent on pen and paper). This seems to correspond to maths students' experience with measure-theoretic probability as well: often the most tedious step in probability courses are related to verifications of measurability (or other measurability issues such as indistinguishability / versions / ...). I have no idea about tactics except that when they work, they are fantastic. So if it is possible to have a <code>measurability</code> tactic as Sebastien proposes, I will be super happy!</li>
</ul>
<p>To be clear, these are just my experiences as a beginner, and not an opinion on how to develop the mathlib probability library. I am very impressed with the existing library and its implementation, so obviously the experts here (including in this thread) know what they are doing :).</p>



<a name="240116719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240116719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240116719">(May 24 2021 at 21:47)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span>, I've got an approval on <a href="https://github.com/leanprover-community/mathlib/issues/7702">#7702</a> which I mention above. Are you against having these instances, or just claiming they're not nearly as useful as they might first look? If the latter, I'll go ahead and merge, since even if the instances aren't that helpful, they seem like the obvious instances to have available.</p>



<a name="240144388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240144388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240144388">(May 25 2021 at 05:35)</a>:</h4>
<p>I'm definitely fine with having this merged! We will see later if this turns out to be useful or not so much.</p>



<a name="240172545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240172545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240172545">(May 25 2021 at 11:22)</a>:</h4>
<p>A follow-up question; which of these is preferable for working with <code>subtype (measurable_set : set α → Prop)</code>?</p>
<ul>
<li>Give that type a new name like <code>event α</code> (does this make sense for non-probability spaces? Is there a better name?)</li>
<li>Rename <code>measurable_set s</code> to <code>is_measurable_set s</code>, so that that we can repurpose <code>measurable_set α</code> to mean `subtype (is_measurable_set : set α → Prop)</li>
<li>Do not introduce a new name, and require users to work with the <code>subtype</code> directly. The main disadvantage of this approach is a lack of an obvious namespace to put definitions and lemmas about the bundled type in.</li>
</ul>



<a name="240681505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240681505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240681505">(May 29 2021 at 04:05)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span>  I have substantially updated probability_space.lean from formal-ml for inclusion in mathlib here (<a href="https://github.com/leanprover-community/mathlib/blob/1e717b785574bb153f1f3a1b3d0ff644b905751f/src/probability_theory/probability_space.lean">https://github.com/leanprover-community/mathlib/blob/1e717b785574bb153f1f3a1b3d0ff644b905751f/src/probability_theory/probability_space.lean</a>). This now avoids creating many lemmas already in mathlib. I ran into a few roadblocks where I would appreciate your help again.. These are marked TODO. If you can help me resolve these, there are many other probability/machine learning components in formal-ml that would be good additions to mathlib.</p>
<p>Line 70. "def event" should replace "measurable_space" with "probability_space" but then I could not resolve all the errors when I changed this.</p>
<p>Line 649. Should we get rid of the alternative definition of measurable_set as measurable_setB (which I could work out how to do) or just keep it with a name like "measurable_space_sub".</p>
<p>Line 1068. "lemma eall_finset_empty" is commented out because I could not resolve the type mismatch.</p>
<p>Line 1122. I brought back "infix <code> •ℕ </code>:70 := nsmul" from an older version of mathlib to get this to compile. How do I get rid of it again?</p>
<p>Line 1148. See new definition of "noncomputable def classical.decidable_eq" which I could not eliminate</p>
<p>There are compile errors I could not resolve: line 1050, 1408 (Pr_exists_eq_powerset), 1492 (independent_events_not_of_independent_events), 2880 (Pr_eany_sum), 3260, 3298 (independent_events_empty), 3410 (and_mem_exists), 3521 (Pr_sum_partition), 3542 (conditional_independent_event_pair_limit), 3580 (compose_independent_pair_right).</p>
<p>Line 2250. Is "measurable_set_prod'" necessary given "measurable_set_prod"</p>
<p>Line 2326. "noncomputable def fintype.encodable" could be imported from data.equiv.list rather than being redefined here.</p>
<p>Line 2402. Is "singleton_prod'" needed given "set.prod_singleton_singleton"?</p>
<p>Line 2594. Can lemma eq_or_ne2 be dropped?</p>
<p>Line 2605, 3029, 3124. Move to nnreal?</p>
<p>Lines 2624, 2686, 2707, 2710, 2725, 2738, 2754, 2770, 2780, 2787, 2843, 2854, . Move to sum?</p>
<p>Lines 3043, 3061, 3076. Move to set?</p>
<p>Hunter</p>



<a name="240686761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240686761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240686761">(May 29 2021 at 06:27)</a>:</h4>
<p>Line 70 is better with <code>measurable_space</code></p>



<a name="240686812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240686812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240686812">(May 29 2021 at 06:28)</a>:</h4>
<p>Line 649: <code>measurable_setB</code> is not an "alternative definition", it's an identical one to <code>event</code>. There is no reason to keep it.</p>



<a name="240686945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240686945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240686945">(May 29 2021 at 06:31)</a>:</h4>
<p>Line 83: this already exists, <a href="https://leanprover-community.github.io/mathlib_docs/find/measurable_set.subtype.has_mem">docs#measurable_set.subtype.has_mem</a></p>



<a name="240687032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240687032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240687032">(May 29 2021 at 06:33)</a>:</h4>
<p>Line 210: <code>has_emptyc_event</code> already exists, it's <a href="https://leanprover-community.github.io/mathlib_docs/find/measurable_set.subtype.has_emptyc">docs#measurable_set.subtype.has_emptyc</a>.</p>



<a name="240687477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240687477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240687477">(May 29 2021 at 06:44)</a>:</h4>
<p>Line ???: eany_finset is <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sup">docs#finset.sup</a></p>



<a name="240689283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240689283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240689283">(May 29 2021 at 07:32)</a>:</h4>
<p>I don't remember if I said this before, but I don't think your current approach to trying to pull parts of formal-ml into mathlib is going to be fruitful. Here's the approach I would take if I were invested in this project:</p>
<ul>
<li>Make a fork of formal-ml, and in that fork: ..</li>
<li>Turn on CI (like I suggested in <a href="https://github.com/Google/formal-ml/issues/1">Google/formal-ml#1</a>)</li>
<li>Fix the build. Formal_ml currently doesn't compile without any changes</li>
<li>Run <code>leanproject up</code>. Fix the build. The community on Zulip can likely help with bits of this step, as the people here (like me) are usually responsible for the breakage I. The first place. This step is the hardest one</li>
<li>Look for parts of formal-ml that duplicate mathlib and remove them. Make sure the build still works by replacing their uses with mathlib equivalents. <a class="stream" data-stream-id="217875" href="/#narrow/stream/217875-Is-there-code-for-X.3F">#Is there code for X?</a> can help with (self-contained) "does mathlib already have this" questions. </li>
<li>Start looking for small bits of the now-compatible formal-ml that can be added to mathlib.</li>
<li>Add these to mathlib, update mathlib in formal-ml, then remove them from formal-ml</li>
</ul>
<p>By skipping straight to this penultimate step as you are now, you're not only squashing all the hard work into one extra hard task, but you're also putting all your eggs into one basket; if your code doesn't end up in mathlib, then all your work essentially ends up discarded. With my suggestion, you still end up with a better formal-ml, even if it doesn't make it into mathlib.</p>



<a name="240690546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240690546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240690546">(May 29 2021 at 08:09)</a>:</h4>
<p>(deleted)</p>



<a name="240859335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240859335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240859335">(May 31 2021 at 18:09)</a>:</h4>
<p>Thanks, I am making good progress on steps 4-5--no point in fixing broken bits that are unused or duplicate. I am primarily using <code>library_search</code>--has anyone explored making this faster for instance through indexing?</p>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/Probability.20theory/near/240689283">said</a>:</p>
<blockquote>
<ul>
<li>Run <code>leanproject up</code>. Fix the build. The community on Zulip can likely help with bits of this step, as the people here (like me) are usually responsible for the breakage I. The first place. This step is the hardest one</li>
<li>Look for parts of formal-ml that duplicate mathlib and remove them. Make sure the build still works by replacing their uses with mathlib equivalents. <a class="stream" data-stream-id="217875" href="/#narrow/stream/217875-Is-there-code-for-X.3F">#Is there code for X?</a> can help with (self-contained) "does mathlib already have this" questions. ```</li>
</ul>
</blockquote>



<a name="240862175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240862175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240862175">(May 31 2021 at 18:50)</a>:</h4>
<p>The point in fixing formal-ml <em>before</em> updating mathlib (step 3) is to separate "this code is broken because it is wrong" and "this code is broken because the community broke it"</p>



<a name="240862575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240862575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240862575">(May 31 2021 at 18:56)</a>:</h4>
<p>Ah, I see you "fixed" CI by commenting out bits you don't care about - that's probably ok</p>



<a name="240862719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240862719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240862719">(May 31 2021 at 18:58)</a>:</h4>
<p>Nice job on getting it passing, anyway!</p>



<a name="240866333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240866333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240866333">(May 31 2021 at 19:52)</a>:</h4>
<p>Yes, I got formal-ml to compile before upgrading, as there were only 1-2 two issues (I commented out a few tricky-looking bits) and also discovered that #check and #print send output to the console without triggering a CI failure. After upgrading, I was able to fix almost all community-broken code by hand and using library_search (can we provide deprecated defs/thms/lemmas that point to the new ones). The big task now is finding code that duplicates mathlib relying largely on running library_search over a hundred times, and factoring it out out manually (wish I had Eclipse-like "inline/extract" refactoring tools to do this automatically). I am holding off committing until I have finished or reached a roadblock.</p>



<a name="240870108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240870108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240870108">(May 31 2021 at 20:50)</a>:</h4>
<p>Is there a way to check if a definition duplicates one already in mathlib?</p>



<a name="240870162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240870162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240870162">(May 31 2021 at 20:51)</a>:</h4>
<p><code>library_search</code> is probably the best automatic method, but I would recommend reading all the theorem statements in files that seem to be in the same topic as what you are porting</p>



<a name="240870215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240870215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240870215">(May 31 2021 at 20:52)</a>:</h4>
<p>You can also ask in the <a class="stream" data-stream-id="217875" href="/#narrow/stream/217875-Is-there-code-for-X.3F">#Is there code for X?</a> stream.</p>



<a name="240875919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240875919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240875919">(May 31 2021 at 22:20)</a>:</h4>
<p>There is hopefully scope to make library_search faster, but it will rely on good caching. <code>library_search</code> under the hood is just using <code>apply</code>, and the "problem" is that Leo did an incredible job of making <code>apply</code> _fast_: so fast that any naive filtering you do actually makes things slower.</p>
<p>But in the context of running library_search relative to a fixed library (i.e. mathlib), presumably you can cache a lot of the work required to build indices, and it would be great if someone did this!</p>



<a name="240922712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/240922712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#240922712">(Jun 01 2021 at 10:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/Probability.20theory/near/239776174">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span>, thoughts on renaming <a href="https://leanprover-community.github.io/mathlib_docs/find/measurable_set">docs#measurable_set</a> to <code>is_measurable</code> so that <code>measurable_set</code> can be used to instead mean <code>subtype is_measurable</code>?</p>
</blockquote>
<p>Huh, it used to be called <code>is_measurable</code> but was renamed to <code>measurable_set</code> in <a href="https://github.com/leanprover-community/mathlib/issues/6001">#6001</a>. Perhaps <code>is_measurable_set</code> would be a better name.</p>



<a name="241090958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241090958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241090958">(Jun 02 2021 at 00:04)</a>:</h4>
<p>How can I use the instance "measurable_set.subtype.has_emptyc" rather than the instance on the third line below? If I comment out that line, then there is a redline under the ∅ symbol.</p>
<p>def event (Ω : Type<em>) [measurable_space Ω] : Type</em> := {x : set Ω // measurable_set x}<br>
def event_empty (Ω : Type*) [measurable_space Ω] : event Ω := { val := ∅,   property := measurable_set.empty,}<br>
instance has_emptyc_event {Ω : Type*} {M : measurable_space Ω} : has_emptyc (event Ω) := ⟨ @event_empty Ω M ⟩<br>
lemma has_emptyc_emptyc_event {Ω : Type*} [probability_space Ω] : ∅ = (event_empty Ω) := sorry</p>



<a name="241091096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241091096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241091096">(Jun 02 2021 at 00:06)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks">#backticks</a> / <a href="https://leanprover-community.github.io/mwe.html">#mwe</a></p>



<a name="241091115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241091115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241091115">(Jun 02 2021 at 00:06)</a>:</h4>
<p>In front of <code>def event</code> write <code>@[derive has_emptyc]</code>.</p>



<a name="241091124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241091124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241091124">(Jun 02 2021 at 00:06)</a>:</h4>
<p>This is how you copy instances to a type synonym.</p>



<a name="241091946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241091946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241091946">(Jun 02 2021 at 00:21)</a>:</h4>
<p>Cool. But that does not seem to work for <code>@[derive has_mem]</code> as there is an error "type expected at has_mem"</p>
<p><code>instance {Ω : Type*} [P : probability_space Ω] : has_mem Ω (event Ω) := { mem := event_mem }
lemma event_mem_val {Ω : Type*} [P : probability_space Ω] (ω : Ω) (E : event Ω) :  (ω ∈ E) = (ω ∈ E.val) := rfl</code></p>



<a name="241092156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241092156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241092156">(Jun 02 2021 at 00:24)</a>:</h4>
<p><code>derive</code> takes typeclasses with just one argument. You may need to write a lambda to tell it what the other argument of <code>has_mem</code> should be.</p>



<a name="241092169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241092169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241092169">(Jun 02 2021 at 00:24)</a>:</h4>
<p>Per <a href="https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks">#backticks</a>, if you use triple backticks you'll get a code block, which is more readable.</p>



<a name="241092190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241092190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241092190">(Jun 02 2021 at 00:25)</a>:</h4>
<p>It's also much easier to give a complete answer if you post a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>, so others can copy and paste your problem into Lean.</p>



<a name="241092205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241092205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241092205">(Jun 02 2021 at 00:25)</a>:</h4>
<p>If they have to add imports and variables themselves they're just not going to do it, so you get vaguer answers. :-)</p>



<a name="241092538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241092538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241092538">(Jun 02 2021 at 00:29)</a>:</h4>
<p>Got it, how would you suggest proving the last below (now a mwe)</p>
<div class="codehilite" data-code-language="import"><pre><span></span><code>import measure_theory.measure_space
open measure_theory measurable_space
class probability_space (α : Type*) extends measure_space α := (volume_univ : volume (set.univ) = 1)
@[derive has_emptyc] def event (Ω : Type*) [measurable_space Ω] : Type* := {x : set Ω // measurable_set x}
def event_empty (Ω : Type*) [measurable_space Ω] : event Ω := { val := ∅,   property := measurable_set.empty,}
lemma has_emptyc_emptyc_event {Ω : Type*} [probability_space Ω] : ∅ = (event_empty Ω) := sorry```
</code></pre></div>



<a name="241092695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241092695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241092695">(Jun 02 2021 at 00:31)</a>:</h4>
<p>Put a return after the <code> ``` </code>, or else it will eat the first line of the code block and not syntax highlight it</p>



<a name="241092700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241092700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241092700">(Jun 02 2021 at 00:31)</a>:</h4>
<p>(Put a newline after the initial three backticks.)</p>



<a name="241092793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241092793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241092793">(Jun 02 2021 at 00:32)</a>:</h4>
<p>also before the final <code> ``` </code>, or else it will show up at the end of the code block</p>



<a name="241092938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241092938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241092938">(Jun 02 2021 at 00:34)</a>:</h4>
<p><code>rfl</code>?</p>



<a name="241093003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241093003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241093003">(Jun 02 2021 at 00:35)</a>:</h4>
<p>Actually never mind, this lemma is not needed for what it was being used for</p>



<a name="241093007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241093007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241093007">(Jun 02 2021 at 00:35)</a>:</h4>
<p>And just to demonstrate how to format this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.measure_space</span>

<span class="kn">open</span> <span class="n">measure_theory</span> <span class="n">measurable_space</span>

<span class="kd">class</span> <span class="n">probability_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">measure_space</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">volume_univ</span> <span class="o">:</span> <span class="n">volume</span> <span class="o">(</span><span class="n">set.univ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">@[derive has_emptyc]</span>
<span class="kd">def</span> <span class="n">event</span> <span class="o">(</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">Ω</span> <span class="bp">//</span> <span class="n">measurable_set</span> <span class="n">x</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">event_empty</span> <span class="o">(</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">:</span> <span class="n">event</span> <span class="bp">Ω</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">val</span> <span class="o">:=</span> <span class="bp">∅</span><span class="o">,</span> <span class="n">property</span> <span class="o">:=</span> <span class="n">measurable_set.empty</span><span class="o">,}</span>

<span class="kd">lemma</span> <span class="n">has_emptyc_emptyc_event</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∅</span> <span class="bp">=</span> <span class="o">(</span><span class="n">event_empty</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">rfl</span>
</code></pre></div>



<a name="241093077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241093077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241093077">(Jun 02 2021 at 00:36)</a>:</h4>
<p>As I said, the proof is just <code>rfl</code>, and you certainly don't need this lemma because you don't need the definition <code>event_empty</code>, because you can just use <code>∅</code>.</p>



<a name="241093215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241093215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241093215">(Jun 02 2021 at 00:38)</a>:</h4>
<p>You missed the first line, which was <code>import measure_theory.measurable_space</code>, although it's not needed since it is implied by the second import</p>



<a name="241093250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241093250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241093250">(Jun 02 2021 at 00:39)</a>:</h4>
<p>I deleted it on purpose. :-)</p>



<a name="241111606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241111606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241111606">(Jun 02 2021 at 06:55)</a>:</h4>
<p>I think it might be a good idea to replace <code>def event</code> with <code>abbreviation event</code>? Since that way, you get all the instances and lemmas about them for free.</p>



<a name="241111933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241111933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241111933">(Jun 02 2021 at 07:00)</a>:</h4>
<p>I don't think that would be a good idea. The space of measurable sets is quite structured (it's a sigma algebra!) so it would be better to have it be its own thing with a lattice instance (although that means that it should probably use <code>\bot</code> instead of <code>\empty</code>)</p>



<a name="241117928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241117928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241117928">(Jun 02 2021 at 08:14)</a>:</h4>
<p>I don't see the problem - the only typeclasses we have on <code>subtype measurable_set</code> right now are precisely the ones Hunter wants</p>



<a name="241117951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241117951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241117951">(Jun 02 2021 at 08:14)</a>:</h4>
<p>So why not make <code>event</code>, which is defined as that, reducible?</p>



<a name="241117998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241117998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241117998">(Jun 02 2021 at 08:15)</a>:</h4>
<p>The lattice instance exists already as <a href="https://leanprover-community.github.io/mathlib_docs/find/measurable_set.subtype.boolean_algebra">docs#measurable_set.subtype.boolean_algebra</a></p>



<a name="241488754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241488754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241488754">(Jun 04 2021 at 04:00)</a>:</h4>
<p>How can I make event_univ have the type of event?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.measurable_space</span>
<span class="kn">import</span> <span class="n">measure_theory.measure_space</span>

<span class="kn">open</span> <span class="n">measure_theory</span> <span class="n">measurable_space</span>

<span class="kd">@[derive [has_union,has_emptyc,has_compl, has_sdiff,has_union,has_inter]</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">event</span> <span class="o">(</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">Ω</span> <span class="bp">//</span> <span class="n">measurable_set</span> <span class="n">x</span><span class="o">}</span>

<span class="kd">class</span> <span class="n">probability_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">measure_space</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">(</span><span class="n">volume_univ</span> <span class="o">:</span> <span class="n">volume</span> <span class="o">(</span><span class="n">set.univ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">event_univ</span> <span class="o">(</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">:</span> <span class="n">event</span> <span class="bp">Ω</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">val</span> <span class="o">:=</span> <span class="n">set.univ</span><span class="o">,</span> <span class="n">property</span> <span class="o">:=</span> <span class="n">measurable_set.univ</span><span class="o">,}</span>
</code></pre></div>



<a name="241489188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241489188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241489188">(Jun 04 2021 at 04:08)</a>:</h4>
<p>I don't understand your question. Doesn't it have type <code>event Ω</code> already in your code block?</p>



<a name="241489210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241489210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241489210">(Jun 04 2021 at 04:09)</a>:</h4>
<p>Also --- I think you may have missed Eric's comment above that already the entire <code>boolean_algebra</code> structure is available, you should just <code>derive</code> that.</p>



<a name="241498812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241498812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241498812">(Jun 04 2021 at 07:16)</a>:</h4>
<p>Or make <code>event</code> reducible (via <code>abbreviation</code>) so that you don't need to derive anything, <em>and</em> you get a handful of simp lemmas for free</p>



<a name="241498871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241498871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241498871">(Jun 04 2021 at 07:17)</a>:</h4>
<p>With the <code>boolean_algebra</code> structure, <code>event_univ</code> is <code>⊤</code>.</p>



<a name="241710689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241710689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241710689">(Jun 06 2021 at 21:02)</a>:</h4>
<p>Cool, so I change <code>def</code> to <code>abbreviation</code> in front of <code>event</code>, but how would I define <code>event_univ</code> as top leveraging the <code>boolean_algebra</code> structure (or otherwise). Right now, <code>event_univ</code> is not <code>event</code> but a Pi type: <code>event_univ : Π (Ω : Type u_1) [_inst_1 : measurable_space Ω], event Ω</code>.  Also, if I derive <code>boolean_algebra</code>, do I still need <code>has_union</code> etc?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.measurable_space</span>
<span class="kn">import</span> <span class="n">measure_theory.measure_space</span>
<span class="kn">open</span> <span class="n">measure_theory</span> <span class="n">measurable_space</span>
<span class="kd">@[derive [boolean_algebra,has_union,has_emptyc,has_compl, has_sdiff,has_union,has_inter]</span><span class="o">]</span> <span class="c1">-- is `has_union` etc needed?</span>
<span class="kd">abbreviation</span> <span class="n">event</span> <span class="o">(</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">Ω</span> <span class="bp">//</span> <span class="n">measurable_set</span> <span class="n">x</span><span class="o">}</span>
<span class="kd">class</span> <span class="n">probability_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">measure_space</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">(</span><span class="n">volume_univ</span> <span class="o">:</span> <span class="n">volume</span> <span class="o">(</span><span class="n">set.univ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">event_univ</span> <span class="o">(</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">:</span> <span class="n">event</span> <span class="bp">Ω</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">val</span> <span class="o">:=</span> <span class="n">set.univ</span><span class="o">,</span> <span class="n">property</span> <span class="o">:=</span> <span class="n">measurable_set.univ</span><span class="o">,}</span> <span class="c1">-- does not work</span>
<span class="k">#check</span> <span class="n">event_univ</span> <span class="c1">--should be type event</span>
<span class="kd">def</span> <span class="n">event_univ'</span> <span class="o">(</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">:</span> <span class="n">event</span> <span class="bp">Ω</span> <span class="o">:=</span> <span class="bp">Ω.</span><span class="n">T</span> <span class="c1">-- ??? --how to make this "top"</span>
</code></pre></div>
<p>And then, would the <code>boolean_algebra</code> structure allow me to avoid new definitions of "and" etc for events, currently given as </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">measurable_inter</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">event</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span> <span class="n">event</span> <span class="bp">Ω</span> <span class="o">:=</span>  <span class="o">{</span> <span class="n">val</span> <span class="o">:=</span><span class="n">A.val</span> <span class="bp">∩</span> <span class="n">B.val</span><span class="o">,</span>   <span class="n">property</span> <span class="o">:=</span> <span class="n">measurable_set.inter</span> <span class="n">A.property</span> <span class="n">B.property</span><span class="o">,}</span>
<span class="kd">def</span> <span class="n">eand</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">event</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span> <span class="n">event</span> <span class="bp">Ω</span> <span class="o">:=</span>  <span class="n">measurable_inter</span> <span class="n">A</span> <span class="n">B</span>
<span class="kd">infixr</span> <span class="bp">`∧`</span> <span class="o">:=</span> <span class="n">eand</span>
<span class="kd">def</span> <span class="n">enot</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">event</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span> <span class="n">event</span> <span class="bp">Ω</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">val</span> <span class="o">:=(</span><span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span><span class="bp">ᶜ</span><span class="o">,</span> <span class="n">property</span> <span class="o">:=</span> <span class="n">measurable_set.compl</span> <span class="n">A.property</span><span class="o">,}</span>
<span class="kd">def</span> <span class="n">event_eqv</span> <span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span><span class="o">:</span><span class="n">probability_space</span> <span class="bp">Ω</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span><span class="o">:</span><span class="n">event</span> <span class="bp">Ω</span><span class="o">):</span><span class="n">event</span> <span class="bp">Ω</span> <span class="o">:=</span> <span class="o">(</span><span class="n">A</span> <span class="bp">∧</span> <span class="n">B</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">((</span><span class="bp">¬ₑ</span> <span class="n">A</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">¬ₑ</span> <span class="n">B</span><span class="o">))</span>
<span class="kd">infixr</span> <span class="bp">`=ₑ`</span><span class="o">:</span><span class="mi">100</span> <span class="o">:=</span> <span class="n">event_eqv</span>
<span class="c1">-- `measurable` is already in mathlib so `measurable_fun` seems duplicative</span>
<span class="kd">def</span> <span class="n">measurable_fun</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>  <span class="o">{</span><span class="n">β</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">Mα</span><span class="o">:</span><span class="n">measurable_space</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">Mβ</span><span class="o">:</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">):</span><span class="kt">Type</span><span class="bp">*</span><span class="o">:=</span>  <span class="n">subtype</span> <span class="o">(</span><span class="bp">@</span><span class="n">measurable</span> <span class="n">α</span> <span class="n">β</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>
<span class="kd">instance</span> <span class="n">probability_space.to_measurable_space</span> <span class="o">(</span><span class="n">α</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]:</span><span class="n">measurable_space</span> <span class="n">α</span> <span class="o">:=</span>  <span class="n">measure_theory.measure_space.to_measurable_space</span>
<span class="kd">def</span> <span class="n">random_variable</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span><span class="o">:</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">β</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">Mβ</span><span class="o">:</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">):</span><span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="n">measurable_fun</span> <span class="o">(</span><span class="n">probability_space.to_measurable_space</span> <span class="n">α</span><span class="o">)</span> <span class="n">Mβ</span>
<span class="kd">infixr</span>  <span class="bp">`</span> <span class="bp">→ₘ</span> <span class="bp">`</span><span class="o">:</span><span class="mi">80</span> <span class="o">:=</span> <span class="n">measurable_fun</span>
<span class="kd">infixr</span>  <span class="bp">`</span> <span class="bp">→ᵣ</span> <span class="bp">`</span><span class="o">:</span><span class="mi">80</span> <span class="o">:=</span> <span class="n">random_variable</span>
</code></pre></div>



<a name="241711224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241711224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241711224">(Jun 06 2021 at 21:16)</a>:</h4>
<p>For eand and eor, you can probably just do <code>infixr `∧` := has_inf.inf</code>. if that doesn't work, copying the approach used by <a href="https://leanprover-community.github.io/mathlib_docs/find/set.Union/src">src#set.Union</a> would probably work</p>



<a name="241711357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241711357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241711357">(Jun 06 2021 at 21:20)</a>:</h4>
<p>That could look like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">eand</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">:</span> <span class="n">event</span> <span class="bp">Ω</span> <span class="bp">→</span> <span class="n">event</span> <span class="bp">Ω</span> <span class="bp">→</span> <span class="n">event</span> <span class="bp">Ω</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">⊓</span><span class="o">)</span>
<span class="kd">infixr</span> <span class="bp">`∧`</span> <span class="o">:=</span> <span class="n">eand</span>

<span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">enot</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">:</span> <span class="n">event</span> <span class="bp">Ω</span> <span class="bp">→</span> <span class="n">event</span> <span class="bp">Ω</span> <span class="o">:=</span> <span class="n">has_compl.compl</span>
</code></pre></div>



<a name="241711389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241711389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241711389">(Jun 06 2021 at 21:21)</a>:</h4>
<p><code>(⊤ : event Ω)</code> is how to spell <code>event_univ</code>, but most of the time <code> ⊤</code> by itself will work, if you use it where lean is expecting an event.</p>



<a name="241711547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241711547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241711547">(Jun 06 2021 at 21:25)</a>:</h4>
<p>You still need <code>has_union</code> if you want to be able to write <code>Ea ∪ Eb</code> as  another spelling of <code>Ea ⊔ Eb</code>. However, it sounds like you want to prefer a <code>Ea ∨ Eb</code> spelling anyway, so I wouldn't bother worrying about <code> ∪</code></p>



<a name="241726701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241726701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241726701">(Jun 07 2021 at 04:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/Probability.20theory/near/241117928">said</a>:</p>
<blockquote>
<p>I don't see the problem - the only typeclasses we have on <code>subtype measurable_set</code> right now are precisely the ones Hunter wants</p>
</blockquote>
<p>I think the question to solve then is whether we intend to write this subtype as <code>subtype measurable_set</code> or <code>event</code> (or something else), and in either case there should be no abbreviation</p>



<a name="241733959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241733959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241733959">(Jun 07 2021 at 06:26)</a>:</h4>
<p>I agree that we ought to decide on a spelling, but I can't help feeling that even if we pick <code>event</code> as the preferred spelling, it's useful for <code>event</code> to be reducible so that all the subtype coercion lemmas are easier to use.</p>



<a name="241735634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241735634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241735634">(Jun 07 2021 at 06:51)</a>:</h4>
<p>Would having sub-lattice, sub-boolean-algebra and such structures make working with those coercions easier? Event would be defined as a sub-boolean-algebra for example. This is a question, not a suggestion, since those aspects are not very clear to me.<br>
We could define sub-sigma-algebra as well if we define those substructures, in order to get the properties of countable unions.</p>



<a name="241736965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241736965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241736965">(Jun 07 2021 at 07:08)</a>:</h4>
<p>Or maybe you already proved all the properties provided by <code>set_like</code> and the usual substructure construction for <code>subtype measurable_set</code> and it would make no difference. Turns out, I really don't know what I am talking about here, hence I'll stop. :)</p>



<a name="241740949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241740949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241740949">(Jun 07 2021 at 07:54)</a>:</h4>
<p>Yes, having sublattices in some form would help here</p>



<a name="241741027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241741027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241741027">(Jun 07 2021 at 07:55)</a>:</h4>
<p>There was a start towards sublattices in <a href="https://github.com/leanprover-community/mathlib/issues/7093">#7093</a>, but it looks abandoned.</p>



<a name="241741525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241741525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241741525">(Jun 07 2021 at 08:01)</a>:</h4>
<p>Although I'm starting to consider an alternative design, with a new typeclass <code>subtype.closed_under</code>, and have instances like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.lattice</span>

<span class="sd">/-- A class indicating a property holds on `op` if it holds on both arguments -/</span>
<span class="kd">class</span> <span class="n">subtype.closed_under₂</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">closed</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">},</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">has_inf</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">subtype.closed_under₂</span> <span class="n">p</span> <span class="o">(</span><span class="bp">⊓</span><span class="o">)]</span> <span class="o">:</span> <span class="n">has_inf</span> <span class="o">(</span><span class="n">subtype</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">inf</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">⟨</span><span class="n">a</span> <span class="bp">⊓</span> <span class="n">b</span><span class="o">,</span> <span class="n">subtype.closed_under₂.closed</span> <span class="n">_</span> <span class="n">a.2</span> <span class="n">b.2</span><span class="o">⟩}</span>

<span class="kd">instance</span> <span class="n">subtype.semilattice_inf_of_closed_under</span>
  <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">semilattice_inf</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">subtype.closed_under₂</span> <span class="n">p</span> <span class="o">(</span><span class="bp">⊓</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">semilattice_inf</span> <span class="o">(</span><span class="n">subtype</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">subtype.semilattice_inf</span> <span class="o">(</span><span class="bp">@</span><span class="n">subtype.closed_under₂.closed</span> <span class="n">α</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>
</code></pre></div>



<a name="241741581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241741581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241741581">(Jun 07 2021 at 08:02)</a>:</h4>
<p>Which means we don't need a different subtype for every combination of inf/sup/top/bot</p>



<a name="241966952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241966952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241966952">(Jun 08 2021 at 18:45)</a>:</h4>
<p><code>borel_space</code> used to have <code>measurable.ennreal_mul</code>; what can I use in its place below:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">ennreal_measurable_is_submonoid</span>
  <span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span><span class="bp">Ω</span><span class="o">:</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]:</span>
   <span class="n">is_submonoid</span> <span class="o">(</span><span class="bp">@</span><span class="n">measurable</span> <span class="bp">Ω</span> <span class="n">ennreal</span> <span class="n">M</span><span class="bp">Ω</span> <span class="o">(</span><span class="n">borel</span> <span class="n">ennreal</span><span class="o">))</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">one_mem</span> <span class="o">:=</span><span class="bp">@</span><span class="n">measurable_const</span> <span class="n">ennreal</span> <span class="bp">Ω</span> <span class="o">(</span><span class="n">borel</span> <span class="n">ennreal</span><span class="o">)</span> <span class="n">M</span><span class="bp">Ω</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">mul_mem</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">A1</span> <span class="n">A2</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">measurable.ennreal_mul</span> <span class="n">A1</span> <span class="n">A2</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">}</span>
</code></pre></div>



<a name="241973080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241973080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241973080">(Jun 08 2021 at 19:28)</a>:</h4>
<p>Is it just <a href="https://leanprover-community.github.io/mathlib_docs/find/measurable.mul">docs#measurable.mul</a>?</p>



<a name="241973430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241973430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241973430">(Jun 08 2021 at 19:30)</a>:</h4>
<p>Yes, it is</p>



<a name="241989788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/241989788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#241989788">(Jun 08 2021 at 21:35)</a>:</h4>
<p>Perfect, I should have consulted the documentation. Wonder why library_search/!, hint, suggest all missed the proof with one apply. It might be useful to have a deprecation file that proves old results with the new mathlib for each version.</p>



<a name="242009878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242009878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242009878">(Jun 09 2021 at 01:56)</a>:</h4>
<p>In the first instance defined below for nnreal, there is an error for <code>const_measurable_fun.has_coe</code> "synthesized type class instance is not definitionally equal to expression inferred by typing rules, synthesized  nnreal.measurable_space inferred  borel nnreal". Note that the second instance for real does not generate an error. I cannot replace <code>borel nnreal</code> with <code>nnreal.measurable_space</code> in the instance definition without creating other errors in subsequent code.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.measurable_space</span>
<span class="kn">import</span> <span class="n">measure_theory.borel_space</span>

<span class="kd">def</span> <span class="n">measurable_fun</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>  <span class="o">{</span><span class="n">β</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">Mα</span><span class="o">:</span><span class="n">measurable_space</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">Mβ</span><span class="o">:</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">):</span><span class="kt">Type</span><span class="bp">*</span><span class="o">:=</span>
    <span class="n">subtype</span> <span class="o">(</span><span class="bp">@</span><span class="n">measurable</span> <span class="n">α</span> <span class="n">β</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>

<span class="kd">infixr</span>  <span class="bp">`</span> <span class="bp">→ₘ</span> <span class="bp">`</span><span class="o">:</span><span class="mi">80</span> <span class="o">:=</span> <span class="n">measurable_fun</span>

<span class="kd">lemma</span> <span class="n">const_measurable</span> <span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">{</span><span class="n">β</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">c</span><span class="o">:</span><span class="n">β</span><span class="o">):</span>
  <span class="o">(</span><span class="n">measurable</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">ω</span><span class="o">:</span><span class="bp">Ω</span><span class="o">,</span> <span class="n">c</span><span class="o">))</span> <span class="o">:=</span> <span class="n">measurable_const</span>

<span class="kd">def</span> <span class="n">const_measurable_fun</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span><span class="bp">Ω</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
   <span class="o">[</span><span class="n">Mβ</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">β</span><span class="o">):</span><span class="n">M</span><span class="bp">Ω</span> <span class="bp">→ₘ</span> <span class="n">Mβ</span> <span class="o">:=</span>
   <span class="o">{</span> <span class="n">val</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">ω</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">),</span> <span class="n">c</span><span class="o">),</span> <span class="n">property</span> <span class="o">:=</span> <span class="n">const_measurable</span> <span class="n">c</span><span class="o">,}</span>

<span class="kd">instance</span> <span class="n">const_measurable_fun.has_coe</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span><span class="o">:</span><span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">{</span><span class="n">M</span><span class="bp">Ω</span><span class="o">:</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">}:</span><span class="n">has_coe</span> <span class="n">α</span> <span class="o">(</span><span class="n">M</span><span class="bp">Ω</span> <span class="bp">→ₘ</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">α</span><span class="o">),</span> <span class="n">const_measurable_fun</span> <span class="n">a</span><span class="o">)}</span>

<span class="c1">--noncomputable</span>
<span class="kd">instance</span> <span class="n">coe_measurable_fun_of_nnreal</span>
      <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span><span class="o">:</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">}</span>
<span class="o">:</span><span class="n">has_coe</span> <span class="n">nnreal</span> <span class="o">(</span><span class="n">measurable_fun</span> <span class="n">P</span> <span class="o">(</span><span class="n">borel</span> <span class="n">nnreal</span><span class="o">))</span> <span class="o">:=</span> <span class="n">const_measurable_fun.has_coe</span>

<span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="n">coe_measurable_fun_of_real</span>
      <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span><span class="o">:</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">}</span>
  <span class="o">:</span><span class="n">has_coe</span> <span class="n">real</span> <span class="o">(</span><span class="n">measurable_fun</span> <span class="n">P</span> <span class="o">(</span><span class="n">borel</span> <span class="n">real</span><span class="o">))</span> <span class="o">:=</span> <span class="n">const_measurable_fun.has_coe</span>
</code></pre></div>



<a name="242011813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242011813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242011813">(Jun 09 2021 at 02:34)</a>:</h4>
<p>What are the errors produced in the subsequent code?  It seems like the <code>measure_space</code> instance on <code>nnreal</code> has indeed been changed from the borel construction to the subtype construction, but presumably there was good reason for this.</p>



<a name="242011933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242011933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242011933">(Jun 09 2021 at 02:37)</a>:</h4>
<p>The change is from <a href="https://github.com/leanprover-community/mathlib/issues/6209">#6209</a> (you can use git blame to track such things down)</p>



<a name="242012080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242012080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242012080">(Jun 09 2021 at 02:40)</a>:</h4>
<p>Hopefully the instance <a href="https://leanprover-community.github.io/mathlib_docs/find/subtype.borel_space">docs#subtype.borel_space</a> will let you convert from the one construction to the other.</p>



<a name="242019506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242019506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242019506">(Jun 09 2021 at 05:29)</a>:</h4>
<p><span class="user-mention" data-user-id="260507">@Heather Macbeth</span> that worked, I just replaced <code>borel nnreal</code> with <code>nnreal.measurable_space</code> throughout the file. This was allow me to define expected value.</p>



<a name="242133067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242133067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242133067">(Jun 09 2021 at 21:27)</a>:</h4>
<p><span class="user-mention" data-user-id="260507">@Heather Macbeth</span> I am stuck on what to replace <code>borel β</code> with in the sequence below  as <code>measurable_space β</code> does not work. In the instance declaration at the bottom, there is the error <code>SC_measurable_comm_semiring has type comm_semiring (measurable_fun MΩ (borel nnreal)) but is expected to have type  comm_semiring (measurable_fun MΩ nnreal.measurable_space)</code> :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.measurable_space</span>
<span class="kn">import</span> <span class="n">measure_theory.borel_space</span>
<span class="kn">import</span> <span class="n">topology.algebra.ring</span>

<span class="kn">import</span> <span class="n">formal_ml.real_measurable_space</span>
<span class="kn">import</span> <span class="n">formal_ml.semiring</span>
<span class="kn">import</span> <span class="n">formal_ml.independent_events</span>

<span class="kd">def</span> <span class="n">measurable_fun</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>  <span class="o">{</span><span class="n">β</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">Mα</span><span class="o">:</span><span class="n">measurable_space</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">Mβ</span><span class="o">:</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">):</span><span class="kt">Type</span><span class="bp">*</span><span class="o">:=</span>
    <span class="n">subtype</span> <span class="o">(</span><span class="bp">@</span><span class="n">measurable</span> <span class="n">α</span> <span class="n">β</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">def</span> <span class="n">SC_sum_measurable_is_add_submonoid_from_semiring</span>
<span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span><span class="bp">Ω</span><span class="o">:</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span>
  <span class="o">{</span><span class="n">β</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">T</span><span class="o">:</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">SC</span><span class="o">:</span><span class="n">topological_space.second_countable_topology</span> <span class="n">β</span><span class="o">}</span>
   <span class="o">{</span><span class="n">CSR</span><span class="o">:</span><span class="n">semiring</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">TA</span><span class="o">:</span><span class="n">topological_semiring</span> <span class="n">β</span><span class="o">}:</span>
   <span class="n">is_add_submonoid</span> <span class="o">(</span><span class="bp">@</span><span class="n">measurable</span> <span class="bp">Ω</span> <span class="n">β</span> <span class="n">M</span><span class="bp">Ω</span> <span class="o">(</span><span class="n">borel</span> <span class="n">β</span><span class="o">))</span> <span class="o">:=</span>
   <span class="o">(</span><span class="bp">@</span><span class="n">SC_sum_measurable_is_add_submonoid</span> <span class="bp">Ω</span> <span class="n">M</span><span class="bp">Ω</span> <span class="n">β</span> <span class="n">T</span> <span class="n">SC</span> <span class="o">(</span><span class="n">add_comm_monoid.to_add_monoid</span> <span class="n">β</span><span class="o">)</span>
   <span class="o">(</span><span class="n">topological_semiring.to_has_continuous_add</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">SC_mul_measurable_is_submonoid_from_semiring</span>
  <span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span><span class="bp">Ω</span><span class="o">:</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span>
  <span class="o">{</span><span class="n">β</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">T</span><span class="o">:</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">SC</span><span class="o">:</span><span class="n">topological_space.second_countable_topology</span> <span class="n">β</span><span class="o">}</span>
   <span class="o">{</span><span class="n">CSR</span><span class="o">:</span><span class="n">semiring</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">TA</span><span class="o">:</span><span class="n">topological_semiring</span> <span class="n">β</span><span class="o">}:</span>
   <span class="n">is_submonoid</span> <span class="o">(</span><span class="bp">@</span><span class="n">measurable</span> <span class="bp">Ω</span> <span class="n">β</span> <span class="n">M</span><span class="bp">Ω</span> <span class="o">(</span><span class="n">borel</span> <span class="n">β</span><span class="o">))</span> <span class="o">:=</span>
   <span class="o">(</span><span class="bp">@</span><span class="n">SC_mul_measurable_is_submonoid</span> <span class="bp">Ω</span> <span class="n">M</span><span class="bp">Ω</span> <span class="n">β</span> <span class="n">T</span> <span class="n">SC</span> <span class="o">(</span><span class="n">monoid_with_zero.to_monoid</span> <span class="n">β</span><span class="o">)</span>
   <span class="o">(</span><span class="n">topological_semiring.to_has_continuous_mul</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">SC_measurable_semiring_is_sub_semiring</span>
<span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span><span class="bp">Ω</span><span class="o">:</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span>
  <span class="o">{</span><span class="n">β</span><span class="o">:</span><span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">T</span><span class="o">:</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">SC</span><span class="o">:</span><span class="n">topological_space.second_countable_topology</span> <span class="n">β</span><span class="o">}</span>
   <span class="o">{</span><span class="n">CSR</span><span class="o">:</span><span class="n">semiring</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">TA</span><span class="o">:</span><span class="n">topological_semiring</span> <span class="n">β</span><span class="o">}:</span>
  <span class="n">is_sub_semiring</span> <span class="o">(</span><span class="bp">@</span><span class="n">measurable</span> <span class="bp">Ω</span> <span class="n">β</span> <span class="n">M</span><span class="bp">Ω</span> <span class="o">(</span><span class="n">borel</span> <span class="n">β</span><span class="o">))</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="bp">..</span><span class="o">(</span><span class="bp">@</span><span class="n">SC_sum_measurable_is_add_submonoid_from_semiring</span> <span class="bp">Ω</span> <span class="n">M</span><span class="bp">Ω</span> <span class="n">β</span> <span class="n">T</span> <span class="n">SC</span> <span class="n">_</span> <span class="n">TA</span><span class="o">),</span>
    <span class="bp">..</span><span class="o">(</span><span class="bp">@</span><span class="n">SC_mul_measurable_is_submonoid_from_semiring</span> <span class="bp">Ω</span> <span class="n">M</span><span class="bp">Ω</span> <span class="n">β</span> <span class="n">T</span> <span class="n">SC</span> <span class="n">_</span> <span class="n">TA</span><span class="o">),</span>
  <span class="o">}</span>

<span class="kd">def</span> <span class="n">SC_measurable_comm_semiring</span>
  <span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span><span class="bp">Ω</span><span class="o">:</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span>
  <span class="o">{</span><span class="n">β</span><span class="o">:</span><span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">T</span><span class="o">:</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">SC</span><span class="o">:</span><span class="n">topological_space.second_countable_topology</span> <span class="n">β</span><span class="o">}</span>
   <span class="o">{</span><span class="n">CSR</span><span class="o">:</span><span class="n">comm_semiring</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">TA</span><span class="o">:</span><span class="n">topological_semiring</span> <span class="n">β</span><span class="o">}:</span>
   <span class="n">comm_semiring</span> <span class="o">(</span><span class="n">measurable_fun</span> <span class="n">M</span><span class="bp">Ω</span> <span class="o">(</span> <span class="n">borel</span> <span class="n">β</span><span class="o">)):=</span>
   <span class="bp">@</span><span class="n">subtype.comm_semiring</span> <span class="o">(</span><span class="bp">Ω</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="n">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">measurable</span> <span class="bp">Ω</span> <span class="n">β</span> <span class="n">M</span><span class="bp">Ω</span> <span class="o">(</span><span class="n">borel</span> <span class="n">β</span><span class="o">))</span>
   <span class="o">(</span><span class="bp">@</span><span class="n">SC_measurable_semiring_is_sub_semiring</span> <span class="bp">Ω</span> <span class="n">M</span><span class="bp">Ω</span> <span class="n">β</span> <span class="n">T</span> <span class="n">SC</span> <span class="o">(</span><span class="n">comm_semiring.to_semiring</span> <span class="n">β</span><span class="o">)</span> <span class="n">TA</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">nnreal_measurable_fun_comm_semiring</span> <span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span><span class="bp">Ω</span><span class="o">:</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]:</span>
  <span class="n">comm_semiring</span> <span class="o">(</span><span class="n">measurable_fun</span> <span class="n">M</span><span class="bp">Ω</span> <span class="o">(</span><span class="n">nnreal.measurable_space</span><span class="o">)):=</span>
  <span class="bp">@</span><span class="n">SC_measurable_comm_semiring</span> <span class="bp">Ω</span> <span class="n">M</span><span class="bp">Ω</span> <span class="n">nnreal</span> <span class="n">nnreal.topological_space</span>
    <span class="n">nnreal.topological_space.second_countable_topology</span> <span class="n">nnreal.comm_semiring</span>
    <span class="n">nnreal.topological_semiring</span>
</code></pre></div>



<a name="242134371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242134371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242134371">(Jun 09 2021 at 21:38)</a>:</h4>
<p><span class="user-mention" data-user-id="397140">@Hunter Monroe</span> Can you please give a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>?  This depends on a project, <code>formal_ml</code>, which I don't have downloaded.</p>



<a name="242134689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242134689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242134689">(Jun 09 2021 at 21:41)</a>:</h4>
<p>But, at a guess, instead of constructing all these algebraic structures using <code>borel β</code>, you should assume</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">borel_space</span> <span class="n">β</span><span class="o">]</span>
</code></pre></div>



<a name="242134814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242134814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242134814">(Jun 09 2021 at 21:42)</a>:</h4>
<p>This is saying to Lean that, even though the <em>construction</em> of the sigma-algebra is not using <a href="https://leanprover-community.github.io/mathlib_docs/find/borel">docs#borel</a>, nonetheless the sigma-algebra which results is equal to the Borel sigma-algebra.</p>



<a name="242137368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242137368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242137368">(Jun 09 2021 at 22:06)</a>:</h4>
<p>Maybe you want to do something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.borel_space</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">def</span> <span class="n">SC_measurable_semiring_is_subsemiring</span>
  <span class="o">(</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span>
  <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space.second_countable_topology</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">borel_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_semiring</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">subsemiring</span> <span class="o">(</span><span class="bp">Ω</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">f</span> <span class="bp">|</span> <span class="n">measurable</span> <span class="n">f</span><span class="o">},</span>
  <span class="n">one_mem'</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">measurable_const</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">mul_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span> <span class="n">hf</span> <span class="n">hg</span><span class="o">,</span> <span class="n">hf.mul</span> <span class="n">hg</span> <span class="o">,</span>
  <span class="n">zero_mem'</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">measurable_const</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">add_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span> <span class="n">hf</span> <span class="n">hg</span><span class="o">,</span> <span class="n">hf.add</span> <span class="n">hg</span> <span class="o">}</span>

<span class="sd">/-- Measurable functions from `Ω` to `nnreal` are a subsemiring of all functions. -/</span>
<span class="kd">noncomputable</span> <span class="kd">example</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">:</span> <span class="n">subsemiring</span> <span class="o">(</span><span class="bp">Ω</span> <span class="bp">→</span> <span class="n">nnreal</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">SC_measurable_semiring_is_subsemiring</span> <span class="bp">Ω</span> <span class="n">nnreal</span>
</code></pre></div>



<a name="242138383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242138383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242138383">(Jun 09 2021 at 22:19)</a>:</h4>
<p>OK, here is a 452 line mwe, the question is focused on what to replace <code>borel</code> with in the last two def's (SC_measurable_semiring_is_sub_semiring, SC_measurable_comm_semiring) to avoid the error in the instance at the very end nnreal_measurable_fun_comm_semiring. The repository <a href="https://github.com/hmonroe/formal-ml">https://github.com/hmonroe/formal-ml</a> has partial progress in getting formal-ml to work with the latest version of mathlib, which would bring a good chunk of probability theory.</p>



<a name="242138498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242138498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242138498">(Jun 09 2021 at 22:20)</a>:</h4>
<p>Not sure the attachment came through and I am just looking at your messages. <a href="/user_uploads/3121/lYIcwvNZgXNsduP0zin7j5vd/real_random_variable-copy.lean">real_random_variable-copy.lean</a></p>



<a name="242138869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242138869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242138869">(Jun 09 2021 at 22:25)</a>:</h4>
<p>I think your example nearly works but the instance is looking for <code>SC_measurable_comm_semiring</code>--how would tweak your example?</p>



<a name="242140172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242140172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242140172">(Jun 09 2021 at 22:40)</a>:</h4>
<p><span class="user-mention" data-user-id="397140">@Hunter Monroe</span> You don't need to do anything -- it already is a <code>comm_semiring</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.borel_space</span>

<span class="kd">noncomputable theory</span>
<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">def</span> <span class="n">SC_measurable_semiring_is_subsemiring</span>
  <span class="o">(</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span>
  <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space.second_countable_topology</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">borel_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_semiring</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">subsemiring</span> <span class="o">(</span><span class="bp">Ω</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">f</span> <span class="bp">|</span> <span class="n">measurable</span> <span class="n">f</span><span class="o">},</span>
  <span class="n">one_mem'</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">measurable_const</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">mul_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="n">measurable.mul</span><span class="o">,</span>
  <span class="n">zero_mem'</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">measurable_const</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">add_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="n">measurable.add</span> <span class="o">}</span>

<span class="sd">/-- Measurable functions from `Ω` to `nnreal` are a subsemiring of all functions. -/</span>
<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">:</span> <span class="n">subsemiring</span> <span class="o">(</span><span class="bp">Ω</span> <span class="bp">→</span> <span class="n">nnreal</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">SC_measurable_semiring_is_subsemiring</span> <span class="bp">Ω</span> <span class="n">nnreal</span>

<span class="kd">example</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">:</span> <span class="n">comm_semiring</span> <span class="o">(</span><span class="n">foo</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>



<a name="242140213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242140213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242140213">(Jun 09 2021 at 22:41)</a>:</h4>
<p>You can post stuff like this as a <a href="http://gist.github.com">gist</a>, it saves people from having to download anything.</p>
<p>I can't help with Borel stuff, but you use loads of <code>@</code>s. A use of <code>@</code> is often an indication that something is wrong -- <code>@</code>s can usually be avoided. For example (line 31): </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">set.preimage_fst_def</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">Bα</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)}</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">set.preimage</span> <span class="o">(</span><span class="n">prod.fst</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">''</span> <span class="n">Bα</span><span class="o">)</span> <span class="bp">=</span>
    <span class="o">{</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">Bα</span><span class="o">),</span> <span class="n">U</span> <span class="bp">=</span> <span class="n">set.prod</span> <span class="n">A</span> <span class="n">set.univ</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span> <span class="n">hA</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span> <span class="n">hA</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">set.prod</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span> <span class="n">hA</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span> <span class="n">hA</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">set.prod</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span><span class="o">⟩</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>or</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">measurable_fun_product_measurableh</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">M1</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">M2</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">β</span><span class="o">]:</span>
  <span class="n">prod.measurable_space</span> <span class="bp">=</span> <span class="n">M1.comap</span> <span class="n">prod.fst</span> <span class="bp">⊔</span> <span class="n">M2.comap</span> <span class="n">prod.snd</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="242143152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242143152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242143152">(Jun 09 2021 at 23:22)</a>:</h4>
<p><span class="user-mention" data-user-id="260507">@Heather Macbeth</span>  if I change the name of your def to <code>SC_measurable_comm_semiring</code>, then I get the error <code>SC_measurable_comm_semiring Ω nnreal term  nnreal.comm_semiring has type  comm_semiring nnrea but is expected to have type  measurable_space nnreal</code>. Could you help me fix that?</p>



<a name="242143400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242143400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242143400">(Jun 09 2021 at 23:26)</a>:</h4>
<p><span class="user-mention" data-user-id="397140">@Hunter Monroe</span> What is the line that throws the error?</p>



<a name="242143539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242143539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242143539">(Jun 09 2021 at 23:28)</a>:</h4>
<p>In the instance, there is a red line under <code>SC_measurable_comm_semiring</code> with the error I gave, where I renamed your definition to <code>SC_measurable_comm_semiring</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">nnreal_measurable_fun_comm_semiring</span> <span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span><span class="bp">Ω</span><span class="o">:</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]:</span>
  <span class="n">comm_semiring</span> <span class="o">(</span><span class="n">measurable_fun</span> <span class="n">M</span><span class="bp">Ω</span> <span class="o">(</span><span class="n">nnreal.measurable_space</span><span class="o">)):=</span>
  <span class="bp">@</span><span class="n">SC_measurable_comm_semiring</span> <span class="bp">Ω</span> <span class="n">M</span><span class="bp">Ω</span> <span class="n">nnreal</span> <span class="n">nnreal.topological_space</span>
    <span class="n">nnreal.topological_space.second_countable_topology</span> <span class="n">nnreal.comm_semiring</span>
    <span class="n">nnreal.topological_semiring</span>
</code></pre></div>



<a name="242143705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242143705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242143705">(Jun 09 2021 at 23:30)</a>:</h4>
<p><span class="user-mention" data-user-id="397140">@Hunter Monroe</span> You ought not to need to define this explicitly as an instance!  I wrote it as an <code>example</code> to show that Lean can infer it where needed!</p>



<a name="242143755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242143755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242143755">(Jun 09 2021 at 23:31)</a>:</h4>
<p>What is the first place in the code where the <code>comm_semiring</code> instance is needed?  If you can give me that lemma, I can try to reframe the lemma so the <code>comm_semiring</code> instance is inferred automatically.</p>



<a name="242144098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242144098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242144098">(Jun 09 2021 at 23:36)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>Thanks for the tip. This is Martin Zinkevich's Formal-ML repository (over 33K lines of it), which I am trying to get to compile in the latest version of mathlib, as a way of learning Lean. Once the code compiles, I will address the @'s among other issues when refactoring for inclusion in mathlib.</p>



<a name="242144942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242144942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242144942">(Jun 09 2021 at 23:49)</a>:</h4>
<p><span class="user-mention" data-user-id="260507">@Heather Macbeth</span> one example is below, where commenting out the instance generates a "failed to synthesize instance" error. The refl proof does not go through in any case (any ideas?). If you want to download the repository using the URL above, this is from the real_random_variable.lean file. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">infixr</span>  <span class="bp">`</span> <span class="bp">→ₘ</span> <span class="bp">`</span><span class="o">:</span><span class="mi">80</span> <span class="o">:=</span> <span class="n">measurable_fun</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">nnreal_measurable_fun_zero_val_def</span> <span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span><span class="bp">Ω</span><span class="o">:</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]:</span>  <span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="n">M</span><span class="bp">Ω</span> <span class="bp">→ₘ</span> <span class="o">(</span><span class="n">nnreal.measurable_space</span><span class="o">))</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">refl</span>
</code></pre></div>



<a name="242145546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242145546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242145546">(Jun 09 2021 at 23:58)</a>:</h4>
<p>At a glance, <code>measurable_fun</code> is designed with incorrect argument explicitness</p>



<a name="242145792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242145792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242145792">(Jun 10 2021 at 00:01)</a>:</h4>
<p>I'd expect the two <code>Type</code>s in <code>()</code> not <code>{}</code>, and the two <code>measurable_space</code>s in <code>[]</code> not <code>()</code>.</p>



<a name="242147649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242147649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242147649">(Jun 10 2021 at 00:32)</a>:</h4>
<p><span class="user-mention" data-user-id="397140">@Hunter Monroe</span> The simp-lemma you provide doesn't use the commutativity, but here's how I'd do it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.borel_space</span>

<span class="kd">noncomputable theory</span>

<span class="kd">def</span> <span class="n">measurable_fun</span>
  <span class="o">(</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span>
  <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space.second_countable_topology</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">borel_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_semiring</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">subsemiring</span> <span class="o">(</span><span class="bp">Ω</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">f</span> <span class="bp">|</span> <span class="n">measurable</span> <span class="n">f</span><span class="o">},</span>
  <span class="n">one_mem'</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">measurable_const</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">mul_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="n">measurable.mul</span><span class="o">,</span>
  <span class="n">zero_mem'</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">measurable_const</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">add_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="n">measurable.add</span> <span class="o">}</span>

<span class="kd">infixr</span> <span class="bp">`→ₘ</span> <span class="bp">`</span><span class="o">:</span><span class="mi">80</span> <span class="o">:=</span> <span class="n">measurable_fun</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">nnreal_measurable_fun_zero_val_def</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="bp">Ω</span> <span class="bp">→ₘ</span> <span class="n">nnreal</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">rfl</span>

<span class="c1">-- not needed for anything, but just to check</span>
<span class="kd">example</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">:</span> <span class="n">comm_semiring</span> <span class="o">(</span><span class="bp">Ω</span> <span class="bp">→ₘ</span> <span class="n">nnreal</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>



<a name="242149444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242149444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242149444">(Jun 10 2021 at 01:06)</a>:</h4>
<p>I should say that what I wrote above is slick for this use case, but it might cause problems down the line if you want <code>measurable_fun</code> to be a monoid when it maps into a monoid, a module when it maps into a module, etc etc.</p>
<p>I think the standard way to get the full suite of algebraic objects (see <a href="https://leanprover-community.github.io/mathlib_docs/find/continuous_map.monoid">docs#continuous_map.monoid</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/bounded_continuous_function.normed_group">docs#bounded_continuous_function.normed_group</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/measure_theory.ae_eq_fun.monoid">docs#measure_theory.ae_eq_fun.monoid</a>) is to define <code>measurable_fun</code> to be the subtype and then equip it with successive algebraic structures by hand.  This is fairly close to what you did before but, when <a href="https://leanprover-community.github.io/mathlib_docs/find/borel_space">docs#borel_space</a> and typeclass inference are used correctly, it doesn't throw errors.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.borel_space</span>

<span class="kd">noncomputable theory</span>

<span class="kd">variables</span> <span class="o">(</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">measurable_fun</span> <span class="o">:=</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Ω</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">//</span> <span class="n">measurable</span> <span class="n">f</span><span class="o">}</span>

<span class="kd">infixr</span> <span class="bp">`→ₘ</span> <span class="bp">`</span><span class="o">:</span><span class="mi">80</span> <span class="o">:=</span> <span class="n">measurable_fun</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_measurable_add₂</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">add_monoid</span> <span class="o">(</span><span class="bp">Ω</span> <span class="bp">→ₘ</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="o">⟨</span><span class="n">f.1</span> <span class="bp">+</span> <span class="n">g.1</span><span class="o">,</span> <span class="n">f.2.add</span> <span class="n">g.2</span><span class="o">⟩,</span>
  <span class="n">add_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">subtype.ext</span> <span class="bp">$</span> <span class="n">add_assoc</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">zero</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">measurable_const</span><span class="o">⟩,</span>
  <span class="n">zero_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">subtype.ext</span> <span class="bp">$</span> <span class="n">zero_add</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">add_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">subtype.ext</span> <span class="bp">$</span> <span class="n">add_zero</span> <span class="n">_</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_measurable_mul₂</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">monoid</span> <span class="o">(</span><span class="bp">Ω</span> <span class="bp">→ₘ</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="o">⟨</span><span class="n">f.1</span> <span class="bp">*</span> <span class="n">g.1</span><span class="o">,</span> <span class="n">f.2.mul</span> <span class="n">g.2</span><span class="o">⟩,</span>
  <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">subtype.ext</span> <span class="bp">$</span> <span class="n">mul_assoc</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">measurable_const</span><span class="o">⟩,</span>
  <span class="n">one_mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">subtype.ext</span> <span class="bp">$</span> <span class="n">one_mul</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">mul_one</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">subtype.ext</span> <span class="bp">$</span> <span class="n">mul_one</span> <span class="n">_</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space.second_countable_topology</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">[</span><span class="n">borel_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_semiring</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">semiring</span> <span class="o">(</span><span class="bp">Ω</span> <span class="bp">→ₘ</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add_comm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">subtype.ext</span> <span class="bp">$</span> <span class="n">add_comm</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">zero_mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">subtype.ext</span> <span class="bp">$</span> <span class="n">zero_mul</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">mul_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">subtype.ext</span> <span class="bp">$</span> <span class="n">mul_zero</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">left_distrib</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">subtype.ext</span> <span class="bp">$</span> <span class="n">left_distrib</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">right_distrib</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">subtype.ext</span> <span class="bp">$</span> <span class="n">right_distrib</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">measurable_fun.add_monoid</span> <span class="bp">Ω</span> <span class="n">β</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">measurable_fun.monoid</span> <span class="bp">Ω</span> <span class="n">β</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space.second_countable_topology</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">[</span><span class="n">borel_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_semiring</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">comm_semiring</span> <span class="o">(</span><span class="bp">Ω</span> <span class="bp">→ₘ</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mul_comm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">subtype.ext</span> <span class="bp">$</span> <span class="n">mul_comm</span> <span class="n">_</span> <span class="n">_</span>
  <span class="bp">..</span> <span class="n">measurable_fun.semiring</span> <span class="bp">Ω</span> <span class="n">β</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">nnreal_measurable_fun_zero_val_def</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="bp">Ω</span> <span class="bp">→ₘ</span> <span class="n">nnreal</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">rfl</span>

<span class="c1">-- not needed for anything, but just to check</span>
<span class="kd">example</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">:</span> <span class="n">comm_semiring</span> <span class="o">(</span><span class="bp">Ω</span> <span class="bp">→ₘ</span> <span class="n">nnreal</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>



<a name="242163933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242163933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242163933">(Jun 10 2021 at 06:22)</a>:</h4>
<p>I have an open PR against mathlib that does precisely that, <a href="https://github.com/leanprover-community/mathlib/issues/7833">#7833</a></p>



<a name="242420653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242420653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242420653">(Jun 12 2021 at 01:48)</a>:</h4>
<p><span class="user-mention" data-user-id="260507">@Heather Macbeth</span> How would you suggest adapting the random variable definition to building on your suggestion:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.borel_space</span>

<span class="kd">noncomputable theory</span>

<span class="kd">def</span> <span class="n">measurable_fun</span>
  <span class="o">(</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span>
  <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space.second_countable_topology</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">borel_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_semiring</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">subsemiring</span> <span class="o">(</span><span class="bp">Ω</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">f</span> <span class="bp">|</span> <span class="n">measurable</span> <span class="n">f</span><span class="o">},</span>
  <span class="n">one_mem'</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">measurable_const</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">mul_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="n">measurable.mul</span><span class="o">,</span>
  <span class="n">zero_mem'</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">measurable_const</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">add_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="n">measurable.add</span> <span class="o">}</span>

<span class="kd">infixr</span> <span class="bp">`→ₘ</span> <span class="bp">`</span><span class="o">:</span><span class="mi">80</span> <span class="o">:=</span> <span class="n">measurable_fun</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">nnreal_measurable_fun_zero_val_def</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="bp">Ω</span> <span class="bp">→ₘ</span> <span class="n">nnreal</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">def</span> <span class="n">random_variable'</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">{</span><span class="n">β</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">):</span><span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="n">measurable_fun</span> <span class="bp">Ω</span> <span class="n">β</span>

<span class="kd">infixr</span>  <span class="bp">`</span> <span class="bp">→ᵣ'</span> <span class="bp">`</span><span class="o">:</span><span class="mi">80</span> <span class="o">:=</span> <span class="n">random_variable'</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">nnreal_random_variable_add_val_def</span> <span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">{</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span><span class="bp">Ω</span> <span class="bp">→ᵣ'</span> <span class="o">(</span><span class="n">nnreal</span><span class="o">)}</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a.val</span> <span class="bp">+</span> <span class="n">b.val</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="242420786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242420786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242420786">(Jun 12 2021 at 01:52)</a>:</h4>
<p><span class="user-mention" data-user-id="397140">@Hunter Monroe</span> I don't know much about probability, sorry.</p>
<p>By the way, it looks like you are defining the semiring structure using the <a href="#narrow/stream/113489-new-members/topic/Probability.20theory/near/242147649">quick-and-dirty</a> method I proposed at first, but since <span class="user-mention" data-user-id="310045">@Eric Wieser</span> has an open PR for a more comprehensive construction, it would be better to merge that in and base your work on that ....</p>



<a name="242421185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242421185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242421185">(Jun 12 2021 at 02:05)</a>:</h4>
<p>I guess my first thought would be not to use <code>random_variable</code> at all -- just to refer throughout to <code>measurable_fun</code>, or perhaps to make <code>random_variable</code> an <code>abbreviation</code> for <code>measurable_fun</code>.  But maybe a probabilist could draw a distinction here that I'm not seeing.</p>



<a name="242421419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242421419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242421419">(Jun 12 2021 at 02:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/113489-new-members/topic/Probability.20theory/near/242421185">said</a>:</p>
<blockquote>
<p>I guess my first thought would be not to use <code>random_variable</code> at all -- just to refer throughout to <code>measurable_fun</code></p>
</blockquote>
<p>This seems to be how it's done in, eg, <a href="https://leanprover-community.github.io/mathlib_docs/find/probability_theory.lintegral_mul_eq_lintegral_mul_lintegral_of_indep_fun">docs#probability_theory.lintegral_mul_eq_lintegral_mul_lintegral_of_indep_fun</a></p>



<a name="242460336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242460336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242460336">(Jun 12 2021 at 16:48)</a>:</h4>
<p><span class="user-mention" data-user-id="260507">@Heather Macbeth</span> good point on random variables. Another question: how should I conjure up a <code>topological_semiring ennreal</code> as required for the def at the end using your method or Eric's new method?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.borel_space</span>
<span class="kd">noncomputable theory</span>
<span class="kd">def</span> <span class="n">measurable_fun</span>
  <span class="o">(</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span>
  <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space.second_countable_topology</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">borel_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_semiring</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">subsemiring</span> <span class="o">(</span><span class="bp">Ω</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">f</span> <span class="bp">|</span> <span class="n">measurable</span> <span class="n">f</span><span class="o">},</span>
  <span class="n">one_mem'</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">measurable_const</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">mul_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="n">measurable.mul</span><span class="o">,</span>
  <span class="n">zero_mem'</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">measurable_const</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">add_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="n">measurable.add</span> <span class="o">}</span>

  <span class="kd">def</span> <span class="n">nnreal_to_ennreal_measurable_fun</span><span class="o">:</span><span class="n">measurable_fun</span> <span class="o">(</span> <span class="n">nnreal</span><span class="o">)</span> <span class="o">(</span> <span class="n">ennreal</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">val</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">:</span><span class="n">nnreal</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">ennreal</span><span class="o">)),</span>
  <span class="n">property</span> <span class="o">:=</span> <span class="n">nnreal_to_ennreal_measurable</span><span class="o">,}</span>
</code></pre></div>



<a name="242460715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242460715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242460715">(Jun 12 2021 at 16:54)</a>:</h4>
<p>Actually, I didn't see a <code>topological_space</code> instance for <code>ennreal</code> in mathlib.  (Maybe I'm not looking in the right place.). Does anyone know for sure?</p>



<a name="242460755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242460755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242460755">(Jun 12 2021 at 16:55)</a>:</h4>
<p>There is definitely an instance</p>



<a name="242460800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242460800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242460800">(Jun 12 2021 at 16:56)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/ennreal.topological_space">docs#ennreal.topological_space</a></p>



<a name="242461035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242461035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242461035">(Jun 12 2021 at 17:02)</a>:</h4>
<p>Then maybe what's missing, if it's true, is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.algebra.ring</span>
<span class="kn">import</span> <span class="n">topology.algebra.ordered.basic</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">canonically_ordered_comm_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">order_topology</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">topological_semiring</span> <span class="n">α</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="242461246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242461246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242461246">(Jun 12 2021 at 17:08)</a>:</h4>
<p>are you sure that ennreal is a <code>topological_semiring</code>? I am worried about continuity of the multiplication. What do you need that instance for?</p>



<a name="242461452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242461452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242461452">(Jun 12 2021 at 17:13)</a>:</h4>
<p>can confirm it's not a topological semiring because multiplication is not continuous at (0, infty)</p>



<a name="242461900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242461900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242461900">(Jun 12 2021 at 17:24)</a>:</h4>
<p>The multiplication is not continuous, but there is <a href="https://leanprover-community.github.io/mathlib_docs/find/ennreal.has_measurable_mul₂">docs#ennreal.has_measurable_mul₂</a> and similar for add etc. All needed properties for the subsemiring definition should be there. Just don't look for continuity, but directly use measurability.</p>



<a name="242461988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242461988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242461988">(Jun 12 2021 at 17:27)</a>:</h4>
<p>In the original formal-ml repository, commenting out the instance below creates an error in proof of a lemma E[X*Y]=E[X}E[Y} for X, Y independent, nnreal-valued random variables, so the instance is likely not essential for the proof. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="n">ennreal_random_variable_comm_semiring</span> <span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>  <span class="o">{</span><span class="n">p</span><span class="o">:</span><span class="n">probability_space</span> <span class="bp">Ω</span><span class="o">}:</span>  <span class="n">comm_semiring</span> <span class="o">(</span><span class="n">random_variable</span> <span class="n">p</span> <span class="o">(</span><span class="n">borel</span> <span class="n">ennreal</span><span class="o">)):=</span>  <span class="n">ennreal_measurable_fun_comm_semiring</span>
</code></pre></div>



<a name="242462720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242462720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242462720">(Jun 12 2021 at 17:47)</a>:</h4>
<p>I need a strategic decision on whether I should continue trying to get formal-ml to compile with current mathlib--which would likely require someone much more experienced with Lean to help me for an hour or so with compile errors prioritizing the files independent_events.lean, real_random_variable, measure, finite_pi_measure, prod_measure, random_variable_identical, and radon_nikodym/dependencies. I could then continue the spadework to modify formal-ml to include key parts in mathlib: definitions of random variable, the expectation operator, and the Radon-Nikodym theorem (the jewel in the crown). This would include factoring out extra definitions for measurablesetB, measurable functions, and any lemmas already in mathlib that I have missed, while using more standard notation. Alternatively, I could create a less ambitious submission of key probability concepts, cribbing from formal-ml without getting formal-ml to compile. The repository I am working in is <a href="https://github.com/hmonroe/formal-ml">https://github.com/hmonroe/formal-ml</a>.</p>



<a name="242462871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242462871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242462871">(Jun 12 2021 at 17:51)</a>:</h4>
<p>I thought you got formal-ml to compile already?</p>



<a name="242463051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242463051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242463051">(Jun 12 2021 at 17:55)</a>:</h4>
<p>I am not following what you are doing with formal-ml closely, but it looks like you would benefit from writing your own code in order to gain familiarity with mathlib, rather than adapting another code which uses quite different conventions. If I were you, I would pick one goal and build towards it from mathlib, not from formal-ml. Although following the general steps of formal-ml would of course help.</p>
<p>The radon-nikodym theorem looks like a fun goal, and it can be written within measure theory: no need for all those events and random variable definitions. Writing theorems is more fun than coming up with definitions.</p>



<a name="242463186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242463186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242463186">(Jun 12 2021 at 17:58)</a>:</h4>
<p>Part of the thing that makes formal-ml awkward is that it contains lots of definitions that are almost-but-not-quite the same as the mathlib ones</p>



<a name="242463445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242463445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242463445">(Jun 12 2021 at 18:03)</a>:</h4>
<p>Whilst I don't know anything about how probability theory is set up in either mathlib or formal-ml, I have got a lot of experience with getting lean-beginners to the stage where they can write mathlib-ready code, and I think that an effective way to learn Lean is to do small projects yourself from scratch rather than trying to understand 600 lines of rotting code. I agree with Remy that proving theorems is more fun than making definitions -- making definitions is extremely difficult. To give a pretty solid proof of this, take a look at mathlib's definition of a group, which is nothing like what a beginner would write, it is far far more complicated, for reasons which would be difficult for a beginner to understand. I would recommend short projects which could become mathlib PRs, because the PR process is an effective way of learning.</p>



<a name="242483251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242483251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242483251">(Jun 13 2021 at 01:43)</a>:</h4>
<p>OK, I have made a pull request for the first 800 or so lines of probability_space also defining events and probability. I switched to standard set notation (union/intersection/complement) for events. <a href="https://github.com/leanprover-community/mathlib/pull/7913#partial-pull-merging">https://github.com/leanprover-community/mathlib/pull/7913#partial-pull-merging</a>.</p>



<a name="242669320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242669320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242669320">(Jun 14 2021 at 23:00)</a>:</h4>
<p>What is the purpose of making <code>probability_measure</code> a class as opposed to for instance a subtype?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">probability_measure</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="n">measure_univ</span> <span class="o">:</span> <span class="n">μ</span> <span class="n">univ</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>



<a name="242669710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242669710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242669710">(Jun 14 2021 at 23:04)</a>:</h4>
<p>Do you mean, a structure rather than a subtype?</p>



<a name="242670240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242670240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242670240">(Jun 14 2021 at 23:10)</a>:</h4>
<p>Or do you mean, defining it as a <code>Prop</code> rather than as a <code>measure</code> plus a <code>Prop</code>?</p>



<a name="242671403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242671403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242671403">(Jun 14 2021 at 23:26)</a>:</h4>
<p>Broadly, what are the choices and the design considerations? This would help understand how to build on top of it.</p>



<a name="242671719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242671719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242671719">(Jun 14 2021 at 23:31)</a>:</h4>
<p>Have you tried making your suggested variation on a clean copy of mathlib, and compiling it to see what breaks?</p>



<a name="242673028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242673028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242673028">(Jun 14 2021 at 23:51)</a>:</h4>
<p>Let's say you defined "is_probability_measure mu : Prop := mu univ = 1". Then, you'd likely prove all sorts of things about such measures, having to constantly pass (h : is_probability_measure mu) around. And make definitions that require the hypothesis also. In those lemmas and definitions, you might or might not refer to h. Typeclasses allow you require that hypothesis too, but to also infer them form the context. Often, you won't care exactly about h, but lemmas derived from it. And typeclasses will make it much easier to defer to those. The same way that add_le_add doesn't require you to pass a proof of the order.</p>



<a name="242908207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242908207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242908207">(Jun 16 2021 at 16:44)</a>:</h4>
<p>The definition of <code>ite</code> has changed so as to break this lemma statement, with error <code>type mismatch at application ite (classical.prop_decidable (s = ∅)) term classical.prop_decidable (s = ∅) has type decidable (s = ∅) but is expected to have type Prop</code>. Can someone suggest a fix?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.measurable_space</span>
<span class="kn">import</span> <span class="n">measure_theory.measure_space</span>
<span class="kd">lemma</span> <span class="n">measure_theory.outer_measure.top_eq</span> <span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span><span class="o">:</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]:</span>
  <span class="bp">⇑</span><span class="o">(</span><span class="bp">⊤</span><span class="o">:</span><span class="n">measure_theory.outer_measure</span> <span class="bp">Ω</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">set</span> <span class="bp">Ω</span><span class="o">),</span> <span class="o">(</span><span class="bp">@</span><span class="n">ite</span> <span class="o">(</span><span class="n">s</span><span class="bp">=∅</span><span class="o">)</span> <span class="o">(</span><span class="n">classical.prop_decidable</span> <span class="o">(</span><span class="n">s</span><span class="bp">=∅</span><span class="o">))</span> <span class="n">ennreal</span> <span class="mi">0</span> <span class="bp">⊤</span><span class="o">))</span> <span class="o">:=</span>  <span class="gr">sorry</span>
</code></pre></div>



<a name="242909345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242909345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242909345">(Jun 16 2021 at 16:53)</a>:</h4>
<p>The right order of the arguments seems to be different:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">measure_theory.outer_measure.top_eq</span> <span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span><span class="o">:</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]:</span>
  <span class="bp">⇑</span><span class="o">(</span><span class="bp">⊤</span><span class="o">:</span><span class="n">measure_theory.outer_measure</span> <span class="bp">Ω</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">set</span> <span class="bp">Ω</span><span class="o">),</span> <span class="o">(</span><span class="bp">@</span><span class="n">ite</span> <span class="n">ennreal</span> <span class="o">(</span><span class="n">s</span><span class="bp">=∅</span><span class="o">)</span> <span class="o">(</span><span class="n">classical.prop_decidable</span> <span class="o">(</span><span class="n">s</span><span class="bp">=∅</span><span class="o">))</span> <span class="mi">0</span> <span class="bp">⊤</span><span class="o">))</span> <span class="o">:=</span>  <span class="gr">sorry</span>
</code></pre></div>



<a name="242909691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242909691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242909691">(Jun 16 2021 at 16:55)</a>:</h4>
<p>You shouldn't be using <code>@</code> there in the first place</p>



<a name="242910099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242910099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242910099">(Jun 16 2021 at 16:58)</a>:</h4>
<p>Adding <code>[decidable_pred (λ s : set Ω, s = ∅)]</code> as an argument removes the need for the <code>@</code> and results in a slightly more general lemma</p>



<a name="242915242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242915242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242915242">(Jun 16 2021 at 17:35)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> sorry but how do I get rid of the @? I could not find a variation that worked.</p>
<p>lemma measure_theory.outer_measure.top_eq {Ω:Type*} [M:measurable_space Ω] [decidable_pred (λ s : set Ω, s = ∅)]:<br>
  ⇑(⊤:measure_theory.outer_measure Ω) = ( λ s, (@ite ennreal (s=∅) (classical.prop_decidable (s=∅)) 0 ⊤)) :=  sorry</p>



<a name="242915791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242915791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242915791">(Jun 16 2021 at 17:39)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">measure_theory.outer_measure.top_eq</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span>
  <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">Ω</span><span class="o">,</span> <span class="n">s</span> <span class="bp">=</span> <span class="bp">∅</span><span class="o">)]</span> <span class="o">:</span>
  <span class="bp">⇑</span><span class="o">(</span><span class="bp">⊤</span> <span class="o">:</span> <span class="n">measure_theory.outer_measure</span> <span class="bp">Ω</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">s</span> <span class="bp">=</span> <span class="bp">∅</span><span class="o">)</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)</span> <span class="bp">⊤</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>
<p>you have to give a hint about the type of either 0 or top in the ite</p>



<a name="242916040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242916040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242916040">(Jun 16 2021 at 17:41)</a>:</h4>
<p>by the way, the standard notation for <code>⊤</code> in ennreal (<code>ℝ≥0∞</code>) is <code>∞</code></p>



<a name="242918115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/242918115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#242918115">(Jun 16 2021 at 17:57)</a>:</h4>
<p>The Lebesgue Radon Nikodym Theorem, as extracted from formal-ml, now compiles under the current version of mathlib!!! I have a lot of work to clean it up before submitting to mathlib.</p>



<a name="243431823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/243431823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#243431823">(Jun 21 2021 at 19:35)</a>:</h4>
<p>The proof below works for nnreal, but I not for ennreal, where my proof required three cases statements. Am I missing something, and more generally is there a generic way to move nnreal results to ennreal where correct?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.nnreal</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">:</span><span class="n">nnreal</span><span class="o">}:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">add_le_add_left</span>
</code></pre></div>



<a name="243432473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/243432473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#243432473">(Jun 21 2021 at 19:40)</a>:</h4>
<p>I opened it in the online lean editor and it works fine for ennreal.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.ennreal</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ennreal</span><span class="o">}</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">add_le_add_left</span>
</code></pre></div>
<p>Is your local mathlib up to date?</p>



<a name="243465792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/243465792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#243465792">(Jun 22 2021 at 02:23)</a>:</h4>
<p>How can I apply <code>div_le_div_right</code> here? The error message is not clear: <code>type mismatch at application div_le_div_right h₅ term  h₅ has type  0 &lt; ↑(q.denom) but is expected to have type 0 &lt; ?m_3</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.rat</span>
<span class="kd">lemma</span> <span class="n">rat.exists_unit_frac_le_pos</span> <span class="o">{</span><span class="n">q</span><span class="o">:</span><span class="n">ℚ</span><span class="o">}:</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">q</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">n</span><span class="o">:</span><span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span><span class="bp">/</span><span class="o">((</span><span class="n">n</span><span class="o">:</span><span class="n">rat</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">have</span> <span class="n">h₄</span> <span class="o">:</span> <span class="n">q.denom</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">exact</span> <span class="n">q.pos</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h₅</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="bp">↑</span><span class="o">(</span><span class="n">q.denom</span><span class="o">))</span>  <span class="o">:=</span> <span class="kd">by</span> <span class="n">exact</span> <span class="n">nat.cast_pos.mpr</span> <span class="n">h₄</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h₇</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">ℤ</span><span class="o">)</span> <span class="bp">/</span> <span class="o">(</span><span class="bp">↑</span><span class="o">(</span><span class="n">q.denom</span><span class="o">))</span> <span class="bp">≤</span> <span class="o">(</span><span class="bp">↑</span><span class="o">(</span><span class="n">q.num</span><span class="o">)</span> <span class="bp">/</span> <span class="bp">↑</span><span class="o">(</span><span class="n">q.denom</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">div_le_div_right</span> <span class="n">h₅</span>  <span class="o">(</span><span class="bp">↑</span><span class="o">(</span><span class="n">q.denom</span><span class="o">)),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="243466848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/243466848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#243466848">(Jun 22 2021 at 02:44)</a>:</h4>
<p>Do you know about <code>norm_cast</code>, etc?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.rat</span>

<span class="kd">lemma</span> <span class="n">rat.exists_unit_frac_le_pos</span> <span class="o">{</span><span class="n">q</span><span class="o">:</span><span class="n">ℚ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">q</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">n</span><span class="o">:</span><span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span><span class="bp">/</span><span class="o">((</span><span class="n">n</span><span class="o">:</span><span class="n">ℚ</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₅</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">q.denom</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">exact_mod_cast</span> <span class="n">q.pos</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₇</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">ℚ</span><span class="o">)</span> <span class="bp">/</span> <span class="n">q.denom</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">q.num</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">/</span> <span class="n">q.denom</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">div_le_div_right</span> <span class="n">h₅</span><span class="o">,</span>
    <span class="n">exact_mod_cast</span> <span class="n">rat.num_pos_iff_pos.mpr</span> <span class="n">h</span> <span class="o">},</span>

<span class="kd">end</span>
</code></pre></div>



<a name="243467127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/243467127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#243467127">(Jun 22 2021 at 02:50)</a>:</h4>
<p>I didn't check out your version in a full-featured editor, but my guess is that you should have provided explicit casts to <code>ℚ</code> in place of some of the <code>↑</code>.</p>



<a name="243467281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/243467281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#243467281">(Jun 22 2021 at 02:54)</a>:</h4>
<p>Also, have you seen that the fact you want is a lemma in mathlib? <a href="https://leanprover-community.github.io/mathlib_docs/find/exists_nat_one_div_lt">docs#exists_nat_one_div_lt</a></p>



<a name="243470462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/243470462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#243470462">(Jun 22 2021 at 04:09)</a>:</h4>
<p>Cool thanks.</p>



<a name="243552168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/243552168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#243552168">(Jun 22 2021 at 17:38)</a>:</h4>
<p>How can I prove the equivalence below (nnreal replaced with real). I tried <code>norm_cast</code> and <code>real.to_nnreal_mono</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.nnreal</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">ε</span><span class="o">:</span><span class="n">nnreal</span><span class="o">}</span> <span class="o">{</span><span class="n">n'</span><span class="o">:</span><span class="n">ℕ</span> <span class="o">}:</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="bp">→</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">/</span> <span class="o">((</span><span class="n">n'</span><span class="o">:</span><span class="n">real</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">ε</span><span class="o">:</span><span class="n">real</span><span class="o">)</span> <span class="bp">↔</span> <span class="mi">1</span> <span class="bp">/</span> <span class="o">((</span><span class="n">n'</span><span class="o">:</span><span class="n">nnreal</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span><span class="o">):=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>As background, I am trying to prove versions of the following but for nnreal and ennreal, and more generally transfer over results about reals.. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">real.exists_unit_frac_lt_pos</span> <span class="o">{</span><span class="n">ε</span><span class="o">:</span><span class="n">real</span><span class="o">}:</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">n</span><span class="o">:</span><span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span><span class="bp">/</span><span class="o">((</span><span class="n">n</span><span class="o">:</span><span class="n">real</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">&lt;</span> <span class="n">ε</span><span class="o">)</span> <span class="o">:=</span> <span class="n">exists_nat_one_div_lt</span>
</code></pre></div>



<a name="243558025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/243558025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#243558025">(Jun 22 2021 at 18:20)</a>:</h4>
<p>This works, through the magic of <code>simp</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.nnreal</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">ε</span><span class="o">:</span><span class="n">nnreal</span><span class="o">}</span> <span class="o">{</span><span class="n">n'</span><span class="o">:</span><span class="n">ℕ</span> <span class="o">}:</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="bp">→</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">/</span> <span class="o">((</span><span class="n">n'</span><span class="o">:</span><span class="n">real</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">ε</span><span class="o">:</span><span class="n">real</span><span class="o">)</span> <span class="bp">↔</span> <span class="mi">1</span> <span class="bp">/</span> <span class="o">((</span><span class="n">n'</span><span class="o">:</span><span class="n">nnreal</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span><span class="o">):=</span> <span class="kd">by</span> <span class="o">{</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">nnreal.coe_lt_coe</span><span class="o">,</span>
  <span class="n">split</span><span class="bp">;</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">H</span> <span class="n">using</span> <span class="mi">1</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">},</span>
<span class="o">}</span>
</code></pre></div>



<a name="244370873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/244370873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#244370873">(Jun 30 2021 at 02:22)</a>:</h4>
<p>I'll just post also here a link to an exercise I did on weak convergence of probability measures and Portmanteau's theorem: <a class="stream-topic" data-stream-id="113489" href="/#narrow/stream/113489-new-members/topic/Portmanteau.20theorem">#new members &gt; Portmanteau theorem</a>.</p>



<a name="245611413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245611413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245611413">(Jul 11 2021 at 15:04)</a>:</h4>
<p>I would like the statement of the existing theorem below to be <code>E[f*g]=E[f]*E[g]</code> but I am getting the error <code>don't know how to synthesize placeholder</code>. See a mwe below. Note this works in <a href="https://github.com/google/formal-ml/blob/630011d19fdd9539c8d6493a69fe70af5d193590/src/formal_ml/real_random_variable.lean#L795">formal-ml</a> but is such an elaborate approach needed?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.integration</span>
<span class="kn">import</span> <span class="n">probability_theory.independence</span>
<span class="kd">noncomputable theory</span>
<span class="kn">open</span> <span class="n">measure_theory</span>
<span class="n">open_locale</span> <span class="n">ennreal</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kn">namespace</span> <span class="n">probability_theory</span>

<span class="kd">def</span> <span class="n">expected_value</span> <span class="o">[</span><span class="n">M</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">μ</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)</span>
   <span class="o">:=</span> <span class="bp">∫⁻</span> <span class="n">a</span><span class="o">,</span> <span class="n">X</span> <span class="n">a</span> <span class="bp">∂</span><span class="n">μ</span>
<span class="kd">notation</span> <span class="bp">`</span><span class="n">E</span><span class="o">[</span><span class="bp">`</span> <span class="n">X</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span><span class="o">:=</span> <span class="n">expected_value</span> <span class="n">X</span>

<span class="sd">/-- This (roughly) proves that if `f` and `g` are independent random variables,</span>
<span class="sd">   then `E[f * g] = E[f] * E[g]`.-/</span>
<span class="kd">lemma</span> <span class="n">lintegral_mul_eq_lintegral_mul_lintegral_of_independent_measurable_space</span>
  <span class="o">{</span><span class="n">Mf</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">Mg</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">μ</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hMf</span> <span class="o">:</span> <span class="n">Mf</span> <span class="bp">≤</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">hMg</span> <span class="o">:</span> <span class="n">Mg</span> <span class="bp">≤</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">h_ind</span> <span class="o">:</span> <span class="n">indep</span> <span class="n">Mf</span> <span class="n">Mg</span> <span class="n">μ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)</span> <span class="o">(</span><span class="n">h_meas_f</span> <span class="o">:</span> <span class="bp">@</span><span class="n">measurable</span> <span class="n">α</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span> <span class="n">Mf</span> <span class="n">_</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_meas_g</span> <span class="o">:</span> <span class="bp">@</span><span class="n">measurable</span> <span class="n">α</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span> <span class="n">Mg</span> <span class="n">_</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∫⁻</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">g</span> <span class="n">a</span> <span class="bp">∂</span><span class="n">μ</span> <span class="bp">=</span> <span class="bp">∫⁻</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">∂</span><span class="n">μ</span> <span class="bp">*</span> <span class="bp">∫⁻</span> <span class="n">a</span><span class="o">,</span> <span class="n">g</span> <span class="n">a</span> <span class="bp">∂</span><span class="n">μ</span> <span class="o">:=</span><span class="gr">sorry</span>

<span class="kd">end</span> <span class="n">probability_theory</span>
</code></pre></div>



<a name="245611596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245611596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245611596">(Jul 11 2021 at 15:08)</a>:</h4>
<p>Your problem is that lean can't work out <code>μ</code> from the notation</p>



<a name="245611695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245611695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245611695">(Jul 11 2021 at 15:10)</a>:</h4>
<p>One way to resolve this would be to use <a href="https://leanprover-community.github.io/mathlib_docs/find/measure_space">docs#measure_space</a> instead of <a href="https://leanprover-community.github.io/mathlib_docs/find/measurable_space">docs#measurable_space</a>, and the canonical <code>volume</code> measure in place of <code>μ</code></p>



<a name="245612662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245612662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245612662">(Jul 11 2021 at 15:35)</a>:</h4>
<p>I tried that below, replacing <code>μ</code> with <code>Mf.volume</code> and <code>Mg.volume</code>, creating new definitions for <code>measurable</code> and <code>indep</code> based on <code>measure_space</code> not <code>measurable_space</code>, and now have multiple type class instance errors. Presumably I would need to rewrite the statements and proofs in integration.lean as well. Even simple changes seem to blow up in this area.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.integration</span>
<span class="kn">import</span> <span class="n">probability_theory.independence</span>
<span class="kd">noncomputable theory</span>
<span class="kn">open</span> <span class="n">measure_theory</span>
<span class="n">open_locale</span> <span class="n">ennreal</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kn">namespace</span> <span class="n">probability_theory</span>

<span class="kd">def</span> <span class="n">expected_value</span> <span class="o">[</span><span class="n">M</span> <span class="o">:</span> <span class="n">measure_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">μ</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)</span>
   <span class="o">:=</span> <span class="bp">∫⁻</span> <span class="n">a</span><span class="o">,</span> <span class="n">X</span> <span class="n">a</span> <span class="bp">∂</span><span class="n">μ</span>
<span class="kd">notation</span> <span class="bp">`</span><span class="n">E</span><span class="o">[</span><span class="bp">`</span> <span class="n">X</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span><span class="o">:=</span> <span class="n">expected_value</span> <span class="n">X</span>
<span class="kd">def</span> <span class="n">indep'</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">measure_space</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">measure_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">α</span> <span class="bp">.</span> <span class="n">volume_tac</span><span class="o">)</span> <span class="o">:</span>
  <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">indep_sets</span> <span class="o">(</span><span class="n">m₁.measurable_set'</span><span class="o">)</span> <span class="o">(</span><span class="n">m₂.measurable_set'</span><span class="o">)</span> <span class="n">μ</span>
<span class="kd">def</span> <span class="n">measurable'</span> <span class="o">[</span><span class="n">measure_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measure_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">⦃</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">⦄,</span> <span class="n">measurable_set</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">measurable_set</span> <span class="o">(</span><span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">t</span><span class="o">)</span>
<span class="sd">/-- This (roughly) proves that if `f` and `g` are independent random variables,</span>
<span class="sd">   then `E[f * g] = E[f] * E[g]`.-/</span>
<span class="kd">lemma</span> <span class="n">lintegral_mul_eq_lintegral_mul_lintegral_of_independent_measurable_space</span>
  <span class="o">{</span><span class="n">Mf</span> <span class="o">:</span> <span class="n">measure_space</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">Mg</span> <span class="o">:</span> <span class="n">measure_space</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span> <span class="o">:</span> <span class="n">measure_space</span> <span class="n">α</span><span class="o">]</span>
   <span class="o">(</span><span class="n">hMf</span> <span class="o">:</span> <span class="n">Mf</span> <span class="bp">≤</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">hMg</span> <span class="o">:</span> <span class="n">Mg</span> <span class="bp">≤</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">h_ind</span> <span class="o">:</span> <span class="n">indep'</span> <span class="n">Mf</span> <span class="n">Mg</span> <span class="n">μ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)</span> <span class="o">(</span><span class="n">h_meas_f</span> <span class="o">:</span> <span class="bp">@</span><span class="n">measurable'</span> <span class="n">α</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span> <span class="n">Mf</span> <span class="n">_</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_meas_g</span> <span class="o">:</span> <span class="bp">@</span><span class="n">measurable'</span> <span class="n">α</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span> <span class="n">Mg</span> <span class="n">_</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∫⁻</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">g</span> <span class="n">a</span> <span class="bp">∂</span><span class="o">(</span><span class="n">Mf.volume</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">∫⁻</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">∂</span><span class="o">(</span><span class="n">Mf.volume</span><span class="o">)</span> <span class="bp">*</span> <span class="bp">∫⁻</span> <span class="n">a</span><span class="o">,</span> <span class="n">g</span> <span class="n">a</span> <span class="bp">∂</span><span class="o">(</span><span class="n">Mf.volume</span><span class="o">)</span> <span class="o">:=</span><span class="gr">sorry</span>
<span class="kd">end</span> <span class="n">probability_theory</span>
</code></pre></div>



<a name="245612726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245612726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245612726">(Jul 11 2021 at 15:36)</a>:</h4>
<p>Wait, I think I don't understand what you meant by</p>
<blockquote>
<p>I would like the statement of the existing theorem below to be <code>E[f*g]=E[f]*E[g] </code></p>
</blockquote>
<p>Can you provide the things you tried that didn't work?</p>



<a name="245612732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245612732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245612732">(Jul 11 2021 at 15:37)</a>:</h4>
<p>Or are you saying you want the statement you posted to be shown using that notation, but you don't actually want to restate it?</p>



<a name="245612965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245612965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245612965">(Jul 11 2021 at 15:43)</a>:</h4>
<p>The broader goal is to introduce the expected value operator E[...], while the narrow goal is to rewrite that lemma to read: <code>lemma lintegral_mul_eq_lintegral_mul_lintegral_of_independent_measurable_space... : E[f*g]=E[f]*E[g] :=...</code></p>



<a name="245613101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245613101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245613101">(Jul 11 2021 at 15:47)</a>:</h4>
<p>The first thing that did not work was my mwe above, but with <code>E[f*g]=E[f]*E[g]</code> as the thing to be proved. That is, replacing <code>∫⁻ a, f a ∂μ</code> with <code>E[f]</code>.</p>



<a name="245613156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245613156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245613156">(Jul 11 2021 at 15:48)</a>:</h4>
<p>In that case, please include in your <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> both the version that does work <em>and</em> the version that doesn't work!</p>



<a name="245613170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245613170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245613170">(Jul 11 2021 at 15:48)</a>:</h4>
<p>Don't make us try to guess what the non-working version was.</p>



<a name="245613296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245613296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245613296">(Jul 11 2021 at 15:52)</a>:</h4>
<p>Here is the nonworking mwe:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.integration</span>
<span class="kn">import</span> <span class="n">probability_theory.independence</span>
<span class="kd">noncomputable theory</span>
<span class="kn">open</span> <span class="n">measure_theory</span>
<span class="n">open_locale</span> <span class="n">ennreal</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kn">namespace</span> <span class="n">probability_theory</span>

<span class="kd">def</span> <span class="n">expected_value</span> <span class="o">[</span><span class="n">M</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">μ</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)</span>
   <span class="o">:=</span> <span class="bp">∫⁻</span> <span class="n">a</span><span class="o">,</span> <span class="n">X</span> <span class="n">a</span> <span class="bp">∂</span><span class="n">μ</span>
<span class="kd">notation</span> <span class="bp">`</span><span class="n">E</span><span class="o">[</span><span class="bp">`</span> <span class="n">X</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span><span class="o">:=</span> <span class="n">expected_value</span> <span class="n">X</span>

<span class="sd">/-- This (roughly) proves that if `f` and `g` are independent random variables,</span>
<span class="sd">   then `E[f * g] = E[f] * E[g]`.-/</span>
<span class="kd">lemma</span> <span class="n">lintegral_mul_eq_lintegral_mul_lintegral_of_independent_measurable_space</span>
  <span class="o">{</span><span class="n">Mf</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">Mg</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">μ</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hMf</span> <span class="o">:</span> <span class="n">Mf</span> <span class="bp">≤</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">hMg</span> <span class="o">:</span> <span class="n">Mg</span> <span class="bp">≤</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">h_ind</span> <span class="o">:</span> <span class="n">indep</span> <span class="n">Mf</span> <span class="n">Mg</span> <span class="n">μ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)</span> <span class="o">(</span><span class="n">h_meas_f</span> <span class="o">:</span> <span class="bp">@</span><span class="n">measurable</span> <span class="n">α</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span> <span class="n">Mf</span> <span class="n">_</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_meas_g</span> <span class="o">:</span> <span class="bp">@</span><span class="n">measurable</span> <span class="n">α</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span> <span class="n">Mg</span> <span class="n">_</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
<span class="n">E</span><span class="o">[</span><span class="n">f</span><span class="bp">*</span><span class="n">g</span><span class="o">]</span><span class="bp">=</span><span class="n">E</span><span class="o">[</span><span class="n">f</span><span class="o">]</span><span class="bp">*</span><span class="n">E</span><span class="o">[</span><span class="n">g</span><span class="o">]</span> <span class="o">:=</span><span class="gr">sorry</span>

<span class="kd">end</span> <span class="n">probability_theory</span>
</code></pre></div>



<a name="245613997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245613997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245613997">(Jul 11 2021 at 16:08)</a>:</h4>
<p>This works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.integration</span>
<span class="kn">import</span> <span class="n">probability_theory.independence</span>
<span class="kn">open</span> <span class="n">measure_theory</span>
<span class="n">open_locale</span> <span class="n">ennreal</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kn">namespace</span> <span class="n">probability_theory</span>

<span class="kd">def</span> <span class="n">expected_value</span> <span class="o">[</span><span class="n">M</span> <span class="o">:</span> <span class="n">measure_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∫⁻</span> <span class="n">a</span><span class="o">,</span> <span class="n">X</span> <span class="n">a</span> <span class="bp">∂</span><span class="o">(</span><span class="n">volume</span><span class="o">)</span>
<span class="kd">notation</span> <span class="bp">`</span><span class="n">E</span><span class="o">[</span><span class="bp">`</span> <span class="n">X</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span><span class="o">:=</span> <span class="n">expected_value</span> <span class="n">X</span>

<span class="sd">/-- This (roughly) proves that if `f` and `g` are independent random variables,</span>
<span class="sd">   then `E[f * g] = E[f] * E[g]`.-/</span>
<span class="kd">lemma</span> <span class="n">lintegral_mul_eq_lintegral_mul_lintegral_of_independent_measurable_space</span>
  <span class="o">{</span><span class="n">Mf</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">Mg</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span> <span class="o">:</span> <span class="n">measure_space</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">μ</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hMf</span> <span class="o">:</span> <span class="n">Mf</span> <span class="bp">≤</span> <span class="n">measure_space.to_measurable_space</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hMg</span> <span class="o">:</span> <span class="n">Mg</span> <span class="bp">≤</span> <span class="n">measure_space.to_measurable_space</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_ind</span> <span class="o">:</span> <span class="bp">@</span><span class="n">indep</span> <span class="n">_</span> <span class="n">Mf</span> <span class="n">Mg</span> <span class="n">measure_space.to_measurable_space</span> <span class="o">(</span><span class="n">volume</span><span class="o">))</span>
  <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)</span> <span class="o">(</span><span class="n">h_meas_f</span> <span class="o">:</span> <span class="bp">@</span><span class="n">measurable</span> <span class="n">α</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span> <span class="n">Mf</span> <span class="n">_</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_meas_g</span> <span class="o">:</span> <span class="bp">@</span><span class="n">measurable</span> <span class="n">α</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span> <span class="n">Mg</span> <span class="n">_</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
<span class="n">E</span><span class="o">[</span><span class="n">f</span><span class="bp">*</span><span class="n">g</span><span class="o">]</span><span class="bp">=</span><span class="n">E</span><span class="o">[</span><span class="n">f</span><span class="o">]</span><span class="bp">*</span><span class="n">E</span><span class="o">[</span><span class="n">g</span><span class="o">]</span> <span class="o">:=</span><span class="gr">sorry</span>

<span class="kd">end</span> <span class="n">probability_theory</span>
</code></pre></div>



<a name="245614036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245614036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245614036">(Jul 11 2021 at 16:09)</a>:</h4>
<p>I think either you're working with this API in the wrong way, or this API isn't well thought out - the problem with this lemma is that <code>measurable_space</code> is a typeclass, but this lemma is talking about three different instances of the same typeclass, meaning you needs <code>@</code>s everywhere to be clear which one of the three you care about</p>



<a name="245615524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245615524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245615524">(Jul 11 2021 at 16:46)</a>:</h4>
<p>Fantastic. My aim is to rewrite integration.lean so the conclusions have the form <code>E[f*g]=E[f]*E[g]</code> and can serve as a building block for probability theory. Are you suggesting that the lemma should be stated differently? The next lemma matters more, but uses this lemma: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- This proves that if `f` and `g` are independent random variables, then `E[f * g] = E[f] * E[g]`. -/</span>
<span class="kd">lemma</span> <span class="n">lintegral_mul_eq_lintegral_mul_lintegral_of_indep_fun</span> <span class="o">[</span><span class="n">M</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)</span> <span class="o">(</span><span class="n">h_meas_f</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">h_meas_g</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">g</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_indep_fun</span> <span class="o">:</span> <span class="n">indep_fun</span> <span class="o">(</span><span class="n">borel</span> <span class="n">ennreal</span><span class="o">)</span> <span class="o">(</span><span class="n">borel</span> <span class="n">ennreal</span><span class="o">)</span> <span class="n">f</span> <span class="n">g</span> <span class="n">μ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∫⁻</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="n">f</span> <span class="bp">*</span> <span class="n">g</span><span class="o">)</span> <span class="n">a</span> <span class="bp">∂</span><span class="n">μ</span> <span class="bp">=</span> <span class="bp">∫⁻</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">∂</span><span class="n">μ</span> <span class="bp">*</span> <span class="bp">∫⁻</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">g</span> <span class="n">a</span> <span class="bp">∂</span><span class="n">μ</span>
</code></pre></div>



<a name="245615749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245615749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245615749">(Jul 11 2021 at 16:52)</a>:</h4>
<p>Eric is simply saying that <code>measurable_space</code> has been designed with the idea in mind that any type should have at most one measurable space structure, and in your lemma you're putting two measurable space structures on alpha. Typeclasses are not designed to do this.</p>



<a name="245616495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245616495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245616495">(Jul 11 2021 at 17:08)</a>:</h4>
<p>Ok thanks (it is not my lemma but the one in mathlib that needs tuning up).</p>



<a name="245616662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245616662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245616662">(Jul 11 2021 at 17:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="397140">Hunter Monroe</span> <a href="#narrow/stream/113489-new-members/topic/Probability.20theory/near/245615524">said</a>:</p>
<blockquote>
<p>My aim is to rewrite integration.lean so the conclusions have the form <code>E[f*g]=E[f]*E[g]</code> and can serve as a building block for probability theory.</p>
</blockquote>
<p>What do you mean? We certainly don't want the integration files to be polluted with probabilistic notation. Do you mean you want to duplicate <code>integration.lean</code> in some new file with different notations?</p>



<a name="245617731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245617731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245617731">(Jul 11 2021 at 17:30)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, I get the feeling that the lemma statement using the original notation is part of mathlib, and that there are lots of places in the measure theory library where two different measurable_space instances are put on the same type.</p>



<a name="245643208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245643208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245643208">(Jul 12 2021 at 04:16)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> the whole point of the file integration.lean under probability_theory according to the doc strings is to show that for independent random variables <code>E[f*g]=E[f]*E[g]</code>, but then the theorems themselves did not use that notation.</p>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/Probability.20theory/near/245616662">said</a>:</p>
<blockquote>
<p>What do you mean? We certainly don't want the integration files to be polluted with probabilistic notation. Do you mean you want to duplicate <code>integration.lean</code> in some new file with different notations?</p>
</blockquote>



<a name="245818022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245818022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason KY. <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245818022">(Jul 13 2021 at 12:40)</a>:</h4>
<p><span class="user-mention" data-user-id="397140">@Hunter Monroe</span> I just saw this thread and I see that you are working on porting formal-ml to mathlib. I just wanted to say that I have Radon-Nikodym proved through the signed measure rout here: <a href="https://github.com/JasonKYi/probability_theory/blob/main/src/singular.lean#L479">https://github.com/JasonKYi/probability_theory/blob/main/src/singular.lean#L479</a></p>



<a name="245818632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245818632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245818632">(Jul 13 2021 at 12:45)</a>:</h4>
<p>Radon-Nikodym even works for sigma-finite measures, as you know probably, but the hard part is the part for finite measures that you have done. Very nice! Even more motivation for me to review <a href="https://github.com/leanprover-community/mathlib/issues/8247">#8247</a> :-)</p>



<a name="245818799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245818799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason KY. <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245818799">(Jul 13 2021 at 12:46)</a>:</h4>
<p>I do plan to work on generalizing to sigma-finiteness later this week :)</p>



<a name="245819917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245819917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245819917">(Jul 13 2021 at 12:55)</a>:</h4>
<p>Awesome. Review done (well, I stopped after a few lines, because there is something I don't understand :-)</p>



<a name="245822907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245822907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason KY. <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245822907">(Jul 13 2021 at 13:17)</a>:</h4>
<p>I've now removed the extra <code>R</code>. Certainly a surprise that a vector measures doesn't require a vector space!</p>



<a name="245832068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245832068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245832068">(Jul 13 2021 at 14:23)</a>:</h4>
<p>That is great. The Hahn decomposition theorem is already in measure_theory/decomposition--you may be introducing a duplicate version in your hahn.lean file. Note that formal-ml was not well integrated with mathlib with duplicates of many results, including its own proof of the Hahn decomposition theorem. I am no longer trying to bring formal-ml up to date with the latest mathlib, but am still working on key probability theorems, in some cases comparing against formal-ml.</p>
<p><span class="user-mention silent" data-user-id="243312">Jason KY.</span> <a href="#narrow/stream/113489-new-members/topic/Probability.20theory/near/245818022">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="397140">Hunter Monroe</span> I just saw this thread and I see that you are working on porting formal-ml to mathlib. I just wanted to say that I have Radon-Nikodym proved through the signed measure rout here: <a href="https://github.com/JasonKYi/probability_theory/blob/main/src/singular.lean#L479">https://github.com/JasonKYi/probability_theory/blob/main/src/singular.lean#L479</a></p>
</blockquote>



<a name="245832478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245832478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245832478">(Jul 13 2021 at 14:26)</a>:</h4>
<p>My immediate priority is Borel-Cantelli (other direction) and basic expectation/variance results.</p>



<a name="245833642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245833642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason KY. <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245833642">(Jul 13 2021 at 14:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="397140">Hunter Monroe</span> <a href="#narrow/stream/113489-new-members/topic/Probability.20theory/near/245832068">said</a>:</p>
<blockquote>
<p>The Hahn decomposition theorem is already in measure_theory/decomposition--you may be introducing a duplicate version in your hahn.lean file. </p>
</blockquote>
<p>The one in mathlib right now is the non-signed version while the one in mine repo is the signed version :)</p>



<a name="245837104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245837104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245837104">(Jul 13 2021 at 14:57)</a>:</h4>
<p>(deleted)</p>



<a name="245837737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245837737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245837737">(Jul 13 2021 at 15:00)</a>:</h4>
<p>Good point, so you will do another PR with Radon-Nikodym and Hahn?</p>



<a name="245838637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/245838637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason KY. <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#245838637">(Jul 13 2021 at 15:04)</a>:</h4>
<p>Right, I will need the signed version of Hahn for Radon-Nikodym</p>



<a name="249661618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/249661618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#249661618">(Aug 16 2021 at 23:31)</a>:</h4>
<p><span class="user-mention" data-user-id="243312">@Jason KY.</span> have you done a PR for Radon-Nikodym?</p>



<a name="249662794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/249662794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason KY. <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#249662794">(Aug 16 2021 at 23:48)</a>:</h4>
<p>Radon-Nikodym should come right after <a href="https://github.com/leanprover-community/mathlib/pull/8687">#8687</a> <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="294668574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/294668574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniil Homza <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#294668574">(Aug 22 2022 at 12:50)</a>:</h4>
<p>Hi everyone!</p>
<p>I am a new member of Lean community. </p>
<p>For now I try to proof "Weak Law of Large Number". </p>
<p>I am confused on the following problem</p>
<p>"<br>
How to defined all set of form {1}, {1,2}, {1,2,3}.... and say something like there exists N such that \forall n&gt;N \sum_{i=1}^n .......<br>
"<br>
Can someone help with this?</p>
<p>Thank you in advance:)</p>



<a name="294671523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/294671523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#294671523">(Aug 22 2022 at 13:05)</a>:</h4>
<p>Does <a href="https://leanprover-community.github.io/mathlib_docs/find/fin">docs#fin</a> and/or <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.range">docs#finset.range</a> help?</p>



<a name="294671589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/294671589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#294671589">(Aug 22 2022 at 13:05)</a>:</h4>
<p>See also <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum">docs#finset.sum</a>.</p>



<a name="298725143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/298725143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniil Homza <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#298725143">(Sep 14 2022 at 08:32)</a>:</h4>
<p>Hi Lean Community,</p>
<p>I have some easy question to solve but I can not get it. I am interesting to proof that expected value of m r.v. is sum of m expected value of r.v. I can not find such result of summarising of two integrals in section measure_theory. Actually i have problem even in case of such result in case of two r.v. Any Help? Thanks in advance <a href="/user_uploads/3121/xtvGL6RhSQMpnnc8_RiiafCp/123.PNG">123.PNG</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/xtvGL6RhSQMpnnc8_RiiafCp/123.PNG" title="123.PNG"><img src="/user_uploads/3121/xtvGL6RhSQMpnnc8_RiiafCp/123.PNG"></a></div>



<a name="298725617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/298725617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#298725617">(Sep 14 2022 at 08:36)</a>:</h4>
<p>Hi! Helping you would be easier if you posted code instead of a picture, ideally in the form of an <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> . But it looks like the lemma you are looking for is <a href="https://leanprover-community.github.io/mathlib_docs/find/measure_theory.integral_finset_sum">docs#measure_theory.integral_finset_sum</a></p>



<a name="298725764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/298725764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#298725764">(Sep 14 2022 at 08:37)</a>:</h4>
<p>for two random variables it would be <a href="https://leanprover-community.github.io/mathlib_docs/find/measure_theory.integral_add">docs#measure_theory.integral_add</a></p>



<a name="298728793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Probability%20theory/near/298728793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniil Homza <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Probability.20theory.html#298728793">(Sep 14 2022 at 08:59)</a>:</h4>
<p>o, yep, i think is that i am looking for. Sorry for picture) Thank you!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
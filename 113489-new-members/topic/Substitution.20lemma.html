---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Substitution.20lemma.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html">Substitution lemma</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="211854617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211854617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211854617">(Sep 30 2020 at 23:58)</a>:</h4>
<p>In <em><a href="https://ttic.uchicago.edu/~dreyer/course/papers/barendregt.pdf">Typed Lambda Calculi</a></em>, the first lemma Henk Barendregt proposes is the following:</p>
<blockquote>
<p><strong>Proposition 2.1.6 (Substitution lemma).</strong> Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo separator="true">,</mo><mi>N</mi><mo separator="true">,</mo><mi>L</mi><mo>∈</mo><mi mathvariant="normal">Λ</mi></mrow><annotation encoding="application/x-tex">M, N, L \in \Lambda</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Λ</span></span></span></span>. Suppose <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≢</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \not\equiv y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo mathvariant="normal">∉</mo><mi>F</mi><mi>V</mi><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \notin FV(L)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span>. Then</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>x</mi><mo>:</mo><mo>=</mo><mi>N</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>y</mi><mo>:</mo><mo>=</mo><mi>L</mi><mo stretchy="false">]</mo><mo>=</mo><mi>M</mi><mo stretchy="false">[</mo><mi>y</mi><mo>:</mo><mo>=</mo><mi>L</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>x</mi><mo>:</mo><mo>=</mo><mi>N</mi><mo stretchy="false">[</mo><mi>y</mi><mo>:</mo><mo>=</mo><mi>L</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[x := N][y := L] = M[y := L][x := N[y := L]]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span>.</p>
<p><strong>Proof.</strong> By induction on the structure of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">■</mi></mrow><annotation encoding="application/x-tex">\blacksquare</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.675em;vertical-align:0em;"></span><span class="mord amsrm">■</span></span></span></span></p>
</blockquote>
<p>A while ago I tried to formalize it in Lean, but it felt like it was taking way too much work to formalize a one-line proof. Well, not only once I've proved something just to find a <em>much</em> shorter proof on here or mathlib. Lean magicians know a simple proof for this proposition?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">lam</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span>

<span class="kn">open</span> <span class="n">term</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">FV</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">app</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="n">M</span> <span class="bp">∪</span> <span class="n">FV</span> <span class="n">N</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">lam</span> <span class="n">M</span><span class="o">)</span>   <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">∈</span> <span class="n">FV</span> <span class="n">M</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span>   <span class="o">:=</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">FV</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">M</span> <span class="k">with</span> <span class="n">M</span> <span class="n">N</span> <span class="n">ih₁</span> <span class="n">ih₂</span> <span class="n">M</span> <span class="n">ih</span> <span class="n">y</span> <span class="n">generalizing</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">ih₁</span> <span class="n">x</span> <span class="k">with</span> <span class="n">ih₁</span> <span class="n">ih₁</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">ih₂</span> <span class="n">x</span> <span class="k">with</span> <span class="n">ih₂</span> <span class="n">ih₂</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">is_false</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h.cases_on</span> <span class="n">ih₁</span> <span class="n">ih₂</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">all_goals</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">is_true</span> <span class="o">(</span><span class="kd">by</span> <span class="n">exact</span> <span class="n">or.inl</span> <span class="n">ih₁</span> <span class="bp">&lt;|&gt;</span> <span class="n">exact</span> <span class="n">or.inr</span> <span class="n">ih₂</span><span class="o">)</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">decidable.cases_on</span> <span class="o">(</span><span class="n">ih</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="n">is_false</span> <span class="n">is_true</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">dite</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="n">is_true</span> <span class="n">is_false</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">rename_ext</span> <span class="o">(</span><span class="n">ρ</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ρ</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">rename</span> <span class="o">:</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">ρ</span> <span class="o">(</span><span class="n">app</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span> <span class="n">app</span> <span class="o">(</span><span class="n">rename</span> <span class="n">ρ</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">rename</span> <span class="n">ρ</span> <span class="n">N</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">ρ</span> <span class="o">(</span><span class="n">lam</span> <span class="n">M</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">lam</span> <span class="o">(</span><span class="n">rename</span> <span class="o">(</span><span class="n">rename_ext</span> <span class="n">ρ</span><span class="o">)</span> <span class="n">M</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">ρ</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">var</span> <span class="o">(</span><span class="n">ρ</span> <span class="n">x</span><span class="o">)</span>

<span class="n">abbreviation</span> <span class="n">shift</span> <span class="o">:=</span> <span class="n">rename</span> <span class="n">nat.succ</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">subst_ext</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="o">:=</span> <span class="n">var</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">shift</span> <span class="o">(</span><span class="n">σ</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">subst</span> <span class="o">:</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">→</span> <span class="n">term</span><span class="o">)</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">σ</span> <span class="o">(</span><span class="n">app</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span> <span class="n">app</span> <span class="o">(</span><span class="n">subst</span> <span class="n">σ</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">subst</span> <span class="n">σ</span> <span class="n">N</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">σ</span> <span class="o">(</span><span class="n">lam</span> <span class="n">M</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">lam</span> <span class="o">(</span><span class="n">subst</span> <span class="o">(</span><span class="n">subst_ext</span> <span class="n">σ</span><span class="o">)</span> <span class="n">M</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">σ</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">σ</span> <span class="n">x</span>

<span class="n">abbreviation</span> <span class="n">σ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">L</span> <span class="k">else</span> <span class="n">var</span> <span class="n">y</span>

<span class="c1">-- This changes the precedence of `[`. Let's hope this doesn't become an issue.</span>
<span class="kd">notation</span> <span class="n">M</span> <span class="bp">`</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="n">std.prec.max_plus</span> <span class="n">x</span> <span class="bp">`</span> <span class="o">:=</span> <span class="bp">`</span> <span class="n">L</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">subst</span> <span class="o">(</span><span class="n">σ</span> <span class="n">x</span> <span class="n">L</span><span class="o">)</span> <span class="n">M</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="n">L</span> <span class="o">:</span> <span class="n">term</span><span class="o">}</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">FV</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">M</span><span class="o">[</span><span class="n">x</span> <span class="o">:=</span> <span class="n">N</span><span class="o">][</span><span class="n">y</span> <span class="o">:=</span> <span class="n">L</span><span class="o">]</span> <span class="bp">=</span> <span class="n">M</span><span class="o">[</span><span class="n">y</span> <span class="o">:=</span> <span class="n">L</span><span class="o">][</span><span class="n">x</span> <span class="o">:=</span> <span class="n">N</span><span class="o">[</span><span class="n">y</span> <span class="o">:=</span> <span class="n">L</span><span class="o">]]</span> <span class="o">:=</span>
<span class="n">sorry</span>
</code></pre></div>



<a name="211854750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211854750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211854750">(Oct 01 2020 at 00:00)</a>:</h4>
<blockquote>
<p>it was taking way too much work to formalize a one-line proof.</p>
</blockquote>
<p>Ha! Type theory papers are famous for shuffling these "trivial" proof obligations under the rug. (Including mine!)</p>



<a name="211856225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211856225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211856225">(Oct 01 2020 at 00:21)</a>:</h4>
<p>I should point out though that your formalization differs significantly from Barendregt's</p>



<a name="211858229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211858229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211858229">(Oct 01 2020 at 00:54)</a>:</h4>
<p>Here's a more faithful translation of Barendregt:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- import tactic.localized</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">lam</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span>

<span class="kn">open</span> <span class="n">term</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">FV</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">app</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="n">M</span> <span class="bp">∪</span> <span class="n">FV</span> <span class="n">N</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">lam</span> <span class="n">x</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="n">M</span> <span class="bp">\</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span>   <span class="o">:=</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">subst</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">app</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span> <span class="n">app</span> <span class="o">(</span><span class="n">subst</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">subst</span> <span class="n">N</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">lam</span> <span class="n">y</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">lam</span> <span class="n">y</span> <span class="n">M</span> <span class="k">else</span> <span class="n">lam</span> <span class="n">y</span> <span class="o">(</span><span class="n">subst</span> <span class="n">M</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>   <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">L</span> <span class="k">else</span> <span class="n">var</span> <span class="n">y</span>

<span class="c1">-- This changes the precedence of `[`. Let's hope this doesn't become an issue.</span>
<span class="kd">notation</span> <span class="n">M</span> <span class="bp">`</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="n">std.prec.max_plus</span> <span class="n">x</span> <span class="bp">`</span> <span class="o">:=</span> <span class="bp">`</span> <span class="n">L</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">subst</span> <span class="n">x</span> <span class="n">L</span> <span class="n">M</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="n">L</span> <span class="o">:</span> <span class="n">term</span><span class="o">}</span>

<span class="kd">theorem</span> <span class="n">subst_none</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">FV</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">M</span><span class="o">[</span><span class="n">x</span> <span class="o">:=</span> <span class="n">L</span><span class="o">]</span> <span class="bp">=</span> <span class="n">M</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">M</span> <span class="n">generalizing</span> <span class="n">hx</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">not_or_distrib</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span><span class="bp">;</span> <span class="n">simp</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">M_ih</span> <span class="o">(</span><span class="n">mt</span> <span class="n">hx</span> <span class="n">h</span><span class="o">)</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">FV</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">M</span><span class="o">[</span><span class="n">x</span> <span class="o">:=</span> <span class="n">N</span><span class="o">][</span><span class="n">y</span> <span class="o">:=</span> <span class="n">L</span><span class="o">]</span> <span class="bp">=</span> <span class="n">M</span><span class="o">[</span><span class="n">y</span> <span class="o">:=</span> <span class="n">L</span><span class="o">][</span><span class="n">x</span> <span class="o">:=</span> <span class="n">N</span><span class="o">[</span><span class="n">y</span> <span class="o">:=</span> <span class="n">L</span><span class="o">]]</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">M</span><span class="bp">;</span> <span class="n">simp</span> <span class="bp">*</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">simp</span> <span class="bp">*</span><span class="o">,</span>
    <span class="n">subst</span> <span class="n">M_x</span><span class="o">,</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">simp</span> <span class="bp">*</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">subst</span> <span class="n">M</span><span class="o">,</span> <span class="n">rw</span> <span class="n">subst_none</span> <span class="n">hx</span><span class="o">,</span> <span class="n">sorry</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">subst</span> <span class="n">M</span><span class="o">,</span> <span class="n">rw</span> <span class="n">subst_none</span> <span class="n">hx</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>

<p>As you can see, the proof is actually a straightforward induction, except for the <code>sorry</code>'s</p>



<a name="211858254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211858254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211858254">(Oct 01 2020 at 00:54)</a>:</h4>
<p>and the reason I didn't finish the proof is because it's false!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="c1">-- ff</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">z</span> <span class="o">:=</span> <span class="mi">2</span><span class="o">,</span>
      <span class="n">L</span> <span class="o">:=</span> <span class="n">var</span> <span class="n">z</span><span class="o">,</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">var</span> <span class="n">y</span><span class="o">,</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">lam</span> <span class="n">y</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">to_bool</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">FV</span> <span class="n">L</span><span class="o">),</span>
    <span class="n">M</span><span class="o">[</span><span class="n">x</span> <span class="o">:=</span> <span class="n">N</span><span class="o">][</span><span class="n">y</span> <span class="o">:=</span> <span class="n">L</span><span class="o">]</span> <span class="bp">=</span> <span class="n">M</span><span class="o">[</span><span class="n">y</span> <span class="o">:=</span> <span class="n">L</span><span class="o">][</span><span class="n">x</span> <span class="o">:=</span> <span class="n">N</span><span class="o">[</span><span class="n">y</span> <span class="o">:=</span> <span class="n">L</span><span class="o">]])</span>
</code></pre></div>



<a name="211858405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211858405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211858405">(Oct 01 2020 at 00:57)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> I was hoping I could use slim_check out of the box for this but it seems like I have to write a testable instance for <code>term</code>. Are there any plans for <code>@[derive testable]</code>?</p>



<a name="211858610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211858610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211858610">(Oct 01 2020 at 01:01)</a>:</h4>
<p>What you need is an instance of <code>sampleable</code>. I'd like to generate it</p>



<a name="211858700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211858700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211858700">(Oct 01 2020 at 01:02)</a>:</h4>
<p>I've been considering doing some of what QuickChick does in Coq and creating generators for inductive relations too. It needs some thought</p>



<a name="211858961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211858961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211858961">(Oct 01 2020 at 01:07)</a>:</h4>
<p>For inductive relations, you can mostly get by using <code>decidable</code></p>



<a name="211859078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211859078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211859078">(Oct 01 2020 at 01:09)</a>:</h4>
<p>It seems like Barendregt has some line about a "so-called variable convention" (his words) that may allow him to get out of this error, but I don't really understand what his intent is</p>



<a name="211860741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211860741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211860741">(Oct 01 2020 at 01:45)</a>:</h4>
<p>wow it's really called QuickChick <img alt=":coq:" class="emoji" src="https://zulip-avatars.s3.amazonaws.com/3121/emoji/images/17559.png" title="coq"></p>



<a name="211862424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211862424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211862424">(Oct 01 2020 at 02:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Substitution.20lemma/near/211858254">said</a>:</p>
<blockquote>
<p>and the reason I didn't finish the proof is because it's false!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="c1">-- ff</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">z</span> <span class="o">:=</span> <span class="mi">2</span><span class="o">,</span>
      <span class="n">L</span> <span class="o">:=</span> <span class="n">var</span> <span class="n">z</span><span class="o">,</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">var</span> <span class="n">y</span><span class="o">,</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">lam</span> <span class="n">y</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">to_bool</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">FV</span> <span class="n">L</span><span class="o">),</span>
    <span class="n">M</span><span class="o">[</span><span class="n">x</span> <span class="o">:=</span> <span class="n">N</span><span class="o">][</span><span class="n">y</span> <span class="o">:=</span> <span class="n">L</span><span class="o">]</span> <span class="bp">=</span> <span class="n">M</span><span class="o">[</span><span class="n">y</span> <span class="o">:=</span> <span class="n">L</span><span class="o">][</span><span class="n">x</span> <span class="o">:=</span> <span class="n">N</span><span class="o">[</span><span class="n">y</span> <span class="o">:=</span> <span class="n">L</span><span class="o">]])</span>
</code></pre></div>

</blockquote>
<p>Yes, it is false because you have to consider terms up to alpha equivalence.</p>



<a name="211862440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211862440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211862440">(Oct 01 2020 at 02:17)</a>:</h4>
<p>That is reason for using De Bruijn indices. But it may have made the proofs harder.</p>



<a name="211862603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211862603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211862603">(Oct 01 2020 at 02:21)</a>:</h4>
<p>There doesn't seem to be a straight forward way of defining alpha equivalence. The simplest thing I can think of is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>≡</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">M \equiv N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> if there is a bijective renaming <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo>:</mo><mi mathvariant="double-struck">N</mi><mo>→</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\rho : \mathbb{N} \to \mathbb{N}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mtext> </mtext><mi>ρ</mi><mtext> </mtext><mi>M</mi><mo>=</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">rename \, \rho \, M = N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>.</p>



<a name="211862755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211862755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211862755">(Oct 01 2020 at 02:24)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">rename</span> <span class="o">(</span><span class="n">ρ</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">app</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span> <span class="n">app</span> <span class="o">(</span><span class="n">rename</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">rename</span> <span class="n">N</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">lam</span> <span class="n">x</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">lam</span> <span class="o">(</span><span class="n">ρ</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">rename</span> <span class="n">M</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">var</span> <span class="o">(</span><span class="n">ρ</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">α</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">ρ</span><span class="o">,</span> <span class="n">function.bijective</span> <span class="n">ρ</span> <span class="bp">∧</span> <span class="n">rename</span> <span class="n">ρ</span> <span class="n">M</span> <span class="bp">=</span> <span class="n">N</span>
</code></pre></div>

<p>This seems correct. I may to make this relation into a setoid tomorrow if I have time.</p>



<a name="211863206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211863206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211863206">(Oct 01 2020 at 02:33)</a>:</h4>
<p>That doesn't actually solve the problem, as there is no guard in the case <code>(lam y P)[x := N] == lam y (P [x := N]), provided x != y</code> that prevents occurences of y in N from being captured. It simply makes the equation fail to hold sometimes</p>



<a name="211863257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211863257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211863257">(Oct 01 2020 at 02:34)</a>:</h4>
<p>If you want to use de bruijn indices, I would suggest using a book that deals with terms that way, as the proofs of all the basic properties is very different</p>



<a name="211863914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211863914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211863914">(Oct 01 2020 at 02:49)</a>:</h4>
<p>Here's the way I would suggest setting up de bruijn terms:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">lam</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span>

<span class="kn">open</span> <span class="n">term</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">shiftn</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">app</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span> <span class="n">app</span> <span class="o">(</span><span class="n">shiftn</span> <span class="n">k</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">shiftn</span> <span class="n">k</span> <span class="n">N</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">lam</span> <span class="n">M</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">lam</span> <span class="o">(</span><span class="n">shiftn</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">M</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">k</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span>   <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">k</span> <span class="k">then</span> <span class="n">var</span> <span class="n">x</span> <span class="k">else</span> <span class="n">var</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">abbreviation</span> <span class="n">shift</span> <span class="o">:=</span> <span class="n">shiftn</span> <span class="mi">0</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">substn</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">k</span> <span class="n">L</span> <span class="o">(</span><span class="n">app</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span> <span class="n">app</span> <span class="o">(</span><span class="n">substn</span> <span class="n">k</span> <span class="n">L</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">substn</span> <span class="n">k</span> <span class="n">L</span> <span class="n">N</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">k</span> <span class="n">L</span> <span class="o">(</span><span class="n">lam</span> <span class="n">M</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">lam</span> <span class="o">(</span><span class="n">substn</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">shift</span> <span class="n">L</span><span class="o">)</span> <span class="n">M</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">k</span> <span class="n">L</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span>   <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">k</span> <span class="k">then</span> <span class="n">var</span> <span class="n">x</span> <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">k</span> <span class="k">then</span> <span class="n">L</span> <span class="k">else</span> <span class="n">var</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">abbreviation</span> <span class="n">subst</span> <span class="o">:=</span> <span class="n">substn</span> <span class="mi">0</span>

<span class="kd">notation</span> <span class="n">M</span> <span class="bp">`</span><span class="o">[</span><span class="mi">0</span><span class="bp">`</span> <span class="bp">`</span> <span class="o">:=</span> <span class="bp">`</span> <span class="n">L</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">subst</span> <span class="n">L</span> <span class="n">M</span>
</code></pre></div>

<p>You can't really state Barendregt's theorem with this version though, as <code>subst</code> has to be used in restricted ways, basically only the operations that are needed to define beta reduction and typing</p>



<a name="211864624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211864624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211864624">(Oct 01 2020 at 03:04)</a>:</h4>
<p>your definition of alpha equivalence is not correct, as it fails to prove <code>lam x (lam x (var x)) =ₐ lam x (lam y (var y))</code></p>



<a name="211864719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211864719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211864719">(Oct 01 2020 at 03:06)</a>:</h4>
<p>There is an elegant inductive definition using a context:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">alpha</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">{</span><span class="bp">Γ</span> <span class="n">M</span> <span class="n">M'</span> <span class="n">N</span> <span class="n">N'</span><span class="o">}</span> <span class="o">:</span> <span class="n">alpha</span> <span class="bp">Γ</span> <span class="n">M</span> <span class="n">M'</span> <span class="bp">→</span> <span class="n">alpha</span> <span class="bp">Γ</span> <span class="n">N</span> <span class="n">N'</span> <span class="bp">→</span> <span class="n">alpha</span> <span class="bp">Γ</span> <span class="o">(</span><span class="n">app</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">app</span> <span class="n">M'</span> <span class="n">N'</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">lam</span> <span class="o">{</span><span class="bp">Γ</span> <span class="n">x</span> <span class="n">x'</span> <span class="n">M</span> <span class="n">M'</span><span class="o">}</span> <span class="o">:</span> <span class="n">alpha</span> <span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">x'</span><span class="o">)</span> <span class="o">::</span> <span class="bp">Γ</span><span class="o">)</span> <span class="n">M</span> <span class="n">M'</span> <span class="bp">→</span> <span class="n">alpha</span> <span class="bp">Γ</span> <span class="o">(</span><span class="n">lam</span> <span class="n">x</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">lam</span> <span class="n">x'</span> <span class="n">M'</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">{</span><span class="bp">Γ</span> <span class="n">x</span> <span class="n">x'</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x'</span><span class="o">)</span> <span class="bp">∈</span> <span class="bp">Γ</span> <span class="bp">→</span> <span class="n">alpha</span> <span class="bp">Γ</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">var</span> <span class="n">x'</span><span class="o">)</span>
</code></pre></div>

<p>but unfortunately it also fails in the case of shadowed variables</p>



<a name="211864922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/211864922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#211864922">(Oct 01 2020 at 03:11)</a>:</h4>
<p>You can define it by closing the relation <code>lam x (M [x := y]) =ₐ lam y M</code> under the term formers and refl/symm/trans, but this requires a previous definition of substitution (you can get around the BV capture problem here by just not having the result be defined, since it's only one case in the inductive relation)</p>



<a name="212179362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/212179362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#212179362">(Oct 03 2020 at 16:35)</a>:</h4>
<p>On the subject of inductive relations <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, I've been considering creating generators for Lean's <code>expr</code> type and in that situation, generating type correct terms is useful but most terms that you'll generate will not by type correct. I'd like to formalize the Lean typing relation (or a subset thereof) so that we could use <code>slim_check</code> to test tactics in a useful way. Is this something you've thought about?</p>



<a name="212181682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/212181682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#212181682">(Oct 03 2020 at 17:36)</a>:</h4>
<p>can't you use <code>type_check</code> if you want to test the result of a tactic?</p>



<a name="212181750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/212181750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#212181750">(Oct 03 2020 at 17:38)</a>:</h4>
<p>reimplementing lean in lean would be a huge project and the result wouldn't be particularly fast</p>



<a name="212183216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Substitution%20lemma/near/212183216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Substitution.20lemma.html#212183216">(Oct 03 2020 at 18:11)</a>:</h4>
<p><code>type_check</code> would be the right thing to do if you want to use type correctness as a guard. What I want to do is a generator that creates type correct expression. I don't want to evaluate a decision procedure about type correctness. I want to use the relation guide the construction of examples</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
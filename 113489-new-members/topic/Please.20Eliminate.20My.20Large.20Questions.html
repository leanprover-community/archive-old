---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html">Please Eliminate My Large Questions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="196007956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196007956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ken Lee <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196007956">(May 01 2020 at 20:47)</a>:</h4>
<p>What is large elimination? What is subsingleton elimination? Why do we care about these? What do they have to do with proof irrelevance? What's so good about proof irrelevance anyway?</p>



<a name="196012582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196012582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196012582">(May 01 2020 at 21:33)</a>:</h4>
<p>Some inductive propsition have a recursor that can make elements of a Type e.g. <code>eq</code>, <code>true</code>, <code>false</code>, <code>and</code>, <code>acc</code>. Others can only make a Prop, e.g. <code>exists</code> and <code>or</code>. eliminating into Type is call large elemination. If large elimination was allowed on <code>or</code> then the iota reduction rule would be inconsistent because of proof irrelevance, your function could return different values for <code>or.inl x</code> and <code>or.inr y</code>, even though <code>or.inl x.= or.inr y</code>. The Props with large elimination don't have this problem.</p>



<a name="196012775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196012775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196012775">(May 01 2020 at 21:35)</a>:</h4>
<p>This is basically because they would be a subsingleton anyway, even if they were types. They only have one constructor, and all arguments are either props or are mentioned in the type of the output. There is a more precise rule for this somewhere.</p>



<a name="196012885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196012885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196012885">(May 01 2020 at 21:36)</a>:</h4>
<p>I think other people can answer what is so good about proof irrelevance better than me, but one example is that <code>subtype.ext</code> would not hold without it.</p>



<a name="196013729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196013729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196013729">(May 01 2020 at 21:44)</a>:</h4>
<p><a href="https://lean-forward.github.io/logical-verification/2018/41_notes.html" title="https://lean-forward.github.io/logical-verification/2018/41_notes.html">https://lean-forward.github.io/logical-verification/2018/41_notes.html</a> might be helpful</p>



<a name="196015004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196015004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ken Lee <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196015004">(May 01 2020 at 21:59)</a>:</h4>
<p>Thanks Chris. I will have a read</p>



<a name="196015631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196015631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196015631">(May 01 2020 at 22:06)</a>:</h4>
<p>Only the Prop type is proof irrelevant (all terms are definitionally equal) because it has to be in order to support classical reasoning - that was my understanding from the HoTT book. I asked a related question a little while ago, where I learned there are type theories that support continuation passing (e.g. exception handlers) model classical logic in a proof relevant way  (I think). As far as I know there are no proof assistants that utilize this approach for reasons unknown to me.</p>



<a name="196015836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196015836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196015836">(May 01 2020 at 22:09)</a>:</h4>
<p>Is this the thing about callcc with type <code>(((A -&gt; B) -&gt; A) -&gt; A</code> that has some computational interpretation. I never understood that.</p>



<a name="196016521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196016521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196016521">(May 01 2020 at 22:19)</a>:</h4>
<p>Yes. I don't understand it either. But it seems like an exciting approach since to me proof relevance and computational interpretation seem desirable. But I'm sure there's some drawback that makes it not practical or something</p>



<a name="196017228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196017228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196017228">(May 01 2020 at 22:29)</a>:</h4>
<p>I think it's an interesting observation that proof irrelevance and ignoring computation, the approach used in mathlib in general, has meant that the library has grown very quickly and seems to be well on the way to covering a pure mathematics degree</p>



<a name="196017788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196017788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196017788">(May 01 2020 at 22:38)</a>:</h4>
<p>Well I certainly wouldn't want to adopt a system that provides proof relevance at the expense of being able to do ordinary mathematics efficiently. But from my feeble understanding of the exception handling/continuation-passing style is that this wouldn't be the case. I don't see how on the surface any of what we do in Lean would be different and would slow anything down, it would just add proof relevance so that we could do interesting things with proof objects themselves.</p>



<a name="196018062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196018062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196018062">(May 01 2020 at 22:42)</a>:</h4>
<p>There are all these different interesting ways to write a proof of the same proposition that I as a human outside the system can appreciate, but the type theory itself cannot because all the proofs are equal. It would be neat if the type theory itself could represent all the proofs and therefore have functions from one proof to another etc. You could prove things about the space of proofs for a proposition or something.</p>



<a name="196018176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196018176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196018176">(May 01 2020 at 22:44)</a>:</h4>
<p>You not really forced to use proof irrelevance in Lean even though it's available, you can always use <code>Type</code> if you want.</p>



<a name="196018344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196018344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196018344">(May 01 2020 at 22:47)</a>:</h4>
<p>Yes but my understanding is you're restricted to constructive logic outside of Prop</p>



<a name="196018881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196018881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196018881">(May 01 2020 at 22:56)</a>:</h4>
<p>I think the continuation passing style would look something like this under-the-hood (mixing C++-style code with Lean)</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">dne</span> <span class="o">:</span> <span class="bp">¬¬</span><span class="n">p</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span><span class="o">,</span>
<span class="n">try</span> <span class="o">{</span>
   <span class="c1">-- derive contradiction, raising an exception</span>
<span class="o">}</span> <span class="n">catch</span> <span class="n">Exception</span> <span class="n">e</span> <span class="o">{</span>
    <span class="c1">-- something something</span>
    <span class="n">return</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span>
<span class="o">}</span>
</code></pre></div>



<a name="196020106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196020106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196020106">(May 01 2020 at 23:15)</a>:</h4>
<p>We already have a syntax for LEM, namely <code>if/then/else</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">dne</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">not</span> <span class="o">(</span><span class="n">not</span> <span class="n">p</span><span class="o">))</span> <span class="o">:</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="k">then</span> <span class="n">hp</span> <span class="k">else</span> <span class="n">false</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">h</span> <span class="n">hp</span><span class="o">)</span>
</code></pre></div>


<p>I think you are proposing a kind of "computational" semantics for <code>if/then/else</code> where <code>if hp : p then x[hp] else y[hp]</code> is implemented as "capture the current continuation and pass it to <code>y</code> as a claimed proof of <code>not p</code>; if <code>y</code> ever tries to invoke this proof then reset to the branch point and instead pass <code>x</code> the proof of <code>p</code> you got from <code>y</code>".</p>



<a name="196020172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196020172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196020172">(May 01 2020 at 23:16)</a>:</h4>
<p>As I understand it, this is somehow logically sound in that a valid proof using classical logic is transformed into a program which terminates (in some sense).</p>



<a name="196020244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196020244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196020244">(May 01 2020 at 23:17)</a>:</h4>
<p>Yes yes. Now do you know why this doesn't seem to be implemented in any proof assistant? Looks like continuation passing idea dates back to at least the early 90s</p>



<a name="196020248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196020248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196020248">(May 01 2020 at 23:17)</a>:</h4>
<p>However, another property you would probably like for your language is that <code>if hp : p then x[hp] else y[hp]</code> evaluates to <code>x[hp]</code> if <code>p</code> is true and <code>y[hp]</code> if <code>p</code> is false, and this property would be lost. For example if <code>y</code> does not actually use <code>hp</code> then the result will always be <code>y</code>.</p>



<a name="196020318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196020318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196020318">(May 01 2020 at 23:18)</a>:</h4>
<p>So, the semantics is logically sound (you will get out some value) but not sound in the sense of producing the <em>correct</em> value.</p>



<a name="196020330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196020330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196020330">(May 01 2020 at 23:18)</a>:</h4>
<p>So, for programming it's rather useless.</p>



<a name="196020486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196020486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196020486">(May 01 2020 at 23:20)</a>:</h4>
<p>In particular using LEM you can define a function <code>value : Prop -&gt; bool</code> with <code>value true = tt</code> and <code>value false = ff</code> according to the logic, but if you actually run <code>value p</code> you will always get the answer <code>ff</code> (or maybe <code>tt</code>, depending on how you defined it).</p>



<a name="196020827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196020827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196020827">(May 01 2020 at 23:25)</a>:</h4>
<p>I'm not sure I follow but that's my fault not yours. I thought all we care about when proving something is to create a valid term of a type, doesn't matter what term it is</p>



<a name="196020913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196020913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196020913">(May 01 2020 at 23:26)</a>:</h4>
<p>I agree that a function that always raises an exception and doesn't give you what you expect isn't a useful function, but exception handling as a construct is useful in that it allows you to do something else before the function returns. You might try calling the function again with a different value for example.</p>



<a name="196020914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196020914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196020914">(May 01 2020 at 23:26)</a>:</h4>
<p>Well that's what I care about, and that's why proof <em>ir</em>relevance is a natural and good property to look for in your system.</p>



<a name="196021065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196021065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196021065">(May 01 2020 at 23:29)</a>:</h4>
<p>Well there are two levels. On the one hand, in order to prove something under the propositions-as-types paradigm, I only need to construct a term of that type, any term. So in some sense, no matter what all terms are "equally good" since they prove the type. But in another sense, I might care that a particular term uses lemma1 versus another term that uses lemma2, and this could be an interesting area of study in its own right. That is only possible with proof relevance. So I don't see how proof relevance gets rid of anything good that is in a proof irrelevant system; you only get more options.</p>



<a name="196021127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196021127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196021127">(May 01 2020 at 23:30)</a>:</h4>
<p>No, it is possible for example by examining the proof metatheoretically.</p>



<a name="196021133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196021133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196021133">(May 01 2020 at 23:30)</a>:</h4>
<p>I don't think it has any internal meaning.</p>



<a name="196021171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196021171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196021171">(May 01 2020 at 23:31)</a>:</h4>
<p>We have this in Lean in the sense that the olean file will be different depending on which proof you wrote.</p>



<a name="196021264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196021264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196021264">(May 01 2020 at 23:32)</a>:</h4>
<p>To turn your argument around, being able to prove that <code>proof1 = proof2</code> for any two proofs of the same statement is something only possible with proof irrelevance, and it can only be good to have this additional option.</p>



<a name="196021462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196021462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196021462">(May 01 2020 at 23:35)</a>:</h4>
<p>If two terms are syntactically identical but with different names, you could prove proof1 = proof2 using reflexivity right?</p>



<a name="196021546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196021546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196021546">(May 01 2020 at 23:36)</a>:</h4>
<p>Sure, but the interesting case is when the proofs are not syntactically identical</p>



<a name="196021575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196021575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196021575">(May 01 2020 at 23:37)</a>:</h4>
<p>for a more recent version of the link that chris posted, see <a href="https://github.com/blanchette/logical_verification_2020/raw/master/hitchhikers_guide.pdf" title="https://github.com/blanchette/logical_verification_2020/raw/master/hitchhikers_guide.pdf">https://github.com/blanchette/logical_verification_2020/raw/master/hitchhikers_guide.pdf</a>.<br>
they talk about benefits of proof irrelevance in 11.2 and 11.4.</p>



<a name="196021784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196021784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196021784">(May 01 2020 at 23:41)</a>:</h4>
<p>I think the usual abuse of "proof" to mean inhabitant of a proposition causes some confusion here</p>



<a name="196021857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196021857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196021857">(May 01 2020 at 23:42)</a>:</h4>
<p>But in Lean right now, if I restrict myself to non-Prop types and therefore do not use classical axioms, then I can construct two (non-syntactically identical) terms for a theorem about some property of lists, for example. Then I could perhaps write a function that computes a distance between two terms and then I could have a sort of metric space of proof terms. Many other interesting things I could do with the proof terms.</p>



<a name="196021917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196021917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196021917">(May 01 2020 at 23:43)</a>:</h4>
<p>And with continuation-passing, I think this could be extended into proofs using classical logic</p>



<a name="196021982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196021982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196021982">(May 01 2020 at 23:44)</a>:</h4>
<p>You seem to be confusing a proof <strong>term</strong> (a syntactic thing) with its value internally</p>



<a name="196022017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196022017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196022017">(May 01 2020 at 23:45)</a>:</h4>
<p>If I give you <code>x y : forall (a b : nat), a + b = b + a</code>, there is no function you can define inside Lean that has any way to distinguish between <code>x</code> and <code>y</code></p>



<a name="196022090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196022090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196022090">(May 01 2020 at 23:47)</a>:</h4>
<p>In fact, in this case, I'm pretty sure that even if you do not use Prop at all, you can still prove that <code>x = y</code></p>



<a name="196022101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196022101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196022101">(May 01 2020 at 23:47)</a>:</h4>
<p>well, at least if you allow <code>funext</code></p>



<a name="196022272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196022272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196022272">(May 01 2020 at 23:50)</a>:</h4>
<p>You can distinguish proofs of <code>p -&gt; p or p</code> based on whether they produce <code>or.inl</code> or <code>or.inr</code>, but this is not at all the same kind of thing as "distance between two terms".</p>



<a name="196022625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196022625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196022625">(May 01 2020 at 23:56)</a>:</h4>
<p>Ah I see now. You could only do stuff like that metatheoretically as you said earlier. Like in homoiconic programming languages like Lisp or Julia you could take the syntactic term code and use it as data. Not sure if such languages could be made to correspond to a consistent logic.</p>



<a name="196022656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196022656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196022656">(May 01 2020 at 23:57)</a>:</h4>
<p>Here is a concrete advantage of (definitional) proof irrelevance. Suppose I need to prove</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">A</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="n">y</span><span class="o">)</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">+</span> <span class="mi">3</span><span class="bp">*</span><span class="n">x</span><span class="bp">^</span><span class="mi">2</span><span class="bp">*</span><span class="n">y</span> <span class="bp">+</span> <span class="mi">3</span><span class="bp">*</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">^</span><span class="mi">3</span> <span class="o">:=</span> <span class="bp">...</span>
<span class="c1">-- example shamelessly stolen from Kevin</span>
</code></pre></div>


<p>as part of a larger development. Proving this by hand would be a not very enjoyable exercise. Fortunately we have the <code>ring</code> tactic so I can just write <code>by ring</code> and move on. Later I use lemma <code>A</code> in order to prove some amazing theorem.</p>
<p>Now the next day somebody finds that the <code>ring</code> tactic has an annoying bug where sometimes you have to write <code>ring, ring</code>, and this gets fixed. As a side effect, maybe <code>ring</code> no longer produces the exact same proof term for lemma <code>A</code> as it did before. But that is fine, since I have a guarantee that changing the proof of <code>A</code> will not break the proof of my amazing theorem--that's provided by definitional proof irrelevance.</p>



<a name="196023025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196023025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196023025">(May 02 2020 at 00:04)</a>:</h4>
<p>But even if it changes the proof term I don't see how it should affect anything downstream. It just needs to type check right?</p>



<a name="196023308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196023308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196023308">(May 02 2020 at 00:10)</a>:</h4>
<p>In terms of using Lean for mathematics, we really only need the type checker right?. We don't actually need to compute with values. So technically the type of functions <code>ℕ → ℕ</code> is a theorem and I can "prove" it by constructing e.g. <code>theorem add2 (n : ℕ) : ℕ := n + 2</code> or <code>theorem mul2 (n : ℕ) : ℕ := 2 * n</code> and if I have some downstream theorem that depends on there being a proof of ℕ → ℕ then I could give it <code>add2</code> or <code>mul2</code> and it shouldn't care. Now if I want to use Lean to like crunch numbers for data analysis then I absolutely care whether I'm using <code>add2</code> or <code>mul2</code></p>



<a name="196023599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196023599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196023599">(May 02 2020 at 00:16)</a>:</h4>
<p>If you use the keyword <code>theorem</code> then you cannot use the function defined computationally, and we do not call these theorems nor their definitions proofs.</p>



<a name="196023614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196023614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196023614">(May 02 2020 at 00:17)</a>:</h4>
<p>Of course, Lean is not "definition-irrelevant"!</p>



<a name="196023634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196023634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196023634">(May 02 2020 at 00:18)</a>:</h4>
<p>But I can compute with the theorem. <code>#reduce mul2 5 -- 10</code></p>



<a name="196023664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196023664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196023664">(May 02 2020 at 00:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243102">Brandon Brown</span> <a href="#narrow/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions/near/196023025" title="#narrow/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions/near/196023025">said</a>:</p>
<blockquote>
<p>But even if it changes the proof term I don't see how it should affect anything downstream. It just needs to type check right?</p>
</blockquote>
<p>If changing a proof term does not affect anything downstream, it exactly means that you have proof irrelevance.</p>



<a name="196023697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196023697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196023697">(May 02 2020 at 00:19)</a>:</h4>
<p>Okay, but you can't use <code>#eval</code> or <code>lean --run</code> and this is clearly not the way the language is meant to be used.</p>



<a name="196023767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196023767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196023767">(May 02 2020 at 00:21)</a>:</h4>
<p>But I assume that's just an efficiency thing, no need to generate code for things that won't be used for computation. There's no fundamental reason <code>theorem</code> couldn't simply be an alias for <code>def</code>  , I guess except for the fact that non-constructive proofs won't be computable</p>



<a name="196023831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196023831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196023831">(May 02 2020 at 00:23)</a>:</h4>
<p>I'm increasingly lost here.</p>



<a name="196023889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196023889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196023889">(May 02 2020 at 00:24)</a>:</h4>
<p>Didn't you just suggest that you want to use <code>add2</code> or <code>mul2</code> for computation?</p>



<a name="196023907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196023907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196023907">(May 02 2020 at 00:24)</a>:</h4>
<p>I'm saying sometimes I care about computation sometimes I only care about type correctness</p>



<a name="196023915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196023915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196023915">(May 02 2020 at 00:24)</a>:</h4>
<p>If you don't want to distinguish between <code>theorem</code> and <code>def</code> then fine: we call something a "theorem" when its type is a Prop, and a "definition" otherwise.</p>



<a name="196023923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196023923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196023923">(May 02 2020 at 00:25)</a>:</h4>
<p>Great, so use Prop when you only care about proving and don't use it when you care about computation.</p>



<a name="196023929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196023929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196023929">(May 02 2020 at 00:25)</a>:</h4>
<p>By proof we mean some <code>p</code> where the type of <code>p</code> is a Prop.</p>



<a name="196023935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196023935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196023935">(May 02 2020 at 00:25)</a>:</h4>
<p>Then, proof irrelevance is what we want because we don't intend to compute with such <code>p</code> anyways.</p>



<a name="196024167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196024167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196024167">(May 02 2020 at 00:32)</a>:</h4>
<p>We don't use the word "proof" for things like <code>add2</code>. I think other sources (e.g., the HoTT book?) may use the term in a sense which includes things like <code>add2</code>.</p>



<a name="196024285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196024285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196024285">(May 02 2020 at 00:35)</a>:</h4>
<p>But that's just a convention</p>



<a name="196024353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196024353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196024353">(May 02 2020 at 00:37)</a>:</h4>
<p>Anyway, I think I need to sit on this for awhile before I can come back with anything more interesting. I can see that proof irrelevance (just using the type checker) is all we need for ordinary mathematics. Perhaps there is no benefit if all theorems had computable terms, but I still haven't ruled it out and it's something I want to think about more.</p>



<a name="196024354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196024354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196024354">(May 02 2020 at 00:37)</a>:</h4>
<p>Is callcc consistent with funext? It seems like the implementation could return different thing for extensionally equal functions as input.</p>



<a name="196024358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196024358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196024358">(May 02 2020 at 00:37)</a>:</h4>
<p>Of course, but it is the convention we are using in the context of the term "proof irrelevance"</p>



<a name="196024645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196024645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196024645">(May 02 2020 at 00:44)</a>:</h4>
<p>Well <code>((A -&gt; B) -&gt; A) -&gt; A</code> can be constructed using <code>choice</code>, right? The problem only begins when you want to start asserting equations about it</p>



<a name="196024860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196024860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196024860">(May 02 2020 at 00:49)</a>:</h4>
<p>Does this application of callcc terminate? The term of type <code>A</code> I returned used the function <code>A -&gt; B</code> that doesn't exist.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">axiom</span> <span class="n">callcc</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">p</span> <span class="o">:=</span>
<span class="n">callcc</span> <span class="bp">_</span> <span class="n">false</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="o">(</span><span class="n">h</span> <span class="err">∘</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span><span class="o">))</span>
</code></pre></div>



<a name="196024932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196024932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196024932">(May 02 2020 at 00:50)</a>:</h4>
<p>I might have misunderstood what it does.</p>



<a name="196025270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196025270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196025270">(May 02 2020 at 00:59)</a>:</h4>
<p>I think any function you can write using <code>callcc</code> will terminate, but certainly this one does. Moreover, if you compose it with <code>p ∨ ¬ p -&gt; bool</code> defined in the obvious way, it will produce <code>ff</code>.</p>



<a name="196025322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196025322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196025322">(May 02 2020 at 01:00)</a>:</h4>
<p>Operationally this is because the <code>p ∨ ¬ p -&gt; bool</code> function doesn't inspect the proof of <code>¬ p</code>, which is where the continuation is stored, so execution will follow the normal path</p>



<a name="196025651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196025651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196025651">(May 02 2020 at 01:10)</a>:</h4>
<p>If you happen to have a proof <code>H : p</code> and use it to eliminate the <code>¬ p</code> case, what will happen operationally is this: first the normal path will be taken, returning <code>or.inr (h ∘ or.inl)</code>,  where <code>h</code> is the saved continuation; then you pattern match on this, obtaining <code>h ∘ or.inl = \lam x, h (or.inl x) : p -&gt; false</code>, and apply this to <code>H</code>; the result is to apply <code>h</code> to <code>or.inl H</code>, which resets the computation to the point where <code>callcc</code> returns, this time giving you <code>or.inl H</code>.</p>



<a name="196025719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196025719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196025719">(May 02 2020 at 01:12)</a>:</h4>
<p>If you happen to have a proof <code>H : not (not p)</code> and use it to eliminate the <code>not p</code> case, then what happens depends on the definition of <code>H</code> and things might get complicated...</p>



<a name="196039027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/196039027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#196039027">(May 02 2020 at 07:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243102">Brandon Brown</span> <a href="#narrow/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions/near/196023907" title="#narrow/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions/near/196023907">said</a>:</p>
<blockquote>
<p>I'm saying sometimes I care about computation sometimes I only care about type correctness</p>
</blockquote>
<p>I think you underestimate the complexity of type checking with <em>dependent</em> types. Consider the following:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="mi">3</span>
<span class="n">def</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="mi">5</span>

<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">rfl</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">-- type checks</span>
<span class="c1">-- #check (rfl : b = 3) -- does not type check</span>
</code></pre></div>


<p>Here <code>a</code> and <code>b</code> have the same type, but they are not interchangeable.</p>
<p>Another example: suppose I've defined a function <code>exp : ℝ → ℝ</code>, and now I want to prove that <code>exp</code> is increasing. My proof of this will certainly rely on the definition of <code>exp</code>, not just its type! But I'm not really 'computing' with <code>exp</code>; I'm only doing proofs.</p>
<p>So you should always be careful with how you define "data" like <code>exp</code>, but by Proof Irrelevance there is no need to worry about how you prove theorems</p>



<a name="197008657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197008657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ken Lee <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197008657">(May 09 2020 at 19:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110044">Chris Hughes</span> <a href="#narrow/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions/near/196012582" title="#narrow/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions/near/196012582">said</a>:</p>
<blockquote>
<p>Some inductive propsition have a recursor that can make elements of a Type e.g. <code>eq</code>, <code>true</code>, <code>false</code>, <code>and</code>, <code>acc</code>. Others can only make a Prop, e.g. <code>exists</code> and <code>or</code>. eliminating into Type is call large elemination. If large elimination was allowed on <code>or</code> then the iota reduction rule would be inconsistent because of proof irrelevance, your function could return different values for <code>or.inl x</code> and <code>or.inr y</code>, even though <code>or.inl x.= or.inr y</code>. The Props with large elimination don't have this problem.</p>
</blockquote>
<p>I just understood your example with or. It makes sense now. Thanks!</p>



<a name="197016240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197016240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197016240">(May 09 2020 at 22:08)</a>:</h4>
<p>People who don't use a proof irrelevant prop night think there are two different proofs of (P and Q) implies (P or Q).</p>



<a name="197016820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197016820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197016820">(May 09 2020 at 22:20)</a>:</h4>
<p>I was going to object to the phrasing of this statement but I guess it's technically accurate. But the alternative to "using a proof irrelevant prop" is "not using prop", not "using a proof relevant prop" (which is an oxymoron).</p>



<a name="197016829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197016829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197016829">(May 09 2020 at 22:21)</a>:</h4>
<p>At least if proof relevance is taken up to propositional equality.</p>



<a name="197018121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197018121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197018121">(May 09 2020 at 22:41)</a>:</h4>
<p>One way to think about this that generalizes to higher dimensions is that Props secretly have extra "truncation constructors" that assert that any two values of the type are actually equal. When you eliminate out of a Prop you need to say where these truncation constructors go, and there is no way to do that. However, there are two cases where it's fine to omit them:</p>
<ul>
<li>when eliminating into another Prop, since then in the target it's also automatically true that any two values are equal;</li>
<li>when the singleton elimination rule applies (rouhgly, there's at most one constructor), since then you don't need to add the truncation constructors.</li>
</ul>



<a name="197018197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197018197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197018197">(May 09 2020 at 22:43)</a>:</h4>
<p>Can I eliminate or into a subsingleton?</p>



<a name="197018236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197018236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197018236">(May 09 2020 at 22:44)</a>:</h4>
<p>No</p>



<a name="197018254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197018254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197018254">(May 09 2020 at 22:45)</a>:</h4>
<p>It's true that definitional proof irrelevance makes this picture a bit murky, which is why you have to imagine the truncation constructors as "proofs of definitional equality" or something and they are not expressable in the language.</p>



<a name="197018311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197018311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197018311">(May 09 2020 at 22:46)</a>:</h4>
<p>The recursor you get in Lean for a Prop (whether large- or small-eliminating) is sort of the best approximation that you can actually write down.</p>



<a name="197018384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197018384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197018384">(May 09 2020 at 22:49)</a>:</h4>
<p>One thing I don't have a very good understanding of is the significance of definitional proof irrelevance versus propositional proof irrelevance. There are quite big differences between the two I think. Understanding this difference is I guess quite important to understanding the downsides of HoTT.</p>



<a name="197018613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197018613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197018613">(May 09 2020 at 22:55)</a>:</h4>
<p>It seems like a big deal to me, but somehow Coq users managed without it for a long time.</p>



<a name="197018696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197018696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197018696">(May 09 2020 at 22:57)</a>:</h4>
<p>Are things like the Odd order theorem done in a logic weaker than HoTT?</p>



<a name="197018703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197018703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197018703">(May 09 2020 at 22:58)</a>:</h4>
<p>I think so...</p>



<a name="197018766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197018766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197018766">(May 09 2020 at 22:59)</a>:</h4>
<p>well, as far as Prop is concerned anyways</p>



<a name="197018769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197018769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197018769">(May 09 2020 at 22:59)</a>:</h4>
<p>I imagine Coq in general has crazy stuff you cannot disable</p>



<a name="197018815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197018815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197018815">(May 09 2020 at 23:00)</a>:</h4>
<p>So it's weaker than Coq HoTT right?</p>



<a name="197018885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197018885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197018885">(May 09 2020 at 23:02)</a>:</h4>
<p>oh I understand the question now... I'm not sure.</p>



<a name="197018900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197018900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197018900">(May 09 2020 at 23:03)</a>:</h4>
<p>I think you are asking whether you can prove that identity types are subsingletons in Coq, right?</p>



<a name="197019060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197019060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197019060">(May 09 2020 at 23:06)</a>:</h4>
<p>It looks like it is an axiom but I don't know whether the Feit-Thompson proof used it. I guess probably. But it seems like the kind of axiom you can just push back onto your hypotheses (e.g., into the definition of "finite" group)</p>



<a name="197019076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197019076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197019076">(May 09 2020 at 23:07)</a>:</h4>
<p>oh, now I'm reading that it follows from decidable equality</p>



<a name="197019082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197019082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197019082">(May 09 2020 at 23:07)</a>:</h4>
<p>My memory of this was that there was a proof irrelevance axiom, but that's not as good as definitional proof irrelevance I don't think.</p>



<a name="197019088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197019088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197019088">(May 09 2020 at 23:07)</a>:</h4>
<p>Right, it's not as good, but the question is how much not as good and/or can you fix it with automation.</p>



<a name="197019470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197019470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197019470">(May 09 2020 at 23:16)</a>:</h4>
<p>Is this provable without proof irrelevance. <code>(Π (a b : α) (h₁ h₂ : a = b), subsingleton (h₁ = h₂)) → ∀ a b : α, subsingleton (a = b)</code> This is the key to proving identity types are subsinlgetons with proof irrelevance right? You need that two proofs of equality of equalities are equal?</p>



<a name="197020021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197020021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197020021">(May 09 2020 at 23:25)</a>:</h4>
<p>This is not true in HoTT. A 1-type need not be a 0-type.</p>



<a name="197020521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197020521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197020521">(May 09 2020 at 23:33)</a>:</h4>
<p>And this is because you can have topological spaces where the fundamental group at any point is trivial, but it is not path connected, like the disjoint union of path connected spaces?</p>



<a name="197020687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197020687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197020687">(May 09 2020 at 23:36)</a>:</h4>
<p>Well, it's one level up from that, I think...</p>



<a name="197020701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197020701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197020701">(May 09 2020 at 23:37)</a>:</h4>
<p>or maybe two levels?</p>



<a name="197020821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197020821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197020821">(May 09 2020 at 23:38)</a>:</h4>
<p>You said: Suppose whenever I have two points <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>, and two paths <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">h_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">h_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>, and two homotopies between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">h_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">h_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, they are equal.</p>



<a name="197020847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197020847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197020847">(May 09 2020 at 23:38)</a>:</h4>
<p>So I can't have a space like a 2-sphere, but a circle is fine.</p>



<a name="197020943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197020943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197020943">(May 09 2020 at 23:40)</a>:</h4>
<p>I think I should have said simply connected not path connected.</p>



<a name="197020955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197020955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197020955">(May 09 2020 at 23:41)</a>:</h4>
<p>A counterexample to your statement is going to be a something whose loop spaces are discrete but which is not discrete. Like a circle for example</p>



<a name="197021007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197021007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197021007">(May 09 2020 at 23:42)</a>:</h4>
<p>By "discrete" I mean like an ordinary set without any of this funny homotopy business.</p>



<a name="197021059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197021059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197021059">(May 09 2020 at 23:44)</a>:</h4>
<p>Oh yes. I see now. I had an out by one error.</p>



<a name="197040372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197040372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197040372">(May 10 2020 at 07:53)</a>:</h4>
<p>Can you prove <code>eq_of_heq</code> in Coq? This is something that really uses the definitional proof irrelevance right?</p>



<a name="197041519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Please%20Eliminate%20My%20Large%20Questions/near/197041519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions.html#197041519">(May 10 2020 at 08:23)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">universe</span> <span class="n">u</span>
<span class="kn">inductive</span> <span class="n">eq&#39;</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">rfl</span> <span class="o">:</span> <span class="n">eq&#39;</span> <span class="n">a</span>

<span class="kn">inductive</span> <span class="n">heq&#39;</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">},</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">rfl</span> <span class="o">:</span> <span class="n">heq&#39;</span> <span class="n">a</span>

<span class="kn">axiom</span> <span class="n">proof_irrel&#39;</span> <span class="o">{</span><span class="n">α</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="n">h₂</span> <span class="o">:</span> <span class="bp">@</span><span class="n">eq&#39;</span> <span class="n">α</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">eq&#39;</span> <span class="n">h₁</span> <span class="n">h₂</span>

<span class="n">noncomputable</span> <span class="kn">theorem</span> <span class="n">eq_of_heq&#39;</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">heq&#39;</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">eq&#39;</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="bp">@@</span><span class="n">heq&#39;</span><span class="bp">.</span><span class="n">rec_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">β</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">h&#39;</span> <span class="o">:</span> <span class="n">eq&#39;</span> <span class="n">α</span> <span class="n">β</span><span class="o">,</span> <span class="n">eq&#39;</span> <span class="o">(</span><span class="n">eq&#39;</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h&#39;</span> <span class="n">a</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="n">b</span><span class="o">)</span> <span class="n">h</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">eq&#39;</span> <span class="n">α</span> <span class="n">α</span><span class="o">),</span> <span class="n">eq&#39;</span><span class="bp">.</span><span class="n">rec_on</span> <span class="o">(</span><span class="n">proof_irrel&#39;</span> <span class="n">eq&#39;</span><span class="bp">.</span><span class="n">rfl</span> <span class="n">h₂</span><span class="o">)</span> <span class="n">eq&#39;</span><span class="bp">.</span><span class="n">rfl</span><span class="o">)</span> <span class="n">eq&#39;</span><span class="bp">.</span><span class="n">rfl</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
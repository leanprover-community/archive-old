---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/.22Does.20Theorem.20A.20depend.20on.20Theorem.20B.3F.22.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Does.20Theorem.20A.20depend.20on.20Theorem.20B.3F.22.html">"Does Theorem A depend on Theorem B?"</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="262230711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Does%20Theorem%20A%20depend%20on%20Theorem%20B%3F%22/near/262230711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Does.20Theorem.20A.20depend.20on.20Theorem.20B.3F.22.html#262230711">(Nov 21 2021 at 09:11)</a>:</h4>
<p>Is there something like <code>#print axioms</code> that can tell me whether the proof of some particular theorem depends on some other theorem, either directly or through some chain of dependencies?  For example, I just proved something that looked like it ought to depend on <code>nat.factors_unique</code> and wanted to confirm that it really was using that lemma.  To check this I had to do a series of searches in my file to trace out the chain of dependencies from <code>nat.factors_unique</code>.  That was a simple enough relay race in my case, but is there an automated way to do this?</p>



<a name="262232448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Does%20Theorem%20A%20depend%20on%20Theorem%20B%3F%22/near/262232448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Does.20Theorem.20A.20depend.20on.20Theorem.20B.3F.22.html#262232448">(Nov 21 2021 at 09:58)</a>:</h4>
<p><code>#print</code> will show you the term-mode proof, which includes the exact list of lemmas used (even the ones found by <code>simp</code> in the background)</p>



<a name="262233709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Does%20Theorem%20A%20depend%20on%20Theorem%20B%3F%22/near/262233709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Does.20Theorem.20A.20depend.20on.20Theorem.20B.3F.22.html#262233709">(Nov 21 2021 at 10:31)</a>:</h4>
<p>I don't know of anything out of the box, but it shouldn't be too difficult to make something like this (based on Mario's get axioms perhaps <a href="#narrow/stream/113489-new-members/topic/intuitionistic.20logic/near/224372208">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/intuitionistic.20logic/near/224372208</a>)</p>



<a name="262236797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Does%20Theorem%20A%20depend%20on%20Theorem%20B%3F%22/near/262236797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Does.20Theorem.20A.20depend.20on.20Theorem.20B.3F.22.html#262236797">(Nov 21 2021 at 11:53)</a>:</h4>
<p><code>#print</code> reveals the direct antecedents to the lemma but not their dependencies in turn.  I guess it should be possible to recursively apply something like this, building up the list of dependencies until either the target is found or some termination condition is reached.</p>



<a name="262236858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Does%20Theorem%20A%20depend%20on%20Theorem%20B%3F%22/near/262236858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Does.20Theorem.20A.20depend.20on.20Theorem.20B.3F.22.html#262236858">(Nov 21 2021 at 11:54)</a>:</h4>
<p>At some point I'll inevitably be drawn into learning how to write tactics, and then something like this might be a good project to work on.</p>



<a name="262236883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Does%20Theorem%20A%20depend%20on%20Theorem%20B%3F%22/near/262236883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Does.20Theorem.20A.20depend.20on.20Theorem.20B.3F.22.html#262236883">(Nov 21 2021 at 11:55)</a>:</h4>
<p>One dumb way to solve this is just replace the proof in question with <code>sorry</code> and see which other proofs start complaining</p>



<a name="262236930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Does%20Theorem%20A%20depend%20on%20Theorem%20B%3F%22/near/262236930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Does.20Theorem.20A.20depend.20on.20Theorem.20B.3F.22.html#262236930">(Nov 21 2021 at 11:56)</a>:</h4>
<p>You'll have to wait for compilation, but it answers the question with minimal actual work by you</p>



<a name="262237314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Does%20Theorem%20A%20depend%20on%20Theorem%20B%3F%22/near/262237314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Does.20Theorem.20A.20depend.20on.20Theorem.20B.3F.22.html#262237314">(Nov 21 2021 at 12:04)</a>:</h4>
<p>Or maybe even turn the theorem into an axiom and then you will find it in <code>#print axioms</code> if the other theorem depends on it</p>



<a name="262237659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Does%20Theorem%20A%20depend%20on%20Theorem%20B%3F%22/near/262237659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Does.20Theorem.20A.20depend.20on.20Theorem.20B.3F.22.html#262237659">(Nov 21 2021 at 12:12)</a>:</h4>
<p>I didn't test it so much yet so use with caution and if you find any errors please tell me and I'll fix it, but this is what I had in mind:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.prime</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.does_use_aux</span> <span class="o">(</span><span class="n">env</span> <span class="o">:</span> <span class="n">environment</span><span class="o">)</span> <span class="o">(</span><span class="n">tgt</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="n">name</span> <span class="bp">→</span>
  <span class="n">bool</span> <span class="bp">×</span> <span class="n">name_set</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">bool</span> <span class="bp">×</span> <span class="n">name_set</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">p</span><span class="bp">@</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">ns</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">ns.contains</span> <span class="n">n</span> <span class="k">then</span> <span class="n">pure</span> <span class="n">p</span> <span class="k">else</span> <span class="k">do</span>
  <span class="n">d</span> <span class="bp">←</span> <span class="n">env.get</span> <span class="n">n</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">ns</span> <span class="o">:=</span> <span class="n">ns.insert</span> <span class="n">n</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">process</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">bool</span> <span class="bp">×</span> <span class="n">name_set</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="k">do</span>
    <span class="n">v.fold</span> <span class="o">(</span><span class="n">pure</span> <span class="o">(</span><span class="n">b</span> <span class="bp">||</span> <span class="o">(</span><span class="n">d.to_name</span> <span class="bp">=</span> <span class="n">tgt</span><span class="o">),</span> <span class="n">ns</span><span class="o">))</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">e</span> <span class="n">_</span> <span class="n">r</span><span class="o">,</span> <span class="n">r</span> <span class="bp">&gt;&gt;=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span>
      <span class="k">if</span> <span class="n">e.is_constant</span> <span class="k">then</span> <span class="n">tactic.does_use_aux</span> <span class="n">e.const_name</span> <span class="n">p</span> <span class="k">else</span> <span class="n">pure</span> <span class="n">p</span><span class="o">),</span>
  <span class="k">match</span> <span class="n">d</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">declaration.defn</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">v</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">process</span> <span class="n">v</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">declaration.thm</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">v</span><span class="o">)</span>      <span class="o">:=</span> <span class="n">process</span> <span class="n">v.get</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">ns</span><span class="o">)</span>
  <span class="kd">end</span>

<span class="sd">/-- does `src` use `tgt`? -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.does_use</span> <span class="o">(</span><span class="n">src</span> <span class="n">tgt</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">bool</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">env</span> <span class="bp">←</span> <span class="n">tactic.get_env</span><span class="o">,</span>
  <span class="n">prod.fst</span> <span class="bp">&lt;$&gt;</span> <span class="n">tactic.does_use_aux</span> <span class="n">env</span> <span class="n">tgt</span> <span class="n">src</span> <span class="o">(</span><span class="n">ff</span><span class="o">,</span> <span class="n">mk_name_set</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">tactic.does_use</span> <span class="bp">`</span><span class="n">nat.prime.factors_pow</span> <span class="bp">``</span><span class="n">nat.factors_unique</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic.trace</span>
</code></pre></div>



<a name="262237698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Does%20Theorem%20A%20depend%20on%20Theorem%20B%3F%22/near/262237698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Does.20Theorem.20A.20depend.20on.20Theorem.20B.3F.22.html#262237698">(Nov 21 2021 at 12:12)</a>:</h4>
<p>Here's a variation on that axiom checking code to check if an arbitrary theorem depends on an arbitrary set of other theorems/definitions:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.get_dependents_aux</span> <span class="o">(</span><span class="n">env</span> <span class="o">:</span> <span class="n">environment</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">name</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">name</span> <span class="bp">→</span>
  <span class="n">list</span> <span class="n">name</span> <span class="bp">×</span> <span class="n">name_set</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">list</span> <span class="n">name</span> <span class="bp">×</span> <span class="n">name_set</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">p</span><span class="bp">@</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">ns</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">ns.contains</span> <span class="n">n</span> <span class="k">then</span> <span class="n">pure</span> <span class="n">p</span> <span class="k">else</span> <span class="k">do</span>
  <span class="n">d</span> <span class="bp">←</span> <span class="n">env.get</span> <span class="n">n</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">ns</span> <span class="o">:=</span> <span class="n">ns.insert</span> <span class="n">n</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">process</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">list</span> <span class="n">name</span> <span class="bp">×</span> <span class="n">name_set</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="k">do</span>
    <span class="n">v.fold</span> <span class="o">(</span><span class="n">pure</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">ns</span><span class="o">))</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">e</span> <span class="n">_</span> <span class="n">r</span><span class="o">,</span> <span class="n">r</span> <span class="bp">&gt;&gt;=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span>
      <span class="k">if</span> <span class="n">e.is_constant</span> <span class="k">then</span> <span class="n">tactic.get_dependents_aux</span> <span class="n">e.const_name</span> <span class="n">p</span> <span class="k">else</span> <span class="n">pure</span> <span class="n">p</span><span class="o">),</span>
  <span class="k">if</span> <span class="n">f</span> <span class="n">n</span> <span class="k">then</span> <span class="n">pure</span> <span class="o">(</span><span class="n">n</span><span class="o">::</span><span class="n">l</span><span class="o">,</span> <span class="n">ns</span><span class="o">)</span> <span class="k">else</span>
  <span class="k">match</span> <span class="n">d</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">declaration.defn</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">v</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">process</span> <span class="n">v</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">declaration.thm</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">v</span><span class="o">)</span>      <span class="o">:=</span> <span class="n">process</span> <span class="n">v.get</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">ns</span><span class="o">)</span>
  <span class="kd">end</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.get_dependents</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">environment</span> <span class="bp">→</span> <span class="n">name</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">list</span> <span class="n">name</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">env</span> <span class="bp">←</span> <span class="n">tactic.get_env</span><span class="o">,</span>
  <span class="n">prod.fst</span> <span class="bp">&lt;$&gt;</span> <span class="n">tactic.get_dependents_aux</span> <span class="n">env</span> <span class="o">(</span><span class="n">f</span> <span class="n">env</span><span class="o">)</span> <span class="n">n</span> <span class="o">([],</span> <span class="n">mk_name_set</span><span class="o">)</span>

<span class="k">#eval</span> <span class="k">do</span>
  <span class="n">tactic.get_dependents</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="bp">`</span><span class="n">classical.some</span><span class="o">)</span> <span class="bp">`</span><span class="n">classical.em</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic.trace</span>
  <span class="c1">-- [classical.some]</span>
</code></pre></div>
<p>The lambda is a predicate yielding possible sources (i.e. "theorem A") and the second argument is the sink ("theorem B"), and it returns the set of elements satisfying the predicate among the dependencies, so if it's empty then it doesn't depend on the value.</p>



<a name="262237709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Does%20Theorem%20A%20depend%20on%20Theorem%20B%3F%22/near/262237709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Does.20Theorem.20A.20depend.20on.20Theorem.20B.3F.22.html#262237709">(Nov 21 2021 at 12:13)</a>:</h4>
<p>LOL nice Mario <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="262237995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Does%20Theorem%20A%20depend%20on%20Theorem%20B%3F%22/near/262237995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Does.20Theorem.20A.20depend.20on.20Theorem.20B.3F.22.html#262237995">(Nov 21 2021 at 12:20)</a>:</h4>
<p>Wow, thanks!</p>



<a name="262238284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Does%20Theorem%20A%20depend%20on%20Theorem%20B%3F%22/near/262238284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Does.20Theorem.20A.20depend.20on.20Theorem.20B.3F.22.html#262238284">(Nov 21 2021 at 12:27)</a>:</h4>
<p>Actually, here's a more useful version:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.get_dependents_aux</span> <span class="o">(</span><span class="n">env</span> <span class="o">:</span> <span class="n">environment</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">name</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">name</span> <span class="bp">→</span>
  <span class="n">bool</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">name</span> <span class="bp">×</span> <span class="n">name_map</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">bool</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">name</span> <span class="bp">×</span> <span class="n">name_map</span> <span class="n">bool</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">(</span><span class="n">b₁</span><span class="o">,</span> <span class="n">p</span><span class="bp">@</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">ns</span><span class="o">))</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">ns.find</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">b₁</span> <span class="bp">||</span> <span class="n">b</span><span class="o">,</span> <span class="n">p</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">d</span> <span class="bp">←</span> <span class="n">env.get</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">process</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">bool</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">name</span> <span class="bp">×</span> <span class="n">name_map</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="k">do</span>
      <span class="n">v.fold</span> <span class="o">(</span><span class="n">pure</span> <span class="o">(</span><span class="n">ff</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">ns</span><span class="o">))</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">e</span> <span class="n">_</span> <span class="n">r</span><span class="o">,</span> <span class="n">r</span> <span class="bp">&gt;&gt;=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span>
        <span class="k">if</span> <span class="n">e.is_constant</span> <span class="k">then</span> <span class="n">tactic.get_dependents_aux</span> <span class="n">e.const_name</span> <span class="n">p</span> <span class="k">else</span> <span class="n">pure</span> <span class="n">p</span><span class="o">),</span>
    <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">ns</span><span class="o">)</span> <span class="bp">←</span> <span class="k">if</span> <span class="n">f</span> <span class="n">n</span> <span class="k">then</span> <span class="n">pure</span> <span class="o">(</span><span class="n">tt</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">ns</span><span class="o">)</span> <span class="k">else</span>
      <span class="k">match</span> <span class="n">d</span> <span class="k">with</span>
      <span class="bp">|</span> <span class="o">(</span><span class="n">declaration.defn</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">v</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">process</span> <span class="n">v</span>
      <span class="bp">|</span> <span class="o">(</span><span class="n">declaration.thm</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">v</span><span class="o">)</span>      <span class="o">:=</span> <span class="n">process</span> <span class="n">v.get</span>
      <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">ff</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">ns</span><span class="o">)</span>
      <span class="kd">end</span><span class="o">,</span>
    <span class="n">pure</span> <span class="o">(</span><span class="n">b₁</span> <span class="bp">||</span> <span class="n">b</span><span class="o">,</span> <span class="k">if</span> <span class="n">b</span> <span class="k">then</span> <span class="n">n</span><span class="o">::</span><span class="n">l</span> <span class="k">else</span> <span class="n">l</span><span class="o">,</span> <span class="n">ns.insert</span> <span class="n">n</span> <span class="n">b</span><span class="o">)</span>
  <span class="kd">end</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.get_dependents</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">environment</span> <span class="bp">→</span> <span class="n">name</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">list</span> <span class="n">name</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">env</span> <span class="bp">←</span> <span class="n">tactic.get_env</span><span class="o">,</span>
  <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">ns</span><span class="o">)</span> <span class="bp">←</span> <span class="n">tactic.get_dependents_aux</span> <span class="n">env</span> <span class="o">(</span><span class="n">f</span> <span class="n">env</span><span class="o">)</span> <span class="n">n</span> <span class="o">(</span><span class="n">ff</span><span class="o">,</span> <span class="o">[],</span> <span class="n">mk_name_map</span><span class="o">),</span>
  <span class="n">pure</span> <span class="n">l</span>

<span class="k">#eval</span> <span class="k">do</span>
  <span class="n">tactic.get_dependents</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="bp">`</span><span class="n">classical.some</span><span class="o">)</span> <span class="bp">``</span><span class="n">classical.by_contradiction</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic.trace</span>
  <span class="c1">-- [classical.by_contradiction,</span>
  <span class="c1">--  classical.prop_decidable,</span>
  <span class="c1">--  classical.prop_decidable._proof_1,</span>
  <span class="c1">--  classical.em,</span>
  <span class="c1">--  _private.3251178891.p_implies_uv,</span>
  <span class="c1">--  _private.3239198671.not_uv_or_p,</span>
  <span class="c1">--  _private.3639808893.v,</span>
  <span class="c1">--  _private.2514476823.u,</span>
  <span class="c1">--  classical.some]</span>
</code></pre></div>
<p>The input is the same, a target theorem and a source predicate, but now it returns the list of all theorems in the dependency lattice between the source and target, which should give you a sense of what the critical path is.</p>



<a name="262238655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Does%20Theorem%20A%20depend%20on%20Theorem%20B%3F%22/near/262238655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Does.20Theorem.20A.20depend.20on.20Theorem.20B.3F.22.html#262238655">(Nov 21 2021 at 12:34)</a>:</h4>
<p>That's fantastic, thank you!</p>



<a name="262238734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Does%20Theorem%20A%20depend%20on%20Theorem%20B%3F%22/near/262238734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Does.20Theorem.20A.20depend.20on.20Theorem.20B.3F.22.html#262238734">(Nov 21 2021 at 12:36)</a>:</h4>
<p>And indeed running </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="k">do</span>
  <span class="n">tactic.get_dependents</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="bp">`</span><span class="n">nat.factors_unique</span><span class="o">)</span>
     <span class="bp">``</span><span class="n">prime_factorization_unique_of_pos</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic.trace</span>
</code></pre></div>
<p>confirms that <code>prime_factorization_unique_of_pos</code> depends on <code>nat.factors_unique</code>, as expected:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">([</span><span class="n">nat.factors_unique</span><span class="o">],</span>
 <span class="o">[</span><span class="n">nat.prime_factorization_injective_on_pos</span><span class="o">,</span>
  <span class="n">nat.factors_unique</span><span class="o">,</span>
  <span class="n">nat.prime_factorization_unique_of_pos</span><span class="o">,</span>
  <span class="n">nat.perm_factors_mul_of_coprime</span><span class="o">,</span>
  <span class="n">nat.factor_count_eq_of_coprime_left</span><span class="o">,</span>
  <span class="n">nat.perm_factors_mul_of_pos</span><span class="o">,</span>
  <span class="n">nat.prime.factors_pow</span><span class="o">,</span>
  <span class="n">nat.multiplicative_factorization</span><span class="o">,</span>
  <span class="n">nat.prime_factorization_prod_eq</span><span class="o">,</span>
  <span class="n">nat.prime_factorization_union_of_coprime</span><span class="o">,</span>
  <span class="n">nat.prime_factorization_prime_pos_pow</span><span class="o">,</span>
  <span class="n">nat.factor_count_eq_of_coprime_right</span><span class="o">])</span>
</code></pre></div>



<a name="262239003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Does%20Theorem%20A%20depend%20on%20Theorem%20B%3F%22/near/262239003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Does.20Theorem.20A.20depend.20on.20Theorem.20B.3F.22.html#262239003">(Nov 21 2021 at 12:44)</a>:</h4>
<p>(updated the code above to use the <code>list name</code> the way it was intended. Now the list is in DFS dependency order instead of random order)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/subtype.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtype.html">subtype</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="246325968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtype/near/246325968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtype.html#246325968">(Jul 17 2021 at 13:57)</a>:</h4>
<p>Is it possible to prove that two subtypes are equal?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.card</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">q</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">subtype</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">subtype</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="gr">sorry</span><span class="o">}</span>
</code></pre></div>



<a name="246326133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtype/near/246326133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtype.html#246326133">(Jul 17 2021 at 14:01)</a>:</h4>
<p>Yes, first show <code>p = q</code></p>



<a name="246326189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtype/near/246326189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtype.html#246326189">(Jul 17 2021 at 14:02)</a>:</h4>
<p>Which you should be able to do by combining <a href="https://leanprover-community.github.io/mathlib_docs/find/propext">docs#propext</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/funext">docs#funext</a></p>



<a name="277493886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtype/near/277493886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Victor Porton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtype.html#277493886">(Apr 02 2022 at 00:25)</a>:</h4>
<p>Is there a notion of subtype (like subset)?</p>



<a name="277494400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtype/near/277494400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtype.html#277494400">(Apr 02 2022 at 00:36)</a>:</h4>
<p>If you scroll up this thread you'll see that there's indeed a <code>subtype</code>. It's defined in core as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"> Remark: subtype must take a Sort instead of Type because of the axiom strong_indefinite_description. -/</span>
<span class="kd">structure</span> <span class="n">subtype</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">property</span> <span class="o">:</span> <span class="n">p</span> <span class="n">val</span><span class="o">)</span>
</code></pre></div>
<p>But I'm not sure this is what you mean by "subtype"</p>



<a name="277494433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtype/near/277494433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtype.html#277494433">(Apr 02 2022 at 00:37)</a>:</h4>
<p>(<a href="https://leanprover-community.github.io/mathlib_docs/find/subtype">docs#subtype</a>)</p>



<a name="277494449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtype/near/277494449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Victor Porton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtype.html#277494449">(Apr 02 2022 at 00:37)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> I mean subtype relation like subset relation.</p>



<a name="277494513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtype/near/277494513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Victor Porton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtype.html#277494513">(Apr 02 2022 at 00:38)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> Not this.</p>



<a name="277494521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtype/near/277494521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtype.html#277494521">(Apr 02 2022 at 00:38)</a>:</h4>
<p>Can you elaborate on what you mean?</p>



<a name="277494533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtype/near/277494533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtype.html#277494533">(Apr 02 2022 at 00:38)</a>:</h4>
<p>The answer is "no" in the way you'd probably want -- every term has a type and only one type, and if you had subset-like subtypes you'd have to allow terms with more than one type.</p>
<p>Instead, what we have is that for every <code>set</code> (equivalently, every predicate on a type), there exists a type whose terms are, in some sense, in one-to-one correspondence with the elements of the set. There's an injective function from that type to the original type whose image consists of the elements of that <code>set</code>. One possible implementation of this type is <code>subtype</code>.</p>



<a name="277494551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtype/near/277494551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtype.html#277494551">(Apr 02 2022 at 00:39)</a>:</h4>
<p>If you like to hear things like "subobject classifiers" I once <a href="#narrow/stream/113489-new-members/topic/.E2.9C.94.20Difference.20between.20set.20and.20subtype/near/269546712">posted a diagram</a>.</p>



<a name="277494657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtype/near/277494657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtype.html#277494657">(Apr 02 2022 at 00:40)</a>:</h4>
<p>In Lean/mathlib we use coercions to make it seem like <code>subtype</code> is a "subtype" in the sense you want, but you have to get used to it.</p>



<a name="277494683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtype/near/277494683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtype.html#277494683">(Apr 02 2022 at 00:41)</a>:</h4>
<p>For example, when I write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">x</span>
</code></pre></div>
<p>Lean is automatically inserting coercions so that it's actually</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">subtype</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">x.val</span>
</code></pre></div>



<a name="277494766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/subtype/near/277494766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/subtype.html#277494766">(Apr 02 2022 at 00:43)</a>:</h4>
<p>If you're wanting to consider more than one "subtype" of a type and relate them in different ways, it's usually less of a pain to work with sets, which, just to be clear, are just predicates on a type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
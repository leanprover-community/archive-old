---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html">Resolve coercion in hypothesis</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="218942377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942377">(Dec 05 2020 at 16:37)</a>:</h4>
<p>I have <code>h: ↥p</code>. How do I rewrite it to <code>h: p = tt</code>? Neither <code>rw coe</code> nor <code>simp</code> worked.</p>



<a name="218942445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942445">(Dec 05 2020 at 16:38)</a>:</h4>
<p><code>p</code> is a bool, presumably? You could do cases on it I guess, but there is probably a one-liner.</p>



<a name="218942470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942470">(Dec 05 2020 at 16:39)</a>:</h4>
<p>yes, p is a bool ;) Would love to have a one-liner at hand to deal with coercions!</p>



<a name="218942527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942527">(Dec 05 2020 at 16:40)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">p</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">hp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218942615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942615">(Dec 05 2020 at 16:42)</a>:</h4>
<p>Why is <code>cases hp</code> closing the goal?</p>



<a name="218942636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942636">(Dec 05 2020 at 16:43)</a>:</h4>
<p>Ah, because it is an empty inductive type</p>



<a name="218942637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942637">(Dec 05 2020 at 16:43)</a>:</h4>
<p>because there are no cases, so there are no goals after it's done :-)</p>



<a name="218942649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942649">(Dec 05 2020 at 16:43)</a>:</h4>
<p>but how does it resolve the coercion?</p>



<a name="218942699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942699">(Dec 05 2020 at 16:44)</a>:</h4>
<p><del>If <code>p</code> is a random bool then Lean doesn't know what <code>↥p</code> is, but if <code>p</code> is <code>tt</code> or <code>ff</code> then it knows.</del></p>



<a name="218942720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942720">(Dec 05 2020 at 16:45)</a>:</h4>
<p>no I just checked the definition and what I just said is false.</p>



<a name="218942769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942769">(Dec 05 2020 at 16:46)</a>:</h4>
<p>I had assumed the coercion would be defined by cases, but <code>↥p := p = tt</code></p>



<a name="218942779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942779">(Dec 05 2020 at 16:46)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">exact</span> <span class="n">hp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218942782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942782">(Dec 05 2020 at 16:46)</a>:</h4>
<p>hmm, I guess exact is doing some kind of reduction then?</p>



<a name="218942786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942786">(Dec 05 2020 at 16:47)</a>:</h4>
<p>They are definitionally equal. You can use <code>change</code> to change one to the other. Sorry for misleading you!</p>



<a name="218942796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942796">(Dec 05 2020 at 16:47)</a>:</h4>
<p><code>example (p : bool) (hp : p) : p = tt := hp</code></p>



<a name="218942838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942838">(Dec 05 2020 at 16:48)</a>:</h4>
<p>no problem, thank you very much for helping me  reducing my confusion ;)</p>



<a name="218942846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942846">(Dec 05 2020 at 16:48)</a>:</h4>
<p>does definitionionally equal mean they are equal after rewriting definitions?</p>



<a name="218942861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942861">(Dec 05 2020 at 16:49)</a>:</h4>
<p>why does this unfolding of definitions happen automatically, while I have to unfold all my definitions manually or with simp?</p>



<a name="218942865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942865">(Dec 05 2020 at 16:49)</a>:</h4>
<p>In term mode Lean can see through all definitions.</p>



<a name="218942870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942870">(Dec 05 2020 at 16:49)</a>:</h4>
<p>You need to talk to someone who knows something about computers really.</p>



<a name="218942917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942917">(Dec 05 2020 at 16:50)</a>:</h4>
<p><a href="https://leanprover.github.io/reference/expressions.html#computation">https://leanprover.github.io/reference/expressions.html#computation</a> is something I found useful</p>



<a name="218942920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942920">(Dec 05 2020 at 16:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis/near/218942870">said</a>:</p>
<blockquote>
<p>You need to talk to someone who knows something about computers really.</p>
</blockquote>
<p>i remember that you wrote a pretty good blog post on the matter yourself</p>



<a name="218942934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942934">(Dec 05 2020 at 16:50)</a>:</h4>
<p>but you might know it already. You might want to hear something about <code>#reduce</code> but this is something I never use or think about.</p>



<a name="218942949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942949">(Dec 05 2020 at 16:51)</a>:</h4>
<p>Lean won't unfold a definition automatically, but if I say <code>x = y</code> and the proof is <code>rfl</code>, then at that point Lean will start to try and prove x and y are definitionally equal and it will happily unfold anything.</p>



<a name="218942953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942953">(Dec 05 2020 at 16:51)</a>:</h4>
<p><a href="https://xenaproject.wordpress.com/2019/05/21/equality-part-1-definitional-equality/">https://xenaproject.wordpress.com/2019/05/21/equality-part-1-definitional-equality/</a><br>
<a href="https://xenaproject.wordpress.com/2019/05/25/equality-part-2-syntactic-equality/">https://xenaproject.wordpress.com/2019/05/25/equality-part-2-syntactic-equality/</a></p>



<a name="218942996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218942996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218942996">(Dec 05 2020 at 16:52)</a>:</h4>
<p>In fact you can hang Lean by giving it two complicated terms which aren't equal and then telling it to try and prove them by <code>rfl</code>. The <code>exact</code> tactic will presumably just be a wrapper around <code>rfl</code>.</p>



<a name="218943022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218943022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218943022">(Dec 05 2020 at 16:53)</a>:</h4>
<p>ah so <code>rfl</code> is the tactic I can use to show that two syntactically different terms are definitionally equivalent?</p>



<a name="218943026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218943026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218943026">(Dec 05 2020 at 16:53)</a>:</h4>
<p><code>rfl</code> is the term, <code>refl</code> is the tactic.</p>



<a name="218943070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218943070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218943070">(Dec 05 2020 at 16:54)</a>:</h4>
<p>thanks a lot!</p>



<a name="218943088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218943088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218943088">(Dec 05 2020 at 16:55)</a>:</h4>
<p>(strictly speaking <code>refl</code> is a bit stronger, it will attempt to prove any goal of the form <code>R a b</code> where <code>R</code> is a reflexive predicate which has been tagged with the <code>@[refl]</code> attribute by invoking reflexivity of <code>R</code> and then trying to prove <code>a = b</code>; for example you can prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2 \le 2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> with <code>refl</code> in tactic mode but not with <code>rfl</code> in term mode, which is strictly for equality)</p>



<a name="218943135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218943135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218943135">(Dec 05 2020 at 16:56)</a>:</h4>
<p><code>example : 2 + 2 = 4 := rfl</code> (because both reduce to <code>S(S(S(S(0))))</code></p>



<a name="218943214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218943214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218943214">(Dec 05 2020 at 16:58)</a>:</h4>
<p>if you care about implementation details, <code>rfl</code> is just <code>eq.refl</code> (<a href="https://github.com/leanprover-community/lean/blob/master/library/init/core.lean#L231">https://github.com/leanprover-community/lean/blob/master/library/init/core.lean#L231</a>), where <code>eq.refl</code> is described in TPIL (<a href="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductive-families">https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductive-families</a>), and definitional equality is built into the kernel</p>



<a name="218943216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218943216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218943216">(Dec 05 2020 at 16:58)</a>:</h4>
<p><code>example (p : bool) : p = tt = ↥p := rfl</code></p>



<a name="218943237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218943237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218943237">(Dec 05 2020 at 16:59)</a>:</h4>
<p>and the contradiction is that definitional equality is undecidable but <code>rfl</code> is a computer program :-) There's an example in the reference manual where two things are definitionally equal but <code>rfl</code> doesn't prove it, but this is very much an edge case.</p>



<a name="218943505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218943505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218943505">(Dec 05 2020 at 17:05)</a>:</h4>
<p>But why is <code>refl</code> able to solve this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">p</span><span class="o">:</span> <span class="n">bool</span><span class="o">):</span> <span class="n">tt</span> <span class="bp">&amp;&amp;</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>?</p>



<a name="218943551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218943551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218943551">(Dec 05 2020 at 17:06)</a>:</h4>
<p>Here's how I'd diagnose this.</p>



<a name="218943579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218943579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218943579">(Dec 05 2020 at 17:07)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="kd">notation</span> <span class="bp">&amp;&amp;</span> <span class="c1">-- it's notation for `band`</span>

<span class="k">#check</span> <span class="n">band</span> <span class="c1">-- and now right click and peek definition</span>
</code></pre></div>



<a name="218943616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218943616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218943616">(Dec 05 2020 at 17:08)</a>:</h4>
<p>I find</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">band</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">tt</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">ff</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">ff</span>
</code></pre></div>



<a name="218943629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218943629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218943629">(Dec 05 2020 at 17:08)</a>:</h4>
<p>so <code>tt &amp;&amp; p</code> is by definition <code>p</code>.</p>



<a name="218943638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218943638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218943638">(Dec 05 2020 at 17:08)</a>:</h4>
<p>So I guess there is some kind of reduction β and  refl solves <code>R a b</code> by checking whether β a is syntactically equal to β b? Can I somehow invoke this reduction β manually to make terms simpler in hypothesis/goals?</p>



<a name="218943653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218943653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218943653">(Dec 05 2020 at 17:09)</a>:</h4>
<p>yeah you need to talk to a computers person. I have no idea how all this works.</p>



<a name="218943701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218943701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218943701">(Dec 05 2020 at 17:10)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#dsimp">https://leanprover-community.github.io/mathlib_docs/tactics.html#dsimp</a></p>



<a name="218943714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218943714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218943714">(Dec 05 2020 at 17:10)</a>:</h4>
<p>If I want to unfold things I just <code>unfold</code> them. As a mathematician I believe that definitional equality is a weird implementation issue which I should not be using; I don't like the fact that <code>n + 0 = n</code> is definitional and <code>0 + n = n</code> is not because this upsets my view of the universe as a beautiful symmetric thing. In short, I try not to think about definitional equality. But for what you're doing it's probably super-important!</p>



<a name="218944098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218944098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218944098">(Dec 05 2020 at 17:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="234196">Henning Dieterichs</span> <a href="#narrow/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis/near/218943638">said</a>:</p>
<blockquote>
<p>So I guess there is some kind of reduction β and  refl solves <code>R a b</code> by checking whether β a is syntactically equal to β b? Can I somehow invoke this reduction β manually to make terms simpler in hypothesis/goals?</p>
</blockquote>
<p>The tactic for this is called <code>whnf</code></p>



<a name="218944105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218944105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218944105">(Dec 05 2020 at 17:21)</a>:</h4>
<p>but it's not great for interactive use</p>



<a name="218944106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218944106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218944106">(Dec 05 2020 at 17:21)</a>:</h4>
<p>prefer <code>simp</code></p>



<a name="218944165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218944165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218944165">(Dec 05 2020 at 17:22)</a>:</h4>
<p>But still, this does not work to get rid of the coercion operator:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="n">hp</span><span class="o">,</span>
    <span class="n">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218944182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218944182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218944182">(Dec 05 2020 at 17:23)</a>:</h4>
<p>I don't want to prove that two terms are equal, I want to obtain p = tt, so I can rewrite that term at a different hypothesis</p>



<a name="218944261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218944261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218944261">(Dec 05 2020 at 17:25)</a>:</h4>
<p>there should be a theorem that says that</p>



<a name="218945424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218945424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218945424">(Dec 05 2020 at 17:55)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold_coes</span> <span class="n">at</span> <span class="n">hp</span><span class="o">,</span>
  <span class="n">assumption</span>
<span class="kd">end</span>
</code></pre></div>
<p>works but goes a little against the way things are supposed to work.</p>



<a name="218945472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218945472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218945472">(Dec 05 2020 at 17:56)</a>:</h4>
<p>(and of course the <code>assumption</code> tactic works without <code>unfold_coes</code> anyway, because it also relies on <code>rfl</code> ;-) )</p>



<a name="218948987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218948987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Calle Sönne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218948987">(Dec 05 2020 at 19:21)</a>:</h4>
<p>I think I have a very similar problem to this one. I also need to "unfold" a coercion, but in my specific situation I am unsure how to enter tactic mode to be able to try the above suggestions. Here is my code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">limit_cone</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="bp">⥤</span> <span class="n">Profinite</span><span class="o">)</span> <span class="o">:</span> <span class="n">cone</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">to_Top</span> <span class="o">:=</span> <span class="o">{</span>
          <span class="n">α</span> <span class="o">:=</span> <span class="o">(</span><span class="n">F</span> <span class="bp">⋙</span> <span class="n">Profinite_to_Top</span> <span class="bp">⋙</span> <span class="n">forget</span> <span class="n">Top</span><span class="o">)</span><span class="bp">.</span><span class="n">sections</span><span class="o">,</span>
          <span class="n">str</span> <span class="o">:=</span> <span class="n">topological_space.induced</span>
                  <span class="o">(</span><span class="bp">@</span><span class="n">set.inclusion</span> <span class="n">_</span> <span class="o">(</span><span class="n">F</span> <span class="bp">⋙</span> <span class="n">Profinite_to_Top</span> <span class="bp">⋙</span> <span class="o">(</span><span class="n">forget</span> <span class="n">Top</span><span class="o">))</span><span class="bp">.</span><span class="n">sections</span> <span class="n">set.univ</span> <span class="o">(</span><span class="n">set.subset_univ</span> <span class="n">_</span><span class="o">))</span>
                  <span class="o">(</span><span class="bp">@</span><span class="k">Pi</span><span class="bp">.</span><span class="n">topological_space</span> <span class="n">J</span> <span class="o">((</span><span class="n">F</span> <span class="bp">⋙</span> <span class="n">Profinite_to_Top</span> <span class="bp">⋙</span> <span class="o">(</span><span class="n">forget</span> <span class="n">Top</span><span class="o">))</span><span class="bp">.</span><span class="n">obj</span><span class="o">)</span>
                  <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="o">((</span><span class="n">F</span> <span class="bp">⋙</span> <span class="n">Profinite_to_Top</span><span class="o">)</span><span class="bp">.</span><span class="n">obj</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">str</span><span class="o">))</span>
          <span class="o">},</span>
        <span class="n">is_compact</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
        <span class="n">is_t2</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
        <span class="n">is_totally_disconnected</span> <span class="o">:=</span> <span class="n">_</span> <span class="o">},</span>
  <span class="n">π</span> <span class="o">:=</span> <span class="n">_</span> <span class="o">}</span>
</code></pre></div>
<p>And I get the following error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">topological_space.induced</span> <span class="o">(</span><span class="n">set.inclusion</span> <span class="n">_</span><span class="o">)</span> <span class="k">Pi</span><span class="bp">.</span><span class="n">topological_space</span>
<span class="n">term</span>
  <span class="k">Pi</span><span class="bp">.</span><span class="n">topological_space</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">topological_space</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">J</span><span class="o">),</span> <span class="o">(</span><span class="n">F</span> <span class="bp">⋙</span> <span class="n">Profinite_to_Top</span> <span class="bp">⋙</span> <span class="n">forget</span> <span class="n">Top</span><span class="o">)</span><span class="bp">.</span><span class="n">obj</span> <span class="n">a</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">topological_space</span> <span class="bp">↥</span><span class="n">set.univ</span>
</code></pre></div>
<p>and set.univ is just: <code>set (Π (j : J), (F ⋙ Profinite_to_Top ⋙ forget Top).obj j)</code>.</p>
<p>So is there some way of "wrapping" the Pi.topological_space line in tactic mode and then rewriting it in there? Or is there a theorem I can use directly in term mode?</p>



<a name="218949077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218949077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218949077">(Dec 05 2020 at 19:23)</a>:</h4>
<p>I suspect that <code>↥set.univ</code> is not _definitionally_ equal to <code>(Π (a : J), (F ⋙ Profinite_to_Top ⋙ forget Top).obj a)</code>.</p>



<a name="218949179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218949179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Calle Sönne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218949179">(Dec 05 2020 at 19:25)</a>:</h4>
<p>When I have my cursor on the Pi.topological_space line and press set.univ in the infoview that is what I get</p>



<a name="218949247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218949247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Calle Sönne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218949247">(Dec 05 2020 at 19:27)</a>:</h4>
<p>Or I get that set.univ is <code>set (Π (j : J), (F ⋙ Profinite_to_Top ⋙ forget Top).obj j)</code> but maybe I dont understand what the coercion is doing. I assume that coe_sort will give me <code>(Π (j : J), (F ⋙ Profinite_to_Top ⋙ forget Top).obj j)</code></p>



<a name="218949942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218949942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218949942">(Dec 05 2020 at 19:42)</a>:</h4>
<p>No it won't, it will give you a type which bijects with that but which is not equal to that.</p>



<a name="218949947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218949947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218949947">(Dec 05 2020 at 19:42)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refl</span> <span class="c1">-- fails</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218950047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218950047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218950047">(Dec 05 2020 at 19:44)</a>:</h4>
<p>The coercion will give you a subtype of X corresponding to all the terms in X for which <code>true</code> is true, so in particular it will give you a different but isomorphic type.</p>



<a name="218950076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218950076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218950076">(Dec 05 2020 at 19:45)</a>:</h4>
<p>What happens if you just delete <code>str</code> completely? Does type class inference fill it in?</p>



<a name="218950219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218950219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Calle Sönne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218950219">(Dec 05 2020 at 19:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis/near/218950076">said</a>:</p>
<blockquote>
<p>What happens if you just delete <code>str</code> completely? Does type class inference fill it in?</p>
</blockquote>
<p>unfortunately not</p>



<a name="218950257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218950257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218950257">(Dec 05 2020 at 19:49)</a>:</h4>
<p>What is the goal in <code>str := begin sorry end</code>?</p>



<a name="218950267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218950267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Calle Sönne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218950267">(Dec 05 2020 at 19:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis/near/218950047">said</a>:</p>
<blockquote>
<p>The coercion will give you a subtype of X corresponding to all the terms in X for which <code>true</code> is true, so in particular it will give you a different but isomorphic type.</p>
</blockquote>
<p>That is interesting.  So I should look for some lemma which puts a topology on an isomorphic type? Maybe that will be hard to work with in practice though</p>



<a name="218950275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218950275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218950275">(Dec 05 2020 at 19:49)</a>:</h4>
<p>Maybe something like <code>str := by unfold sections; apply_instance</code> will work? Can you post some working code which I can run at my end?</p>



<a name="218950278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218950278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Calle Sönne <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218950278">(Dec 05 2020 at 19:49)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">topological_space</span> <span class="bp">↥</span><span class="o">((</span><span class="n">F</span> <span class="bp">⋙</span> <span class="n">Profinite_to_Top</span> <span class="bp">⋙</span> <span class="n">forget</span> <span class="n">Top</span><span class="o">)</span><span class="bp">.</span><span class="n">sections</span><span class="o">)</span>
</code></pre></div>



<a name="218950318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Resolve%20coercion%20in%20hypothesis/near/218950318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Resolve.20coercion.20in.20hypothesis.html#218950318">(Dec 05 2020 at 19:50)</a>:</h4>
<p><span class="user-mention" data-user-id="132603">@Calle Sönne</span> if you want to do this in real time you can stream in Xena</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
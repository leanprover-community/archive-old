---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html">How do I tell Lean that a subclass is a kind of the supercla</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="220269994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220269994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220269994">(Dec 17 2020 at 16:57)</a>:</h4>
<p>I'm working on this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.lebesgue_measure</span>

<span class="kn">open</span> <span class="n">measure_theory</span>

<span class="kd">noncomputable theory</span>

<span class="kd">class</span> <span class="n">probability_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">measure_space</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_probability_measure</span><span class="o">:</span>  <span class="n">probability_measure</span> <span class="n">volume</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">random_variable</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">domain</span> <span class="o">:</span> <span class="n">probability_space</span> <span class="n">α</span> <span class="o">)</span>
<span class="o">(</span><span class="n">codomain</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">β</span> <span class="o">)</span>
<span class="o">(</span><span class="n">outcome</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_measurable_outcome</span> <span class="o">:</span> <span class="bp">@</span><span class="n">measurable</span> <span class="n">α</span>  <span class="n">β</span> <span class="n">domain</span> <span class="n">codomain</span> <span class="n">outcome</span><span class="o">)</span>
</code></pre></div>
<p>I am trying to say that a random variable is a measurable function from a probability space to a measurable space.  Even though the function is declared α → β and I have proofs that <code>domain</code> is a <code>probability_space</code> and <code>codomain</code> is a <code>measurable_space</code>, I still guess that I need to add a proof that <code>outcome</code> is a measurable function.  Or is it obvious?  I'm unsure.</p>
<p>Anyway, if I do have to do the extra step of proving that <code>outcome</code> is <code>measurable</code>, I need to get this type right:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">@</span><span class="n">measurable</span> <span class="n">α</span>  <span class="n">β</span> <span class="n">domain</span> <span class="n">codomain</span> <span class="n">outcome</span>
</code></pre></div>
<p>However, it is complaining</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">measurable</span>
<span class="n">term</span>
  <span class="n">domain</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">probability_space</span> <span class="n">α</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">measurable_space</span> <span class="n">α</span>
</code></pre></div>
<p>even though</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">probability_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">measure_space</span>
</code></pre></div>
<p>and</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">measure_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">measurable_space</span> <span class="n">α</span>
</code></pre></div>
<p>How do I tell Lean that a subclass is a kind of the superclass?</p>



<a name="220271001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220271001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220271001">(Dec 17 2020 at 17:04)</a>:</h4>
<p>I would use something approximately like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.lebesgue_measure</span>

<span class="kn">open</span> <span class="n">measure_theory</span>

<span class="kd">noncomputable theory</span>

<span class="kd">class</span> <span class="n">probability_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">measure_space</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_probability_measure</span><span class="o">:</span>  <span class="n">probability_measure</span> <span class="n">volume</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">random_variable</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">outcome</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_measurable_outcome</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">outcome</span><span class="o">)</span>
</code></pre></div>



<a name="220271258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220271258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220271258">(Dec 17 2020 at 17:06)</a>:</h4>
<p>Thanks!  Why <code>structure</code> and not <code>class</code> in this case?  <code>random_variable</code> is a class of function, it seems possible people might want to create instances.</p>



<a name="220271292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220271292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220271292">(Dec 17 2020 at 17:06)</a>:</h4>
<p>This is more sensible yes, but also in the original formulation you can just write <code>is_measurable_outcome : measurable outcome</code>--if you don't try to do Lean's work for it, it will do it correctly.</p>



<a name="220271512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220271512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220271512">(Dec 17 2020 at 17:08)</a>:</h4>
<p>Oh it looks like <code>measurable</code> is not a class, so I should use regular parens. (fixed code)</p>



<a name="220271785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220271785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220271785">(Dec 17 2020 at 17:10)</a>:</h4>
<p>Does mathlib have bundled measurable functions?</p>



<a name="220277921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220277921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220277921">(Dec 17 2020 at 17:51)</a>:</h4>
<p>Please help me take it a little further.  To the random variable I want to add an inverse.  So if <code>X(ω)</code> is a random variable, then<br>
<code>inverse(y) = {ω : X(ω) = y}</code>.   I tried this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">random_variable</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">outcome</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_measurable_outcome</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">outcome</span><span class="o">)</span>
<span class="o">(</span><span class="n">inverse</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">ω</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">outcome</span> <span class="n">ω</span> <span class="o">})</span> <span class="bp">//</span> <span class="n">ERROR</span>
</code></pre></div>
<p>I got this error message, which I don't know how to fix:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="k">let</span><span class="bp">-</span><span class="n">expression</span><span class="o">,</span> <span class="n">term</span>
  <span class="o">{</span><span class="n">ω</span> <span class="bp">//</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">outcome</span> <span class="n">ω</span><span class="o">}</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="kt">Type</span> <span class="bp">?</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="mi">1</span> <span class="o">(</span><span class="bp">?+</span><span class="mi">1</span><span class="o">))</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">β</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="bp">?</span> <span class="bp">?</span><span class="o">)</span>
</code></pre></div>
<p>From there I want to do this, to say that the distribution space is a probability space induced by <code>X</code> with probability measure <code>volumeX : β→ [0,1]</code> such that <code>volumeX = volume  ∘ (X^-1)</code> is the <a href="https://en.wikipedia.org/wiki/Pushforward_measure">pushforward measure</a> and <code>volumeX</code> is called the distribution of <code>X</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">distribution_space</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span><span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="bp">Ω</span><span class="n">AP</span><span class="o">:</span> <span class="n">probability_space</span> <span class="n">α</span> <span class="o">):</span>  <span class="n">probability_space</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">volume</span> <span class="o">:</span> <span class="bp">Ω</span><span class="n">AP.volume</span> <span class="bp">∘</span> <span class="n">V.generalize_inverse</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_probability_measure</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">)</span>
</code></pre></div>
<p>I'm not sure how to get this all right in Lean, but the ideas are there.</p>
<p>"pushforward"  sounds categorical.  If there were a category <code>Prob</code> there may be some categorical  way to express what I'm trying to do here.  I don't know category theory though.  For now I'm just trying to get this part right.</p>



<a name="220287424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220287424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220287424">(Dec 17 2020 at 19:07)</a>:</h4>
<p>OK I found something in the guts of <code>measure_space</code> but it doesn't show up in  <a href="https://leanprover-community.github.io/mathlib_docs/find/pushforward">docs#pushforward</a>  for in Lean which is all category theory related:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- The pushforward of a measure. It is defined to be `0` if `f` is not a measurable function. -/</span>
<span class="kd">def</span> <span class="n">map</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">α</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ennreal</span><span class="o">]</span> <span class="n">measure</span> <span class="n">β</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">hf</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">f</span> <span class="k">then</span>
  <span class="n">lift_linear</span> <span class="o">(</span><span class="n">outer_measure.map</span> <span class="n">f</span><span class="o">)</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">μ</span> <span class="n">s</span> <span class="n">hs</span> <span class="n">t</span><span class="o">,</span>
    <span class="n">le_to_outer_measure_caratheodory</span> <span class="n">μ</span> <span class="n">_</span> <span class="o">(</span><span class="n">hf</span> <span class="n">hs</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">t</span><span class="o">)</span>
<span class="k">else</span> <span class="mi">0</span>
</code></pre></div>



<a name="220296608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220296608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220296608">(Dec 17 2020 at 20:20)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.lebesgue_measure</span>

<span class="kn">open</span> <span class="n">measure_theory</span>

<span class="kd">noncomputable theory</span>

<span class="kd">class</span> <span class="n">probability_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">measure_space</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_probability_measure</span> <span class="o">:</span>  <span class="n">probability_measure</span> <span class="n">volume</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">random_variable</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">outcome</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_measurable_outcome</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">outcome</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">induced</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">probability_space</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">volume</span> <span class="o">:=</span> <span class="n">measure.map</span> <span class="n">X.outcome</span> <span class="n">volume</span><span class="o">,</span>
  <span class="n">is_probability_measure</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">measure_theory.measure.map_apply</span> <span class="n">X.is_measurable_outcome</span> <span class="n">is_measurable.univ</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">probability_space.is_probability_measure.measure_univ</span><span class="o">,</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>
<p>One thing to note, as we discussed somewhere before, one should really make an API for <code>probability_space</code> so that the proof in <code>is_probability_measure</code> becomes essentially a one-liner.</p>



<a name="220296691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220296691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220296691">(Dec 17 2020 at 20:21)</a>:</h4>
<p>The structure <code>random_variable</code> needs an API as well.</p>



<a name="220296724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220296724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220296724">(Dec 17 2020 at 20:21)</a>:</h4>
<p>But I hope the code above helps you get started :)</p>



<a name="220300706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220300706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220300706">(Dec 17 2020 at 20:52)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="243562">@Adam Topaz</span> that is extremely helpful.  I have been looking at the API of  <code>measure.map</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.measure_space</span>

<span class="kn">open</span> <span class="n">measure_theory</span>

<span class="kd">variables</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span>
<span class="kd">variable</span> <span class="n">MS1</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">α</span>
<span class="kd">variable</span> <span class="n">MS2</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">β</span>
<span class="kd">variable</span> <span class="n">μ_α</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="kd">variable</span> <span class="n">m_α</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">α</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">measure_theory.measure.map</span> <span class="n">α</span> <span class="n">β</span> <span class="n">MS1</span> <span class="n">MS2</span> <span class="n">μ_α</span> <span class="n">m_α</span>
<span class="k">#check</span> <span class="n">measure_theory.measure.map</span> <span class="n">μ_α</span> <span class="n">m_α</span>
</code></pre></div>
<p>This is the pushforward measure in Wikipedia: <a href="https://en.wikipedia.org/wiki/Pushforward_measure">https://en.wikipedia.org/wiki/Pushforward_measure</a></p>
<p>There is also a <code>comap</code> in <code>measure_space</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Pullback of a `measure`. If `f` sends each `measurable` set to a `measurable` set, then for each</span>
<span class="sd">measurable set `s` we have `comap f μ s = μ (f '' s)`. -/</span>
<span class="kd">def</span> <span class="n">comap</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">β</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ennreal</span><span class="o">]</span> <span class="n">measure</span> <span class="n">α</span> <span class="o">:=</span>
</code></pre></div>
<p>What are the aesthetics of calling these <code>map</code> and <code>comap</code> versus <code>pushforward</code> and <code>pullback</code>?  This would provide a conceptual link to various pushforward definitions in <code>Top</code>and <code>category_theory</code>: <a href="https://leanprover-community.github.io/mathlib_docs/find/pushforward">docs#pushforward</a>.  I'm just asking, pure curiosity, not a criticism.</p>



<a name="220317646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220317646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220317646">(Dec 17 2020 at 23:24)</a>:</h4>
<p>Here is the last bit I want to get to before thinking about the overall API.  Please take a look at <a href="http://www.columbia.edu/~md3405/DT_Risk_2_15.pdf">Definition 7</a>:</p>
<p><a href="/user_uploads/3121/Ie07uINmXJry5GnERH22y-wz/Screenshot-from-2020-12-17-18-23-57.png">Screenshot-from-2020-12-17-18-23-57.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/Ie07uINmXJry5GnERH22y-wz/Screenshot-from-2020-12-17-18-23-57.png" title="Screenshot-from-2020-12-17-18-23-57.png"><img src="/user_uploads/3121/Ie07uINmXJry5GnERH22y-wz/Screenshot-from-2020-12-17-18-23-57.png"></a></div>



<a name="220317703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220317703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220317703">(Dec 17 2020 at 23:25)</a>:</h4>
<p>Now take a look at <a href="https://smile.amazon.com/Numerical-Solution-Computer-Experiments-Universitext/dp/3540570748/ref=sr_1_1?dchild=1&amp;keywords=numerical+solution+of+sde+with+computer&amp;qid=1608247382&amp;sr=8-1">section 1.1 B</a>:<br>
<a href="/user_uploads/3121/xNqyyQoq3m2Aoh-L1AEJOOtm/Screenshot-from-2020-12-17-18-24-10.png">Screenshot-from-2020-12-17-18-24-10.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/xNqyyQoq3m2Aoh-L1AEJOOtm/Screenshot-from-2020-12-17-18-24-10.png" title="Screenshot-from-2020-12-17-18-24-10.png"><img src="/user_uploads/3121/xNqyyQoq3m2Aoh-L1AEJOOtm/Screenshot-from-2020-12-17-18-24-10.png"></a></div>



<a name="220317819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220317819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220317819">(Dec 17 2020 at 23:26)</a>:</h4>
<p>What's the question? What is it precisely you want to get?</p>



<a name="220318056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220318056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220318056">(Dec 17 2020 at 23:30)</a>:</h4>
<p>Are you asking about inverses? You could have:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">random_variable</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">outcome</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_measurable_outcome</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">outcome</span><span class="o">)</span>
<span class="o">(</span><span class="n">surj</span><span class="o">:</span> <span class="n">function.surjective</span> <span class="n">outcome</span><span class="o">)</span>
</code></pre></div>
<p>and for the inverse use<br>
<a href="https://leanprover-community.github.io/mathlib_docs/find/function.surj_inv">docs#function.surj_inv</a></p>



<a name="220318097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220318097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220318097">(Dec 17 2020 at 23:30)</a>:</h4>
<p>Here it comes, trying to type faster.  Here's the first part:</p>
<p>So Mark Dean defines a notion of a distribution and a distribution function (when the random variable is into ℝ).  Kloeden&amp;co give an expression for the distribution function:  <code>FX(x) = PX((-∞ ,x)) = P({ω ∈ Ω : X(ω) ≤ x})</code>.</p>
<p>They are both assuming that the random variable is into ℝ.   I don't see any reason for this, because this: <code>X(ω) ≤ x</code> only requires that there be a preorder ≤  on the type β that the preorder is into.</p>



<a name="220318107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220318107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220318107">(Dec 17 2020 at 23:30)</a>:</h4>
<p>Oh so you want the distribution then?</p>



<a name="220318171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220318171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220318171">(Dec 17 2020 at 23:31)</a>:</h4>
<p>No, we have the <code>distribution</code>, I want to define the <code>distribution_function</code> in case <code>β</code> has a preorder in this sketch:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.lebesgue_measure</span>
<span class="kn">import</span> <span class="n">measure_theory.measure_space</span>

<span class="kn">open</span> <span class="n">measure_theory</span>
<span class="kd">noncomputable theory</span>

<span class="kd">class</span> <span class="n">probability_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">measure_space</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_probability_measure</span> <span class="o">:</span>  <span class="n">probability_measure</span> <span class="n">volume</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">probability_space.distribution</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ps</span><span class="o">:</span> <span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
  <span class="n">ps.volume</span>

<span class="kd">def</span> <span class="n">probability_space.distribution_function</span>  <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span> <span class="o">)</span> <span class="o">[</span><span class="n">ps</span><span class="o">:</span> <span class="n">probability_space</span> <span class="n">β</span> <span class="o">]</span>  <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
  <span class="n">sorry</span>

<span class="kd">structure</span> <span class="n">random_variable</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">outcome</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_measurable_outcome</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">outcome</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">instance</span> <span class="n">distribution_space</span>  <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">probability_space</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">volume</span> <span class="o">:=</span> <span class="n">measure.map</span> <span class="n">X.outcome</span> <span class="n">volume</span><span class="o">,</span>
  <span class="n">is_probability_measure</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">measure_theory.measure.map_apply</span> <span class="n">X.is_measurable_outcome</span> <span class="n">is_measurable.univ</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">probability_space.is_probability_measure.measure_univ</span><span class="o">,</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">[</span><span class="n">m</span> <span class="o">:</span> <span class="n">measure_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">measure_space</span> <span class="o">(</span><span class="n">subtype</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">volume</span> <span class="o">:=</span> <span class="n">measure.comap</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">_</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="n">volume</span> <span class="o">}</span>

<span class="kd">theorem</span> <span class="n">subtype.volume_apply</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">[</span><span class="n">measure_space</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">is_measurable</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">x</span><span class="o">})</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">subtype</span> <span class="n">p</span><span class="o">)}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">is_measurable</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">volume</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">volume</span> <span class="o">((</span><span class="n">coe</span> <span class="o">:</span> <span class="n">_</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">measure.comap_apply</span> <span class="n">_</span> <span class="n">subtype.coe_injective</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">is_measurable.subtype_image</span> <span class="n">hp</span><span class="o">)</span> <span class="n">_</span> <span class="n">hs</span>

<span class="kn">namespace</span> <span class="n">Steinhaus</span>

<span class="kd">instance</span> <span class="n">P</span> <span class="o">:</span> <span class="n">probability_measure</span> <span class="o">(</span><span class="n">volume</span> <span class="o">:</span> <span class="n">measure</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">measure_univ</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">refine</span> <span class="o">(</span><span class="n">subtype.volume_apply</span> <span class="n">is_measurable_Icc</span> <span class="n">is_measurable.univ</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">_</span><span class="o">,</span>
    <span class="k">suffices</span> <span class="o">:</span> <span class="n">volume</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span> <span class="o">{</span><span class="n">simpa</span><span class="o">},</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">real.volume_Icc</span><span class="o">],</span> <span class="n">simp</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="bp">Ω</span><span class="n">AP</span> <span class="o">:</span> <span class="n">probability_space</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">is_probability_measure</span> <span class="o">:=</span> <span class="n">Steinhaus.P</span> <span class="o">}</span>

<span class="k">#check</span> <span class="n">Steinhaus.</span><span class="bp">Ω</span><span class="n">AP</span>
<span class="k">#check</span> <span class="n">Steinhaus.</span><span class="bp">Ω</span><span class="n">AP.volume</span> <span class="c1">-- volume : measure ↥(set.Icc 0 1)</span>

<span class="kd">end</span> <span class="n">Steinhaus</span>
</code></pre></div>



<a name="220318266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220318266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220318266">(Dec 17 2020 at 23:32)</a>:</h4>
<p>So we have probability space, random variable, distribution space induced by random variable on probability space, and the final icing on the cake is to show that if I have a preorder on the measurable space that the random variable is into, then I have a distribution function.</p>



<a name="220318351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220318351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220318351">(Dec 17 2020 at 23:33)</a>:</h4>
<p>Why this is at all interesting is because everybody in the world only defines <code>distribution_function</code> when the random variable is into <code>ℝ</code>.  Nobody seems to care about the case where it is into a measurable space with a preorder.  I just think it's an interesting generalization.</p>



<a name="220318410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220318410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220318410">(Dec 17 2020 at 23:34)</a>:</h4>
<p>But it's only possible for me to talk about whether it is interesting or definable in the presence of something like Lean.</p>



<a name="220318472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220318472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220318472">(Dec 17 2020 at 23:35)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> There aren't any inverses involved in those snippets. That's a <code>preimage</code> you see</p>



<a name="220318616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220318616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220318616">(Dec 17 2020 at 23:37)</a>:</h4>
<p>What I'm working on is this generalization of the distribution function in the Kloeden snippet, which Dean defines only if the RV is into the reals:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">probability_space.distribution_function</span>  <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span> <span class="o">)</span> <span class="o">(</span><span class="n">y</span><span class="o">:</span> <span class="n">β</span><span class="o">)</span>  <span class="bp">\</span><span class="o">[</span><span class="n">ps</span><span class="o">:</span> <span class="n">probability_space</span> <span class="n">β</span> <span class="o">]</span>  <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
  <span class="n">ps.volume</span><span class="o">({</span><span class="n">ω</span> <span class="bp">∈</span> <span class="n">α</span> <span class="o">:</span> <span class="n">X</span><span class="o">(</span><span class="n">ω</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">})</span>
</code></pre></div>



<a name="220318638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220318638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220318638">(Dec 17 2020 at 23:37)</a>:</h4>
<p>Ah, misread. Gotcha. So the clean wya to state that is outcome.preimage?</p>



<a name="220318663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220318663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220318663">(Dec 17 2020 at 23:37)</a>:</h4>
<p>Well, the whole measure is <code>measure.comap</code> I think</p>



<a name="220318746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220318746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220318746">(Dec 17 2020 at 23:38)</a>:</h4>
<p>actually <code>measure.map</code></p>



<a name="220318850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220318850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220318850">(Dec 17 2020 at 23:40)</a>:</h4>
<p>That's another question I had about terminology, why <code>measure_space</code> uses <code>map</code> and <code>comap</code> but in the comments it uses <code>pushforward</code> and <code>pullback</code> which comments match terminology used in <code>Top</code> and <code>category_theory</code>.</p>



<a name="220318861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220318861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220318861">(Dec 17 2020 at 23:40)</a>:</h4>
<p>so there isn't really anything to do in definition 7. <code>measure.map x volume</code> is a measure, check</p>



<a name="220318888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220318888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220318888">(Dec 17 2020 at 23:40)</a>:</h4>
<p>because there is a clash of terminology from multiple fields</p>



<a name="220318948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220318948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220318948">(Dec 17 2020 at 23:41)</a>:</h4>
<p>lean uses <code>map</code> and <code>comap</code> for regularity, but this gets instantiated in category theory and topology and algebra and measure theory and mathematicians in these areas all have their own ideas about what to call it</p>



<a name="220318966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220318966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220318966">(Dec 17 2020 at 23:41)</a>:</h4>
<p>OK thanks.  The above sketch works fine.  <span class="user-mention" data-user-id="243562">@Adam Topaz</span> worked out how to derive a distribution space from a random variable on a probability space:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">distribution_space</span>  <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">probability_space</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">volume</span> <span class="o">:=</span> <span class="n">measure.map</span> <span class="n">X.outcome</span> <span class="n">volume</span><span class="o">,</span>
  <span class="n">is_probability_measure</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">measure_theory.measure.map_apply</span> <span class="n">X.is_measurable_outcome</span> <span class="n">is_measurable.univ</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">probability_space.is_probability_measure.measure_univ</span><span class="o">,</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>
<p>The only thing I have left to complete the functionality is generalized distribution function.</p>



<a name="220319037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220319037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220319037">(Dec 17 2020 at 23:42)</a>:</h4>
<p>I think you are missing a lemma there</p>



<a name="220319053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220319053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220319053">(Dec 17 2020 at 23:42)</a>:</h4>
<p>you just proved the <code>map</code> of a probability measure is a probability measure</p>



<a name="220319058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220319058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220319058">(Dec 17 2020 at 23:42)</a>:</h4>
<p>that's a lemma</p>



<a name="220319074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220319074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220319074">(Dec 17 2020 at 23:43)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.lebesgue_measure</span>

<span class="kn">open</span> <span class="n">measure_theory</span>

<span class="kd">noncomputable theory</span>

<span class="kd">class</span> <span class="n">probability_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">measure_space</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_probability_measure</span> <span class="o">:</span>  <span class="n">probability_measure</span> <span class="n">volume</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">probability_space</span>

<span class="kd">lemma</span> <span class="n">volume_univ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">volume</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
  <span class="n">is_probability_measure.measure_univ</span>

<span class="kd">def</span> <span class="n">prob</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_measurable</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">ennreal</span> <span class="o">:=</span>
  <span class="n">volume</span> <span class="n">S</span>

<span class="kd">end</span> <span class="n">probability_space</span>

<span class="kd">structure</span> <span class="n">random_variable</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">outcome</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_measurable_outcome</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">outcome</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">random_variable</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">outcome</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">measurable</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">X.is_measurable_outcome</span>

<span class="kd">def</span> <span class="n">induced</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">probability_space</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">volume</span> <span class="o">:=</span> <span class="n">measure.map</span> <span class="n">X</span> <span class="n">volume</span><span class="o">,</span>
  <span class="n">is_probability_measure</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="n">erw</span> <span class="n">measure_theory.measure.map_apply</span> <span class="n">X.measurable</span> <span class="n">is_measurable.univ</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">probability_space.volume_univ</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">distribution_function</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ennreal</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
  <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">_</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span> <span class="n">is_measurable_Iic</span>

<span class="kd">end</span> <span class="n">random_variable</span>
</code></pre></div>



<a name="220319112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220319112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220319112">(Dec 17 2020 at 23:43)</a>:</h4>
<p>why is <code>prob</code> an <code>ennreal</code>?</p>



<a name="220319119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220319119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220319119">(Dec 17 2020 at 23:43)</a>:</h4>
<p>Because I'm lazy</p>



<a name="220319172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220319172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220319172">(Dec 17 2020 at 23:44)</a>:</h4>
<p>One should change it to <code>\R</code>.</p>



<a name="220319187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220319187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220319187">(Dec 17 2020 at 23:44)</a>:</h4>
<p>Same with <code>distribtion_function</code>.</p>



<a name="220319213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220319213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220319213">(Dec 17 2020 at 23:44)</a>:</h4>
<p>Well that's what I'm trying to generalize.  I want to replace ℝ with β where β has a <code>preorder</code>. What do you think?</p>



<a name="220319262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220319262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220319262">(Dec 17 2020 at 23:45)</a>:</h4>
<p>Sure you could do that.</p>



<a name="220319277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220319277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220319277">(Dec 17 2020 at 23:45)</a>:</h4>
<p>I don't think that's a good idea, it's not general enough</p>



<a name="220319350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220319350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220319350">(Dec 17 2020 at 23:46)</a>:</h4>
<p>the sets <code>{c | c ≤ x}</code> in a preorder don't generate all borel sets</p>



<a name="220319384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220319384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220319384">(Dec 17 2020 at 23:46)</a>:</h4>
<p>you will have to work with the preimages of general sets, at which point it's not clear what the CDF gets you</p>



<a name="220319422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220319422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220319422">(Dec 17 2020 at 23:47)</a>:</h4>
<p>It would be a really wonderful solution to a <a href="https://math.stackexchange.com/questions/3780089/extending-the-concept-of-distribution-function-to-any-totally-or-partially-order/3782009?noredirect=1#comment7787969_3782009">Math StackExchange question I posed in August</a>, i.e. exactly what kind of order does β have to have for this to go through in Lean.</p>



<a name="220319521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220319521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220319521">(Dec 17 2020 at 23:48)</a>:</h4>
<p>For one thing you know by construction of the <code>random_variable</code> that β is a <code>measurable_space</code>.</p>



<a name="220324418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220324418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220324418">(Dec 18 2020 at 00:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla/near/220319053">said</a>:</p>
<blockquote>
<p>you just proved the <code>map</code> of a probability measure is a probability measure, that's a lemma</p>
</blockquote>
<p>It could be that makes it a category, which is something to think about.  I.e. if you were building a probability library from scratch would you want to make it as category theory-ish as possible or just express the main ideas on their own.  There seems to be big interest in category theory here, but it seems that using it in practice like for GCD/Fibonacci example is quite hard.  So then the question is whether the generalization that it provides is productive for particular applications, or is it just nice to think about on its own. The fact that there is map/comap and pullback/pushthrough in different parts of the library shows that there is not a unified view among all the mathlib contributors.  Not that there should be, I'm just slowly learning the "style guide" and "make it a category" doesn't seem to be one of the style imperatives.</p>



<a name="220324993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220324993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220324993">(Dec 18 2020 at 00:59)</a>:</h4>
<p>Regarding this expression for the <code>distribution_function</code>, which is on single points in the codomain of the RV, as opposed to the <code>distribution</code>, which is on subsets of the domain of the RV:  <code>F(x) = P({ω ∈ Ω : X(ω) ≤ x})</code>.  We can see by inspection, since <code>P</code> is a probability measure, that it will be in <code>[0,1]</code>.  If the codomain of the RV is some kind of partially ordered set, the distribution function might not behave in the same way as if it were a linearly ordered dense set.  But the result will still be a CDF.   I will Google "generalized distribution function" and see what I come up with.  In any event, it seems well defined for any order relation <code>≤ </code>.</p>



<a name="220325248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220325248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220325248">(Dec 18 2020 at 01:03)</a>:</h4>
<blockquote>
<p>The fact that there is map/comap and pullback/pushthrough in different parts of the library shows that there is not a unified view among all the mathlib contributors</p>
</blockquote>
<p>To clarify: <code>map</code> and <code>comap</code> are used consistently in lean names, while "pullback" and "pushforward" are used in comments to help connect names to things in the literature (which are all over the place, as one would expect)</p>



<a name="220325458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220325458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220325458">(Dec 18 2020 at 01:06)</a>:</h4>
<blockquote>
<p>It could be that makes it a category, which is something to think about. I.e. if you were building a probability library from scratch would you want to make it as category theory-ish as possible or just express the main ideas on their own.</p>
</blockquote>
<p>I would not suggest adding additional layers unless it gives you an advantage in proving theorems. Instantiating a category is a thing you can do, but it's not particularly helpful on its own. There are lots of things in mathlib that could potentially be instantiations of the category library, but generally it's just another layer on an existing theorem. I would say prove the theorem and add the instantiation if and when you need it for a theorem</p>



<a name="220325607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220325607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220325607">(Dec 18 2020 at 01:08)</a>:</h4>
<p>OK so my main concern, all abstraction aside, is whether any <code>measurable_set</code> <code>S</code> with ≤  for which this expression: <code>F(x: S) = P({ω ∈ Ω : X(ω) ≤ x})</code> makes sense is necessarily linearly ordered, dense and isomorphic to ℝ, or whether any <code>measurable_set</code> with any ≤ defined on it will do.</p>



<a name="220325620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220325620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220325620">(Dec 18 2020 at 01:09)</a>:</h4>
<p>Just to clarify, whenever you have a random variable <code>X</code> with codomain <code>A</code>, and some function from <code>A</code> to the type of all measurable sets in <code>A</code>, you can define something like a distribution function on <code>A</code>. The question is whether this function determines the probability density on <code>A</code> induced by <code>X</code>, and this is certainly not true in general.</p>



<a name="220325734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220325734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220325734">(Dec 18 2020 at 01:10)</a>:</h4>
<p>I think instead of formalizing definitions, you should try to get to the actual theorems, because we can work backward from there to the abstractions that are useful for formalizing the theorem. So far, I don't see any value in the definition <code>random_variable</code>, or <code>distribution</code>, or <code>prob</code> or <code>distribution_function</code>, they are all just wrappers around other things. So let's get to theorems where you really <em>need</em> some probability vocabulary to prove the theorem effectively</p>



<a name="220325787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220325787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220325787">(Dec 18 2020 at 01:11)</a>:</h4>
<p>Random variable, distribution, distribution function and probability space <em>are</em> probability vocabulary.</p>



<a name="220325799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220325799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220325799">(Dec 18 2020 at 01:11)</a>:</h4>
<p>yes I'm aware</p>



<a name="220325818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220325818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220325818">(Dec 18 2020 at 01:11)</a>:</h4>
<p>a wrapper doesn't help you prove theorems</p>



<a name="220325824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220325824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220325824">(Dec 18 2020 at 01:11)</a>:</h4>
<p>Google gave me this, maybe it's of some use: <a href="https://www.ams.org/journals/tran/1957-084-02/S0002-9947-1957-0085326-5/S0002-9947-1957-0085326-5.pdf">https://www.ams.org/journals/tran/1957-084-02/S0002-9947-1957-0085326-5/S0002-9947-1957-0085326-5.pdf</a></p>



<a name="220325914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220325914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220325914">(Dec 18 2020 at 01:13)</a>:</h4>
<p>more words to express things you could already express are not helpful. The power of a definition is when it abbreviates a nontrivial combination of things, like "group" meaning "associative binary operation with a neutral element"</p>



<a name="220325947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220325947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220325947">(Dec 18 2020 at 01:13)</a>:</h4>
<p>the latter expression is more cumbersome than the former, so the definition pulls its weight</p>



<a name="220326001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220326001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220326001">(Dec 18 2020 at 01:14)</a>:</h4>
<p>there are also a bunch of theorems about groups that are not theorems about monoids or associative operations on their own</p>



<a name="220326020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220326020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220326020">(Dec 18 2020 at 01:14)</a>:</h4>
<p>I'm not really trying to prove a theorem, I'm just trying to get the type classes straight to describe the usual vocabulary of probability theory.  That's all.  Because even though that vocabulary is just sugar for things that are already in<code>mathlib</code> in one way or another, they are still challenging for me.  I can't go to<code>mathlib</code> and see the usual vocabulary of probability theory.  It's a modest exercise.</p>



<a name="220326066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220326066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220326066">(Dec 18 2020 at 01:15)</a>:</h4>
<p>So what's the raison d'etre of probability vocabulary? What fact about probability measures is not true about general measures? I have no doubt that such theorems <em>exist</em>, but nothing interesting will happen until you start trying to prove one of them</p>



<a name="220326289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220326289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220326289">(Dec 18 2020 at 01:18)</a>:</h4>
<p>It is really important to find and at least start trying to prove one of these theorems because it guides the structure of definitions around the whole topic. Without it I see all these definitions and they are all useless cruft with negative utility</p>



<a name="220326458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220326458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220326458">(Dec 18 2020 at 01:21)</a>:</h4>
<p>My longer range goal is to understand say the construction of the stochastic Taylor series approximation of the Ito or Stratonovich integral.  I am not trying to prove any new theorems about this topic.  I'm trying to build up the language used in a textbook that goes through that topic.  The textbook doesn't use the measure-theoretic equivalent of <code>probability_space</code>.  It uses <code>probability_space</code>.  I don't think I should feel bad about, for my own purposes in reading that book, providing a definition of <code>probability_space</code>.</p>
<p>Along the way I noticed that <code>F(x: S) = P({ω ∈ Ω : X(ω) ≤ x}</code> could possibly be generalized.  <span class="user-mention" data-user-id="243562">@Adam Topaz</span> expresses this as whether the random variable <code>X</code> "determines the probability density on A induced by X".  It seems that "determines the probability density on A induced by X" is something that could be written in Lean and expressed as a condition that the order relation ≤ has to satisfy.  So, for my own tastes and ambitions, I think it would be interesting to say formalize "determines the probability density on A induced by X" and see where that leads.  It could lead to the requirement that the codomain of the random variable be isomorphic to the reals, which would be an interesting and natural explanation for why every text I can find restricts <code>distribution_function</code> to random variables into the reals.</p>



<a name="220326568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220326568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220326568">(Dec 18 2020 at 01:22)</a>:</h4>
<blockquote>
<p>The textbook doesn't use the measure-theoretic equivalent of probability_space. It uses probability_space. I don't think I should feel bad about, for my own purposes in reading that book, providing a definition of probability_space.</p>
</blockquote>
<p>The point isn't to feel bad about it, it is to build the theory of probability spaces by looking at how it is <em>used</em></p>



<a name="220326600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220326600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220326600">(Dec 18 2020 at 01:23)</a>:</h4>
<p>The question to answer isn't <em>what is a probability space</em>, it is <em>what do people do with probability spaces</em></p>



<a name="220326707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220326707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220326707">(Dec 18 2020 at 01:24)</a>:</h4>
<p>the purpose of a library is to make it easier to write proofs in the area</p>



<a name="220326729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220326729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220326729">(Dec 18 2020 at 01:24)</a>:</h4>
<p>so you have to look at the proofs to understand how to help</p>



<a name="220326958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220326958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220326958">(Dec 18 2020 at 01:27)</a>:</h4>
<p>Regarding what you would need to make the exact definition <code>F(x: S) = P({ω ∈ Ω : X(ω) ≤ x})</code> generalize, I would expect that you need the sets <code>{a | a &lt; x}</code> to generate the topology and hence the entire borel algebra. That is, you need an <code>orderable_topology</code> on the codomain</p>



<a name="220327065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220327065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220327065">(Dec 18 2020 at 01:29)</a>:</h4>
<p>oops it's called <a href="https://leanprover-community.github.io/mathlib_docs/find/order_closed_topology">docs#order_closed_topology</a> now</p>



<a name="220327171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220327171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220327171">(Dec 18 2020 at 01:30)</a>:</h4>
<p>I think you will need to get to some really interesting theorems before the codomain starts to be constrained to look anything like the reals</p>



<a name="220328111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220328111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220328111">(Dec 18 2020 at 01:45)</a>:</h4>
<p>Law of large numbers might be a nice goal.</p>



<a name="220329514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220329514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220329514">(Dec 18 2020 at 02:09)</a>:</h4>
<p>In terms of "what do people do with probability spaces", and the book I am reading, I have some very simple applications that I want to proof-check in Lean:</p>
<ul>
<li>A one-size-fits-all probability space:([0,1], B([0,1]), [a,b] -&gt; b-a). That's done.  Cruft is to name this the Steinhaus space</li>
<li>Some basic language: Random variable, distribution, distribution function</li>
<li>Distribution function for a two-point RV with codomain {0,1} and probabilities p and 1-p</li>
<li>Uniform distribution U[a,b]</li>
<li>Exponential distribution </li>
<li>Gaussian distribution</li>
</ul>
<p>For each of these I want to:</p>
<ul>
<li>Start with Steinhaus as the domain of the random variable X, </li>
<li>Define the codomain as either a finite measurable space for a continuous random variable or the appropriate continuous codomain which could be ereal or ennreal or a real interval</li>
<li>Define the corresponding random variable X</li>
<li>From X derive the distribution function FX</li>
</ul>
<p>This is not the usual order.  The book and most presentations tend to start with the distribution function.  I just like doing it in this order because it appeals to me.  I'm not proving theorems really, just trying to create language for a sequence that appeals to me for presenting these different discrete and continuous distributions in a consistent kind of top-down way.  Also, I am annoyed that the book introduces <code>probability_space</code> on page 3 and then drops it thereafter and just presents the <code>distribution_function</code> for each distribution.  I think if you define something you should use it, so I'm spending my time doing it in this direction.   It's just a personal choice.</p>



<a name="220329934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220329934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220329934">(Dec 18 2020 at 02:16)</a>:</h4>
<p>well the main issue I have with that list is that every single one is a definition, there are no theorems</p>



<a name="220329945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220329945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220329945">(Dec 18 2020 at 02:17)</a>:</h4>
<p>you need at least some sanity checks on the definitions</p>



<a name="220330111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220330111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220330111">(Dec 18 2020 at 02:20)</a>:</h4>
<p>Perhaps your goal might be to have a way to prove that a real function (which is what the books will give in order to define a distribution) yields a probability distribution, that's not completely obvious from the definitions</p>



<a name="220330221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220330221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220330221">(Dec 18 2020 at 02:22)</a>:</h4>
<p>you can then use that to get the exponential distribution and gaussian distribution</p>



<a name="220330234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220330234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220330234">(Dec 18 2020 at 02:23)</a>:</h4>
<p>I think you already did the uniform distribution earlier</p>



<a name="220332584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220332584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220332584">(Dec 18 2020 at 03:07)</a>:</h4>
<p>The interesting (to me) part, which I already did by hand, is when they give a distribution function, to back out what the random variable is that has that distribution function.  It's not always easy to get it right.  So my work is to take the RV that I backed out and prove that if you grind it through the Lean <code>distribution_function</code> construction, that I get the same function.  So that's a proof.</p>
<p>Regarding the generalized disrtibution function, I am trying to generalize</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">distribution_function</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ennreal</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
</code></pre></div>
<p>to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">distribution_function</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span> <span class="o">)</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
</code></pre></div>
<p>Adam's distribution function full definition is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">distribution_function</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ennreal</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
  <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">_</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span> <span class="n">is_measurable_Iic</span>
</code></pre></div>
<p>I am trying to understand the application of <code>@probability_space.prob</code>.   I've got this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.lebesgue_measure</span>

<span class="kn">open</span> <span class="n">measure_theory</span>

<span class="kd">noncomputable theory</span>

<span class="kd">class</span> <span class="n">probability_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">measure_space</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_probability_measure</span> <span class="o">:</span>  <span class="n">probability_measure</span> <span class="n">volume</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">probability_space</span>

<span class="kd">lemma</span> <span class="n">volume_univ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">volume</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
  <span class="n">is_probability_measure.measure_univ</span>

<span class="kd">def</span> <span class="n">prob</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_measurable</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">ennreal</span> <span class="o">:=</span>
  <span class="n">volume</span> <span class="n">S</span>

<span class="kd">end</span> <span class="n">probability_space</span>

<span class="kd">structure</span> <span class="n">random_variable</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">outcome</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_measurable_outcome</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">outcome</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">random_variable</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">outcome</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">measurable</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">X.is_measurable_outcome</span>

<span class="kd">def</span> <span class="n">induced</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">probability_space</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">volume</span> <span class="o">:=</span> <span class="n">measure.map</span> <span class="n">X</span> <span class="n">volume</span><span class="o">,</span>
  <span class="n">is_probability_measure</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="n">erw</span> <span class="n">measure_theory.measure.map_apply</span> <span class="n">X.measurable</span> <span class="n">is_measurable.univ</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">probability_space.volume_univ</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kd">variable</span> <span class="n">MSα</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">α</span>
<span class="kd">variable</span> <span class="n">Pα</span> <span class="o">:</span> <span class="n">probability_space</span> <span class="n">α</span>
<span class="kd">variable</span> <span class="n">Pβ</span> <span class="o">:</span> <span class="n">probability_space</span>  <span class="n">β</span>
<span class="kd">variable</span> <span class="n">Sα</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span>
<span class="kd">variable</span> <span class="n">Sβ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span>

<span class="kd">lemma</span> <span class="n">SMα</span> <span class="o">:</span> <span class="n">is_measurable</span> <span class="n">Sα</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">SMβ</span> <span class="o">:</span> <span class="n">is_measurable</span> <span class="n">Sβ</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">def</span> <span class="n">Xαβ</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="k">#check</span> <span class="n">Xαβ.induced</span> <span class="c1">-- X.induced : probability_space β</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">α</span> <span class="n">Pα</span> <span class="n">Sα</span> <span class="o">(</span><span class="n">SMα</span> <span class="n">Sα</span> <span class="o">)</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">β</span> <span class="n">Pβ</span> <span class="n">Sβ</span> <span class="o">(</span><span class="n">SMβ</span> <span class="n">Sβ</span><span class="o">)</span> <span class="c1">-- FAILS</span>

<span class="kd">def</span> <span class="n">distribution_function</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span> <span class="o">)</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">sorry</span>
<span class="c1">--  @probability_space.prob _ X.induced {c | c ≤ x} is_measurable_Iic</span>

<span class="kd">end</span> <span class="n">random_variable</span>
</code></pre></div>
<p>Even though the one before it works, this fails:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">β</span> <span class="n">Pβ</span> <span class="n">Sβ</span> <span class="o">(</span><span class="n">SMβ</span> <span class="n">Sβ</span><span class="o">)</span> <span class="c1">-- FAILS</span>
</code></pre></div>
<p>I don't fully understand why the type of <code>SMα</code> is <code>Mα : ∀ (Sα : set ?M_1), is_measurable Sα</code>, so I have to re-supply Sα when I use it even though it's declared</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">SMα</span> <span class="o">:</span> <span class="n">is_measurable</span> <span class="n">Sα</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>
<p>So </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">α</span> <span class="n">Pα</span> <span class="n">Sα</span> <span class="o">(</span><span class="n">SMα</span> <span class="n">Sα</span> <span class="o">)</span>
</code></pre></div>
<p>works with type</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">probability_space.prob</span> <span class="n">_</span> <span class="o">:</span> <span class="n">ennreal</span>
</code></pre></div>
<p>But </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">β</span> <span class="n">Pβ</span> <span class="n">Sβ</span> <span class="o">(</span><span class="n">SMβ</span> <span class="n">Sβ</span><span class="o">)</span>
</code></pre></div>
<p>gives </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">synthesized</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">is</span> <span class="n">not</span> <span class="n">definitionally</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">expression</span> <span class="n">inferred</span> <span class="kd">by</span> <span class="n">typing</span> <span class="n">rules</span><span class="o">,</span> <span class="n">synthesized</span>
  <span class="n">_inst_2</span>
<span class="n">inferred</span>
  <span class="n">measure_space.to_measurable_space</span>
</code></pre></div>
<p>I am using @ to avoid this kind of mystery but it's not helping in this case.  Any suggestions?  This is a problem because in this line</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">_</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span> <span class="n">is_measurable_Iic</span>
</code></pre></div>
<p>the term <code>X.induced</code> is going to have type <code>probability_space β</code>.  So I need to understand how to fill out each of the arguments to <code>@probability_space.prob</code> but I can't even <code>#check</code> it in the β case, it only works for α.</p>
<p>The other minor issue is that <code>probability_space.prob</code> has return type <code>ennreal</code> when I know that in the end it will be constrained to <code> (set.Icc (0 : ℝ) 1)</code> by <code>probability_measure volume</code>.  I'd rather just say it in the return type rather than <code>ennreal</code>, but that doesn't go through.</p>



<a name="220332956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220332956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220332956">(Dec 18 2020 at 03:14)</a>:</h4>
<blockquote>
<p>So my work is to take the RV that I backed out and prove that if you grind it through the Lean distribution_function construction, that I get the same function. So that's a proof.</p>
</blockquote>
<p>Can you state this theorem?</p>



<a name="220332974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220332974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220332974">(Dec 18 2020 at 03:15)</a>:</h4>
<p>it's not entirely clear to me what you mean by it</p>



<a name="220333053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220333053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220333053">(Dec 18 2020 at 03:17)</a>:</h4>
<p>I'm not sure there is anything to be gained with the <code>#check</code>s, all those variables are tripping you up. Just state a def or theorem and try to get the assumptions and the statement of the theorem right</p>



<a name="220333096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220333096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220333096">(Dec 18 2020 at 03:18)</a>:</h4>
<p><code>lemma SMα</code> is false, it asserts all sets are measurable</p>



<a name="220333107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220333107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220333107">(Dec 18 2020 at 03:18)</a>:</h4>
<p><code>lemma SMβ</code> is the same as <code>lemma SMα</code></p>



<a name="220337225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220337225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220337225">(Dec 18 2020 at 05:03)</a>:</h4>
<p>The point of the <code>#check</code>s was simply to check the type of the arguments to the expression, I was trying to figure out what kind of thing to fill in the blank for each of the slots in <code>probability_space.prob</code>.  I know that it just applies the volume function, but in the explicit @ form there are a lot of things that need to be in place for the application to go through, and I was trying to understand their types.</p>
<p>The theorem to prove is as follows (for the type of random variables in the text, which is the usual type, not the generalized type I want):</p>
<ul>
<li>We are given, in the text <code>F_X: ℝ → [0,1] </code>, the <code>distribution_function</code> for the <code>random_variable</code> named <code>X: [0,1] → ℝ</code>.</li>
<li>I construct, by inspection, a definition <code>myX</code> for the random variable<code>X</code>.</li>
<li>There is a  <code>distribution</code>, <code>μ_X : borel ℝ → [0,1]</code>, which is implicit.</li>
<li>In the Steinhaus space we have uniform probability measure 'P: borel ℝ → [0,1]`.</li>
<li>By construction (this is already proven out of the by the machinery in the cruft above), we have that <code>μ_X = P ∘ X⁻¹ </code></li>
<li><strong>To prove</strong>: that <code>myX = λ x, μ_X (set.Icc -∞ x)</code></li>
</ul>
<p>For example, consider the two point distribution:<br>
<a href="/user_uploads/3121/0yPq8rVnb_Ww4uJBC_dwPmbb/Screenshot-from-2020-12-18-00-03-15.png">Screenshot-from-2020-12-18-00-03-15.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/0yPq8rVnb_Ww4uJBC_dwPmbb/Screenshot-from-2020-12-18-00-03-15.png" title="Screenshot-from-2020-12-18-00-03-15.png"><img src="/user_uploads/3121/0yPq8rVnb_Ww4uJBC_dwPmbb/Screenshot-from-2020-12-18-00-03-15.png"></a></div>



<a name="220338104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220338104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220338104">(Dec 18 2020 at 05:21)</a>:</h4>
<p>Let <code>x₁, x₂ ∈ ℝ</code> and <code>p₁</code> be the probability of drawing <code>x₁</code>.  Then we can define <code>X(ω) = if ω &lt; p₁ then x₁ else x₂ </code> or</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">myX</span><span class="o">(</span><span class="n">ω</span><span class="o">:</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">ω</span> <span class="bp">&lt;</span> <span class="n">p₁</span> <span class="k">then</span> <span class="n">x₁</span> <span class="k">else</span> <span class="n">x₂</span>
</code></pre></div>
<p>also, the text is telling us that </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">FX</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">ℝ</span> <span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span><span class="bp">&lt;</span><span class="n">x₁</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="k">if</span> <span class="n">x₁</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">x₂</span> <span class="k">then</span> <span class="n">p₁</span> <span class="k">else</span> <span class="mi">1</span>
</code></pre></div>
<p>and then the proof to achieve is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">FX</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">Steinhaus.volume</span> <span class="bp">∘</span> <span class="n">myX.induced</span><span class="o">)</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="bp">∞</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>
<p>I find this interesting and a little bit tricky.   It's not rocket science but it does seem to take some effort to get all the pieces in place.  It's also not the generalized distribution function I was going on about, but it sketches out the path through the woods I am looking to take.</p>



<a name="220338309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220338309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220338309">(Dec 18 2020 at 05:26)</a>:</h4>
<p>I don't think <code>X(ω) = if ω &lt; p₁ then x₁ else x₂</code> is correct. What you need is for the probability that <code>X = x1</code> to equal <code>p1</code>, meaning that the event space is <code>bool</code> or perhaps a general probability space on which you posit an event <code>A</code> whose probability is <code>p1</code></p>



<a name="220379618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220379618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220379618">(Dec 18 2020 at 14:45)</a>:</h4>
<p>On the index space <code>[0,1]</code> I am defining an event<code>A=[0,p1)</code>.  According to Kloeden et al's book, <code>I(A)(ω)= if ω∈A then x₁ else x₂</code> is a random variable on this space, for <code>x₁=0</code> and <code>x₂=1</code>.   Please let me know if I'm reading this wrong:<br>
<a href="/user_uploads/3121/xzE2GNwzbdTfRDxJbnuvHXOn/Screenshot-from-2020-12-18-09-43-54.png">Screenshot-from-2020-12-18-09-43-54.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/xzE2GNwzbdTfRDxJbnuvHXOn/Screenshot-from-2020-12-18-09-43-54.png" title="Screenshot-from-2020-12-18-09-43-54.png"><img src="/user_uploads/3121/xzE2GNwzbdTfRDxJbnuvHXOn/Screenshot-from-2020-12-18-09-43-54.png"></a></div>



<a name="220381267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220381267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220381267">(Dec 18 2020 at 14:58)</a>:</h4>
<p>Note instead of clumping the events in <code>[0,p1)</code> I could have defined <code>A</code> to be the union of a bunch of more randomly scattered subsets.  That's not necessary for the definitions to work.  There is no inherent "randomness" in <code>random_variable</code> in that sense.   A <code>random_variable</code> is a fully determined function from a sample space to a measurable space.</p>



<a name="220396165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220396165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220396165">(Dec 18 2020 at 16:44)</a>:</h4>
<p>You don't need to define <code>A</code> to be anything in particular, it can be a hypothesis</p>



<a name="220396244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220396244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220396244">(Dec 18 2020 at 16:44)</a>:</h4>
<p>it's more general this way anyway because you don't know what event space is needed in order to match all the other constraints in a downstream theorem</p>



<a name="220403837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220403837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220403837">(Dec 18 2020 at 17:37)</a>:</h4>
<p>The Kloeden book brings in (briefly) the idea of probability space, so I want to demonstrate it when explaining things to myself.  I can use <code>(Ω,A,P)= ([0,1],B([0,1]),[a,b]↦ b-a)</code> as a "one sits fits all" probability space.  Then I want to define a random variable on that space, obtain it's distribution <code>D</code>, and then obtain the distribution function <code>F</code>, which results in a new distribution (probability) space like <code>(S,Σ,D)=(R, B(R), D)</code> with CDF <code>F</code>.  I want to do that in Lean for the 6 particular cases in the book.  I'm not trying to make the most general Lean probability theory module, or prove old or new theorems.  I'm just trying to demonstrate a little piece of mechanism, to myself, because it seems pretty to me.   I don't expect anybody else to find it interesting.  Think of it as me doing beginner-level gardening in my back yard.  It's a hobby, not a calling.</p>
<p>On the task of describing stochastic integration at a Lean level of detail, Wilfrid Kendall has done a lot of work, 21 years ago, which seems easily adaptable.  (Adapting old stuff to new contexts is also more hobby gardening, not necessarily of general interest.)  Kendall worked in <a href="https://warwick.ac.uk/fac/sci/statistics/staff/academic-research/kendall/personal/abstracts/#203">Reduce,</a> then <a href="https://warwick.ac.uk/fac/sci/statistics/staff/academic-research/kendall/personal/abstracts/#327">Axiom</a> with <a href="https://warwick.ac.uk/fac/sci/statistics/staff/academic-research/kendall/personal/abstracts/#328">fine details</a>, then <a href="https://warwick.ac.uk/fac/sci/statistics/staff/academic-research/kendall/personal/ppt/333.pdf">Mathematica</a>.  (Note, his .ps.gz files are really just .ps files, they aren't zipped.)  His Axiom papers provide the most detail. Axiom has a much richer type system than Mathematica, so the Axiom implementation is an improvement on it's successor.</p>



<a name="220405377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220405377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220405377">(Dec 18 2020 at 17:49)</a>:</h4>
<blockquote>
<p>I can use (Ω,A,P)= ([0,1],B([0,1]),[a,b]↦ b-a) as a "one sits fits all" probability space.</p>
</blockquote>
<p>It's not, though, as soon as you have more than one variable. What if you have two {0,1} variables <code>X</code> and <code>Y</code> with probabilities <code>p</code> and <code>q</code> to be 1, which are independent? This model will not help there.</p>



<a name="220413401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220413401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220413401">(Dec 18 2020 at 18:52)</a>:</h4>
<p>These 6 examples are all univariate.  Steinhaus space is a good enough indexing space for univariate examples whether continuous or discrete.   I'm not sure that what's in the sketch above (aside from my desire to generalize <code>distribution_function</code>) excludes <a href="https://en.wikipedia.org/wiki/Product_measure">product measures</a>.  Baby steps!</p>



<a name="220414385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220414385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220414385">(Dec 18 2020 at 19:00)</a>:</h4>
<p>it's generally easier to not commit to particular example spaces if you can help it. Define a gaussian distributed RV over any event space</p>



<a name="220414447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220414447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220414447">(Dec 18 2020 at 19:00)</a>:</h4>
<p>you are doing lean on hard mode for some reason I don't understand</p>



<a name="220414577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220414577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220414577">(Dec 18 2020 at 19:01)</a>:</h4>
<p>The use of [0,1] is AFAICT entirely superfluous, and your proofs and definitions will be smaller and easier without it</p>



<a name="220414779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220414779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220414779">(Dec 18 2020 at 19:03)</a>:</h4>
<p>certainly the book you are reading from has made no such commitment to an event space</p>



<a name="220419102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220419102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220419102">(Dec 18 2020 at 19:40)</a>:</h4>
<p>These are toy examples for exposition of a small point.  Before I can generalize these toy examples I have to be able to do them first.  I'm not there yet.  I can't generalize something I don't  know how to do in  a smaller context.</p>
<p>In terms of a grander design, the above sketch has</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">prob</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_measurable</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">ennreal</span> <span class="o">:=</span>
  <span class="n">volume</span> <span class="n">S</span>
</code></pre></div>
<p>I would like to be able to say </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">prob</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_measurable</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">volume</span> <span class="n">S</span>
</code></pre></div>
<p>because probability measures by definition have as codomain <code>[0,1]</code>.  Here's something I need to prove, but I don't know how to say it correctly in Lean:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">volume_type_01</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>  <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">X</span><span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="n">volume</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>
<p>I can say</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">volume_gt_0_lt_1</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>  <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">X</span><span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">0</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">volume</span> <span class="n">X</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">volume</span> <span class="n">X</span><span class="o">)</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>
<p>but that doesn't give me a way to replace <code>ennreal</code> with <code>(set.Icc (0 : ℝ) 1)</code>.</p>



<a name="220419481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220419481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220419481">(Dec 18 2020 at 19:43)</a>:</h4>
<p>I suggest using <a href="https://leanprover-community.github.io/mathlib_docs/find/ennreal.to_real">docs#ennreal.to_real</a></p>



<a name="220420985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220420985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220420985">(Dec 18 2020 at 19:57)</a>:</h4>
<blockquote>
<p>These are toy examples for exposition of a small point. Before I can generalize these toy examples I have to be able to do them first.</p>
</blockquote>
<p>The general case is easier than the specific case. I know this is counterintuitive, but it's true. The toy examples are way harder than general theorems about all measure spaces or all probability spaces, because the contingent details of the example don't get in the way</p>



<a name="220424039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220424039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220424039">(Dec 18 2020 at 20:24)</a>:</h4>
<p>OK. The other thing I want to prove, to get the generalized distribution function, is something I at least know how to state:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_measurable_measurable_with_le</span> <span class="o">(</span><span class="n">xx</span><span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_measurable</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">xx</span><span class="o">}</span> <span class="o">:=</span>
  <span class="n">sorry</span>
</code></pre></div>
<p>With this, the following #check works fine:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="n">XX</span><span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span>
<span class="kd">variable</span> <span class="n">xx</span> <span class="o">:</span> <span class="n">β</span>
<span class="kd">variable</span> <span class="n">Xlte</span> <span class="o">:</span> <span class="n">has_le</span> <span class="n">β</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">β</span> <span class="n">XX.induced</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">xx</span><span class="o">}</span> <span class="n">_</span>  <span class="c1">-- probability_space.prob ?M_1 : ennreal</span>
</code></pre></div>
<p>However the exact same expression preceded by a <code>def f :=</code> instead of a <code>#check</code> results in a fail:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">generalized_distribution_function</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">β</span> <span class="n">XX.induced</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">xx</span><span class="o">}</span> <span class="n">_</span> <span class="c1">-- ERROR</span>
</code></pre></div>
<p>The fail is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">probability_space</span> <span class="n">α</span><span class="o">,</span>
<span class="n">_inst_2</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">β</span><span class="o">,</span>
<span class="n">XX</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">,</span>
<span class="n">xx</span> <span class="n">c</span> <span class="o">:</span> <span class="n">β</span>
<span class="bp">⊢</span> <span class="n">has_le</span> <span class="n">β</span>
</code></pre></div>
<p>where the whole file is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.lebesgue_measure</span>
<span class="kn">open</span> <span class="n">measure_theory</span>
<span class="kd">noncomputable theory</span>

<span class="kd">class</span> <span class="n">probability_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">measure_space</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_probability_measure</span> <span class="o">:</span>  <span class="n">probability_measure</span> <span class="n">volume</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">probability_space</span>

<span class="kd">lemma</span> <span class="n">volume_univ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">volume</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
  <span class="n">is_probability_measure.measure_univ</span>

<span class="kd">def</span> <span class="n">prob</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_measurable</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">ennreal</span> <span class="o">:=</span>
  <span class="n">volume</span> <span class="n">S</span>

<span class="kd">end</span> <span class="n">probability_space</span>

<span class="kd">structure</span> <span class="n">random_variable</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">outcome</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_measurable_outcome</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">outcome</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">random_variable</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">outcome</span><span class="o">⟩</span>
<span class="kd">lemma</span> <span class="n">measurable</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">X.is_measurable_outcome</span>

<span class="kd">def</span> <span class="n">induced</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">probability_space</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">volume</span> <span class="o">:=</span> <span class="n">measure.map</span> <span class="n">X</span> <span class="n">volume</span><span class="o">,</span>
  <span class="n">is_probability_measure</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="n">erw</span> <span class="n">measure_theory.measure.map_apply</span> <span class="n">X.measurable</span> <span class="n">is_measurable.univ</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">probability_space.volume_univ</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">distribution_function</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ennreal</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
  <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">_</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span> <span class="n">is_measurable_Iic</span>

<span class="kd">lemma</span> <span class="n">is_measurable_measurable_with_le</span> <span class="o">(</span><span class="n">xx</span><span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_measurable</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">xx</span><span class="o">}</span> <span class="o">:=</span>
  <span class="n">sorry</span>

<span class="kd">variable</span> <span class="n">XX</span><span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span>
<span class="kd">variable</span> <span class="n">xx</span> <span class="o">:</span> <span class="n">β</span>
<span class="kd">variable</span> <span class="n">Xlte</span> <span class="o">:</span> <span class="n">has_le</span> <span class="n">β</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">β</span> <span class="n">XX.induced</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">xx</span><span class="o">}</span> <span class="n">_</span>  <span class="c1">-- probability_space.prob ?M_1 : ennreal</span>

<span class="kd">def</span> <span class="n">generalized_distribution_function</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">β</span> <span class="n">XX.induced</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">xx</span><span class="o">}</span> <span class="n">_</span> <span class="c1">-- ERROR</span>

<span class="kd">end</span> <span class="n">random_variable</span>
</code></pre></div>



<a name="220424271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220424271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220424271">(Dec 18 2020 at 20:27)</a>:</h4>
<p>As you can see, your variable <code>Xlte</code> is nowhere in your local context. <code>has_le</code> is a typeclass, so you need to use square brackets. Note that <code>has_le</code> is just an arbitrary relation, and whilst I know nothing about probability theory or measure theory, assuming <code>[has_le \beta]</code> is a very weak statement.</p>



<a name="220444096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220444096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220444096">(Dec 19 2020 at 00:38)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I figured out how to state things in a way that typechecks.  Not quite done yet, I want to replace <code>ennreal</code> with real interval <code>[0,1]</code> following <span class="user-mention" data-user-id="243562">@Adam Topaz</span> 's hint.  Here is how it is with <code>ennreal</code>.  There is just no <code>sorry</code>. Instead I introduced a new structure <code>is_measurable_with_le</code> to hold the proof that the set is measurable.  It's a punt, but a more well-defined punt:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.lebesgue_measure</span>
<span class="kn">open</span> <span class="n">measure_theory</span>
<span class="kd">noncomputable theory</span>

<span class="kd">class</span> <span class="n">probability_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">measure_space</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_probability_measure</span> <span class="o">:</span>  <span class="n">probability_measure</span> <span class="n">volume</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">probability_space</span>

<span class="kd">lemma</span> <span class="n">volume_univ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">volume</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
  <span class="n">is_probability_measure.measure_univ</span>

<span class="kd">def</span> <span class="n">prob</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_measurable</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">ennreal</span> <span class="o">:=</span>
  <span class="n">volume</span> <span class="n">S</span>

<span class="kd">end</span> <span class="n">probability_space</span>

<span class="kd">structure</span> <span class="n">random_variable</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">outcome</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_measurable_outcome</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">outcome</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">random_variable</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">outcome</span><span class="o">⟩</span>
<span class="kd">lemma</span> <span class="n">measurable</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">X.is_measurable_outcome</span>

<span class="kd">def</span> <span class="n">induced</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">probability_space</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">volume</span> <span class="o">:=</span> <span class="n">measure.map</span> <span class="n">X</span> <span class="n">volume</span><span class="o">,</span>
  <span class="n">is_probability_measure</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="n">erw</span> <span class="n">measure_theory.measure.map_apply</span> <span class="n">X.measurable</span> <span class="n">is_measurable.univ</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">probability_space.volume_univ</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">distribution_function</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ennreal</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
  <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">_</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span> <span class="n">is_measurable_Iic</span>

<span class="kd">structure</span> <span class="n">is_measurable_with_le</span> <span class="o">(</span><span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">proof</span><span class="o">:</span> <span class="n">is_measurable</span> <span class="o">{</span><span class="n">c</span><span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">})</span>

<span class="kd">def</span> <span class="n">generalized_distribution_function</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">mb</span><span class="o">:</span> <span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span>
          <span class="o">[</span><span class="n">po</span><span class="o">:</span> <span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">X</span><span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">im</span><span class="o">:</span> <span class="bp">@</span><span class="n">is_measurable_with_le</span> <span class="n">β</span> <span class="n">b</span> <span class="n">mb</span> <span class="n">po</span><span class="o">]</span>  <span class="o">:=</span>
    <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">β</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">}</span> <span class="n">im.proof</span>

<span class="kd">end</span> <span class="n">random_variable</span>
</code></pre></div>



<a name="220447077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220447077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220447077">(Dec 19 2020 at 01:46)</a>:</h4>
<p>Here are some theorems. Try filling the sorries at the end.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.lebesgue_measure</span>
<span class="kn">open</span> <span class="n">measure_theory</span>
<span class="kd">noncomputable theory</span>

<span class="kd">class</span> <span class="n">probability_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">measure_space</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_probability_measure</span> <span class="o">:</span>  <span class="n">probability_measure</span> <span class="n">volume</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">probability_space</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">volume_univ</span> <span class="o">:</span> <span class="n">volume</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">is_probability_measure.measure_univ</span>

<span class="kd">lemma</span> <span class="n">volume_le_one</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">volume</span> <span class="n">S</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="bp">←</span> <span class="bp">@</span><span class="n">volume_univ</span> <span class="n">α</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">measure_mono</span> <span class="o">(</span><span class="n">set.subset_univ</span> <span class="n">_</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">prob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">volume</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">to_real</span>

<span class="kd">def</span> <span class="n">nnprob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">nnreal</span> <span class="o">:=</span> <span class="o">(</span><span class="n">volume</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">to_nnreal</span>

<span class="kd">theorem</span> <span class="n">volume_eq_nnprob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">volume</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">nnprob</span> <span class="n">S</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">ennreal.coe_to_nnreal</span> <span class="bp">$</span> <span class="n">ne_top_of_le_ne_top</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rintro</span> <span class="o">⟨⟩)</span> <span class="o">(</span><span class="n">volume_le_one</span> <span class="n">S</span><span class="o">))</span><span class="bp">.</span><span class="n">symm</span>

<span class="kd">theorem</span> <span class="n">prob_eq_nnprob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">prob</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">nnprob</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">nnprob_le_one</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">nnprob</span> <span class="n">S</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">ennreal.coe_le_coe.1</span> <span class="bp">$</span> <span class="kd">by</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">volume_eq_nnprob</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">volume_le_one</span> <span class="n">S</span>

<span class="kd">theorem</span> <span class="n">prob_le_one</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">prob</span> <span class="n">S</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">nnprob_le_one</span> <span class="n">_</span>

<span class="kd">theorem</span> <span class="n">zero_le_prob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">prob</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">nnreal.zero_le_coe</span>

<span class="kd">theorem</span> <span class="n">nnprob_mono</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="n">nnprob</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">nnprob</span> <span class="n">T</span> <span class="o">:=</span>
<span class="n">ennreal.coe_le_coe.1</span> <span class="bp">$</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span> <span class="n">volume_eq_nnprob</span><span class="o">]</span> <span class="n">using</span> <span class="n">measure_mono</span> <span class="n">h</span>

<span class="kd">theorem</span> <span class="n">prob_mono</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="n">prob</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">prob</span> <span class="n">T</span> <span class="o">:=</span>
<span class="n">nnreal.coe_le_coe.2</span> <span class="bp">$</span> <span class="n">nnprob_mono</span> <span class="n">h</span>

<span class="kd">end</span> <span class="n">probability_space</span>

<span class="kd">theorem</span> <span class="n">measurable.map_probability_measure</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">probability_measure</span> <span class="o">(</span><span class="n">measure.map</span> <span class="n">f</span> <span class="n">volume</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="kd">by</span> <span class="n">rw</span> <span class="n">measure_theory.measure.map_apply</span> <span class="n">hf</span> <span class="n">is_measurable.univ</span><span class="bp">;</span>
    <span class="n">exact</span> <span class="n">probability_space.volume_univ</span><span class="o">⟩</span>

<span class="kd">structure</span> <span class="n">random_variable</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">outcome</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_measurable_outcome</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">outcome</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">random_variable</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">outcome</span><span class="o">⟩</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
<span class="kd">lemma</span> <span class="n">measurable</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">X.is_measurable_outcome</span>

<span class="kd">def</span> <span class="n">induced</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">probability_space</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">volume</span> <span class="o">:=</span> <span class="n">measure.map</span> <span class="n">X</span> <span class="n">volume</span><span class="o">,</span>
  <span class="n">is_probability_measure</span> <span class="o">:=</span> <span class="n">X.measurable.map_probability_measure</span> <span class="o">}</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">CDF</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">_</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span>

<span class="kd">theorem</span> <span class="n">zero_le_CDF</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">X.CDF</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">theorem</span> <span class="n">CDF_le_one</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">X.CDF</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">theorem</span> <span class="n">CDF_mono</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">X.CDF</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">X.CDF</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">order_closed_topology</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">opens_measurable_space</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_measurable</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">}</span> <span class="o">:=</span> <span class="n">is_closed.is_measurable</span> <span class="n">is_closed_Iic</span>

<span class="kd">end</span> <span class="n">random_variable</span>
</code></pre></div>



<a name="220448291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220448291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220448291">(Dec 19 2020 at 02:14)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I will work on that.</p>



<a name="220481139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220481139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220481139">(Dec 19 2020 at 18:23)</a>:</h4>
<p>I was able to prove <code>zero_le_CDF</code> and <code>CDF_le_one</code>.  I am stuck on <code>CDF_mono</code>.  I have it reduced to a proposition of form A implies B where I know B.   I have a lemma for A.  I don't know how to introduce the results of A into the hypothesis set.  That's a simple Lean thing but I don't know how to do it.  Then if I had that I could finish.   Also I have to prove A which also seems simple but I don't know how to get started.   Where</p>
<ul>
<li><code>A</code> is<code>{c : β | c ≤ x} ⊆ {c : β | c ≤ y} </code></li>
<li><code>B</code> is <code>@probability_space.prob_mono β X.induced {c : β | c ≤ x} {c : β | c ≤ y}  to hp</code></li>
</ul>
<p>Here is the sketch so far.  The part where I'm stuck as at the bottom:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.lebesgue_measure</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">noncomputable theory</span>

<span class="kn">open</span> <span class="n">measure_theory</span>

<span class="kd">class</span> <span class="n">probability_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">measure_space</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_probability_measure</span> <span class="o">:</span>  <span class="n">probability_measure</span> <span class="n">volume</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">probability_space</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">volume_univ</span> <span class="o">:</span> <span class="n">volume</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">is_probability_measure.measure_univ</span>

<span class="kd">lemma</span> <span class="n">volume_le_one</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">volume</span> <span class="n">S</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="bp">←</span> <span class="bp">@</span><span class="n">volume_univ</span> <span class="n">α</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">measure_mono</span> <span class="o">(</span><span class="n">set.subset_univ</span> <span class="n">_</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">prob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">volume</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">to_real</span>

<span class="kd">def</span> <span class="n">nnprob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">nnreal</span> <span class="o">:=</span> <span class="o">(</span><span class="n">volume</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">to_nnreal</span>

<span class="kd">theorem</span> <span class="n">volume_eq_nnprob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">volume</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">nnprob</span> <span class="n">S</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">ennreal.coe_to_nnreal</span> <span class="bp">$</span> <span class="n">ne_top_of_le_ne_top</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rintro</span> <span class="o">⟨⟩)</span> <span class="o">(</span><span class="n">volume_le_one</span> <span class="n">S</span><span class="o">))</span><span class="bp">.</span><span class="n">symm</span>

<span class="kd">theorem</span> <span class="n">prob_eq_nnprob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">prob</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">nnprob</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">nnprob_le_one</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">nnprob</span> <span class="n">S</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">ennreal.coe_le_coe.1</span> <span class="bp">$</span> <span class="kd">by</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">volume_eq_nnprob</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">volume_le_one</span> <span class="n">S</span>

<span class="kd">theorem</span> <span class="n">prob_le_one</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">prob</span> <span class="n">S</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">nnprob_le_one</span> <span class="n">_</span>

<span class="kd">theorem</span> <span class="n">zero_le_prob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">prob</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">nnreal.zero_le_coe</span>

<span class="kd">theorem</span> <span class="n">nnprob_mono</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="n">nnprob</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">nnprob</span> <span class="n">T</span> <span class="o">:=</span>
<span class="n">ennreal.coe_le_coe.1</span> <span class="bp">$</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span> <span class="n">volume_eq_nnprob</span><span class="o">]</span> <span class="n">using</span> <span class="n">measure_mono</span> <span class="n">h</span>

<span class="kd">theorem</span> <span class="n">prob_mono</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="n">prob</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">prob</span> <span class="n">T</span> <span class="o">:=</span>
<span class="n">nnreal.coe_le_coe.2</span> <span class="bp">$</span> <span class="n">nnprob_mono</span> <span class="n">h</span>

<span class="kd">end</span> <span class="n">probability_space</span>

<span class="kd">theorem</span> <span class="n">measurable.map_probability_measure</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">probability_measure</span> <span class="o">(</span><span class="n">measure.map</span> <span class="n">f</span> <span class="n">volume</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="kd">by</span> <span class="n">rw</span> <span class="n">measure_theory.measure.map_apply</span> <span class="n">hf</span> <span class="n">is_measurable.univ</span><span class="bp">;</span>
    <span class="n">exact</span> <span class="n">probability_space.volume_univ</span><span class="o">⟩</span>

<span class="kd">structure</span> <span class="n">random_variable</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">outcome</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_measurable_outcome</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">outcome</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">random_variable</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">outcome</span><span class="o">⟩</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
<span class="kd">lemma</span> <span class="n">measurable</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">X.is_measurable_outcome</span>

<span class="kd">def</span> <span class="n">induced</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">probability_space</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">volume</span> <span class="o">:=</span> <span class="n">measure.map</span> <span class="n">X</span> <span class="n">volume</span><span class="o">,</span>
  <span class="n">is_probability_measure</span> <span class="o">:=</span> <span class="n">X.measurable.map_probability_measure</span> <span class="o">}</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">CDF</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">_</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">order_closed_topology</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">opens_measurable_space</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_measurable</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">}</span> <span class="o">:=</span> <span class="n">is_closed.is_measurable</span> <span class="n">is_closed_Iic</span>

<span class="kd">lemma</span> <span class="n">prob_eq_CDF</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">X.CDF</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">β</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">zero_le_CDF</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">X.CDF</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">prob_eq_CDF</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="bp">@</span><span class="n">probability_space.zero_le_prob</span> <span class="n">β</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}),</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">CDF_le_one</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">X.CDF</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">prob_eq_CDF</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="bp">@</span><span class="n">probability_space.prob_le_one</span> <span class="n">β</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">factoid</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span> <span class="o">):</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span> <span class="bp">⊆</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span>   <span class="c1">-- STUCK</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">CDF_mono</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">X.CDF</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">X.CDF</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">prob_eq_CDF</span> <span class="o">},</span>
  <span class="c1">-- introduce hp: factoid(x y)  -- STUCK</span>
  <span class="c1">-- apply @probability_space.prob_mono β X.induced {c : β | c ≤ x} {c : β | c ≤ y}  to hp</span>
  <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">random_variable</span>
</code></pre></div>



<a name="220481383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220481383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220481383">(Dec 19 2020 at 18:31)</a>:</h4>
<p>The <code>factoid</code> is false, because you forgot the essential assumption <code>x &lt;= y</code>! Do you see why this theorem should be true mathematically?</p>



<a name="220481575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220481575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220481575">(Dec 19 2020 at 18:37)</a>:</h4>
<p>also you changed the theorems I wrote by moving them after the <code>variables [topological_space beta]...</code> line. They were written before that line because they don't require any of that stuff to be proven</p>



<a name="220481659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220481659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220481659">(Dec 19 2020 at 18:39)</a>:</h4>
<p>In fact, I think that line is wrong; indeed there shouldn't be any measurable space structure on beta, because the theorems are all about <code>X.induced</code> which uses only the measurable structure on alpha</p>



<a name="220482560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220482560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220482560">(Dec 19 2020 at 19:03)</a>:</h4>
<p>I moved those up just to put the <code>sorry</code> parts the bottom.  I will move back down.   How is this for <code>factoid</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">factoid</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span> <span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span> <span class="bp">⊆</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>Given <code>factoid</code> what's the proof language to introduce the result of a <code>lemma</code> into the hypothesis set?  If I have revised <code>factoid</code> then I need that to apply here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">CDF_mono</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">X.CDF</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">X.CDF</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">prob_eq_CDF</span> <span class="o">},</span>
  <span class="c1">-- introduce hp: factoid(x y)</span>
  <span class="c1">-- apply @probability_space.prob_mono β X.induced {c : β | c ≤ x} {c : β | c ≤ y}  to hp</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>The revised sketch is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.lebesgue_measure</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">noncomputable theory</span>

<span class="kn">open</span> <span class="n">measure_theory</span>

<span class="kd">class</span> <span class="n">probability_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">measure_space</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_probability_measure</span> <span class="o">:</span>  <span class="n">probability_measure</span> <span class="n">volume</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">probability_space</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">volume_univ</span> <span class="o">:</span> <span class="n">volume</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">is_probability_measure.measure_univ</span>

<span class="kd">lemma</span> <span class="n">volume_le_one</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">volume</span> <span class="n">S</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="bp">←</span> <span class="bp">@</span><span class="n">volume_univ</span> <span class="n">α</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">measure_mono</span> <span class="o">(</span><span class="n">set.subset_univ</span> <span class="n">_</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">prob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">volume</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">to_real</span>

<span class="kd">def</span> <span class="n">nnprob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">nnreal</span> <span class="o">:=</span> <span class="o">(</span><span class="n">volume</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">to_nnreal</span>

<span class="kd">theorem</span> <span class="n">volume_eq_nnprob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">volume</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">nnprob</span> <span class="n">S</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">ennreal.coe_to_nnreal</span> <span class="bp">$</span> <span class="n">ne_top_of_le_ne_top</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rintro</span> <span class="o">⟨⟩)</span> <span class="o">(</span><span class="n">volume_le_one</span> <span class="n">S</span><span class="o">))</span><span class="bp">.</span><span class="n">symm</span>

<span class="kd">theorem</span> <span class="n">prob_eq_nnprob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">prob</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">nnprob</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">nnprob_le_one</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">nnprob</span> <span class="n">S</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">ennreal.coe_le_coe.1</span> <span class="bp">$</span> <span class="kd">by</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">volume_eq_nnprob</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">volume_le_one</span> <span class="n">S</span>

<span class="kd">theorem</span> <span class="n">prob_le_one</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">prob</span> <span class="n">S</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">nnprob_le_one</span> <span class="n">_</span>

<span class="kd">theorem</span> <span class="n">zero_le_prob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">prob</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">nnreal.zero_le_coe</span>

<span class="kd">theorem</span> <span class="n">nnprob_mono</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="n">nnprob</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">nnprob</span> <span class="n">T</span> <span class="o">:=</span>
<span class="n">ennreal.coe_le_coe.1</span> <span class="bp">$</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span> <span class="n">volume_eq_nnprob</span><span class="o">]</span> <span class="n">using</span> <span class="n">measure_mono</span> <span class="n">h</span>

<span class="kd">theorem</span> <span class="n">prob_mono</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="n">prob</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">prob</span> <span class="n">T</span> <span class="o">:=</span>
<span class="n">nnreal.coe_le_coe.2</span> <span class="bp">$</span> <span class="n">nnprob_mono</span> <span class="n">h</span>

<span class="kd">end</span> <span class="n">probability_space</span>

<span class="kd">theorem</span> <span class="n">measurable.map_probability_measure</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">probability_measure</span> <span class="o">(</span><span class="n">measure.map</span> <span class="n">f</span> <span class="n">volume</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="kd">by</span> <span class="n">rw</span> <span class="n">measure_theory.measure.map_apply</span> <span class="n">hf</span> <span class="n">is_measurable.univ</span><span class="bp">;</span>
    <span class="n">exact</span> <span class="n">probability_space.volume_univ</span><span class="o">⟩</span>

<span class="kd">structure</span> <span class="n">random_variable</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">outcome</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_measurable_outcome</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">outcome</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">random_variable</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">outcome</span><span class="o">⟩</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
<span class="kd">lemma</span> <span class="n">measurable</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">X.is_measurable_outcome</span>

<span class="kd">def</span> <span class="n">induced</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">probability_space</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">volume</span> <span class="o">:=</span> <span class="n">measure.map</span> <span class="n">X</span> <span class="n">volume</span><span class="o">,</span>
  <span class="n">is_probability_measure</span> <span class="o">:=</span> <span class="n">X.measurable.map_probability_measure</span> <span class="o">}</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">CDF</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">_</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">prob_eq_CDF</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">X.CDF</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">β</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">zero_le_CDF</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">X.CDF</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">prob_eq_CDF</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="bp">@</span><span class="n">probability_space.zero_le_prob</span> <span class="n">β</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}),</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">CDF_le_one</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">X.CDF</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">prob_eq_CDF</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="bp">@</span><span class="n">probability_space.prob_le_one</span> <span class="n">β</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">factoid</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span> <span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span> <span class="bp">⊆</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">CDF_mono</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">X.CDF</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">X.CDF</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">prob_eq_CDF</span> <span class="o">},</span>
  <span class="c1">-- introduce hp: factoid(x y)</span>
  <span class="c1">-- apply @probability_space.prob_mono β X.induced {c : β | c ≤ x} {c : β | c ≤ y}  to hp</span>
  <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">order_closed_topology</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">opens_measurable_space</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_measurable</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">}</span> <span class="o">:=</span> <span class="n">is_closed.is_measurable</span> <span class="n">is_closed_Iic</span>

<span class="kd">end</span> <span class="n">random_variable</span>
</code></pre></div>



<a name="220483690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220483690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220483690">(Dec 19 2020 at 19:32)</a>:</h4>
<p>Have you read <a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a> or played the <a href="https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/">natural number game</a>? They introduce all the tools you need to write proofs. In this case, you need <code>have := factoid x y h</code>.</p>



<a name="220484882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220484882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220484882">(Dec 19 2020 at 19:59)</a>:</h4>
<p>Yes I did both but in their examples the <code>have</code> is usually something like <code>have hp : p, from h.left</code> so a labelled proposition from a tactic applied to the existing goal state.  I didn't find any examples in <a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a>  of <code>have := </code> with a term.  In <a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a> and the number game, lemmas and theorems are used into introduce equalities that get applied with <code>rw</code> tactic or implications that get applied with <code>apply</code> or <code>exact</code>.</p>



<a name="220484887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220484887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220484887">(Dec 19 2020 at 19:59)</a>:</h4>
<p>Anyway, DONE:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.lebesgue_measure</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">noncomputable theory</span>

<span class="kn">open</span> <span class="n">measure_theory</span>

<span class="kd">class</span> <span class="n">probability_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">measure_space</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_probability_measure</span> <span class="o">:</span>  <span class="n">probability_measure</span> <span class="n">volume</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">probability_space</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">volume_univ</span> <span class="o">:</span> <span class="n">volume</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">is_probability_measure.measure_univ</span>

<span class="kd">lemma</span> <span class="n">volume_le_one</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">volume</span> <span class="n">S</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="bp">←</span> <span class="bp">@</span><span class="n">volume_univ</span> <span class="n">α</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">measure_mono</span> <span class="o">(</span><span class="n">set.subset_univ</span> <span class="n">_</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">prob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">volume</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">to_real</span>

<span class="kd">def</span> <span class="n">nnprob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">nnreal</span> <span class="o">:=</span> <span class="o">(</span><span class="n">volume</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">to_nnreal</span>

<span class="kd">theorem</span> <span class="n">volume_eq_nnprob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">volume</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">nnprob</span> <span class="n">S</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">ennreal.coe_to_nnreal</span> <span class="bp">$</span> <span class="n">ne_top_of_le_ne_top</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rintro</span> <span class="o">⟨⟩)</span> <span class="o">(</span><span class="n">volume_le_one</span> <span class="n">S</span><span class="o">))</span><span class="bp">.</span><span class="n">symm</span>

<span class="kd">theorem</span> <span class="n">prob_eq_nnprob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">prob</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">nnprob</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">nnprob_le_one</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">nnprob</span> <span class="n">S</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">ennreal.coe_le_coe.1</span> <span class="bp">$</span> <span class="kd">by</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">volume_eq_nnprob</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">volume_le_one</span> <span class="n">S</span>

<span class="kd">theorem</span> <span class="n">prob_le_one</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">prob</span> <span class="n">S</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">nnprob_le_one</span> <span class="n">_</span>

<span class="kd">theorem</span> <span class="n">zero_le_prob</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">prob</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">nnreal.zero_le_coe</span>

<span class="kd">theorem</span> <span class="n">nnprob_mono</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="n">nnprob</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">nnprob</span> <span class="n">T</span> <span class="o">:=</span>
<span class="n">ennreal.coe_le_coe.1</span> <span class="bp">$</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span> <span class="n">volume_eq_nnprob</span><span class="o">]</span> <span class="n">using</span> <span class="n">measure_mono</span> <span class="n">h</span>

<span class="kd">theorem</span> <span class="n">prob_mono</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="n">prob</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">prob</span> <span class="n">T</span> <span class="o">:=</span>
<span class="n">nnreal.coe_le_coe.2</span> <span class="bp">$</span> <span class="n">nnprob_mono</span> <span class="n">h</span>

<span class="kd">end</span> <span class="n">probability_space</span>

<span class="kd">theorem</span> <span class="n">measurable.map_probability_measure</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">probability_measure</span> <span class="o">(</span><span class="n">measure.map</span> <span class="n">f</span> <span class="n">volume</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="kd">by</span> <span class="n">rw</span> <span class="n">measure_theory.measure.map_apply</span> <span class="n">hf</span> <span class="n">is_measurable.univ</span><span class="bp">;</span>
    <span class="n">exact</span> <span class="n">probability_space.volume_univ</span><span class="o">⟩</span>

<span class="kd">structure</span> <span class="n">random_variable</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">outcome</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_measurable_outcome</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">outcome</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">probability_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="n">β</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">random_variable</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">outcome</span><span class="o">⟩</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
<span class="kd">lemma</span> <span class="n">measurable</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">X.is_measurable_outcome</span>

<span class="kd">def</span> <span class="n">induced</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">probability_space</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">volume</span> <span class="o">:=</span> <span class="n">measure.map</span> <span class="n">X</span> <span class="n">volume</span><span class="o">,</span>
  <span class="n">is_probability_measure</span> <span class="o">:=</span> <span class="n">X.measurable.map_probability_measure</span> <span class="o">}</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">CDF</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">_</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">prob_eq_CDF</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">X.CDF</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">probability_space.prob</span> <span class="n">β</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">zero_le_CDF</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">X.CDF</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">prob_eq_CDF</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="bp">@</span><span class="n">probability_space.zero_le_prob</span> <span class="n">β</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}),</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">CDF_le_one</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">X.CDF</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">prob_eq_CDF</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="bp">@</span><span class="n">probability_space.prob_le_one</span> <span class="n">β</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">factoid</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span> <span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span> <span class="bp">⊆</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">}</span> <span class="o">:=</span>
  <span class="n">set.Iic_subset_Iic.mpr</span> <span class="n">h</span>

<span class="kd">theorem</span> <span class="n">CDF_mono</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">X.CDF</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">X.CDF</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">prob_eq_CDF</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:=</span> <span class="n">factoid</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">probability_space.prob_mono</span> <span class="n">β</span> <span class="n">X.induced</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">},</span>
  <span class="n">exact</span> <span class="n">h2</span> <span class="n">h1</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">order_closed_topology</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">opens_measurable_space</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_measurable</span> <span class="o">{</span><span class="n">c</span> <span class="bp">|</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">}</span> <span class="o">:=</span> <span class="n">is_closed.is_measurable</span> <span class="n">is_closed_Iic</span>

<span class="kd">end</span> <span class="n">random_variable</span>
</code></pre></div>



<a name="220485717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220485717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220485717">(Dec 19 2020 at 20:21)</a>:</h4>
<p>In your example <code>h.left</code> is a term</p>



<a name="220485773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220485773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220485773">(Dec 19 2020 at 20:22)</a>:</h4>
<p>Note that <code>have :=</code> (which is part of the less abbreviated <code>have h : t := term</code>) is the tactic mode version; the term mode version is <code>have h : t, from term,</code>.</p>



<a name="220485901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220485901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220485901">(Dec 19 2020 at 20:26)</a>:</h4>
<p>It looks like <code>have</code> is introduced in <a href="https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/?world=5&amp;level=3">https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/?world=5&amp;level=3</a></p>



<a name="220486264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220486264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220486264">(Dec 19 2020 at 20:36)</a>:</h4>
<p>Thanks you are correct!  In terms of my original generalized <code>distribution_function</code> goal, the above can be trimmed down to the assumption that  a random variable is from a probability space α  to a measurable space  β which is a preorder.  <code>CDF</code> is from β to ℝ.  Ideally it should be to <code>set.Icc (0: ℝ) 1</code>.  I guess the additional theorems will help me prove that and restate <code>def CDF (x : β) : ℝ </code> as <code>def CDF (x : β) : set.Icc (0: ℝ) 1</code>?  The example at the end shows how to prove that <code>{c | c ≤ b}</code> is measurable for a type which is a topological space, an order closed topology and a measurable space.  Bu those don't seem to be conditions required by the <code>factoid</code>, which only needs <code>preorder</code>.  Are all these properties needed for anything or just measurable space with preorder?</p>



<a name="220486919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220486919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220486919">(Dec 19 2020 at 20:55)</a>:</h4>
<blockquote>
<p>Ideally it should be to set.Icc (0: ℝ) 1.</p>
</blockquote>
<p>As you can see, we have theorems that it is between zero and one. This is generally preferable up until you actually need to put it into a structure that expects <code>set.Icc (0: ℝ) 1</code>, which you don't currently have</p>



<a name="220486981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220486981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220486981">(Dec 19 2020 at 20:57)</a>:</h4>
<blockquote>
<p>The example at the end shows how to prove that {c | c ≤ b} is measurable for a type which is a topological space, an order closed topology and a measurable space. Bu those don't seem to be conditions required by the factoid, which only needs preorder. Are all these properties needed for anything or just measurable space with preorder?</p>
</blockquote>
<p>I put it as an <code>example</code> to show that it is derivable, but so far nothing actually needs those assumptions. You haven't done anything that requires <code>{c | c ≤ b}</code> to be measurable yet, but if you do those are the assumptions you will need (at that point, and not before)</p>



<a name="220487082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220487082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220487082">(Dec 19 2020 at 21:00)</a>:</h4>
<p>Can you help me with the mechanics of this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">distribution_function</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>  <span class="n">set.Icc</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="mi">1</span> <span class="o">:=</span> <span class="o">(</span><span class="n">CDF</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">to_set_Icc_01</span>
</code></pre></div>
<p>It seems I would need to define</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">nat.to_set_Icc_01</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>
<p>but that doesn't use the 0/1 theorems and doesn't seem right.</p>



<a name="220487159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220487159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220487159">(Dec 19 2020 at 21:02)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">CDF_in_01</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="mi">1</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">X.CDF</span> <span class="n">x</span><span class="o">,</span> <span class="n">X.zero_le_CDF</span> <span class="n">x</span><span class="o">,</span> <span class="n">X.CDF_le_one</span> <span class="n">x</span><span class="o">⟩</span>
</code></pre></div>



<a name="220487162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220487162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220487162">(Dec 19 2020 at 21:02)</a>:</h4>
<p>to reiterate, don't use this unless you need it</p>



<a name="220487190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220487190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220487190">(Dec 19 2020 at 21:03)</a>:</h4>
<p>It's in the nature of CDF, what would be the aesthetic or practical reason not to constrain the codomain in this way?</p>



<a name="220487239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220487239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220487239">(Dec 19 2020 at 21:04)</a>:</h4>
<p>because <code>real</code> has operations on it, like addition, while <code>set.Icc 0 1</code> doesn't</p>



<a name="220487262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220487262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220487262">(Dec 19 2020 at 21:05)</a>:</h4>
<p>Anyway isn't it exciting to know that CDF can be generalized to any measurable space with a preorder?  It's maybe a useless fact but I've never seen it in any presentation of CDF.</p>



<a name="220487317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220487317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220487317">(Dec 19 2020 at 21:06)</a>:</h4>
<p>Sure, this kind of "trivial generalization" comes up all the time in mathlib. It makes you consider questions the original authors hadn't thought about, like what closure properties are needed to prove that the CDF is left-continuous?</p>



<a name="220487342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220487342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220487342">(Dec 19 2020 at 21:07)</a>:</h4>
<p>You just read what the authors say, delete all the assumptions, and then just add the assumptions if they become necessary and not before</p>



<a name="220487383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220487383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220487383">(Dec 19 2020 at 21:08)</a>:</h4>
<p>A nonzero proportion of the time you never add some of them back</p>



<a name="220487407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220487407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220487407">(Dec 19 2020 at 21:08)</a>:</h4>
<p>In fact mathlib has a linter which will do this for you</p>



<a name="220487541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220487541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220487541">(Dec 19 2020 at 21:12)</a>:</h4>
<p>If you don't mind my quoting your proof above, I can now close <a href="https://math.stackexchange.com/questions/3780089/extending-the-concept-of-distribution-function-to-any-totally-or-partially-order/3782009?noredirect=1#comment7787969_3782009">my old Stack Exchange question</a>  with a definitive answer. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>
</code></pre></div>



<a name="220487688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220487688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220487688">(Dec 19 2020 at 21:17)</a>:</h4>
<p>It seems that you got an answer in that question already:</p>
<blockquote>
<p>CDFs are defined only for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> (even for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>) and are used for convenience. The push-forward is of a measure <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">μ</span></span></span></span> by a Random variable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>:</mo><mo stretchy="false">(</mo><mi mathvariant="normal">Ω</mi><mo separator="true">,</mo><mi mathvariant="script">F</mi><mo separator="true">,</mo><mi>μ</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>S</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X:(\Omega,\mathscr{F},\mu)\rightarrow(S,\Sigma)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">Ω</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathscr" style="margin-right:0.13634em;">F</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">μ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mclose">)</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>X</mi></msub><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><mi>μ</mi><mo stretchy="false">(</mo><mi>X</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mu_X(A):=\mu(X\in A)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">μ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> is the object of interest and it is as general as it can be, since <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>S</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(S,\Sigma)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mclose">)</span></span></span></span> has no structure other than being a measurable space.</p>
</blockquote>



<a name="220487735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220487735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220487735">(Dec 19 2020 at 21:18)</a>:</h4>
<p>This is another way to say that in a more general context we stop talking about the CDF because the pushforward measure is more general</p>



<a name="220487761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220487761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220487761">(Dec 19 2020 at 21:19)</a>:</h4>
<p>A CDF is only useful to the extent that it determines the pushforward measure</p>



<a name="220488052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488052">(Dec 19 2020 at 21:27)</a>:</h4>
<p>CDF is defined on points in <code>S</code>.  The convention is that only the case <code>S=R</code> has any use.  What we showed is that if <code>S</code> is any measurable space with a preorder, <code>CDF</code> can still be computed and give back a number in <code>[0,1]</code>.  So  I can define a preorder on a domain like binary expression trees of depth at most <code>n</code> and compute the <code>CDF</code> of a tree in the space of all binary trees depth at most <code>n</code>.  I can say that and say that it is interesting to me because it is.  This has nothing to do with using <code>CDF</code> to determine the pushforward measure.  So that comment doesn't make any sense to me.  I got the result I was looking for, and it doesn't seem to be relevant to that comment.  That or it's not possible to put a preorder on binary trees, and continuing on in the vein, maybe the claim is that any measurable set with preorder is isomorphic to  <code>ℝ</code>.  Is that the case?</p>



<a name="220488108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488108">(Dec 19 2020 at 21:28)</a>:</h4>
<p>Yes you can compute a number, but the question is what does that number mean? It's not true for a general preorder that giving the CDF of the random variable uniquely determines the distribution of the variable</p>



<a name="220488122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488122">(Dec 19 2020 at 21:29)</a>:</h4>
<blockquote>
<p>maybe the claim is that any measurable set with preorder is isomorphic to ℝ. Is that the case?</p>
</blockquote>
<p>This is certainly not the case</p>



<a name="220488215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488215">(Dec 19 2020 at 21:31)</a>:</h4>
<p>you have a function called CDF, but that doesn't on its own mean much. Here's another function called CDF:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">CDF'</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">random_variable</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="mi">0</span>
</code></pre></div>
<p>This one doesn't even need a preorder structure on beta, so it's a clear improvement. It's also monotone, between 0 and 1, and right continuous</p>



<a name="220488412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488412">(Dec 19 2020 at 21:36)</a>:</h4>
<p>Except our CDF is proven to be a <code>probability_measure</code> on a <code>measurable_space</code> with <code>preorder</code>, by construction.  I'll take that.  It's not 0.</p>



<a name="220488417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488417">(Dec 19 2020 at 21:36)</a>:</h4>
<p>Our CDF is no such thing</p>



<a name="220488419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488419">(Dec 19 2020 at 21:36)</a>:</h4>
<p>it's a real function</p>



<a name="220488429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488429">(Dec 19 2020 at 21:36)</a>:</h4>
<p>I can put all those assumptions on <code>CDF'</code> too</p>



<a name="220488443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488443">(Dec 19 2020 at 21:37)</a>:</h4>
<p>Obviously <code>CDF'</code> is a silly function, but the point is that we haven't shown anything about <code>CDF</code> that makes it meaningfully different from <code>CDF'</code></p>



<a name="220488503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488503">(Dec 19 2020 at 21:38)</a>:</h4>
<p>And my claim is that the real theorem of interest that will distinguish the two doesn't hold on arbitrary preorders</p>



<a name="220488511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488511">(Dec 19 2020 at 21:38)</a>:</h4>
<p>Obtained by running <code>prob</code>, where <code>prob</code> was supplied as a <code>probability_measure</code> when building the initial probability space, and then running it through <code>induced</code> on the <code>random_variable</code>.   As long as you have a meaningful and correct <code>probability_space</code> to begin with, and a meaningful and correct <code>random_variable</code>, the <code>CDF</code> will be meaningful and correct and derived from the original <code>probability_space</code> and the supplied <code>random_variable</code>.  There is nothing trivial about it at all.</p>



<a name="220488519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488519">(Dec 19 2020 at 21:39)</a>:</h4>
<p>How do you know it is meaningful and correct?</p>



<a name="220488523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488523">(Dec 19 2020 at 21:39)</a>:</h4>
<p>That's what theorems are for</p>



<a name="220488526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488526">(Dec 19 2020 at 21:39)</a>:</h4>
<p>and we don't have any</p>



<a name="220488535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488535">(Dec 19 2020 at 21:39)</a>:</h4>
<p>except the obvious ones that are true also for <code>CDF'</code></p>



<a name="220488588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488588">(Dec 19 2020 at 21:40)</a>:</h4>
<p>If I start out with say the Steinhaus space and the definition of the random variable for the 2 point-distribution and crank it through I will get the distribution and distribution function for the 2-point random variable.  What's missing?</p>



<a name="220488599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488599">(Dec 19 2020 at 21:41)</a>:</h4>
<p>well that's over <code>real</code></p>



<a name="220488604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488604">(Dec 19 2020 at 21:41)</a>:</h4>
<p>I thought you wanted arbitrary preorders?</p>



<a name="220488626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488626">(Dec 19 2020 at 21:42)</a>:</h4>
<p>As another example we could compute distributions of binary trees of depth <code>n</code>.  This is something people actually think about.  Why can't I have a CDF of those?</p>



<a name="220488663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488663">(Dec 19 2020 at 21:42)</a>:</h4>
<p>The main theorem here is that two random variables with the same <code>CDF</code> are the same random variable</p>



<a name="220488666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488666">(Dec 19 2020 at 21:42)</a>:</h4>
<p>that's not true for <code>CDF'</code></p>



<a name="220488668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488668">(Dec 19 2020 at 21:42)</a>:</h4>
<p>and it's not true for <code>CDF</code> on some preorders</p>



<a name="220488702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488702">(Dec 19 2020 at 21:43)</a>:</h4>
<p>Really, I think it's not worth thinking about the CDF in the more unusual codomains. Just call <code>X.induced</code> CDF if it makes you feel better</p>



<a name="220488836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488836">(Dec 19 2020 at 21:46)</a>:</h4>
<p>So what you proved at the bottom required that <code>S</code> be a topological space, an order closed topology and an opens measurable space.    I don't need those assumptions for <code>def CDF</code>.   If I delete <code>variables [preorder β]</code>, then <code>def CDF</code> crashes.  It doesn't rely however on being topological space, order closed topology and opens measurable space.  Are you saying that I will crash if I try to define a random variable into binary trees of length N with a preorder, because of something I'm not understanding?</p>



<a name="220488843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488843">(Dec 19 2020 at 21:46)</a>:</h4>
<p>In measure theory, a distribution is no more or less than a measure. It takes all subsets of X as its input, and it doesn't need to be boiled down to a function on X</p>



<a name="220488927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488927">(Dec 19 2020 at 21:49)</a>:</h4>
<blockquote>
<p>I don't need those assumptions for def CDF. If I delete variables [preorder β], then def CDF crashes. It doesn't rely however on being topological space, order closed topology and opens measurable space. Are you saying that I will crash if I try to define a random variable into binary trees of length N with a preorder, because of something I'm not understanding?</p>
</blockquote>
<p>This is why you need to prove theorems about your definitions. It's perfectly possible that a definition can be <em>made</em> in some tremendous generality but it doesn't <em>make sense</em> without some more assumptions. In fact <code>def CDF</code> works using only <code>has_le beta</code>, it doesn't even need <code>preorder</code>, but it certainly doesn't <em>make sense</em> in that generality; we already have a theorem that will detect this nonsense, namely <code>CDF_mono</code>. WIthout that theorem you might well think that there are no problems with that definition</p>



<a name="220488932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488932">(Dec 19 2020 at 21:49)</a>:</h4>
<p>But you haven't tried to prove anything more complicated about <code>CDF</code> yet, and when you do you will find that <code>preorder beta</code> isn't good enough either</p>



<a name="220488994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220488994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220488994">(Dec 19 2020 at 21:51)</a>:</h4>
<p>It all comes back to the thing I mentioned earlier: how do people <em>use</em> the definition?</p>



<a name="220489000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220489000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220489000">(Dec 19 2020 at 21:51)</a>:</h4>
<p>making definitions doesn't tell you any deep truths about it, because you can very easily write nonsense without noticing</p>



<a name="220489039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220489039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220489039">(Dec 19 2020 at 21:52)</a>:</h4>
<p>but once you try to use the definition it all falls down</p>



<a name="220489163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220489163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220489163">(Dec 19 2020 at 21:56)</a>:</h4>
<p>Which brings me back to trees.  A long time ago I helped a mathematician counting trees to write <a href="https://www.researchgate.net/profile/Lars_Ericson4/publication/2809929_Enumeration_of_Tree_Properties_by_Naive_Methods/links/5592c72a08ae5af2b0eb59dd/Enumeration-of-Tree-Properties-by-Naive-Methods.pdf">a paper</a> making some probabiliistic arguments about operations on trees.   Conceivably, while doing that, in a practical sense, I might want to define a preorder on trees and compute the percentage of trees in the entire space of trees of size <code>n</code> which were "less than" a single particular tree, or an equivalence class of trees.   So that would be the CDF of a single tree.  It might be boring nonsense to almost everybody in the world, but for the two people in that room, it might be helpful.  So then the question, how much of this will fall down if my trees have a preorder but do not constitute a type which is a topological space, order closed topology and opens measurable space?  All of it, some of it or none of it?  And if it is all of it, can we go further and say that there is a 1-1 onto map between the reals and any such space?</p>



<a name="220489571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220489571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220489571">(Dec 19 2020 at 22:06)</a>:</h4>
<p>Even in this hypothetical scenario, you could just write down "the probability that a random tree is 'less than' the particular tree in question" and not bother with this CDF terminology stuff.</p>



<a name="220524662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220524662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220524662">(Dec 20 2020 at 15:37)</a>:</h4>
<p>Yes, I could write "the probability that a random tree is 'less than' the particular tree in question"  as <code>CDF T</code> after defining a preorder on trees, following the development of the generalized distribution function above, which establishes that I can do so in a well-typed way.   This is very helpful for me.  Thanks!</p>



<a name="220526880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220526880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220526880">(Dec 20 2020 at 16:36)</a>:</h4>
<p>But I think the answer to the question of why distribution function is only defined by the literature for R is in <a href="https://math.stackexchange.com/questions/3780089/extending-the-concept-of-distribution-function-to-any-totally-or-partially-order/3782009#comment7787969_3782009">this comment by Oliver Diaz</a> in the Wikipedia article:</p>
<p>"If (𝑌,𝑑) is s Borel space (a Polish space for instance) then it is measurable isomorphic to (0,1) and one can define an order in 𝑌. The isomorphism however is not explicit, it is based on constructions that use the axiom of choice."</p>
<p>"Measurable isomorphic to (0,1)" is what I was looking for, it gives motivation for only talking about R, in the sense that talking about <code>Y</code> would be redundant under the isomorphism.</p>



<a name="220528652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220528652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220528652">(Dec 20 2020 at 17:27)</a>:</h4>
<p>I don't think that is true at all</p>



<a name="220528664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220528664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220528664">(Dec 20 2020 at 17:28)</a>:</h4>
<p>Y can easily be something like <code>bool</code> with the preorder formulation</p>



<a name="220528759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20tell%20Lean%20that%20a%20subclass%20is%20a%20kind%20of%20the%20supercla/near/220528759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla.html#220528759">(Dec 20 2020 at 17:30)</a>:</h4>
<p>you need a lot more assumptions to make it look like real. Borel won't cut it, Polish might but it's not clear what the reason for such an assumption is</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
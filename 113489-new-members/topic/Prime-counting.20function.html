---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Prime-counting.20function.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html">Prime-counting function</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="235367350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235367350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235367350">(Apr 20 2021 at 15:50)</a>:</h4>
<p>Dear all,<br>
I have started learning Lean recently by doing some of the amazingly written exercises from prof. Buzzard's Formalising Mathematics workshop.<br>
Now I am willing to formalize a simple theorem for myself: number 81 from Wiedijk's list, Divergence of Prime Reciprocals. I am having trouble figuring out how to define a function (n \mapsto p_n) in Lean properly. The definition should clearly rely on the Euclid's theorem of the infinitude of primes somehow. Is there a built-in way to define 'n-th member of a set' in Lean?</p>



<a name="235367993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235367993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235367993">(Apr 20 2021 at 15:54)</a>:</h4>
<p>Sets are inherently disordered, so there is no "nth" element. You might prefer lists, or just a function <code>nat -&gt; _</code></p>



<a name="235368338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235368338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235368338">(Apr 20 2021 at 15:56)</a>:</h4>
<p>Basically, I want a function which takes a subset of a linearly ordered set, and produces a list which contains all its elements sorted.<br>
Although, how is divergence of a series defined in Lean? It uses the definition of a sequence as nat -&gt; reals, right? Then I guess I want a function nat -&gt; reals.</p>



<a name="235368771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235368771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235368771">(Apr 20 2021 at 15:59)</a>:</h4>
<p>The way series work is that they're just functions from a random type (e.g. the naturals) to a type which is an additive commutative monoid and a topological space :-)</p>



<a name="235368922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235368922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235368922">(Apr 20 2021 at 15:59)</a>:</h4>
<p>I didn't even say "topological monoid" because for the <em>definition</em> of convergence you don't need the addition and the topology to be compatible :-) Oh those computer scientists are so funny.</p>



<a name="235369227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235369227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235369227">(Apr 20 2021 at 16:01)</a>:</h4>
<p>So you would want a function from the naturals to the reals, and my instinct is to define this function by recursion, sending 0 to 2 and, if it sends <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>, then it sends <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> to <code>nextprime (p n + 1)</code></p>



<a name="235369288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235369288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235369288">(Apr 20 2021 at 16:01)</a>:</h4>
<p>which means you'll have to write <code>nextprime</code> first.</p>



<a name="235369308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235369308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235369308">(Apr 20 2021 at 16:01)</a>:</h4>
<p>which is already an interesting exercise.</p>



<a name="235369630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235369630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235369630">(Apr 20 2021 at 16:03)</a>:</h4>
<p>And then the theorem you're after would say that the function sending <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>p</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1/p(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> was not <code>summable</code> (you'd need to import <code>topology.algebra.infinite_sum</code> to get access to <code>summable</code>).</p>



<a name="235369761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235369761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235369761">(Apr 20 2021 at 16:04)</a>:</h4>
<p>(Should we have a <code>list.primes_up_to</code>? Or a <code>stream.primes</code>?)</p>



<a name="235369957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235369957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235369957">(Apr 20 2021 at 16:05)</a>:</h4>
<p>I dunno, those are CS questions. Maybe!</p>



<a name="235370002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235370002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235370002">(Apr 20 2021 at 16:05)</a>:</h4>
<p>I cannot believe that it's 2021 and <code>nat.find</code> still does not have a docstring.</p>



<a name="235370877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235370877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235370877">(Apr 20 2021 at 16:11)</a>:</h4>
<p>Looking through <a href="https://leanprover-community.github.io/mathlib_docs/data/nat/prime.html">https://leanprover-community.github.io/mathlib_docs/data/nat/prime.html</a> I only found (n -&gt; list of factors of n) and no (n -&gt; all primes less than n), unfortunately.<br>
I could just use nat.factors(n!), but that would be ugly.</p>



<a name="235370984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235370984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235370984">(Apr 20 2021 at 16:11)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.prime</span>

<span class="kn">open</span> <span class="n">nat</span>

<span class="k">#check</span> <span class="n">exists_infinite_primes</span>
<span class="c1">-- ∀ (n : ℕ), ∃ (p : ℕ), n ≤ p ∧ nat.prime p</span>

<span class="kd">def</span> <span class="n">nextprime</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">nat.find</span> <span class="o">(</span><span class="n">exists_infinite_primes</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>
</code></pre></div>
<p>I think that's the function.</p>



<a name="235371079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235371079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235371079">(Apr 20 2021 at 16:12)</a>:</h4>
<p>oh no wait, is <code>nextprime 3</code> supposed to be 3 or 5? Hmm, pari-gp says 3.</p>



<a name="235371128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235371128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235371128">(Apr 20 2021 at 16:12)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">nextprime</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">nat.find</span> <span class="o">(</span><span class="n">exists_infinite_primes</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>
<p>That's the function then.</p>



<a name="235371191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235371191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235371191">(Apr 20 2021 at 16:12)</a>:</h4>
<p>with sad sad computational performance</p>



<a name="235371220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235371220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235371220">(Apr 20 2021 at 16:13)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">nextprime</span> <span class="mi">4</span> <span class="c1">-- 5</span>
<span class="k">#eval</span> <span class="n">nextprime</span> <span class="mi">5</span> <span class="c1">-- 5</span>
</code></pre></div>
<p>Looks good. Who cares about computational performance, we're proving a theorem.</p>



<a name="235371288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235371288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235371288">(Apr 20 2021 at 16:13)</a>:</h4>
<p>Why is +1 an issue? Because it would skip 3?</p>



<a name="235371397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235371397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235371397">(Apr 20 2021 at 16:14)</a>:</h4>
<p>I added 1 because I was jumping the gun: we do <code>nextprime(p(n)+1)</code> when defining <code>p(n)</code></p>



<a name="235371407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235371407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235371407">(Apr 20 2021 at 16:14)</a>:</h4>
<p>Thanks, will try that out! :-)</p>



<a name="235371592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235371592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235371592">(Apr 20 2021 at 16:15)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.prime</span>

<span class="kn">open</span> <span class="n">nat</span>

<span class="k">#check</span> <span class="n">exists_infinite_primes</span>
<span class="c1">-- ∀ (n : ℕ), ∃ (p : ℕ), n ≤ p ∧ nat.prime p</span>

<span class="kd">def</span> <span class="n">nextprime</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">nat.find</span> <span class="o">(</span><span class="n">exists_infinite_primes</span> <span class="n">n</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">nextprime</span> <span class="mi">4</span> <span class="c1">-- 5</span>
<span class="k">#eval</span> <span class="n">nextprime</span> <span class="mi">5</span> <span class="c1">-- 5</span>

<span class="kn">namespace</span> <span class="n">prime</span>

<span class="kd">def</span> <span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">2</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nextprime</span> <span class="o">(</span><span class="n">p</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">p</span> <span class="mi">3</span> <span class="c1">-- 7 (note we start with p₀ = 2)</span>

<span class="kd">end</span> <span class="n">prime</span>
</code></pre></div>



<a name="235371913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235371913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235371913">(Apr 20 2021 at 16:17)</a>:</h4>
<p>We've made some definitions so definitely the next thing to do is to prove some theorems about those definitions, for example some of the following might be helpful (and some might be hard): nextprime(n)&gt;=n, nextprime(n) is prime, p(n) is prime, every prime p is p(n) for some n. The function p is injective, etc etc. thinking about it I'm not sure that calling the function <code>p</code> is a good idea -- you might want to use <code>p</code> for a prime number. Maybe <code>pcount</code>?</p>



<a name="235371996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235371996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235371996">(Apr 20 2021 at 16:18)</a>:</h4>
<p>If p is prime and n&lt;=p then nextprime(n)&lt;=p etc.</p>



<a name="235372042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235372042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235372042">(Apr 20 2021 at 16:18)</a>:</h4>
<p>Just so you know, PR <a href="https://github.com/leanprover-community/mathlib/issues/7274">#7274</a> has a proof of this! I'd encourage you to still do it (it'll be good fun) and it'll be interesting to compare your two approaches after</p>



<a name="235372077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235372077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235372077">(Apr 20 2021 at 16:18)</a>:</h4>
<p>(for example <a href="https://github.com/leanprover-community/mathlib/issues/7274">#7274</a> doesn't use the next prime function)</p>



<a name="235372130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235372130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235372130">(Apr 20 2021 at 16:18)</a>:</h4>
<p>oh what a crazy coincidence -- I didn't know we had this</p>



<a name="235372200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235372200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235372200">(Apr 20 2021 at 16:19)</a>:</h4>
<p>just 10 hours ago :b</p>



<a name="235372212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235372212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235372212">(Apr 20 2021 at 16:19)</a>:</h4>
<p>Isn't <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> traditionally the number of primes <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\le n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>?</p>



<a name="235372282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235372282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235372282">(Apr 20 2021 at 16:19)</a>:</h4>
<p>sorry yes you're right, my point is that it doesn't use a "next prime" function</p>



<a name="235372778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235372778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235372778">(Apr 20 2021 at 16:23)</a>:</h4>
<p>Interesting! Now I'm curious to see how you even stated it :-)</p>



<a name="235372982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235372982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235372982">(Apr 20 2021 at 16:24)</a>:</h4>
<p>Aah -- very nice!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">filter.tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="bp">∑</span> <span class="n">p</span> <span class="k">in</span> <span class="o">{</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">range</span> <span class="n">n</span> <span class="bp">|</span> <span class="n">nat.prime</span> <span class="n">p</span> <span class="o">},</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">/</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)))</span> <span class="n">at_top</span> <span class="n">at_top</span> <span class="o">:=</span>
</code></pre></div>
<p>You literally write down the finite sums by summing over finite sets.</p>



<a name="235374851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235374851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235374851">(Apr 20 2021 at 16:35)</a>:</h4>
<p>A small follow-up question to be clear: does nat.find outputs a smallest element from a nonempty subset of nat?</p>



<a name="235375121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235375121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235375121">(Apr 20 2021 at 16:37)</a>:</h4>
<p>Or from a proof that a set is nonempty, I guess</p>



<a name="235375538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235375538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235375538">(Apr 20 2021 at 16:40)</a>:</h4>
<p><code>nat.find</code> finds the smallest nat that satisfies some <code>exists (n : nat) such that ...</code></p>



<a name="235375706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235375706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235375706">(Apr 20 2021 at 16:41)</a>:</h4>
<p>A subset of nat, in Lean a term of type <code>set nat</code>, is like a function that takes a <code>x : nat</code> and gives you back the proposition that the <code>x</code> in the subset you're talking about</p>



<a name="235375885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235375885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235375885">(Apr 20 2021 at 16:42)</a>:</h4>
<p>The definition in mathlib, of a nonempty subset is given by <a href="https://leanprover-community.github.io/mathlib_docs/find/set.nonempty">docs#set.nonempty</a>, which is definitionally equal to:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">s.nonempty</span> <span class="bp">=</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span>
</code></pre></div>



<a name="235375984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235375984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235375984">(Apr 20 2021 at 16:43)</a>:</h4>
<p>So, in this piece of code above, is (exists_infinite_primes n) a proof of {p | prime p \and p &gt; n}.nonempty?</p>



<a name="235376024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235376024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235376024">(Apr 20 2021 at 16:43)</a>:</h4>
<p>So yes, if you have some <code>s : set nat</code> and a proof that <code>s.nonempty</code>, then <code>nat.find s.nonempty</code> will give you the least <code>x : nat</code> such that <code>x ∈ s</code></p>



<a name="235376041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235376041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235376041">(Apr 20 2021 at 16:43)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/nat.exists_infinite_primes">docs#nat.exists_infinite_primes</a></p>



<a name="235376132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235376132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235376132">(Apr 20 2021 at 16:44)</a>:</h4>
<p>Ok, thanks!</p>



<a name="235376215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235376215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235376215">(Apr 20 2021 at 16:44)</a>:</h4>
<p>That lemma is definitionally equal to what you just wrote about <code>{ ... }.nonempty</code>. But it is phrased as the explicit existential statement</p>



<a name="235379056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235379056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235379056">(Apr 20 2021 at 17:03)</a>:</h4>
<p><a href="https://github.com/leanprover-community/lean/issues/566">lean#566</a></p>



<a name="235379583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235379583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235379583">(Apr 20 2021 at 17:07)</a>:</h4>
<p>It's in core, that's why there's no docstring. I had to clone Lean! I felt like a real computer scientist :-)</p>



<a name="235380628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235380628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235380628">(Apr 20 2021 at 17:15)</a>:</h4>
<p>there was no need to do that for such a small change btw - on the github website, you can press the little edit box and it'll auto-create a branch for you and let you edit/PR</p>



<a name="235400985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235400985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235400985">(Apr 20 2021 at 19:27)</a>:</h4>
<p>There is a very stupid problem I am running into.<br>
So I want to know that 1/2&gt;0, but when I just write have f : 1/2 &gt; 0 := or whatever, it just assumes that I mean 1, 2 and 0 as naturals, and under this interpretation the statement is wrong! How do I tell Lean that I mean the real 1, not 1 in any other mathematical structure?</p>



<a name="235401175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235401175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235401175">(Apr 20 2021 at 19:28)</a>:</h4>
<p>(1 : ℝ) / 2</p>



<a name="235401698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235401698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235401698">(Apr 20 2021 at 19:32)</a>:</h4>
<p>Ok, thanks!</p>



<a name="235440831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235440831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235440831">(Apr 21 2021 at 01:23)</a>:</h4>
<p><code>(1 / 2 : ℝ)</code> is fine too, and generally more readable.</p>



<a name="235441558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235441558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235441558">(Apr 21 2021 at 01:34)</a>:</h4>
<p>Why does that work? I mean I guess it obviously works because Lean doesn't evaluate the <code>1 / 2</code> until after seeing it should be done in R? So Lean basically doesn't try to interpret the left side of a coersion until after seeing what type it's supposed to be?</p>



<a name="235441693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235441693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235441693">(Apr 21 2021 at 01:37)</a>:</h4>
<p>It's all a bit complicated, but at least when there is expected type information available, Lean works from the outside in. So here is goes to look for a <code>had_div ℝ</code> instance first, and then after that starts trying to interpret the numerals as terms in <code>ℝ</code>.</p>



<a name="235441712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235441712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235441712">(Apr 21 2021 at 01:37)</a>:</h4>
<p>In the opposite direction we sometimes use the trick <code>(X : _)</code>, which basically forces Lean to forget the expected type as it interprets <code>X</code>.</p>



<a name="235441802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235441802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235441802">(Apr 21 2021 at 01:39)</a>:</h4>
<p>Interesting. Thanks for the explanation.</p>



<a name="235475932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235475932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235475932">(Apr 21 2021 at 08:54)</a>:</h4>
<p>What is Lean's notation for restriction of a function?</p>



<a name="235475974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235475974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235475974">(Apr 21 2021 at 08:54)</a>:</h4>
<p>You just compose with the inclusion.</p>



<a name="235476024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235476024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235476024">(Apr 21 2021 at 08:55)</a>:</h4>
<p>It's easy to find names for functions in measure theory in mathlib, but I can't find a list with set-theoretic operations :(</p>



<a name="235476076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235476076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235476076">(Apr 21 2021 at 08:56)</a>:</h4>
<p>Just ask here (but maybe in a new thread).</p>



<a name="235594013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235594013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235594013">(Apr 21 2021 at 22:47)</a>:</h4>
<p>There's also this function for the ith prime which Mario wrote in another thread. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.prime</span>
<span class="kn">open</span> <span class="n">nat</span>

<span class="kd">def</span> <span class="n">find_prime</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">n</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">n</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">decidable_prime_1</span> <span class="n">n</span><span class="bp">;</span> <span class="n">exact</span>
  <span class="k">if</span> <span class="n">prime</span> <span class="n">n</span> <span class="k">then</span> <span class="n">n</span> <span class="k">else</span> <span class="n">find_prime</span> <span class="n">i</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">ith_prime</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">2</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">ith_prime</span> <span class="n">i</span> <span class="k">in</span> <span class="n">find_prime</span> <span class="n">n</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">ith_prime</span> <span class="mi">4</span> <span class="bp">=</span> <span class="mi">11</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
</code></pre></div>



<a name="235623656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235623656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235623656">(Apr 22 2021 at 05:54)</a>:</h4>
<p>(warning: that function computes well but proving that it produces primes requires Bertrand's postulate)</p>



<a name="235626194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235626194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235626194">(Apr 22 2021 at 06:29)</a>:</h4>
<p>Which is almost in mathlib, I think.</p>



<a name="235645459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235645459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235645459">(Apr 22 2021 at 09:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Prime-counting.20function/near/235371079">said</a>:</p>
<blockquote>
<p>oh no wait, is <code>nextprime 3</code> supposed to be 3 or 5? Hmm, pari-gp says 3.</p>
</blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">sage</span><span class="o">:</span> <span class="n">next_prime</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="mi">5</span>
</code></pre></div>



<a name="235645552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235645552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235645552">(Apr 22 2021 at 09:27)</a>:</h4>
<p>Mathlib's compromise:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">nextprime</span> <span class="mi">3</span>
<span class="c1">-- 3</span>
<span class="k">#eval</span> <span class="n">next_prime</span> <span class="mi">3</span>
<span class="c1">-- 5</span>
</code></pre></div>



<a name="235657033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235657033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235657033">(Apr 22 2021 at 11:06)</a>:</h4>
<p><span class="user-mention" data-user-id="254058">@Marc Masdeu</span> how about we go for 4 as a compromise ;-)</p>



<a name="235657131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235657131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235657131">(Apr 22 2021 at 11:07)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">$</span> <span class="n">gp</span>
<span class="bp">?</span> <span class="n">nextprime</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="bp">%</span><span class="mi">1</span> <span class="bp">=</span> <span class="mi">3</span>
<span class="bp">?</span>
</code></pre></div>



<a name="235803858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235803858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235803858">(Apr 23 2021 at 08:15)</a>:</h4>
<p>Does mathlib have the following statement:<br>
If n is a natural number such that for any prime p, the order of p in n is even, then n is a perfect square?</p>



<a name="235805780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235805780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235805780">(Apr 23 2021 at 08:32)</a>:</h4>
<p>I'm failing to even state it, so perhaps not :)</p>



<a name="235808017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235808017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235808017">(Apr 23 2021 at 08:54)</a>:</h4>
<p>Here's a proof sketch, combining <a href="https://leanprover-community.github.io/mathlib_docs/find/unique_factorization_monoid.factors">docs#unique_factorization_monoid.factors</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/multiset.count">docs#multiset.count</a>: Prove by strong induction on <code>m</code> that <code>∀ (m : multiset R), (∀ p, 2 \dvd m.count p) -&gt; ∃ (x : R), m.prod = x * x</code>, and use <a href="https://leanprover-community.github.io/mathlib_docs/find/unique_factorization_monoid.factors_prod">docs#unique_factorization_monoid.factors_prod</a> to conclude <code>∀ x, (order_of_factors_is_even x) -&gt; ∃ y, associated x (y * y)</code>. Finally you need that all units in <code>ℕ</code> are squares (because they are all 1) to conclude that <code>∃ y, x = y * y</code>.</p>



<a name="235809362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235809362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235809362">(Apr 23 2021 at 09:05)</a>:</h4>
<p>I was trying to use <code>multiplicity</code>, though Anne's approach makes more sense - I even have a fair amount of that code written :)<br>
Will send a pointer in a bit</p>



<a name="235809549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235809549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235809549">(Apr 23 2021 at 09:07)</a>:</h4>
<p>Ah good point, forgot about <code>multiplicity</code>. I guess we could split the difference via <a href="https://leanprover-community.github.io/mathlib_docs/find/unique_factorization_monoid.multiplicity_eq_count_factors">docs#unique_factorization_monoid.multiplicity_eq_count_factors</a></p>



<a name="235811415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235811415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235811415">(Apr 23 2021 at 09:22)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.int.basic</span>

<span class="kn">open</span> <span class="n">unique_factorization_monoid</span>

<span class="kd">lemma</span> <span class="n">multiset.exists_nsmul_of_dvd</span>
  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">k</span> <span class="bp">∣</span> <span class="n">multiset.count</span> <span class="n">x</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">t</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">,</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">k</span> <span class="bp">•</span> <span class="n">t</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="n">k</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">m.prime</span> <span class="bp">→</span> <span class="n">k</span> <span class="bp">∣</span> <span class="o">(</span><span class="n">factors</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">count</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">m'</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">factors</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span> <span class="bp">•</span> <span class="n">m'</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">m'</span><span class="o">,</span> <span class="n">hm'</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">apply_fun</span> <span class="n">multiset.prod</span> <span class="n">at</span> <span class="n">hm'</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="n">factors_prod</span> <span class="n">hn.ne'</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">associated_iff_eq</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">multiset.prod_nsmul</span><span class="o">,</span> <span class="n">this</span><span class="o">]</span> <span class="n">at</span> <span class="n">hm'</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">m'.prod</span><span class="o">,</span> <span class="n">hm'</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="n">apply</span> <span class="n">multiset.exists_nsmul_of_dvd</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">nat.factors_eq</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">nat.prime_of_mem_factors</span> <span class="n">hx</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>with the first lemma from <a href="https://github.com/Ruben-VandeVelde/flt/blob/main/src/multiset.lean">https://github.com/Ruben-VandeVelde/flt/blob/main/src/multiset.lean</a></p>



<a name="235812190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235812190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235812190">(Apr 23 2021 at 09:29)</a>:</h4>
<p>Is this your Fermat's Last Theorem repo?</p>



<a name="235868086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235868086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235868086">(Apr 23 2021 at 16:15)</a>:</h4>
<p>With Neil Strickland's little used API for prime multisets, this can be done as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.pnat.factors</span>

<span class="kd">lemma</span> <span class="n">multiset.exists_nsmul_of_dvd</span>
  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">k</span> <span class="bp">∣</span> <span class="n">multiset.count</span> <span class="n">x</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">t</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">,</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">k</span> <span class="bp">•</span> <span class="n">t</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="bp">+</span><span class="o">)</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span><span class="o">,</span> <span class="n">q</span> <span class="bp">∣</span> <span class="n">n.factor_multiset.count</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">k</span><span class="bp">^</span><span class="n">q</span> <span class="o">:=</span>
<span class="k">let</span> <span class="o">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">hm</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">multiset.exists_nsmul_of_dvd</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">hn</span> <span class="n">_</span><span class="o">)</span> <span class="k">in</span>
<span class="o">⟨</span><span class="n">prime_multiset.prod</span> <span class="n">m</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">n.prod_factor_multiset</span><span class="o">,</span> <span class="n">hm</span><span class="o">,</span> <span class="n">prime_multiset.prod_smul</span><span class="o">]⟩</span>
</code></pre></div>



<a name="235872110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235872110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235872110">(Apr 23 2021 at 16:44)</a>:</h4>
<p>I'd be inclined to try and do that computably as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">multiset.nsmul_of_dvd</span>
  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">k</span> <span class="bp">∣</span> <span class="n">multiset.count</span> <span class="n">x</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">{</span> <span class="n">t</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">k</span> <span class="bp">•</span> <span class="n">t</span><span class="o">}</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="235875542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235875542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235875542">(Apr 23 2021 at 17:07)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finsupp</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">to_multiset_symm_apply</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finsupp.to_multiset.symm</span> <span class="n">s</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">multiset.count</span> <span class="n">x</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">convert</span> <span class="n">rfl</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">multiset.exists_nsmul_of_dvd</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">k</span> <span class="bp">∣</span> <span class="n">multiset.count</span> <span class="n">x</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">{</span> <span class="n">t</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">k</span> <span class="bp">•</span> <span class="n">t</span> <span class="o">}</span> <span class="o">:=</span>
<span class="o">⟨(</span><span class="n">finsupp.map_range</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="n">t</span> <span class="bp">/</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">(</span><span class="n">finsupp.to_multiset.symm</span> <span class="n">s</span><span class="o">))</span><span class="bp">.</span><span class="n">to_multiset</span><span class="o">,</span>
  <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">nat.mul_div_cancel'</span> <span class="o">(</span><span class="n">h</span> <span class="n">_</span><span class="o">)]}</span> <span class="o">⟩</span>
</code></pre></div>
<p>Not much more computable, but potentially could be improved</p>



<a name="235879632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235879632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235879632">(Apr 23 2021 at 17:35)</a>:</h4>
<p>Ah, <a href="https://leanprover-community.github.io/mathlib_docs/find/finsupp.to_multiset">docs#finsupp.to_multiset</a> was something I was looking for</p>



<a name="235879709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235879709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235879709">(Apr 23 2021 at 17:36)</a>:</h4>
<p>But <code>finsupp</code> is (almost) entirely non-computable, which is annoying here</p>



<a name="235880244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235880244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235880244">(Apr 23 2021 at 17:40)</a>:</h4>
<p>Oh, it's even more annoying than that; <a href="https://leanprover-community.github.io/mathlib_docs/find/finsupp.to_multiset">docs#finsupp.to_multiset</a> is non-computable only because the addition needed to state <code>map_add</code> is noncomputable!</p>



<a name="235980436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235980436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235980436">(Apr 24 2021 at 15:48)</a>:</h4>
<p>So I have found and used unique_factorization_monoid.factors_prod, to prove that a natural number is a product of a multiset of its prime factors. Is there a converse statement: if s is a multiset of primes, than unique_factorization_monoid.factors (<a href="http://s.prod">s.prod</a>) = s?</p>



<a name="235983513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235983513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235983513">(Apr 24 2021 at 16:34)</a>:</h4>
<p>I think that Neil Strickland proved that equivalence, yes. Hopefully it's somewhere in the same file.</p>



<a name="235983518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235983518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235983518">(Apr 24 2021 at 16:34)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/prime_multiset.factor_multiset_prod">docs#prime_multiset.factor_multiset_prod</a></p>



<a name="235998369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235998369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235998369">(Apr 24 2021 at 19:29)</a>:</h4>
<p>Ok, so now I really struggle with the fact that some useful lemmas are proved fo <code>unique_factorization_monoid.factors</code> and some for <code>pnat.factor_multiset</code>.</p>
<p>I have started by </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">square_separation</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="bp">+</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="bp">+</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℕ</span><span class="bp">+</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">r</span> <span class="bp">∧</span> <span class="n">squarefree</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>

  <span class="k">have</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">pnat.prod_factor_multiset</span> <span class="n">n</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">ev_sep</span> <span class="o">:=</span> <span class="n">even_separation</span> <span class="n">ℕ</span><span class="bp">+</span> <span class="o">(</span><span class="n">n.factor_multiset</span><span class="o">),</span>
  <span class="n">cases</span> <span class="n">ev_sep</span> <span class="k">with</span> <span class="n">t</span> <span class="n">ht</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">ht</span> <span class="k">with</span> <span class="n">r</span> <span class="n">hr</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">hr</span> <span class="k">with</span> <span class="n">n_uni</span> <span class="n">hr'</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">hr'</span> <span class="k">with</span> <span class="n">t_ev</span> <span class="n">r_sqf</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">t_sq</span> <span class="o">:=</span> <span class="n">multiset_square</span> <span class="n">ℕ</span><span class="bp">+</span> <span class="n">t</span> <span class="n">t_ev</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">t_sq</span> <span class="k">with</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">v.prod</span><span class="o">,</span> <span class="n">use</span> <span class="n">r.prod</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">&lt;-</span> <span class="n">multiset.prod_add</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">&lt;-</span> <span class="n">multiset.prod_add</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">&lt;-</span> <span class="n">hv</span><span class="o">,</span> <span class="n">rw</span> <span class="bp">&lt;-</span> <span class="n">n_uni</span><span class="o">,</span>
  <span class="n">symmetry</span><span class="o">,</span> <span class="n">exact</span> <span class="n">f</span><span class="o">,</span>
</code></pre></div>
<p>and then I fail to apply <code>nat.squarefree_iff_nodup_factors</code> because I have to work in <code>\N+</code> and <code>unique_factorization_monoid.squarefree_iff_nodup_factors</code> because <code>\N+</code> is not a unique factorization domain.<br>
Is there a good way to deal with this issue?<br>
For example, is it easy to relate <code>squarefree r.prod</code> and <code>squarefree (\u r.prod : \N)?</code></p>



<a name="235998593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235998593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235998593">(Apr 24 2021 at 19:32)</a>:</h4>
<p><del>#backticks?</del> Ok yay</p>



<a name="235998764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235998764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235998764">(Apr 24 2021 at 19:34)</a>:</h4>
<p>But <code>pnat</code> is a unique factorization monoid, right? So hopefully that instance is in mathlib. And if not, then we should add it.</p>



<a name="235998826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235998826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235998826">(Apr 24 2021 at 19:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="355764">Hanting Zhang</span> <a href="#narrow/stream/113489-new-members/topic/Prime-counting.20function/near/235998593">said</a>:</p>
<blockquote>
<p><del>#backticks?</del> Ok yay</p>
</blockquote>
<p>Thanks, they look nice :)</p>



<a name="235998923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235998923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235998923">(Apr 24 2021 at 19:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/Prime-counting.20function/near/235998764">said</a>:</p>
<blockquote>
<p>But <code>pnat</code> is a unique factorization monoid, right? So hopefully that instance is in mathlib. And if not, then we should add it.</p>
</blockquote>
<p>looks like <a href="https://leanprover-community.github.io/mathlib_docs/ring_theory/unique_factorization_domain.html#unique_factorization_monoid">https://leanprover-community.github.io/mathlib_docs/ring_theory/unique_factorization_domain.html#unique_factorization_monoid</a> means that a unique factorization monoid has a zero by definition, so I guess not.</p>



<a name="235998938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235998938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235998938">(Apr 24 2021 at 19:36)</a>:</h4>
<p>I found</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">src</span><span class="bp">/</span><span class="n">ring_theory</span><span class="bp">/</span><span class="n">int</span><span class="bp">/</span><span class="n">basic.lean</span>
<span class="mi">86</span><span class="o">:</span><span class="kd">instance</span> <span class="o">:</span> <span class="n">unique_factorization_monoid</span> <span class="n">ℕ</span> <span class="o">:=</span>
</code></pre></div>



<a name="235998943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235998943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235998943">(Apr 24 2021 at 19:36)</a>:</h4>
<p>But maybe <code>pnat</code> is missing</p>



<a name="235998946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235998946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235998946">(Apr 24 2021 at 19:36)</a>:</h4>
<p>ooh, hmz</p>



<a name="235998980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235998980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235998980">(Apr 24 2021 at 19:37)</a>:</h4>
<p>Is there a reason that you want to prove your result for <code>pnat</code>?</p>



<a name="235998987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235998987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235998987">(Apr 24 2021 at 19:37)</a>:</h4>
<p>Maybe prove it for <code>nat</code> first?</p>



<a name="235998996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235998996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235998996">(Apr 24 2021 at 19:37)</a>:</h4>
<p>Once you have it for <code>nat</code>, deducing it for <code>pnat</code> is easy.</p>



<a name="235999067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235999067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235999067">(Apr 24 2021 at 19:38)</a>:</h4>
<p>And I guess that you might as well prove it for an arbitrary UFM first, right?</p>



<a name="235999127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235999127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235999127">(Apr 24 2021 at 19:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/Prime-counting.20function/near/235998980">said</a>:</p>
<blockquote>
<p>Is there a reason that you want to prove your result for <code>pnat</code>?</p>
</blockquote>
<p>I prove it for pnat because pnat has a lemma I asked about a few hours ago</p>



<a name="235999142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235999142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235999142">(Apr 24 2021 at 19:39)</a>:</h4>
<p><em>Stepan Nesterov|407114</em>* <a href="#narrow/stream/113489-new-members/topic/Prime-counting.20function/near/235980436">said</a>:</p>
<blockquote>
<p>So I have found and used unique_factorization_monoid.factors_prod, to prove that a natural number is a product of a multiset of its prime factors. Is there a converse statement: if s is a multiset of primes, than unique_factorization_monoid.factors (<a href="http://s.prod">s.prod</a>) = s?</p>
</blockquote>
<p>this one</p>



<a name="235999217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/235999217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#235999217">(Apr 24 2021 at 19:40)</a>:</h4>
<p>And I couldn't find a lemma that unique_factorization_monoid.factors (<a href="http://s.prod">s.prod</a>) is associated to s for s a multiset in a UFM</p>



<a name="236019014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/236019014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#236019014">(Apr 24 2021 at 23:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/Prime-counting.20function/near/235998980">said</a>:</p>
<blockquote>
<p>Is there a reason that you want to prove your result for <code>pnat</code>?</p>
</blockquote>
<p>I think the issue is that Neil Strickland's nice results for prime multisets and pnats were done before unique factorization monoids and they haven't got linked between them</p>



<a name="236062590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/236062590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#236062590">(Apr 25 2021 at 12:41)</a>:</h4>
<p><span class="user-mention" data-user-id="407114">@Stepan Nesterov</span> one line, once I managed to state it :)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.unique_factorization_domain</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_cancel_monoid_with_zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">unique_factorization_monoid</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">nontrivial</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">normalization_monoid</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">prime</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h'</span> <span class="o">:</span> <span class="n">s.prod</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">multiset.rel</span> <span class="n">associated</span> <span class="o">(</span><span class="n">unique_factorization_monoid.factors</span> <span class="o">(</span><span class="n">s.prod</span><span class="o">))</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">prime_factors_unique</span> <span class="n">unique_factorization_monoid.prime_of_factor</span> <span class="n">h</span> <span class="o">(</span><span class="n">unique_factorization_monoid.factors_prod</span> <span class="n">h'</span><span class="o">)</span>
</code></pre></div>



<a name="236063064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/236063064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#236063064">(Apr 25 2021 at 12:49)</a>:</h4>
<p>Ok, thanks, works like a charm :)</p>



<a name="237986581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/237986581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#237986581">(May 08 2021 at 21:41)</a>:</h4>
<p>Under these definitions:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">nextprime</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">nat.find</span> <span class="o">(</span><span class="n">nat.exists_infinite_primes</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">primecount</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">2</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nextprime</span> <span class="o">(</span><span class="n">primecount</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>how do I prove that, say,  primecount 1 = 3? I am able to reduce it to nextprime 3 = 3 by unfolding the definitions, but I don't know how to prove that if 3 is the smallest prime greater than 3, then 3 = nextprime 3.</p>



<a name="237987545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/237987545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#237987545">(May 08 2021 at 22:00)</a>:</h4>
<p>One of the lemmas about <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.find">docs#nat.find</a> should do that</p>



<a name="237988266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/237988266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#237988266">(May 08 2021 at 22:14)</a>:</h4>
<p>It seems that there are three lemmas, which collectively cover 'nat.find p' is the smallest number that satisfies p, but no converse statement.</p>



<a name="237990584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/237990584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#237990584">(May 08 2021 at 22:59)</a>:</h4>
<p>If this is a question, can you formalise what you're looking for in Lean?</p>



<a name="237990747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/237990747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#237990747">(May 08 2021 at 23:01)</a>:</h4>
<p>PS I wrote that nat.find docstring a few weeks ago because I noticed that it was in fashion right now but didn't have a docstring. I notice from Eric's link that the docstring is now live, but there's no link to <code>nat.find_min'</code> whereas the other two things in the API seem to be live links.</p>



<a name="238015590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238015590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238015590">(May 09 2021 at 07:12)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/nat.find_min'">docs#nat.find_min'</a> works at least? I guess the link heuristic doesn't like a trailing <code>'</code>.</p>



<a name="238021093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238021093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238021093">(May 09 2021 at 09:00)</a>:</h4>
<p>I wanted something like this, but I realized it is actually provable from the lemmas:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nat_find_criterion</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">hsat</span> <span class="o">:</span> <span class="n">p</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">hmin</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">nat.find</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">lt_trichotomy</span> <span class="n">m</span> <span class="o">(</span><span class="n">nat.find</span> <span class="n">s</span><span class="o">),</span>
  <span class="n">cases</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">exfalso</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">nat.find_min</span> <span class="n">s</span> <span class="n">f</span> <span class="n">hsat</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">exfalso</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">hmin</span> <span class="o">(</span><span class="n">nat.find</span> <span class="n">s</span><span class="o">)</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hmin</span> <span class="o">(</span><span class="n">nat.find_spec</span> <span class="n">s</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="238021207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238021207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238021207">(May 09 2021 at 09:02)</a>:</h4>
<p>But now, when I try to actually prove that 3 is the first prime with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">primecount_succ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">primecount</span> <span class="o">(</span><span class="n">n.succ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">nextprime</span> <span class="o">(</span><span class="n">primecount</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">zeroth_prime</span> <span class="o">:</span> <span class="n">primecount</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">next_prime</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">nextprime</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">nat.find</span> <span class="o">(</span><span class="n">nat.exists_infinite_primes</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">first_prime</span> <span class="o">:</span> <span class="n">primecount</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">primecount_succ</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">zeroth_prime</span><span class="o">,</span>
  <span class="n">norm_num</span><span class="o">,</span>
  <span class="n">symmetry</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">next_prime</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">nat_find_criterion</span> <span class="mi">3</span> <span class="o">(</span><span class="n">nat.exists_infinite_primes</span> <span class="mi">3</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>
<p>Lean says <br>
invalid apply tactic, failed to unify<br>
  3 = nat.find _
with<br>
  3 = nat.find _</p>



<a name="238021227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238021227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238021227">(May 09 2021 at 09:02)</a>:</h4>
<p>How do I modify the lemma so that it becomes applicable?</p>



<a name="238021295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238021295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238021295">(May 09 2021 at 09:03)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mwe.html">#mwe</a>?</p>



<a name="238021447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238021447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238021447">(May 09 2021 at 09:05)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.prime</span>
<span class="kn">import</span> <span class="n">topology.algebra.infinite_sum</span>
<span class="kn">import</span> <span class="n">algebra.squarefree</span>
<span class="kn">import</span> <span class="n">ring_theory.unique_factorization_domain</span>
<span class="kn">import</span> <span class="n">data.multiset.basic</span>
<span class="kn">import</span> <span class="n">data.nat.parity</span>
<span class="kn">import</span> <span class="n">algebra.associated</span>
<span class="kn">import</span> <span class="n">data.pnat.factors</span>

<span class="kn">open</span> <span class="n">finset</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">def</span> <span class="n">nextprime</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">nat.find</span> <span class="o">(</span><span class="n">nat.exists_infinite_primes</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">primecount</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">2</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nextprime</span> <span class="o">(</span><span class="n">primecount</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">primecount</span> <span class="mi">1</span>

<span class="kd">lemma</span> <span class="n">primecount_succ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">primecount</span> <span class="o">(</span><span class="n">n.succ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">nextprime</span> <span class="o">(</span><span class="n">primecount</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">zeroth_prime</span> <span class="o">:</span> <span class="n">primecount</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">next_prime</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">nextprime</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">nat.find</span> <span class="o">(</span><span class="n">nat.exists_infinite_primes</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">nat_find_criterion</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">hsat</span> <span class="o">:</span> <span class="n">p</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">hmin</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">nat.find</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">lt_trichotomy</span> <span class="n">m</span> <span class="o">(</span><span class="n">nat.find</span> <span class="n">s</span><span class="o">),</span>
  <span class="n">cases</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">exfalso</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">nat.find_min</span> <span class="n">s</span> <span class="n">f</span> <span class="n">hsat</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">exfalso</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">hmin</span> <span class="o">(</span><span class="n">nat.find</span> <span class="n">s</span><span class="o">)</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hmin</span> <span class="o">(</span><span class="n">nat.find_spec</span> <span class="n">s</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">first_prime</span> <span class="o">:</span> <span class="n">primecount</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">primecount_succ</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">zeroth_prime</span><span class="o">,</span>
  <span class="n">norm_num</span><span class="o">,</span>
  <span class="n">symmetry</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">next_prime</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">nat_find_criterion</span> <span class="mi">3</span> <span class="o">(</span><span class="n">nat.exists_infinite_primes</span> <span class="mi">3</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="238022629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238022629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238022629">(May 09 2021 at 09:26)</a>:</h4>
<p>The puzzling issue is you combined <code>open_locale classical</code> with wanting to compute. You can't have everything. So the first layer of fix is to go to </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.prime</span>
<span class="kn">import</span> <span class="n">topology.algebra.infinite_sum</span>
<span class="kn">import</span> <span class="n">algebra.squarefree</span>
<span class="kn">import</span> <span class="n">ring_theory.unique_factorization_domain</span>
<span class="kn">import</span> <span class="n">data.multiset.basic</span>
<span class="kn">import</span> <span class="n">data.nat.parity</span>
<span class="kn">import</span> <span class="n">algebra.associated</span>
<span class="kn">import</span> <span class="n">data.pnat.factors</span>

<span class="kn">open</span> <span class="n">finset</span>
<span class="c1">--open_locale classical</span>

<span class="kd">def</span> <span class="n">nextprime</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">nat.find</span> <span class="o">(</span><span class="n">nat.exists_infinite_primes</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">primecount</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">2</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nextprime</span> <span class="o">(</span><span class="n">primecount</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">primecount</span> <span class="mi">1</span>

<span class="kd">lemma</span> <span class="n">primecount_succ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">primecount</span> <span class="o">(</span><span class="n">n.succ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">nextprime</span> <span class="o">(</span><span class="n">primecount</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">zeroth_prime</span> <span class="o">:</span> <span class="n">primecount</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">next_prime</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">nextprime</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">nat.find</span> <span class="o">(</span><span class="n">nat.exists_infinite_primes</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">nat_find_criterion</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hsat</span> <span class="o">:</span> <span class="n">p</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hmin</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">nat.find</span> <span class="o">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">hsat</span><span class="o">⟩</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">first_prime</span> <span class="o">:</span> <span class="n">primecount</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">change</span> <span class="n">nextprime</span> <span class="mi">3</span> <span class="bp">=</span> <span class="mi">3</span><span class="o">,</span>
  <span class="n">symmetry</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">nat_find_criterion</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="238022637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238022637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238022637">(May 09 2021 at 09:27)</a>:</h4>
<p>(I put everything so you can use a diff tool to compare with your file)</p>



<a name="238022757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238022757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238022757">(May 09 2021 at 09:29)</a>:</h4>
<p>The second layer is to realize you criterion is already in mathlib:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nat_find_criterion</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hsat</span> <span class="o">:</span> <span class="n">p</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hmin</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">nat.find</span> <span class="o">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">hsat</span><span class="o">⟩</span> <span class="o">:=</span>
<span class="o">((</span><span class="n">nat.find_eq_iff</span> <span class="o">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">hsat</span><span class="o">⟩)</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">⟨</span><span class="n">hsat</span><span class="o">,</span> <span class="n">hmin</span><span class="o">⟩)</span><span class="bp">.</span><span class="n">symm</span>
</code></pre></div>



<a name="238022827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238022827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238022827">(May 09 2021 at 09:30)</a>:</h4>
<p>So you can remove it and start the last proof with:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">first_prime</span> <span class="o">:</span> <span class="n">primecount</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">erw</span> <span class="n">nat.find_eq_iff</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="238022926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238022926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238022926">(May 09 2021 at 09:32)</a>:</h4>
<p>Note the <code>e</code> in <code>erw</code> asks <code>rw</code> to unfold definitions, but you could also write <code>change nat.find _ = _,</code> as the first line and then use the ordinary <code>rw</code></p>



<a name="238023052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023052">(May 09 2021 at 09:34)</a>:</h4>
<p>Actually, if I remove open_locale classical, then my proof of nat_find_criterion stops working, and Lean objects with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">s</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span>
<span class="n">hsat</span> <span class="o">:</span> <span class="n">p</span> <span class="n">m</span><span class="o">,</span>
<span class="n">hmin</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">n</span>
<span class="bp">⊢</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>



<a name="238023057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023057">(May 09 2021 at 09:34)</a>:</h4>
<p>Where can I read about what open_locale classical actually does?<br>
It seems to come up quite often</p>



<a name="238023061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023061">(May 09 2021 at 09:35)</a>:</h4>
<p>Did you actually compare my version with yours?</p>



<a name="238023075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023075">(May 09 2021 at 09:35)</a>:</h4>
<p>I did change the statement of <code>nat_find_criterion</code></p>



<a name="238023182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023182">(May 09 2021 at 09:37)</a>:</h4>
<p>By adding <code>[decidable_pred p]</code>, I see</p>



<a name="238023199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023199">(May 09 2021 at 09:37)</a>:</h4>
<p>I don't know if we have a web page gathering what different locales do. You can go in the src folder of mathlib and run <code>grep -R "localized.*classical"</code></p>



<a name="238023338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023338">(May 09 2021 at 09:40)</a>:</h4>
<p>That would show you everything, potentially including stuff you haven't imported. To make sure, you can write in your current lean file<br>
<code>run_cmd print_localized_commands [`classical]</code>, as explained on <a href="https://leanprover-community.github.io/mathlib_docs/commands.html#localized%20notation">https://leanprover-community.github.io/mathlib_docs/commands.html#localized%20notation</a> (whose title is a bit misleading)</p>



<a name="238023394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023394">(May 09 2021 at 09:41)</a>:</h4>
<p>Either way, you see that <code>open_locale classical</code> puts the instance tag on a bunch of declarations: <code>eq.decidable</code>, <code>decidable_eq_of_decidable_le</code>, <code>classical.prop_decidable</code>.</p>



<a name="238023408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023408">(May 09 2021 at 09:41)</a>:</h4>
<p>Oh, I thought all it did was <a href="https://leanprover-community.github.io/mathlib_docs/find/classical.dec/src">src#classical.dec</a></p>



<a name="238023468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023468">(May 09 2021 at 09:42)</a>:</h4>
<p>The main thing is <code>classical.prop_decidable</code></p>



<a name="238023501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023501">(May 09 2021 at 09:43)</a>:</h4>
<p>Huh, I guess <a href="https://leanprover-community.github.io/mathlib_docs/find/classical.prop_decidable">docs#classical.prop_decidable</a> is what <a href="https://leanprover-community.github.io/mathlib_docs/find/classical.dec">docs#classical.dec</a> is short for.</p>



<a name="238023520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023520">(May 09 2021 at 09:43)</a>:</h4>
<p>Stepan, do you understand what all those instances are about, or do you need more explanations?</p>



<a name="238023613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023613">(May 09 2021 at 09:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/Prime-counting.20function/near/238023501">said</a>:</p>
<blockquote>
<p>Huh, I guess <a href="https://leanprover-community.github.io/mathlib_docs/find/classical.prop_decidable">docs#classical.prop_decidable</a> is what <a href="https://leanprover-community.github.io/mathlib_docs/find/classical.dec">docs#classical.dec</a> is short for.</p>
</blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="n">classical.dec</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">@[nolint id.{1} (list.{0} name) (Prop def_lemma)]</span>
<span class="cm">noncomputable theorem classical.dec : Π (p : Prop), decidable p :=</span>
<span class="cm">λ (p : Prop), classical.prop_decidable p</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="238023621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023621">(May 09 2021 at 09:45)</a>:</h4>
<p>I have no idea we why this need this duplication</p>



<a name="238023624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023624">(May 09 2021 at 09:45)</a>:</h4>
<p>So I guess <code>open_locale classical</code> lets you use axiom of choice (which implies the law of excluded middle)?</p>



<a name="238023680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023680">(May 09 2021 at 09:46)</a>:</h4>
<p>No, that's not at all about the axiom of choice.</p>



<a name="238023681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023681">(May 09 2021 at 09:46)</a>:</h4>
<p>But Lean is using classical logic by default, right? I'm using <code>by_contra</code> all the time and it is allowed</p>



<a name="238023689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023689">(May 09 2021 at 09:46)</a>:</h4>
<p>It's about excluded middle only.</p>



<a name="238023809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023809">(May 09 2021 at 09:48)</a>:</h4>
<p>So if we are allowed to apply <code>classical.choice</code> only to <code>Prop</code>, then this is equivalent to excluded middle?</p>



<a name="238023890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023890">(May 09 2021 at 09:50)</a>:</h4>
<p>You are always free to use <code>classical.choice</code> etc whenever. The locale just means that typeclass search will use it to produce <code>decidable</code> instances via LEM.</p>



<a name="238023898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023898">(May 09 2021 at 09:50)</a>:</h4>
<p>But now I'm confused on why do we have to open something if I can already use <code>by_contra</code> in Lean without opening it anyway?</p>



<a name="238023919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023919">(May 09 2021 at 09:50)</a>:</h4>
<p>Because by_contra isn't typeclass search</p>



<a name="238023940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023940">(May 09 2021 at 09:51)</a>:</h4>
<p>Lean can do two things: it can do mathematical reasoning, and there of course you want excluded middle and choice, but it can also do programming, which is useful when you want to write tactics and, less crucially, can be convenient in some proofs about computable objects. In programming excluded middle doesn't make any sense. Whatever the language, you want to be able to write <code>if condition then ... else ...</code> without the program hanging forever. The decidable classes in Lean are a way to register decision procedures so that it can <em>execute</em> such <code>if</code> statements. If <code>classical.decidable_prop</code> is an instance you're telling Lean that the procedure for any condition is to use the excluded middle law, but this will block execution.</p>



<a name="238023941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238023941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238023941">(May 09 2021 at 09:51)</a>:</h4>
<p>Many tactics will fall back on classical mode anyway, but if you are in term mode some things won't work, for example <code>if x = y then ...</code> if <code>x = y</code> isn't decidable</p>



<a name="238024209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238024209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238024209">(May 09 2021 at 09:56)</a>:</h4>
<p>So if my definition is not <code>noncomputable</code>, then Lean will be able to actually calculate its output</p>



<a name="238024301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238024301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238024301">(May 09 2021 at 09:58)</a>:</h4>
<p>Then shouldn't there be some universal tactic that proves things like <code>primecount 1  = 3</code> by computation? If I type <code>#eval primecount 1</code>, then Lean correctly outputs <code>3</code>, which means that deep down it knows the answer somehow</p>



<a name="238024375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238024375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238024375">(May 09 2021 at 10:00)</a>:</h4>
<p>yes, that exists</p>



<a name="238024528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238024528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238024528">(May 09 2021 at 10:02)</a>:</h4>
<p>due to recent changes in lean it doesn't quite work out of the box but you can do this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.prime</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">nat.decidable_prime_1</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">nat.prime</span> <span class="mi">7</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
</code></pre></div>



<a name="238024646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238024646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238024646">(May 09 2021 at 10:04)</a>:</h4>
<p>Why is <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.decidable_prime_1">docs#nat.decidable_prime_1</a> not an instance?</p>



<a name="238024674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238024674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238024674">(May 09 2021 at 10:05)</a>:</h4>
<p>because it's slower than the default instance, which is used by <code>#eval</code></p>



<a name="238024697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238024697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238024697">(May 09 2021 at 10:05)</a>:</h4>
<p>if you want to do kernel computation you shouldn't use either one and use <code>num.prime</code> instead</p>



<a name="238024908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238024908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238024908">(May 09 2021 at 10:09)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.num.prime</span>

<span class="kd">def</span> <span class="n">find_prime</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">num</span> <span class="bp">→</span> <span class="n">num</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">n</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">n.prime</span> <span class="k">then</span> <span class="n">n</span> <span class="k">else</span> <span class="n">find_prime</span> <span class="n">i</span> <span class="n">n.succ</span>

<span class="kd">def</span> <span class="n">ith_prime</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">num</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">2</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">ith_prime</span> <span class="n">i</span> <span class="k">in</span> <span class="n">find_prime</span> <span class="n">n</span> <span class="n">n.succ</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">ith_prime</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">3</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">ith_prime</span> <span class="mi">4</span> <span class="bp">=</span> <span class="mi">11</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">ith_prime</span> <span class="mi">100</span> <span class="bp">=</span> <span class="mi">547</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
</code></pre></div>



<a name="238024976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238024976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238024976">(May 09 2021 at 10:10)</a>:</h4>
<p>The "universal tactic that proves things like <code>primecount 1 = 3</code> by computation" is called <code>norm_num</code></p>



<a name="238025004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238025004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238025004">(May 09 2021 at 10:10)</a>:</h4>
<p>however you have to write plugins for it to support new functions, and it doesn't know about <code>primecount</code></p>



<a name="238025022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Prime-counting%20function/near/238025022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Prime-counting.20function.html#238025022">(May 09 2021 at 10:11)</a>:</h4>
<p>If it did, it could do a lot better than this naive counting algorithm</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
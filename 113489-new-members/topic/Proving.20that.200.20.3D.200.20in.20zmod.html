---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html">Proving that 0 = 0 in zmod</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="208093798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208093798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208093798">(Aug 26 2020 at 13:55)</a>:</h4>
<p>I am having trouble with this simple lemma.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">zero_eq_zero</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>


<p>In fact, I have been able to prove this, which I thought would already be in mathlib:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>  <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)]</span>

<span class="kn">lemma</span> <span class="n">zero_iff_n_divides</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">↔</span> <span class="n">n</span>  <span class="err">∣</span> <span class="n">x</span><span class="bp">.</span><span class="n">val</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">finish</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
        <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">w</span> <span class="n">hw</span><span class="o">,</span>
        <span class="n">suffices</span> <span class="o">:</span> <span class="n">w</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">finish</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="n">x</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="o">:=</span> <span class="bp">@@</span><span class="n">zmod</span><span class="bp">.</span><span class="n">val_lt</span> <span class="bp">_</span><span class="n">inst_1</span> <span class="n">x</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">hw</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
        <span class="n">suffices</span> <span class="o">:</span> <span class="n">w</span> <span class="bp">&lt;</span> <span class="mi">1</span><span class="o">,</span> <span class="k">by</span> <span class="n">linarith</span><span class="o">,</span>
        <span class="n">exact</span> <span class="o">(</span><span class="n">mul_lt_iff_lt_one_right</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">H</span><span class="o">,</span>
    <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>


<p>and I can't seem to prove the analogous one for integers:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>  <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)]</span>

<span class="kn">lemma</span> <span class="n">zero_iff_n_divides&#39;</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">):=</span>
<span class="k">begin</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">finish</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
        <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">w</span> <span class="n">hw</span><span class="o">,</span>
        <span class="n">suffices</span> <span class="o">:</span> <span class="n">w</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
        <span class="o">{</span>
            <span class="k">have</span> <span class="n">hw0</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">nlinarith</span><span class="o">,</span>
            <span class="n">exact</span> <span class="n">zero_eq_zero</span> <span class="n">hw0</span><span class="o">,</span>
        <span class="o">},</span>
        <span class="n">sorry</span>
    <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>


<p>Incidentally, I don't see with the typeclass inference system doesn't work in this case (hence the two occurrences of _inst_1 in the proof). Is there something that I am overlooking?</p>
<p>Thank you!</p>



<a name="208094032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208094032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208094032">(Aug 26 2020 at 13:57)</a>:</h4>
<p>Can you post a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>? You're missing one or more of imports, variables, opens, universes</p>



<a name="208094259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208094259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208094259">(Aug 26 2020 at 13:58)</a>:</h4>
<p><code>&lt;</code> is not a class, so <code>[0 &lt; n]</code> won't work. Inputs to functions in <code>[square brackets]</code> are supposed to be filled in by the type class inference system, and the type class inference system only deals with classes, so it won't deal with <code>&lt;</code>.</p>



<a name="208094498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208094498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208094498">(Aug 26 2020 at 14:00)</a>:</h4>
<p>I feel like some people might think I'm just nagging when I ask for MWE's, but I genuinely don't know what to import to get zmod and I'm too lazy to find out.</p>



<a name="208094576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208094576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208094576">(Aug 26 2020 at 14:00)</a>:</h4>
<p>That compiles in my system.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">zmod</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">classical</span>
<span class="n">noncomputable</span> <span class="n">theory</span>


<span class="kn">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>  <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)]</span>

<span class="kn">lemma</span> <span class="n">zero_eq_zero</span>  <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208094670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208094670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208094670">(Aug 26 2020 at 14:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod/near/208094498">said</a>:</p>
<blockquote>
<p>I feel like some people might think I'm just nagging when I ask for MWE's, but I genuinely don't know what to import to get zmod and I'm too lazy to find out.</p>
</blockquote>
<p>I am not one of those people.</p>



<a name="208094703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208094703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208094703">(Aug 26 2020 at 14:01)</a>:</h4>
<p>You're using a coercion from zmod n to Z? Eew. I am surprised there is even a coercion :-)</p>



<a name="208094936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208094936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208094936">(Aug 26 2020 at 14:03)</a>:</h4>
<p>Well somewhere in Zulip I saw that it's best to work with int than with nat whenever possible.</p>



<a name="208094949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208094949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208094949">(Aug 26 2020 at 14:03)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">h</span><span class="o">:</span> <span class="err">↑</span><span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="err">⊢</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span>
</code></pre></div>


<p>I don't know what the definition of that arrow is yet</p>



<a name="208095117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095117">(Aug 26 2020 at 14:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="254058">Marc Masdeu</span> <a href="#narrow/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod/near/208094936">said</a>:</p>
<blockquote>
<p>Well somewhere in Zulip I saw that it's best to work with int than with nat whenever possible.</p>
</blockquote>
<p>that surely highly depends on context</p>



<a name="208095144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095144">(Aug 26 2020 at 14:04)</a>:</h4>
<p>I say that if you're in zmod you shouldn't coerce to int</p>



<a name="208095164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095164">(Aug 26 2020 at 14:04)</a>:</h4>
<p>or to nat</p>



<a name="208095212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095212">(Aug 26 2020 at 14:04)</a>:</h4>
<p>If you plan to do subtractions you shouldn't be using nat because it doesn't have a subtraction (it's a semiring, not a ring)</p>



<a name="208095261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095261">(Aug 26 2020 at 14:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod/near/208094949">said</a>:</p>
<blockquote>
<div class="codehilite"><pre><span></span><code><span class="n">h</span><span class="o">:</span> <span class="err">↑</span><span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="err">⊢</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span>
</code></pre></div>


<p>I don't know what the definition of that arrow is yet</p>
</blockquote>
<p>Kevin, we longer have this issue since Ed offered us magic widgets.</p>



<a name="208095285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095285">(Aug 26 2020 at 14:05)</a>:</h4>
<p>Just click on the arrow.</p>



<a name="208095296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095296">(Aug 26 2020 at 14:05)</a>:</h4>
<p>What I want is an easy way to go from x=y (in zmod n) to n dividing x'-y', where x' and y' are lifts to integers. So here is where subtraction appears.</p>



<a name="208095329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095329">(Aug 26 2020 at 14:05)</a>:</h4>
<p>when we say "lift", we choose x' first</p>



<a name="208095380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095380">(Aug 26 2020 at 14:06)</a>:</h4>
<p>what are x' and y'? Are they arbitrary? Is this a theorem about x and y, or about x' and y'?</p>



<a name="208095401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095401">(Aug 26 2020 at 14:06)</a>:</h4>
<p>i.e. rather than using the standard lift that isn't canonical, instead let the integer be the variable</p>



<a name="208095437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095437">(Aug 26 2020 at 14:06)</a>:</h4>
<p>so the "correct" theorem should say that for x y : Z, (x : zmod n) = y &lt;-&gt; n | (x - y)</p>



<a name="208095443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095443">(Aug 26 2020 at 14:06)</a>:</h4>
<p><a href="/user_uploads/3121/mUaX_-qQkVNr0zek6n8vdPVp/uparrow2.png">uparrow2.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/mUaX_-qQkVNr0zek6n8vdPVp/uparrow2.png" title="uparrow2.png"><img src="/user_uploads/3121/mUaX_-qQkVNr0zek6n8vdPVp/uparrow2.png"></a></div>



<a name="208095452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095452">(Aug 26 2020 at 14:06)</a>:</h4>
<p>coercing from int to zmod is good; from zmod to int is bad</p>



<a name="208095463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095463">(Aug 26 2020 at 14:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> I said I didn't know the definition precisely because this trick told me nothing</p>



<a name="208095528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095528">(Aug 26 2020 at 14:07)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">has_lift</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="bp">ℤ</span><span class="o">)</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">tactic.mk_instance failed to generate instance for</span>
<span class="cm">  has_lift (zmod n) ℤ</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="208095545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095545">(Aug 26 2020 at 14:07)</a>:</h4>
<p>I've never understood the zoo of lifts and coercions properly</p>



<a name="208095582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095582">(Aug 26 2020 at 14:07)</a>:</h4>
<p>The trick tells you this is coercion from <code>zmod n</code> to <code>int</code>, that's infinitely more information than what you would have had before widgets.</p>



<a name="208095642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095642">(Aug 26 2020 at 14:08)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="bp">ℤ</span><span class="o">)</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">tactic.mk_instance failed to generate instance for</span>
<span class="cm">  has_coe (zmod n) ℤ</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="208095697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095697">(Aug 26 2020 at 14:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod/near/208095582">said</a>:</p>
<blockquote>
<p>The trick tells you this is coercion from <code>zmod n</code> to <code>int</code>, that's infinitely more information than what you would have had before widgets.</p>
</blockquote>
<p>I already knew that from the lemma statement <code>lemma zero_eq_zero  {x : zmod n} (h : (x : ℤ) = 0) : x = 0 :=</code></p>



<a name="208095728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095728">(Aug 26 2020 at 14:08)</a>:</h4>
<p>I genuinely don't know how to work out what the map is</p>



<a name="208095894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095894">(Aug 26 2020 at 14:10)</a>:</h4>
<p>oh -- I keep going with the widgets!</p>



<a name="208095971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208095971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208095971">(Aug 26 2020 at 14:10)</a>:</h4>
<p><a href="/user_uploads/3121/VAMedzE_4iIR6nCMr1zp9Zbf/tada.png">tada.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/VAMedzE_4iIR6nCMr1zp9Zbf/tada.png" title="tada.png"><img src="/user_uploads/3121/VAMedzE_4iIR6nCMr1zp9Zbf/tada.png"></a></div>



<a name="208096021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208096021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208096021">(Aug 26 2020 at 14:11)</a>:</h4>
<p>what is that cursed instance</p>



<a name="208096114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208096114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208096114">(Aug 26 2020 at 14:12)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm">- Cast an integer modulo `n` to another semiring.</span>
<span class="cm">This function is a morphism if the characteristic of `R` divides `n`.</span>
<span class="cm">See `zmod.cast_hom` for a bundled version. -/</span>
<span class="n">def</span> <span class="n">cast</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">},</span> <span class="n">zmod</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">R</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="o">:=</span> <span class="n">int</span><span class="bp">.</span><span class="n">cast</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span>

<span class="c1">-- see Note [coercion into rings]</span>
<span class="bp">@</span><span class="o">[</span><span class="n">priority</span> <span class="mi">900</span><span class="o">]</span> <span class="kn">instance</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_coe_t</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">cast</span><span class="bp">⟩</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">cast_zero</span> <span class="o">:</span> <span class="o">((</span><span class="mi">0</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">n</span><span class="bp">;</span> <span class="n">refl</span> <span class="o">}</span>
</code></pre></div>



<a name="208096194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208096194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208096194">(Aug 26 2020 at 14:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  <a href="https://github.com/leanprover-community/mathlib/pull/3882#discussion_r475005206">https://github.com/leanprover-community/mathlib/pull/3882#discussion_r475005206</a></p>



<a name="208096491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208096491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208096491">(Aug 26 2020 at 14:14)</a>:</h4>
<p>This coercion has no good ring-theoretic properties. <span class="user-mention" data-user-id="110596">@Rob Lewis</span> the Teichmuller lift is at least a homomorphism of monoids with zero :-)</p>



<a name="208096526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208096526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208096526">(Aug 26 2020 at 14:14)</a>:</h4>
<p>OK I'll try to explain myself a bit better. I was trying to prove</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">p</span> <span class="n">r</span> <span class="n">n</span> <span class="n">m</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">fact</span> <span class="n">p</span><span class="bp">.</span><span class="n">prime</span><span class="o">]</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)]</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">m</span><span class="o">)]</span> <span class="o">[</span><span class="mi">1</span> <span class="bp">≤</span> <span class="n">r</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">basic_lemma</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span><span class="o">))</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
   <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>


<p>This is a statement about elements all in zmod (either p or p^r). It seems that it should be very easy, but I got this so far:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">basic_lemma</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span><span class="o">))</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="k">have</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="n">p</span><span class="o">,</span> <span class="k">by</span> <span class="n">assumption</span><span class="o">,</span>
    <span class="k">have</span>  <span class="n">h1</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span><span class="bp">^</span><span class="n">r</span> <span class="err">∣</span> <span class="o">((</span><span class="n">x</span><span class="bp">.</span><span class="n">val</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span><span class="bp">.</span><span class="n">val</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">),</span>
    <span class="o">{</span>
        <span class="k">have</span> <span class="n">h&#39;</span> <span class="o">:</span>  <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">-</span><span class="mi">1</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">sub_eq_zero</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">h</span><span class="o">,</span>
        <span class="c1">--rw_mod_cast zmod.int_coe_zmod_eq_zero_iff_dvd at h&#39;,</span>
        <span class="n">sorry</span>
    <span class="o">},</span>
    <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="o">((</span><span class="n">x</span><span class="bp">.</span><span class="n">val</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span><span class="bp">.</span><span class="n">val</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">),</span>
    <span class="o">{</span>
        <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">w</span> <span class="n">h1w</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">h1w</span><span class="o">,</span>
        <span class="n">ring</span><span class="o">,</span>
        <span class="n">fconstructor</span><span class="o">,</span>
        <span class="n">use</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="o">(</span><span class="n">r</span><span class="bp">-</span><span class="mi">1</span><span class="o">))</span> <span class="bp">*</span> <span class="n">w</span><span class="o">,</span>
        <span class="n">rw</span> <span class="err">←</span> <span class="n">int</span><span class="bp">.</span><span class="n">mul_assoc</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">hp</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span><span class="bp">^</span><span class="n">r</span> <span class="bp">=</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">p</span><span class="bp">^</span><span class="o">(</span><span class="n">r</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span>
        <span class="o">{</span>
            <span class="n">induction</span> <span class="n">r</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
            <span class="o">{</span>
                <span class="n">linarith</span><span class="o">,</span>
            <span class="o">},</span>
            <span class="o">{</span>
                <span class="n">ring</span><span class="o">,</span>
                <span class="n">ring</span><span class="o">,</span>
            <span class="o">}</span>
        <span class="o">},</span>
        <span class="n">rw</span> <span class="err">←</span><span class="n">hp</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">int</span><span class="bp">.</span><span class="n">mul_comm</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="o">((</span><span class="n">x</span><span class="bp">.</span><span class="n">val</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">∣</span> <span class="o">(</span><span class="n">x</span><span class="bp">.</span><span class="n">val</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="k">have</span> <span class="n">hfac</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span><span class="bp">.</span><span class="n">val</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span><span class="bp">.</span><span class="n">val</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span>
                    <span class="bp">=</span> <span class="o">((</span><span class="n">x</span><span class="bp">.</span><span class="n">val</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">((</span><span class="n">x</span><span class="bp">.</span><span class="n">val</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">ring</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">hfac</span> <span class="n">at</span> <span class="n">h2</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">int</span><span class="bp">.</span><span class="n">prime</span><span class="bp">.</span><span class="n">dvd_mul&#39;</span> <span class="n">hp</span> <span class="n">h2</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="n">cases</span> <span class="n">h3</span> <span class="k">with</span> <span class="n">h3l</span> <span class="n">h3r</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">left</span><span class="o">,</span>
        <span class="n">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">sub_eq_zero</span><span class="bp">.</span><span class="n">mp</span> <span class="n">this</span><span class="o">,</span>
        <span class="n">rw</span><span class="err">←</span> <span class="n">zmod</span><span class="bp">.</span><span class="n">int_coe_zmod_eq_zero_iff_dvd</span> <span class="o">(((</span><span class="n">x</span><span class="bp">.</span><span class="n">val</span><span class="o">):</span><span class="bp">ℤ</span><span class="o">)</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="n">p</span> <span class="n">at</span> <span class="n">h3l</span><span class="o">,</span>
        <span class="n">push_cast</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
        <span class="n">rw</span> <span class="bp">@@</span><span class="n">x_val_trans</span> <span class="bp">_</span><span class="n">inst_1</span> <span class="bp">_</span><span class="n">inst_4</span> <span class="n">at</span> <span class="n">h3l</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">h3l</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
        <span class="n">right</span><span class="o">,</span>
        <span class="n">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">eq_neg_of_add_eq_zero</span> <span class="n">this</span><span class="o">,</span>
        <span class="n">rw</span><span class="err">←</span> <span class="n">zmod</span><span class="bp">.</span><span class="n">int_coe_zmod_eq_zero_iff_dvd</span> <span class="o">(((</span><span class="n">x</span><span class="bp">.</span><span class="n">val</span><span class="o">):</span><span class="bp">ℤ</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">p</span> <span class="n">at</span> <span class="n">h3r</span><span class="o">,</span>
        <span class="n">push_cast</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
        <span class="n">rw</span> <span class="bp">@@</span><span class="n">x_val_trans</span> <span class="bp">_</span><span class="n">inst_1</span> <span class="bp">_</span><span class="n">inst_4</span> <span class="n">at</span> <span class="n">h3r</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">h3r</span><span class="o">,</span>
    <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>


<p>So I find myself trying to prove</p>
<div class="codehilite"><pre><span></span><code><span class="err">↑</span><span class="n">p</span> <span class="bp">^</span> <span class="n">r</span> <span class="err">∣</span> <span class="err">↑</span><span class="o">(</span><span class="n">x</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="bp">*</span> <span class="err">↑</span><span class="o">(</span><span class="n">x</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span>
</code></pre></div>


<p>in the realm of int...</p>



<a name="208096728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208096728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208096728">(Aug 26 2020 at 14:16)</a>:</h4>
<p>To prove the basic lemma, let xbar be x mod p and deduce that xbar^2=1 and then you're done because zmod p is a field, right?</p>



<a name="208096875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208096875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208096875">(Aug 26 2020 at 14:17)</a>:</h4>
<p>This was my math proof, but I had a bit more trouble writing it in Lean!</p>



<a name="208096894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208096894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208096894">(Aug 26 2020 at 14:17)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> right, so the problem is how to coerce from zmod (p^r) to zmod p</p>



<a name="208096931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208096931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208096931">(Aug 26 2020 at 14:17)</a>:</h4>
<p>now that cursed instance seems like a good candidate</p>



<a name="208096981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208096981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208096981">(Aug 26 2020 at 14:18)</a>:</h4>
<p>because zmod p does have characteristic dividing p^r</p>



<a name="208097009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208097009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208097009">(Aug 26 2020 at 14:18)</a>:</h4>
<p>But <span class="user-mention" data-user-id="110064">@Kenny Lau</span> this coercion should be simple, right?</p>



<a name="208097035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208097035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208097035">(Aug 26 2020 at 14:18)</a>:</h4>
<p>so maybe <code>zmod.cast_hom</code> would help</p>



<a name="208097246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208097246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208097246">(Aug 26 2020 at 14:20)</a>:</h4>
<p>In the situation where the coercion is ring-theoretically reasonable one should use the ring-theoretic coercion I guess</p>



<a name="208097374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208097374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208097374">(Aug 26 2020 at 14:20)</a>:</h4>
<p>I feel like this is still <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a></p>



<a name="208097412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208097412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208097412">(Aug 26 2020 at 14:21)</a>:</h4>
<p>the "basic lemma" has a coercion from zmod (p^r) to zmod p</p>



<a name="208097420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208097420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208097420">(Aug 26 2020 at 14:21)</a>:</h4>
<p>what demanded this coercion to start with?</p>



<a name="208097462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208097462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208097462">(Aug 26 2020 at 14:21)</a>:</h4>
<p>There is no API for it and it's a horrible function, so it's horrible to use.</p>



<a name="208097617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208097617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208097617">(Aug 26 2020 at 14:22)</a>:</h4>
<p>OK the feeling I had throughout is that zmod's API is not quite working yet. It is very hard to work with it, since it has references to %, to MOD, ...</p>



<a name="208097984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208097984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208097984">(Aug 26 2020 at 14:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod/near/208097374">said</a>:</p>
<blockquote>
<p>I feel like this is still <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a></p>
</blockquote>
<p>You got me. I want to prove that in Z/p^r  (p odd) the only solutions to x^2-1=0 are 1 and -1. The way I can prove this is to lift x to x'=+-1 + e, with e being a multiple of p (hence the basic lemma). Then I prove that p^r divides e, here is where I use that p is odd.</p>



<a name="208098113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208098113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208098113">(Aug 26 2020 at 14:26)</a>:</h4>
<p>right, that looks like the standard proof.</p>



<a name="208098764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208098764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208098764">(Aug 26 2020 at 14:30)</a>:</h4>
<p>I might start from scratch...</p>



<a name="208100005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208100005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208100005">(Aug 26 2020 at 14:39)</a>:</h4>
<p>rofl <code>cast</code> uses <code>nat.cast_coe</code> because it's coercing to a general ring, as opposed to the standard coercion from nat to int.</p>



<a name="208100141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208100141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208100141">(Aug 26 2020 at 14:40)</a>:</h4>
<p>so the issue is to prove that <code>nat.cast_coe</code> is injective when going from nat to int.</p>



<a name="208101618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208101618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208101618">(Aug 26 2020 at 14:49)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">zmod</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">classical</span>
<span class="n">noncomputable</span> <span class="n">theory</span>


<span class="kn">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)]</span>

<span class="kn">lemma</span> <span class="n">zero_eq_zero</span>  <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="c1">-- this workaround is because you&#39;re using `fact`</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">unfreeze_local_instances</span><span class="o">,</span>
  <span class="c1">-- deal with n = 0 case</span>
  <span class="n">cases</span> <span class="n">n</span> <span class="k">with</span> <span class="n">d</span><span class="o">,</span> <span class="n">cases</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">,</span>
  <span class="c1">-- now n = d + 1</span>
  <span class="c1">-- now take x apart</span>
  <span class="n">cases</span> <span class="n">x</span> <span class="k">with</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span>
  <span class="c1">-- now a is a natural</span>
  <span class="n">ext</span><span class="o">,</span> <span class="n">dsimp</span><span class="o">,</span>
  <span class="c1">-- and it suffices to prove a = 0,</span>
  <span class="n">unfold_coes</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="c1">-- zmod.cast has no API because nobody uses it</span>
  <span class="n">rw</span> <span class="n">zmod</span><span class="bp">.</span><span class="n">cast</span><span class="bp">.</span><span class="n">equations</span><span class="bp">._</span><span class="n">eqn_2</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="c1">-- We know the usual map ℕ → ℤ is injective</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_eq_zero</span><span class="o">,</span>
  <span class="c1">-- so we would be done by h</span>
  <span class="n">convert</span> <span class="n">h</span><span class="o">,</span>
  <span class="c1">-- except we now have to prove that the two coercions ℕ → ℤ are equal.</span>
  <span class="n">apply</span> <span class="n">congr_arg</span> <span class="n">has_coe_t</span><span class="bp">.</span><span class="n">mk</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">n</span><span class="o">,</span>
  <span class="c1">-- we prove it by induction</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">unfold</span> <span class="n">nat</span><span class="bp">.</span><span class="n">cast</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">hd</span><span class="o">,</span>
    <span class="n">refl</span> <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>


<p>You're really fighting the system here because the casts don't have too much API</p>



<a name="208102192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208102192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208102192">(Aug 26 2020 at 14:53)</a>:</h4>
<p>My apologies for the awful coercion. I don't know how to improve it.</p>



<a name="208102248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208102248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208102248">(Aug 26 2020 at 14:53)</a>:</h4>
<p>Wow! That is incredibly hard!! Thanks <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, this is the kind of thing that throw some people off...</p>



<a name="208102255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208102255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208102255">(Aug 26 2020 at 14:53)</a>:</h4>
<p>Because it's so general it's hard to find lemmas about it.</p>



<a name="208102392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208102392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208102392">(Aug 26 2020 at 14:54)</a>:</h4>
<p>What's going on here Marc is that there is a map from Z/nZ to <em>any ring</em> given by literally sending 0,1,2,...,n-1 to 0,1,2,...,n-1. There aren't really any lemmas you can prove about it.</p>



<a name="208102450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208102450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208102450">(Aug 26 2020 at 14:54)</a>:</h4>
<p>However, for a given ring like the integers, there are lemmas you can prove (for example injectivity)</p>



<a name="208102497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208102497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208102497">(Aug 26 2020 at 14:55)</a>:</h4>
<p>but these lemmas are not proved, as far as I can see.</p>



<a name="208102573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208102573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208102573">(Aug 26 2020 at 14:55)</a>:</h4>
<p>because probably there are a million such lemmas. We know that "if x is in Z/nZ then lift x to Z" is a reasonable thing to do</p>



<a name="208102639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208102639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208102639">(Aug 26 2020 at 14:56)</a>:</h4>
<p>but "if x is in Z/nZ then randomly map it to Z/mZ" is perhaps not so common</p>



<a name="208102676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208102676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208102676">(Aug 26 2020 at 14:56)</a>:</h4>
<p>I see. Yes, the general map is a bit dumb, but it's very common <strong>as you know</strong> in arithmetic to lift elements in Z/n to Z and then prove things about those lifts, so it'd be useful to have some lemmas about this.</p>



<a name="208102819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208102819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208102819">(Aug 26 2020 at 14:57)</a>:</h4>
<p>It might be interesting <span class="user-mention" data-user-id="112680">@Johan Commelin</span> to see how many times in the library this map is used when the target ring is not nat or int. If people are only using it to lift from Z/n to Z (this is Marc's use case and also yours in the PR) then perhaps it's worth restricting to that case and then writing the API which Marc needed here.</p>



<a name="208102869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208102869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208102869">(Aug 26 2020 at 14:57)</a>:</h4>
<p>Maybe it'd be best to do as in mathlib, start with integers and prove things about their images in various zmods</p>



<a name="208102954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208102954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208102954">(Aug 26 2020 at 14:58)</a>:</h4>
<p>right, that's another way of thinking about it.</p>



<a name="208102984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208102984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208102984">(Aug 26 2020 at 14:58)</a>:</h4>
<p>There is congruence mod n in mathlib, and it's an equivalence relation on integers</p>



<a name="208103019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208103019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208103019">(Aug 26 2020 at 14:58)</a>:</h4>
<p>and that has a whole file of API, a very solid one.</p>



<a name="208103082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208103082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208103082">(Aug 26 2020 at 14:59)</a>:</h4>
<p>Yes, I will want to work with the ring (and its units) zmod n, so I'd rather not think in terms of equivalence relations...</p>



<a name="208103095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208103095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208103095">(Aug 26 2020 at 14:59)</a>:</h4>
<p>I feel like lifting from Z/p^n to Z/p^(n+1) is still a useful thing though</p>



<a name="208103139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208103139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208103139">(Aug 26 2020 at 14:59)</a>:</h4>
<p>Ideally, it would be easy to go back and forth between all these objects.</p>



<a name="208103255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208103255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208103255">(Aug 26 2020 at 15:00)</a>:</h4>
<p>but I would be strongly tempted here not to use the cast. It <em>is</em> easy to go back and forth between these objects, because you can do it directly without using the coercion.</p>



<a name="208103378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208103378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208103378">(Aug 26 2020 at 15:00)</a>:</h4>
<p>I'll try...</p>



<a name="208103457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208103457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208103457">(Aug 26 2020 at 15:01)</a>:</h4>
<p>If n&gt;0 then a term of type <code>zmod n</code> is just a pair (a,h) with a a natural and h a proof that it's less than n. So you can just use (a,h') to move from Z/n to Z/(pn) where h' is a proof that a&lt;pn manufactured from the proof that it's less than n</p>



<a name="208103579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208103579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208103579">(Aug 26 2020 at 15:02)</a>:</h4>
<p>It would be very easy to prove things about that map because it's defined concretely on the level of integers without using nat.cast or zmod.cast</p>



<a name="208104739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208104739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208104739">(Aug 26 2020 at 15:10)</a>:</h4>
<p>I can't find x^2=1 -&gt; x=+-1 in a field</p>



<a name="208105088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208105088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208105088">(Aug 26 2020 at 15:13)</a>:</h4>
<p>There's <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_self_eq_one_iff">docs#mul_self_eq_one_iff</a></p>



<a name="208105719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208105719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208105719">(Aug 26 2020 at 15:16)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">zmod</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">classical</span>
<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">zmod</span><span class="bp">.</span><span class="n">cast_hom</span>


<span class="kn">variables</span> <span class="o">{</span><span class="n">p</span> <span class="n">r</span> <span class="n">n</span> <span class="n">m</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="bp">.</span><span class="n">prime</span><span class="o">)</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">div_pow</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="err">∣</span> <span class="n">p</span><span class="bp">^</span><span class="n">r</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="c1">-- do a case split on r=0 or r=s+1</span>
  <span class="n">cases</span> <span class="n">r</span> <span class="k">with</span> <span class="n">s</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- r=0 can&#39;t happen</span>
    <span class="n">cases</span> <span class="n">hr</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- r = s + 1 so we can use nat.pow_succ</span>
    <span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pow_succ</span><span class="o">,</span>
    <span class="c1">-- library_search found the next line</span>
    <span class="n">apply</span> <span class="n">dvd_mul_left</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kn">end</span>

<span class="n">include</span> <span class="n">hp</span> <span class="n">hn</span> <span class="n">hm</span> <span class="n">hr</span>

<span class="kn">lemma</span> <span class="n">basic_lemma</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="n">r</span><span class="o">))</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">zmod</span><span class="bp">.</span><span class="n">cast_hom</span> <span class="o">(</span><span class="n">div_pow</span> <span class="n">p</span> <span class="n">hr</span><span class="o">)</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">p</span><span class="o">),</span> <span class="c1">-- the ring hom</span>
  <span class="n">set</span> <span class="n">xp</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">x</span> <span class="k">with</span> <span class="n">hxp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hxpsquared</span> <span class="o">:</span> <span class="n">xp</span> <span class="bp">*</span> <span class="n">xp</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">hxp</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">f</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">f</span><span class="bp">.</span><span class="n">map_one</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">fact</span> <span class="n">p</span><span class="bp">.</span><span class="n">prime</span> <span class="o">:=</span> <span class="n">hp</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">mul_self_eq_one_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hxpsquared</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208110429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208110429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208110429">(Aug 26 2020 at 15:52)</a>:</h4>
<p>Note that mathlib knows that <code>coe : int → zmod n</code> is surjective. In fact it knows that arbitrary ring homs to <code>zmod n</code> are surjective.</p>



<a name="208110441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208110441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208110441">(Aug 26 2020 at 15:52)</a>:</h4>
<p>I guess that might be helpful...</p>



<a name="208110462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208110462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208110462">(Aug 26 2020 at 15:52)</a>:</h4>
<p>But I haven't thought about the details of what's going on here.</p>



<a name="208122490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208122490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208122490">(Aug 26 2020 at 17:30)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">zmod</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">theorem</span> <span class="n">cast_inj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">i</span><span class="o">},</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">int</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span> <span class="n">fin</span><span class="bp">.</span><span class="n">val_injective</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">cast_inj</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">zero_eq_zero</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">cast_inj</span> <span class="o">(</span><span class="n">h</span><span class="bp">.</span><span class="n">trans</span> <span class="err">$</span> <span class="k">by</span> <span class="n">simp</span><span class="o">)</span>
</code></pre></div>



<a name="208122552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208122552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208122552">(Aug 26 2020 at 17:31)</a>:</h4>
<p>Right! And now if we want to prove it for rationals, you have to prove a whole new cast_inj :-(</p>



<a name="208122719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208122719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208122719">(Aug 26 2020 at 17:32)</a>:</h4>
<p>I tried to generalize it but <code>char_p</code> wasn't built to handle this</p>



<a name="208122740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208122740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208122740">(Aug 26 2020 at 17:32)</a>:</h4>
<p>I don't know how to say "R is a ring with the first n elements distinct"</p>



<a name="208122852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208122852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208122852">(Aug 26 2020 at 17:34)</a>:</h4>
<p>Anyway this proof doesn't really generalize because the zero case uses <code>int.cast_id</code></p>



<a name="208122944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208122944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208122944">(Aug 26 2020 at 17:34)</a>:</h4>
<p>so a different ring would actually be substantively different</p>



<a name="208128926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20that%200%20%3D%200%20in%20zmod/near/208128926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod.html#208128926">(Aug 26 2020 at 18:25)</a>:</h4>
<p>Thanks for the discussion. I am slowly understanding how this is working...</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
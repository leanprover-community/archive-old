---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html">difference `let` and `have`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="206130930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206130930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206130930">(Aug 06 2020 at 11:56)</a>:</h4>
<p>I am struggling in understanding the sentence "The difference between <code>let</code> and <code>have</code> is that <code>let</code> introduces a local definition in the context, so that the definition of the local constant can be unfolded in the proof." from the Lean Book.</p>



<a name="206131016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206131016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206131016">(Aug 06 2020 at 11:57)</a>:</h4>
<p>In practice, it seems to me that if I want to introduce an object (say, a set) and then state that it has more structure, I should type</p>
<div class="codehilite"><pre><span></span><code><span class="k">let</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="k">in</span> <span class="n">Z</span> <span class="bp">|</span> <span class="n">x</span> <span class="n">is</span> <span class="n">even</span><span class="o">}</span>
<span class="k">let</span> <span class="n">X</span> <span class="o">:</span> <span class="n">is</span> <span class="n">a</span> <span class="n">subgroup</span>
</code></pre></div>


<p>whereas I would have expected the right tactic to be</p>
<div class="codehilite"><pre><span></span><code><span class="k">let</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="k">in</span> <span class="n">Z</span> <span class="bp">|</span> <span class="n">x</span> <span class="n">is</span> <span class="n">even</span><span class="o">}</span>
<span class="k">have</span> <span class="n">hX</span> <span class="o">:</span> <span class="n">X</span> <span class="n">is</span> <span class="n">a</span> <span class="n">subgroup</span>
</code></pre></div>


<p>I suspect that some type-business is hidden under the scene, as X cannot be a subgroup if it is a set. At any rate, my first question is about the difference between <code>let</code> and <code>have</code> and, secondly, about the "right" tactic to introduce an object, giving it a name, and then stating some properties of it.</p>



<a name="206134253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206134253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206134253">(Aug 06 2020 at 12:35)</a>:</h4>
<p>A bit difficult to say more than the book does without a more precise example.</p>



<a name="206134465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206134465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206134465">(Aug 06 2020 at 12:37)</a>:</h4>
<p>In general, for Props, use <code>have</code>. For data, use <code>let v : T := e</code> if the rest of the proof is going to need use the fact that <code>v</code> equals <code>e</code>, otherwise you can use <code>have</code> here as well.</p>



<a name="206135329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206135329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206135329">(Aug 06 2020 at 12:45)</a>:</h4>
<p>Well, in my example, I have a maximal ideal <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> in a ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> and I am defining its "inverse", as fractional ideal in the fraction field <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>: the localization map is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>. So what I did was<br>
<code>
let M1 := {x : K | ∀ y ∈ M, f.is_integer (x * f.to_map y)},
have M1 : fractional_ideal f,
</code><br>
having in mind that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">M1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord">1</span></span></span></span> was the definition of a subset of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>, and the second line was my claim that it is indeed a fractional ideal. But this creates two hypothesis called <code>M1</code>, whereas I got the advice of writing<br>
<code>
let M1 := {x : K | ∀ y ∈ M, f.is_integer (x * f.to_map y)},
let M1 : fractional_ideal f,
</code><br>
which indeed does the job, but I am puzzled both from the fact that saying "let M1" twice sounds odd, and also in properly understanding what's the difference.</p>



<a name="206135484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206135484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206135484">(Aug 06 2020 at 12:46)</a>:</h4>
<p>I think you should check the definition of <code>fractional_ideal</code></p>



<a name="206135523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206135523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206135523">(Aug 06 2020 at 12:47)</a>:</h4>
<p>I am also confused why you have two definitions both called <code>M1</code></p>



<a name="206135693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206135693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206135693">(Aug 06 2020 at 12:48)</a>:</h4>
<p><code>have M1 : fractional_ideal f,</code><br>
this couldn't possibly be correct, since it contains no reference to the original <code>M1</code>, unless there are more lines in between</p>



<a name="206135752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206135752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206135752">(Aug 06 2020 at 12:49)</a>:</h4>
<p>You seem to be imagining that <code>fractional_ideal</code> is something like "<code>is_fractional_ideal</code>", but it couldn't be because where is the ideal then?</p>



<a name="206135806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206135806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206135806">(Aug 06 2020 at 12:50)</a>:</h4>
<p>In the second one, I assume your definition of the second <code>M1</code> refers to the first <code>M1</code>?</p>



<a name="206136178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206136178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206136178">(Aug 06 2020 at 12:53)</a>:</h4>
<p>In the second I wanted to state "M1 belongs to the set of fractional ideals wrt f</p>



<a name="206136229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206136229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206136229">(Aug 06 2020 at 12:53)</a>:</h4>
<p>Oh I see, but that's not how <code>let</code>/<code>have</code> work</p>



<a name="206136294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206136294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206136294">(Aug 06 2020 at 12:54)</a>:</h4>
<p>(it's also not how types work)</p>



<a name="206136300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206136300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206136300">(Aug 06 2020 at 12:54)</a>:</h4>
<p>I see. Can you explain a bit more?</p>



<a name="206136321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206136321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206136321">(Aug 06 2020 at 12:54)</a>:</h4>
<p><code>have M1 : fractional_ideal f</code> means exactly the same as <code>have M7 : fractional_ideal f</code> except that the new variable is called <code>M1</code> instead of <code>M7</code></p>



<a name="206136401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206136401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206136401">(Aug 06 2020 at 12:55)</a>:</h4>
<p>if you reuse the name <code>M1</code>, it just means you end up with two variables with the same name (generally undesirable)</p>



<a name="206136403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206136403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206136403">(Aug 06 2020 at 12:55)</a>:</h4>
<p>And what do they (both) mean?</p>



<a name="206136517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206136517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206136517">(Aug 06 2020 at 12:56)</a>:</h4>
<p>And, you can never prove a statement of the form "such-and-such expression has such-and-such type" which seems to have been what you were trying to express</p>



<a name="206136558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206136558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206136558">(Aug 06 2020 at 12:56)</a>:</h4>
<p>well, they both introduce a variable of type <code>fractional_ideal f</code></p>



<a name="206136585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206136585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206136585">(Aug 06 2020 at 12:56)</a>:</h4>
<p>Ah, I see.</p>



<a name="206136625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206136625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206136625">(Aug 06 2020 at 12:57)</a>:</h4>
<p>I really need to run now, I will try to contact you later - or study more! Thanks in advance, at any rate.</p>



<a name="206146908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206146908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206146908">(Aug 06 2020 at 14:18)</a>:</h4>
<p>Here I am again-could you speculate a bit on your sentence that " one can never prove a statement of the form such-and-such expression has such-and-such type"? Do you mean that every expression comes with its type and it won't change forever?</p>



<a name="206147102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206147102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206147102">(Aug 06 2020 at 14:19)</a>:</h4>
<p>every term has a type which does not change</p>



<a name="206147183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206147183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206147183">(Aug 06 2020 at 14:20)</a>:</h4>
<p>But do subgroups and normal subgroups have the same type?</p>



<a name="206147226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206147226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206147226">(Aug 06 2020 at 14:20)</a>:</h4>
<p>i think normal is a predicate on subgroups, something like <code>is_normal : subgroup G \to Prop</code></p>



<a name="206147319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206147319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206147319">(Aug 06 2020 at 14:21)</a>:</h4>
<p>So, if submodule is a predicate on (sub)sets, I can prove something like </p>
<div class="codehilite"><pre><span></span><code><span class="k">let</span> <span class="n">M1</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">M</span><span class="o">,</span> <span class="n">f</span><span class="bp">.</span><span class="n">is_integer</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">f</span><span class="bp">.</span><span class="n">to_map</span> <span class="n">y</span><span class="o">)},</span>
<span class="k">have</span> <span class="n">M1</span> <span class="o">:</span> <span class="n">fractional_ideal</span> <span class="n">f</span><span class="o">,</span>
</code></pre></div>



<a name="206147339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206147339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206147339">(Aug 06 2020 at 14:21)</a>:</h4>
<p>meaning, with the second line, that the first line is a fractional ideal</p>



<a name="206147358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206147358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206147358">(Aug 06 2020 at 14:21)</a>:</h4>
<p>no</p>



<a name="206147396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206147396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206147396">(Aug 06 2020 at 14:21)</a>:</h4>
<p><code>t : T</code> only makes sense when <code>T</code> is the type of <code>t</code></p>



<a name="206147474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206147474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206147474">(Aug 06 2020 at 14:22)</a>:</h4>
<p>the type of <code>M1</code> is <code>set K</code></p>



<a name="206147529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206147529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206147529">(Aug 06 2020 at 14:22)</a>:</h4>
<p>if you have a predicate <code>is_fractional_ideal : set K \to Prop</code></p>



<a name="206147554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206147554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206147554">(Aug 06 2020 at 14:22)</a>:</h4>
<p>then you could write <code>have hM1 : is_fractional_ideal M1</code></p>



<a name="206147597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206147597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206147597">(Aug 06 2020 at 14:23)</a>:</h4>
<p>ahah! That's what I was looking for, I guess.</p>



<a name="206147643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206147643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206147643">(Aug 06 2020 at 14:23)</a>:</h4>
<p>then you get a goal of type <code>is_fractional_ideal M1</code></p>



<a name="206147684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206147684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206147684">(Aug 06 2020 at 14:23)</a>:</h4>
<p>after you prove it, you'll have a local variable called <code>hM1</code> which can be thought of as storing the proof</p>



<a name="206147691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206147691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206147691">(Aug 06 2020 at 14:23)</a>:</h4>
<p>Is the <code>is_</code> construction automatically built by Lean when one defines something?</p>



<a name="206147697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206147697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206147697">(Aug 06 2020 at 14:23)</a>:</h4>
<p>no</p>



<a name="206147760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206147760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206147760">(Aug 06 2020 at 14:24)</a>:</h4>
<p>I was giving hypothetical names because I'm not familiar with this part of the library</p>



<a name="206147808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206147808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206147808">(Aug 06 2020 at 14:24)</a>:</h4>
<p>Ah, ok: so, the existence of <code>fractional_ideal</code> (which I know to exist) does not imply the existence of <code>is_fractional_ideal</code></p>



<a name="206147845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206147845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206147845">(Aug 06 2020 at 14:24)</a>:</h4>
<p>let me go look at <a href="https://leanprover-community.github.io/mathlib_docs/find/fractional_ideal">docs#fractional_ideal</a></p>



<a name="206147856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206147856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206147856">(Aug 06 2020 at 14:24)</a>:</h4>
<p>(although I suspect this second to exist as well, I am trying to dig into the construction of those things)</p>



<a name="206148283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206148283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206148283">(Aug 06 2020 at 14:28)</a>:</h4>
<p>Have you found a "predicate" that seems to do the trick? I haven't, but I might have overlooked it.</p>



<a name="206148482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206148482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206148482">(Aug 06 2020 at 14:29)</a>:</h4>
<p>If you click on "Equations" (or just view source) you can see the associated predicate is called <code>is_fractional</code></p>



<a name="206148676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206148676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206148676">(Aug 06 2020 at 14:30)</a>:</h4>
<p>(Presumably, you were going to have to look at the definition of <code>fractional_ideal</code> next no matter what?)</p>



<a name="206148862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206148862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206148862">(Aug 06 2020 at 14:32)</a>:</h4>
<p>OkOk, I see the problem I was facing. And going back to the first question, after having defined M1 with <code>let</code>, should I type</p>
<div class="codehilite"><pre><span></span><code><span class="k">have</span> <span class="n">hM1</span> <span class="o">:</span> <span class="n">is_fractional</span> <span class="n">M1</span>
</code></pre></div>


<p>or </p>
<div class="codehilite"><pre><span></span><code><span class="k">let</span> <span class="n">hM1</span> <span class="o">:</span> <span class="n">is_fractional</span> <span class="n">M1</span>
</code></pre></div>


<p>?</p>



<a name="206149386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206149386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206149386">(Aug 06 2020 at 14:36)</a>:</h4>
<p>use <code>have hM1 : is_fractional M1,</code></p>



<a name="206149536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206149536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206149536">(Aug 06 2020 at 14:37)</a>:</h4>
<p>that's telling lean: I want to prove this proposition <code>is_fractional M1</code> in tactic mode and then forget about the proof, but keep the statement and call it <code>hM1</code></p>



<a name="206244232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206244232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206244232">(Aug 07 2020 at 10:56)</a>:</h4>
<p><span class="user-mention" data-user-id="300245">@Filippo A. E. Nuccio</span> as a mathematician coming into this, it can be a bit confusing. There are two ways of working with mathematical objects in Lean -- a "bundled" way and an "unbundled" way. The other thing you to know is how to orientate your self in Lean's type universe -- there are universes, types and terms. In the universe Type, the types are what we think of as sets and the terms are what we think of as their elements. In the Prop universe, the types are what we think of as theorem statements, and the terms are what we think of as proofs.</p>
<p>So now let me tell you about groups and subgroups. For whatever reason, the way you say "let G be a group" in Lean is that you make a term <code>G : Type</code> (i.e. a set), and then we make a term called something silly like <code>_inst_1</code> of type <code>group G</code>. The type <code>group G</code> is a type, so it's what we think of as a set, and it's the set of all group structures on the set G. So a term of type <code>group G</code> is the data of a multiplication, identity and inverse, plus also the proofs of all the group axioms. The reason the term of type <code>group G</code> has a weird name is that we users never have to say that name in our code -- you write <code>[group G]</code> in square brackets and that means "leave Lean's type class inference system to deal with all the group structure on G automatically" -- which means that if <code>a b : G</code> you can write <code>a * b</code> and Lean will know what you mean.</p>
<p>Now subgroups are dealt with in a completely different way. If G is a group then <code>G : Type</code> and if <code>H</code> is a subgroup then it turns out that <code>H</code> is <em>not</em> a type, it is a term. There is a type <code>subgroup G</code>, which is a type, so it's a set in our language, and it's the set of all subgroups of G. So <code>H : subgroup G</code> means H is a subgroup of G, and so H is actually something like a quadrauple of data under the hood, it's a subset and three proofs (that it's closed under multiplication, inverse and identity). </p>
<p>If you want to work with fractional ideals you really should read the docstring at the top of <code>fractional_ideal.lean</code>. This tells you all the names of all the important functions and definitions. Finding them in the lean file itself and hovering over them will tell you the types of all these terms, and then you have to start thinking very clearly about what is bundled and what isn't. For example, <code>fractional_ideal f</code> is the type of fractional ideals in P (using notation from the docstring) so a term of type <code>fractional_ideal f</code> is a fractional ideal, which means that it is some sort of n-tuple encoding all the things which a mathematician needs to make a fractional ideal. In particular its name will not be the same as the name of the underlying submodule, which is a different thing because it has a different type.</p>



<a name="206244469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206244469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206244469">(Aug 07 2020 at 11:00)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> is this the start of a blogpost?</p>



<a name="206246353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206246353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206246353">(Aug 07 2020 at 11:27)</a>:</h4>
<p>Please <em>please</em> stop this. Each new message or blog post where Kevin repeats that mathematicians should replace <code>Type</code> by "set" and <code>set</code> by "subset" is simply adding confusion for no good reason.</p>



<a name="206246787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206246787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206246787">(Aug 07 2020 at 11:34)</a>:</h4>
<p>I know this winds you up Patrick, but this is how to teach a beginner with no knowledge of type theory how to think about types and terms in the context of something they already understand.</p>



<a name="206247192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206247192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206247192">(Aug 07 2020 at 11:41)</a>:</h4>
<p>But you are teaching something <em>wrong</em>. What's the point?</p>



<a name="206247528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206247528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206247528">(Aug 07 2020 at 11:46)</a>:</h4>
<p>Why do you say it's wrong? This is literally how the model of lean in set theory works</p>



<a name="206247583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206247583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206247583">(Aug 07 2020 at 11:47)</a>:</h4>
<p>so people from a set theory background (inasmuch as this is true for traditional mathematicians) expect this kind of terminology</p>



<a name="206247682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206247682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206247682">(Aug 07 2020 at 11:48)</a>:</h4>
<p>The model is not the real thing, and it comes with a lot of extra junk that encourages bad intuition.</p>



<a name="206247695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206247695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206247695">(Aug 07 2020 at 11:49)</a>:</h4>
<p>Now there is an additional bit of learning to make a new distinction in type theory that did not exist in set theory (namely the difference between a set-in-itself and a set-as-subset-of-another), but that can be taught separately</p>



<a name="206247725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206247725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206247725">(Aug 07 2020 at 11:49)</a>:</h4>
<p>if you want to draw a parallel between concepts in set theory and concepts in type theory, this is the right parallel</p>



<a name="206247806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206247806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206247806">(Aug 07 2020 at 11:50)</a>:</h4>
<p>We now have a lot of data proving this parallel is harmful when learning.</p>



<a name="206247807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206247807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206247807">(Aug 07 2020 at 11:50)</a>:</h4>
<p>"the model is not the real thing" that depends on your religion</p>



<a name="206247852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206247852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206247852">(Aug 07 2020 at 11:51)</a>:</h4>
<p>I think it's best to get out of the way early the explanation about types and sets, but then, as soon as possible, to stop conflating them.</p>



<a name="206247950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206247950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206247950">(Aug 07 2020 at 11:53)</a>:</h4>
<p>Certainly when Kevin says "There is a type <code>subgroup G</code>, which is a type, so it's a set in our language." I get sad. :-)</p>



<a name="206247987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206247987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206247987">(Aug 07 2020 at 11:53)</a>:</h4>
<p>If that sentence is to make any sense it should be "so it's a set in the old language"?</p>



<a name="206248062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248062">(Aug 07 2020 at 11:54)</a>:</h4>
<p>Exactly, this kind of sentence if just piling up confusion.</p>



<a name="206248274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248274">(Aug 07 2020 at 11:57)</a>:</h4>
<p>I guess you could also use a vaguer word like "collection" there</p>



<a name="206248334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248334">(Aug 07 2020 at 11:58)</a>:</h4>
<p>"The type <code>subgroup G</code> is the collection of all subgroup structures on <code>G</code>"</p>



<a name="206248379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248379">(Aug 07 2020 at 11:58)</a>:</h4>
<p>but that sentence doesn't seem especially wrong to me even if you substitute the word "set" in for "collection"</p>



<a name="206248417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248417">(Aug 07 2020 at 11:59)</a>:</h4>
<p>That sentence is just wrong whatever the interpretation.</p>



<a name="206248484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248484">(Aug 07 2020 at 12:00)</a>:</h4>
<p>it's not, that's literally what the type represents</p>



<a name="206248521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248521">(Aug 07 2020 at 12:00)</a>:</h4>
<p>Did you really intended to put those "sub" here?</p>



<a name="206248538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248538">(Aug 07 2020 at 12:01)</a>:</h4>
<p>what sub? the one in "subgroup"?</p>



<a name="206248547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248547">(Aug 07 2020 at 12:01)</a>:</h4>
<p>yes</p>



<a name="206248565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248565">(Aug 07 2020 at 12:01)</a>:</h4>
<p>Because the sentence you get from removing both "sub" makes sense.</p>



<a name="206248570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248570">(Aug 07 2020 at 12:01)</a>:</h4>
<p>um yes, that's the name of the mathematical concept</p>



<a name="206248593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248593">(Aug 07 2020 at 12:01)</a>:</h4>
<p>The collection of all group structures on <code>G</code> is a completely different type</p>



<a name="206248615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248615">(Aug 07 2020 at 12:02)</a>:</h4>
<p>I'm talking about <code>subgroup G</code></p>



<a name="206248689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248689">(Aug 07 2020 at 12:02)</a>:</h4>
<p>I think I see the confusion, the sentence is also true if you replace <code>subgroup</code> with <code>group</code></p>



<a name="206248699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248699">(Aug 07 2020 at 12:03)</a>:</h4>
<p>A term with type <code>subgroup G</code> is not a structure <em>on</em> <code>G</code>.</p>



<a name="206248701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248701">(Aug 07 2020 at 12:03)</a>:</h4>
<p>I think Patrick's complaint in this sentence is that a "subgroup structure" is an alien concept.</p>



<a name="206248724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248724">(Aug 07 2020 at 12:03)</a>:</h4>
<p>I could say "subgroup of G" but that just sounds circular</p>



<a name="206248748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248748">(Aug 07 2020 at 12:03)</a>:</h4>
<p>and "subgroup structure" makes it clearer that it's more like a tuple than a set</p>



<a name="206248806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248806">(Aug 07 2020 at 12:04)</a>:</h4>
<p>Aren't we discussing how to make things clearer, not more obscure?</p>



<a name="206248820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248820">(Aug 07 2020 at 12:04)</a>:</h4>
<p>I should hope so</p>



<a name="206248855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248855">(Aug 07 2020 at 12:04)</a>:</h4>
<p>If I understand correctly <span class="user-mention" data-user-id="110031">@Patrick Massot</span> means that although <code>group G</code> designates the types <strong>group-structure on</strong> <code>G</code>, whereas <code>subgroup G</code> designates the types of subgroups of <code>G</code>, not a "structure of subgroup"</p>



<a name="206248880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248880">(Aug 07 2020 at 12:05)</a>:</h4>
<p>it is the type of all subgroup structures of G</p>



<a name="206248895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248895">(Aug 07 2020 at 12:05)</a>:</h4>
<p>as in, an element of the type is a subgroup structure</p>



<a name="206248984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248984">(Aug 07 2020 at 12:06)</a>:</h4>
<p>Mario, that's simply not what mathematicians call structures. That's the programming language notion of structure.</p>



<a name="206248998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206248998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206248998">(Aug 07 2020 at 12:06)</a>:</h4>
<p>Anyway, this conversation is going nowhere.</p>



<a name="206249002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206249002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206249002">(Aug 07 2020 at 12:06)</a>:</h4>
<p>tuple?</p>



<a name="206249009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206249009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206249009">(Aug 07 2020 at 12:06)</a>:</h4>
<p>I'll stop it.</p>



<a name="206249019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206249019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206249019">(Aug 07 2020 at 12:06)</a>:</h4>
<p>give me something to work with here</p>



<a name="206249022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206249022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206249022">(Aug 07 2020 at 12:06)</a>:</h4>
<p>(but feel free to continue without me)</p>



<a name="206249034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206249034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206249034">(Aug 07 2020 at 12:07)</a>:</h4>
<p>you are just asserting that things aren't clear without suggesting any alternative</p>



<a name="206249275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206249275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206249275">(Aug 07 2020 at 12:10)</a>:</h4>
<p>Maybe that's a french thing, but to me a "a group structure on a set/type <code>G</code>" designates the things we add to the "raw" <code>G</code> to make it behave like a group. That is, it corresponds to the class <code>group</code> of Lean, because it doesn't "includes" the set/type itself</p>



<a name="206249468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206249468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206249468">(Aug 07 2020 at 12:13)</a>:</h4>
<p>It's at least also a Dutch thing. If I pretend to only be a mathematician, "a subgroup structure of G" sounds more like "an algebraic structure containing all subgroups of G" than "an object consisting of a subset of G along with a proof that this is a group".</p>



<a name="206249735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206249735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206249735">(Aug 07 2020 at 12:16)</a>:</h4>
<p>It would be clearer for mathematician to say "<code>subgroups G</code> is the type of subgroups of G, which are represented by a subset of G along with the proofs showing it is a subgroup"</p>



<a name="206250110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206250110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206250110">(Aug 07 2020 at 12:21)</a>:</h4>
<p>A word to abbreviate this further would be nice, but I think "structure" is not the best choice for that. "tuple" might work if you explain that tuples can also contain proofs in type theory. "object" would be nice if it didn't have the category theory connotations.</p>



<a name="206250448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206250448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206250448">(Aug 07 2020 at 12:25)</a>:</h4>
<p>Hmm, how about borrowing the word <code>record</code> from Haskell/Agda? "<code>subgroup G</code> is the type of records representing a subgroup of G"?</p>



<a name="206250867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206250867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206250867">(Aug 07 2020 at 12:31)</a>:</h4>
<p>It's also not too hard to explain the lack of plural as a naming convention, where types in lean are named after the terminology you would use to refer to an element of that type</p>



<a name="206251497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206251497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206251497">(Aug 07 2020 at 12:38)</a>:</h4>
<p>(deleted)</p>



<a name="206255092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206255092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206255092">(Aug 07 2020 at 13:15)</a>:</h4>
<p>Naming conventions are interesting. About a third of the time <code>set X</code> is named correctly. Mathematicians have three totally interchangable ways of thinking about <code>set X</code>. It could be the type of subsets of <code>X</code>, and if you think about it this way then you wish it was called <code>subset X</code>. It could be the type of sets made from elements of <code>X</code>, and here <code>set X</code> is the perfect name. Or you could just observe that the set of subsets of X is the power set of X so it should be called <code>powerset X</code>. The issue seems to be whether the name is being used to describe the type or the terms. </p>
<p>An interesting example is <code>(T : set (set X))</code> in the definition of a topological space. Mathematicians might say "T is a set of subsets of X (called the open sets...)" and here we're using two different words for the same thing in Lean</p>



<a name="206259837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206259837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206259837">(Aug 07 2020 at 14:00)</a>:</h4>
<p>I'm still a beginner in mathematics so maybe what I say is irrelevant here, but don't you think you're spending too much energy on "setifying" Lean ? I mean, sure, types are not usual in maths, but why not just learn what they are once and then you can just use the exact terminology ? I don't think that's harder than some other concepts of maths</p>



<a name="206311385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206311385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206311385">(Aug 07 2020 at 21:25)</a>:</h4>
<p>That is such a French response ;-)</p>



<a name="206311517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206311517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206311517">(Aug 07 2020 at 21:26)</a>:</h4>
<p>Why not explain the translation? For me they are the same thing, ZFC sets and Lean types, they're just tools to set up maths</p>



<a name="206315917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206315917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206315917">(Aug 07 2020 at 22:21)</a>:</h4>
<p>How do you explain that terms of different types can't be compared with equality? That looks different than zfc to me.</p>



<a name="206316411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206316411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206316411">(Aug 07 2020 at 22:28)</a>:</h4>
<p>I don't think this is a problem because it's not actually a thing mathematicians usually want to do, so it usually only shows up in hypothetical arguments about how weird ZFC is</p>



<a name="206317713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206317713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206317713">(Aug 07 2020 at 22:49)</a>:</h4>
<p>OTOH, for many people <code>(2 : ℝ)</code> and <code>(2 : ℕ)</code> is the same number.</p>



<a name="206317781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206317781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206317781">(Aug 07 2020 at 22:50)</a>:</h4>
<p>Or <code>(2 : ℝ)</code> and <code>(2 : ℝ≥0)</code></p>



<a name="206317806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206317806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206317806">(Aug 07 2020 at 22:51)</a>:</h4>
<p>What about (2 : N) and (2 : Z/7)?</p>



<a name="206317812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206317812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206317812">(Aug 07 2020 at 22:51)</a>:</h4>
<p>They really aren't the same number</p>



<a name="206317875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206317875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206317875">(Aug 07 2020 at 22:52)</a>:</h4>
<p>Even better, 2 :N and 2 : C_7 (the 7-adic complex numbers). Are these the same?</p>



<a name="206354396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206354396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206354396">(Aug 08 2020 at 16:26)</a>:</h4>
<p>Mathematics is the art of giving the same name to different things</p>



<a name="206678838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206678838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206678838">(Aug 12 2020 at 10:30)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> : after I received your first answer, I tried to digest it and did not open Zulip in the meantime. As a result, I missed most of the above conversation and most of <span class="user-mention" data-user-id="110031">@Patrick Massot</span> 's complaints. They might be relevant for the following questions I had for you, but I am not sure. I'll post them as different messages so that they could be answered more easily. I will at any rate try to read, as you suggest, the intro to the file on <code>fractional ideals</code> to understand that file better.</p>



<a name="206678848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206678848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206678848">(Aug 12 2020 at 10:30)</a>:</h4>
<p>1) You speak about universes and mention <code>Prop</code> and <code>Type</code>. Are there other examples of universes?</p>



<a name="206678933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206678933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206678933">(Aug 12 2020 at 10:31)</a>:</h4>
<p>2) If I understand correctly, you are saying that to create a group one first creates a set <code>G:Type</code>and then produces a term of type <code>group G</code>. But when has the type <code>group G</code> being created? What I mean to ask is that on a given set one can put a trillion of structures (group, ring, topological field, manifold, etc...) and it seems to me that what you are saying is that each of these structures is a term of the relevant type. So we should have a trillion of types from which to pick a term... Or does one first create <code>G:Type</code> then <code>group G:Type</code> and then finally pick a term of the latter type to put a structure on <code>G</code>? And what is the state of affairs after having put this structure, does Lean still understand by <code>G</code> the underlying set or since this has been upgraded to a group, <code>G</code> now denotes the group (so, the set plus the chosen group structure) and is there a way to recover the underlying set?</p>



<a name="206679008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206679008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206679008">(Aug 12 2020 at 10:32)</a>:</h4>
<p>3) A similar question for the type <code>subgroup G</code>: was this type built automatically once a term <code>_ inst_1: group G</code> had been picked up? But more fundamentally, if I want to (1) construct a group <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex"> G' </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> and (2) prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo>⊂</mo><mi>G</mi></mrow><annotation encoding="application/x-tex"> G' \subset G </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.790992em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>, it looks as a nightmare, because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">G'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> will be of type <code>G': Type</code> with its <code>_inst_1'</code> but I will eventually need <code>G': subgroup G</code> which I won't be able to perform.</p>



<a name="206679066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206679066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206679066">(Aug 12 2020 at 10:33)</a>:</h4>
<p>4) In the same vein, if I produce a subset <code>A:set G</code> (or may be <code>A:set G.val</code> or whatever the name of<br>
the underlying set to G is) and want to prove that it is actually a subgroup, I will need to modify its type to <code>A: subset G</code>: is it doable? As a matter of fact, while I am writing this, I realize that may be the true statement is that "there exists a subgroup of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> whose underlying set is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>" and this looks more doable-but how, really?</p>



<a name="206680672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206680672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206680672">(Aug 12 2020 at 10:56)</a>:</h4>
<p>1) No, <code>Prop</code> and <code>Type</code> are the only universes, as far as normal mathematics is concerned. Computer scientists also use something called <code>Type u</code> but this is something which doesn't exist in mathematics unless you are doing category theory; whenever I see <code>Type u</code> in mathlib I just pretend it says <code>Type</code>. The only other "universe" is <code>Sort u</code> or <code>Sort *</code> which means "either <code>Prop</code> or <code>Type</code>". </p>
<p><a href="https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory/">https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory/</a></p>
<p>2) Yes, groups are unbundled. A group in ZFC is a set plus a group structure (multiplication, inverse, identity, axioms). In Lean's type theory a group is a type <code>G</code> and a term <code>_inst_1 : group G</code>. To give a term of type <code>group G</code> is to give all the group structure on <code>G</code>. I don't really understand your question. "But when has the type <code>group G</code> being created?". The <code>group</code> function (which takes as input a type <code>G</code> and has output the type of all group structures on <code>G</code>) is defined in mathlib. Yes, if you have some ordered Lie group like the reals then you will have to pick lots of terms, terms giving the structures and more terms saying that the structures are compatible. I'm not sure you have a question here. In maths we say "let R be a commutative topological ring", in Lean we say <code>variable (R : Type) [ring R] [topological_space R]  [topological_ring R]</code>. But <code>R</code> is still a type -- the "upgrading" you're talking about is all done by the type class inference system. In particular if <code>a b : R</code> then I can talk about <code>a * b</code> and the type class inference system finds the multiplication from the term of type <code>ring R</code> precisely because I use these square brackets <code>[]</code> -- that's the point of them.</p>
<p>3) I have no idea what your mental model of these things are. The <code>subgroup</code> function was "built automatically" the moment you imported the relevant mathlib files. So sure, that function was built before you start. But if you now "build" G, whatever that means, Lean will not "build" <code>subgroup G</code> until you run the <code>subgroup</code> function on the input <code>G</code>. </p>
<p>If you have two groups G and H and an injective group hom H -&gt; G then you can build the term of type <code>subgroup G</code>; conversely given a term of type <code>subgroup G</code> you can build a group <code>H</code> and an injective hom <code>H -&gt; G</code>. Mathematicians do this automatically but in Lean there is a separation between these two concepts. You say it looks like a nightmare but you're wrong. In practice you are either mostly doing groupy things with H or subgroupy things -- as a mathematician you have never really considered the difference, but Lean will make you do this. If it was a nightmare then we wouldn't have been able to make perfectoid spaces. Mathematicians do this all the time -- the natural number 37, the integer 37, the real number 37, the p-adic number 37 are all different 37's in Lean but this is not blocking progress. When you say "I will eventually need <code>G' : subgroup G</code> you have misunderstood the solution. You will eventually need the term of type <code>subgroup G</code> corresponding to <code>G'</code> and you are used to also calling this term <code>G'</code> but in Lean it is simply called <code>f(G')</code> for some function f with a name like <code>to_subgroup</code> or something. The fact that <code>G'</code> and <code>f(G')</code> are not literally equal objects in Lean doesn't matter, because you do groupy things with G', and subgroupy things with f(G'), and when you want to relate constructions in the two universes the function is there which relates them, says the diagram commutes, whatever.</p>
<p><a href="https://xenaproject.wordpress.com/2020/04/30/the-invisible-map/">https://xenaproject.wordpress.com/2020/04/30/the-invisible-map/</a></p>
<p>4) is the same question as 3 but in another domain. This phenomenon is everywhere when you do mathematics in type theory (as people have been doing for many decades) and they understand it well.</p>
<p>The point is that as a mathematician you just <em>assume</em> that this set-up will be unworkable, because you can see that in theory this leads to complications, but in practice mathematical arguments either focus on one implementation or the other, so things work out fine in practice. Lean has a very sophisticated system for moving between concepts, typically represented either by weird little up-arrows or by nothing at all (depending on which system is doing the moving) and in practice it does not get in your way (most of the time).</p>



<a name="206681570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206681570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206681570">(Aug 12 2020 at 11:08)</a>:</h4>
<p>Thanks: one thing I had overlooked is that <code>group</code> and <code>subgroup</code> could be seen as functions producing a Type from another Type, and this makes sense and much of your answer looks much clearer.  I am not assuming that this set-up is unworkable, I am just trying to understand it and to put as few things as possible (to my brain/knowledge) under the rug. Time will help...</p>



<a name="206682067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206682067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206682067">(Aug 12 2020 at 11:16)</a>:</h4>
<p>Everything is a function in functional programming -- or a constant (like nat).</p>



<a name="206691600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206691600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206691600">(Aug 12 2020 at 13:15)</a>:</h4>
<p>You can be even more extreme and say that a constant is just a constant function that takes no argument</p>



<a name="206795343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206795343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206795343">(Aug 13 2020 at 09:24)</a>:</h4>
<p>The never-ending lesson one learns from Lean is the delicacy of "is".</p>



<a name="206795360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206795360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206795360">(Aug 13 2020 at 09:24)</a>:</h4>
<p>First, there are different equalities noticeable in proofs: syntactic equality, definitional equality, propositional equality, and isomorphism etc. And this list can be further divided when it comes to choosing a specific tool (e.g. tactics) for the job.</p>



<a name="206795381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206795381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206795381">(Aug 13 2020 at 09:25)</a>:</h4>
<p>Then, there are the "is" issues in modeling mathematical structures:</p>
<p>In type theory, one starts with a hard type, which is a fixed and unbendable identity. This is far different from a set (in the sense of Mathematics), which is a flexible collection summoned by a certain condition (i.e. a proposition).</p>



<a name="206795402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206795402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206795402">(Aug 13 2020 at 09:25)</a>:</h4>
<p>This hard type will never be equal to another hard type in the sense of absolute equality. In order to make a hard type flexible enough to interact with other hard types like it "is" something (e.g. a group), one can give a mathematical structure to a type (by some proofs). If the type is <code>G</code> and the mathematical structure is <code>group</code> then it looks like <code>group G</code> in Lean.</p>



<a name="206795458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206795458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206795458">(Aug 13 2020 at 09:26)</a>:</h4>
<p>But this is not the right mental model to apply universally. One can't directly translate anything in the form of <code>group G</code> to "<code>G</code> is a <code>group</code>". An obvious counter-example is <code>subgroup G</code>, in this case, there's something new created as the <code>subgroup</code> "of" <code>G</code>. If we apply this counter-example back to <code>group G</code>, we will realize that <code>group G</code> also creates something new as the <code>group</code> structure "of" <code>G</code> that's not <code>G</code> itself.</p>



<a name="206795475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206795475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206795475">(Aug 13 2020 at 09:26)</a>:</h4>
<p>The same applies to <code>set G</code>. It's a set of <code>G</code> but <code>G</code> is not a set. There's no "is" here, only "of".</p>



<a name="206795505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206795505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206795505">(Aug 13 2020 at 09:26)</a>:</h4>
<p>These mathematical structures are all external to the type, like a role the type plays. And the role interacts with other roles of other types through all sorts of propositions about the roles, like our physical bodies are playing roles following social rules. And all these hard types, roles, propositions are all represented by types (in a general sense) in type theory to have a unified but also diverse solution.</p>



<a name="206795529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206795529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206795529">(Aug 13 2020 at 09:27)</a>:</h4>
<p>The situation is even more complicated for multiple parameters. A <code>vector_space K V</code> can be used to describe a vector space V "over" a field K, a <code>clifford_algebra R M Q</code> can be used to describe "the Clifford algebra of a module <code>M</code> <em>over</em> a commutative ring <code>R</code>, <em>equipped with</em> a quadratic_form <code>Q</code>".</p>



<a name="206795542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206795542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206795542">(Aug 13 2020 at 09:27)</a>:</h4>
<p>One might use "is" in the former case but "of" will be inevitable in the latter case, and both cases involve adverbs. The latter case also demonstrated that the last parameter might not be the thing we imagine to be "is" like in <code>vector_space K V</code>, because <code>clifford_algebra R M Q</code> "is" not any of <code>R</code>, <code>M</code>, <code>Q</code> but something new created out "of" them.</p>



<a name="206799304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206799304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206799304">(Aug 13 2020 at 10:21)</a>:</h4>
<p>What the typeclass mechanism does in this context is just auto-dressing , when a raw type appears in a statement or a proof, it will find a proper role for the type that makes sense in the context, this is called “type class resolution” and when it fails, it complains about “fail to synthesize” and the raw type will start to have difficulties interacting with other roles of other types. There’re little tricks to provide hints for finding the right dress(role).</p>



<a name="206816838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206816838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206816838">(Aug 13 2020 at 13:50)</a>:</h4>
<p><span class="user-mention" data-user-id="296911">@Utensil Song</span>  Thanks for the answer: do you have an accessible and structured reference to study all this?</p>



<a name="206870276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206870276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206870276">(Aug 13 2020 at 20:55)</a>:</h4>
<p>Filippo, you should know that Utensil likes to approach these kinds of questions from a philosophical (or maybe even poetical) point of view. But it doesn't necessarily makes it easier for others to understand, compared to the more conventional approach based on raw facts.</p>



<a name="206871959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206871959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206871959">(Aug 13 2020 at 21:08)</a>:</h4>
<p>In the case at hand, you can first type <code>#check @group</code> (remember the <code>@</code> makes all inputs explicit) to see that <code>group</code> is a function with a single input which is a type and a single output which is a type (in the same universe, but let's ignore universes since they don't play any role here). So <code>group G</code> is meaningful if and only if <code>G</code> is a type. Then you can type <code>#print group</code> to see what would be the definition of <code>group G</code> (using jump to definition would be less useful here because groups are built on top of simpler stuff like monoids). After a couple of meta-data that are technical implementation details, you see</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">group</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">fields</span><span class="o">:</span>
<span class="n">group</span><span class="bp">.</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">],</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="n">group</span><span class="bp">.</span><span class="n">mul_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c_1</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c_1</span><span class="o">)</span>
<span class="n">group</span><span class="bp">.</span><span class="n">one</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">],</span> <span class="n">α</span>
<span class="n">group</span><span class="bp">.</span><span class="n">one_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span>
<span class="n">group</span><span class="bp">.</span><span class="n">mul_one</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">a</span>
<span class="n">group</span><span class="bp">.</span><span class="n">inv</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">],</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="n">group</span><span class="bp">.</span><span class="n">mul_left_inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span>
</code></pre></div>


<p>The word structure on the first line is much closer to the C language use of this word than Bourbaki's word, it simply means a bunch of things put together. This first line also tells you again the information we got from <code>#check</code>.  Then comes the list of things ("fields") that are put together. The capital Pi is a weird notation that is preferred to a good old forall in contexts where data is involved (as opposed to statements). For instance line 3 tells: if you give me a type <code>α</code> and a term <code>c</code> with type <code>group α</code> then I'll give you a multiplication map <code>α → α → α</code>. The next piece of data is two lines down: if you give me a type <code>α</code> and a term <code>c</code> with type <code>group α</code> then I'll give you a term with type <code>α</code> (and denote by one thanks to some trick that is irrelevant here). There is also the inversion map further down. All the other lines are axioms that multiplication and one should satisfy.</p>



<a name="206873295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206873295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206873295">(Aug 13 2020 at 21:21)</a>:</h4>
<p>Fundamentally, everything we need to talk about needs to have a type. And in order to define a type from one or several existing types, you mostly need to tell how to create terms having that type and how to build a function whose domain is your new type. To make this more symmetric, you can say you need to describe how to define function <em>into</em> your new type, and <em>from</em> your new type. There are very few built-in ways to define types. Function types are built in, at the very core of everything. Almost everything else are inductive types, which are defined using the <code>inductive</code> keyword or, in an important special case, the <code>structure</code> (or <code>class</code>) keyword. Building terms of an inductive type is made using a constructor. Structures are inductive types with only one constructor, called <code>mk</code> by default. So you can learn how to build an element whose type is <code>group G</code> by typing <code>#check @group.mk</code> which indeed takes as input all the ingredients listed above. Calling this function directly is not very convenient when proofs are long so we have syntax sugar to help us (using <code>{ mul := ..., one :=...}</code> etc. But really this is calling this constructor function. The other direction is more complicated. To build a function <em>out</em> of <code>group G</code> you use the recursor <code>group.rec</code>. So you can <code>#check @group.rec</code>. It will tell you how to define a function taking as input a type <code>G</code> and a term <code>c</code> of type <code>group G</code> and get some term of type <code>C G</code> (but we can pretend this target type does not depend on <code>G</code> if you are interested in a fixed <code>G</code>). Basically you are allowed to use all the ingredients that go into the definition of a term with type <code>group G</code> but nothing else.</p>



<a name="206873517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/206873517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#206873517">(Aug 13 2020 at 21:23)</a>:</h4>
<p>All this is explained much better in TPIL.</p>



<a name="207015507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/207015507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#207015507">(Aug 15 2020 at 10:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> Thanks so much! This makes many things much clearer, above others that the syntax<br>
<code>group.one : Π {α : Type u} [c : group α], α</code><br>
means that the result is a term of type <code>α</code> and not <code>α</code> itself. I will play with <code>#check</code> and <code>#print</code> and try to develop some more intuition. Concerning TPIL, I must confess that it is not a very easy read-the examples are very much CS-oriented (at least, this is what I feel), and seldom Math-oriented. But I will try to study more before complaining...</p>



<a name="207015673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/207015673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#207015673">(Aug 15 2020 at 10:28)</a>:</h4>
<p>Yes, we're writing mathematics in Lean precisely because the TPIL examples aren't mathematical enough</p>



<a name="207015679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/207015679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#207015679">(Aug 15 2020 at 10:28)</a>:</h4>
<p>Which of course is perfect for some learners but not for my own target audience</p>



<a name="207018940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/207018940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#207018940">(Aug 15 2020 at 12:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="300245">Filippo A. E. Nuccio</span> <a href="#narrow/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60/near/206816838">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="296911">Utensil Song</span>  Thanks for the answer: do you have an accessible and structured reference to study all this?</p>
</blockquote>
<p>What I shared before was merely what I made sense of my observation during breaking things and piecing things together in Lean.</p>
<p>Systematic learning can be reading any of <a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a> , <a href="https://leanprover-community.github.io/mathematics_in_lean/">#mil</a> , #tutorial, <a href="https://leanprover-community.github.io/lftcm2020/">LFTCM 2020 Workshop</a> or my personal first and favorite guide <a href="https://github.com/blanchette/logical_verification_2020/raw/master/hitchhikers_guide.pdf">The Hitchhiker’s Guide to Logical Verification</a> and doing exercises in them.</p>



<a name="207018942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/207018942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#207018942">(Aug 15 2020 at 12:07)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathematics_in_lean/">#mil</a> is the best source if you're looking for a math-oriented tutorial, but the Hitchhiker’s Guide has weaved a right proportion of type theory into the learning process so it's a good supplement for <a href="https://leanprover-community.github.io/mathematics_in_lean/">#mil</a>  IMHO. On the other hand, <a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a> requires you to have an immersive walkthrough with it and examine the technicality carefully, it's easy to get lost in it if you don't already have a big picture.</p>
<p>I also invested quite some time to read <a href="https://leanprover-community.github.io/papers.html">related papers</a> about Lean &amp; Mathlib, about formalized math, about type foundations, and about the problems Lean 4 tries to solve, as well as the mathlib source and sometimes Lean source.</p>



<a name="207019831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/207019831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#207019831">(Aug 15 2020 at 12:30)</a>:</h4>
<p>_<strong>Patrick Massot|110031</strong> <a href="#narrow/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60/near/206870276">said</a>:</p>
<blockquote>
<p>Filippo, you should know that Utensil likes to approach these kinds of questions from a philosophical (or maybe even poetical) point of view. But it doesn't necessarily make it easier for others to understand, compared to the more conventional approach based on raw facts.</p>
</blockquote>
<p>Human's mind is a complicated machine, it never stops modeling raw facts, just as Einstein said, what you can observe depends on the theory you use. Mental models can be subconscious but it's always there, both helping you and creating obstacles for the specific job.</p>
<p>Besides gathering more raw facts by doing exercise, an important step for adjusting it is trying to explicitly state the inaccurate but partially working mental models. One thing that I particularly appreciate the Zulip chat is that there're the diverse (thus inspiring) metanarratives about modeling math in Lean.</p>



<a name="207020133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/difference%20%60let%60%20and%20%60have%60/near/207020133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60.html#207020133">(Aug 15 2020 at 12:38)</a>:</h4>
<p>While we're listing things to learn from, the opening chapters of the Homotopy Type Theory book are a great introduction to the basics of dependent type theory, for people with a mathematical background.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
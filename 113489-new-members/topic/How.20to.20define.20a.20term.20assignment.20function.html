---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html">How to define a term assignment function</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="255471292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255471292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255471292">(Sep 29 2021 at 20:45)</a>:</h4>
<p>My goal is to write some of model theory in Lean to get practice with the language.  I am stuck trying to define a term assignment function, which is supposed to convert a term in a language into an element of some universe that is picked out by a structure. Here is what I've tried which does not compile and I'm not sure why.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">language</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">functions</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">relations</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span>

<span class="kd">variable</span> <span class="n">L</span> <span class="o">:</span> <span class="n">language</span>

<span class="kd">inductive</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">var</span>           <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">func</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>  <span class="o">:</span> <span class="n">L.functions</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">term</span><span class="o">)</span> <span class="bp">→</span> <span class="n">term</span>

<span class="kd">inductive</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">eq</span>          <span class="o">:</span> <span class="n">term</span> <span class="n">L</span> <span class="bp">→</span> <span class="n">term</span> <span class="n">L</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">rel</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">L.relations</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">term</span> <span class="n">L</span><span class="o">)</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">neg</span>         <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">or</span>          <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">all</span>         <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">iA</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span><span class="o">)</span>

<span class="sd">/-- An L-structure -/</span>
<span class="kd">structure</span> <span class="n">Structure</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">A</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">functions</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">L.functions</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span>
<span class="o">(</span><span class="n">relations</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">L.relations</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kd">variable</span> <span class="bp">𝔸</span> <span class="o">:</span> <span class="n">Structure</span> <span class="n">L</span> <span class="n">A</span>

<span class="sd">/-- Variable assignment function into A -/</span>
<span class="kd">def</span> <span class="n">var_assign</span> <span class="o">:=</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">A</span>

<span class="sd">/-- Term assignment function -/</span>
<span class="kd">def</span> <span class="n">term_assign</span> <span class="o">:=</span> <span class="n">term</span> <span class="n">L</span> <span class="bp">→</span> <span class="n">A</span>

<span class="kd">set_option</span> <span class="n">trace.eqn_compiler.elim_match</span> <span class="n">true</span>

<span class="sd">/-- Term assignment function induced by s -/</span>
<span class="sd">/-- Doesn't compile -/</span>
<span class="kd">def</span> <span class="n">term_assign_of_s</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">var_assign</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="n">L</span> <span class="bp">→</span> <span class="n">A</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">t</span> <span class="o">:</span> <span class="n">term</span> <span class="n">L</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span>               <span class="o">:=</span> <span class="n">s</span> <span class="n">n</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">func</span> <span class="n">n</span> <span class="n">fsymb</span> <span class="n">args</span><span class="o">)</span>   <span class="o">:=</span> <span class="o">(</span><span class="bp">𝔸.</span><span class="n">functions</span> <span class="n">n</span> <span class="n">fsymb</span><span class="o">)</span> <span class="o">(</span><span class="n">term_assign_of_s</span> <span class="bp">∘</span> <span class="n">args</span><span class="o">)</span>
  <span class="kd">end</span>
</code></pre></div>



<a name="255479170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255479170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255479170">(Sep 29 2021 at 21:37)</a>:</h4>
<p>I got  a compiling version, but couldn't get it non-meta (ie. lean doesn't see why this terminates without help/rearanging)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">language</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">functions</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">relations</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span>

<span class="kd">variable</span> <span class="n">L</span> <span class="o">:</span> <span class="n">language</span>

<span class="kd">inductive</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">var</span>           <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">func</span>    <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">L.functions</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">term</span><span class="o">)</span> <span class="bp">→</span> <span class="n">term</span>

<span class="kd">inductive</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">eq</span>          <span class="o">:</span> <span class="n">term</span> <span class="n">L</span> <span class="bp">→</span> <span class="n">term</span> <span class="n">L</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">rel</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">L.relations</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">term</span> <span class="n">L</span><span class="o">)</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">neg</span>         <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">or</span>          <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">all</span>         <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">iA</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span><span class="o">)</span>

<span class="sd">/-- An L-structure -/</span>
<span class="kd">structure</span> <span class="n">Structure</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">A</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">functions</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">L.functions</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span>
<span class="o">(</span><span class="n">relations</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">L.relations</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kd">variable</span> <span class="bp">𝔸</span> <span class="o">:</span> <span class="n">Structure</span> <span class="n">L</span> <span class="n">A</span>

<span class="sd">/-- Variable assignment function into A -/</span>
<span class="kd">def</span> <span class="n">var_assign</span> <span class="o">:=</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">A</span>

<span class="sd">/-- Term assignment function -/</span>
<span class="kd">def</span> <span class="n">term_assign</span> <span class="o">:=</span> <span class="n">term</span> <span class="n">L</span> <span class="bp">→</span> <span class="n">A</span>

<span class="kd">set_option</span> <span class="n">trace.eqn_compiler.elim_match</span> <span class="n">true</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">term_assign_of_s</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">var_assign</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="n">L</span> <span class="bp">→</span> <span class="n">A</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">term.var</span> <span class="n">n</span><span class="o">)</span>               <span class="o">:=</span> <span class="n">s</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">term.func</span> <span class="n">fsymb</span> <span class="n">args</span><span class="o">)</span>   <span class="o">:=</span> <span class="bp">𝔸.</span><span class="n">functions</span> <span class="n">fsymb</span> <span class="o">(</span><span class="n">term_assign_of_s</span> <span class="bp">∘</span> <span class="n">args</span><span class="o">)</span>
</code></pre></div>



<a name="255479740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255479740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255479740">(Sep 29 2021 at 21:41)</a>:</h4>
<p>What is meta doing here?</p>



<a name="255480469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255480469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255480469">(Sep 29 2021 at 21:46)</a>:</h4>
<p>Its telling lean not to try and check that the recursion halts.</p>



<a name="255480626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255480626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255480626">(Sep 29 2021 at 21:48)</a>:</h4>
<p>So its not really ideal to prove things about, but hopefully you can see the syntax changes to get the function defined at least</p>



<a name="255480792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255480792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255480792">(Sep 29 2021 at 21:49)</a>:</h4>
<p>If you remove it you'll see the error message, maybe check out <a href="#narrow/stream/113488-general/topic/Unexpected.20occurence.20of.20recursive.20function/near/243769927">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Unexpected.20occurence.20of.20recursive.20function/near/243769927</a></p>



<a name="255481653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255481653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255481653">(Sep 29 2021 at 21:55)</a>:</h4>
<p>This works without <code>meta</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">term_assign_of_s</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">var_assign</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="n">L</span> <span class="bp">→</span> <span class="n">A</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">term.var</span> <span class="n">n</span><span class="o">)</span>               <span class="o">:=</span> <span class="n">s</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">term.func</span> <span class="n">fsymb</span> <span class="n">args</span><span class="o">)</span>   <span class="o">:=</span> <span class="bp">𝔸.</span><span class="n">functions</span> <span class="n">fsymb</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">term_assign_of_s</span> <span class="o">(</span><span class="n">args</span> <span class="n">x</span><span class="o">))</span>
</code></pre></div>



<a name="255481719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255481719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255481719">(Sep 29 2021 at 21:56)</a>:</h4>
<p>The equation compiler can't see through <code>∘</code></p>



<a name="255481780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255481780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255481780">(Sep 29 2021 at 21:56)</a>:</h4>
<p>Or phrased in terms of the error message, it does not expect to see recursive functions without their full argument list</p>



<a name="255482712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255482712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255482712">(Sep 29 2021 at 22:02)</a>:</h4>
<p>Thank you. What is the reason you don't need to write a lambda function for matching on the term?</p>



<a name="255482807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255482807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255482807">(Sep 29 2021 at 22:03)</a>:</h4>
<p>The rule is just that you're not allowed to have <code>term_assign_of_s</code> in the RHS unless it's of the form <code>term_assign_of_s x</code></p>



<a name="255482835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255482835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255482835">(Sep 29 2021 at 22:03)</a>:</h4>
<p>I don't understand your question</p>



<a name="255491358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255491358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255491358">(Sep 29 2021 at 23:20)</a>:</h4>
<p>I'm asking why don't I need to do this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">term_assign_of_s</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">var_assign</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="n">L</span> <span class="bp">→</span> <span class="n">A</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">t</span> <span class="o">:</span> <span class="n">term</span> <span class="n">L</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">term.var</span> <span class="n">n</span><span class="o">)</span>               <span class="o">:=</span> <span class="n">s</span> <span class="n">n</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">term.func</span> <span class="n">fsymb</span> <span class="n">args</span><span class="o">)</span>     <span class="o">:=</span> <span class="bp">𝔸.</span><span class="n">functions</span> <span class="n">fsymb</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">term_assign_of_s</span> <span class="o">(</span><span class="n">args</span> <span class="n">x</span><span class="o">))</span>
  <span class="kd">end</span>
</code></pre></div>



<a name="255491964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255491964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255491964">(Sep 29 2021 at 23:26)</a>:</h4>
<p>the syntax for def-match acts like a lambda followed by a match. What you wrote is mostly equivalent, except that for writing recursive functions the def-match syntax is mandatory</p>



<a name="255492043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255492043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255492043">(Sep 29 2021 at 23:27)</a>:</h4>
<p>by def-match I mean <code>def foo (params...) : type | ...</code> instead of <code>def foo (params...) : type := ...</code></p>



<a name="255494788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255494788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255494788">(Sep 29 2021 at 23:57)</a>:</h4>
<p>Got it thanks</p>



<a name="255495454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255495454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255495454">(Sep 30 2021 at 00:03)</a>:</h4>
<p>I have another question. How can I overload syntax for formula without Lean getting confused with Prop. For example here I have overloaded <code> = </code> and Lean thinks that I have formula even though I want to be a Prop</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">language</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">functions</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">relations</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">language</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">var</span>           <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">func</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>  <span class="o">:</span> <span class="n">L.functions</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">term</span><span class="o">)</span> <span class="bp">→</span> <span class="n">term</span>

<span class="kd">inductive</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">eq</span>          <span class="o">:</span> <span class="n">term</span> <span class="n">L</span> <span class="bp">→</span> <span class="n">term</span> <span class="n">L</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">rel</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">L.relations</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">term</span> <span class="n">L</span><span class="o">)</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">neg</span>         <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">or</span>          <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">all</span>         <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>

<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span><span class="o">:</span><span class="mi">88</span>   <span class="o">:=</span> <span class="n">formula.eq</span>

<span class="kn">open</span> <span class="n">term</span>
<span class="kn">open</span> <span class="n">formula</span>

<span class="kd">def</span> <span class="n">occurs_in_term</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="n">L</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">m</span><span class="o">)</span>      <span class="o">:=</span> <span class="n">to_bool</span> <span class="o">(</span><span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="sd">/-- Lean thinks this is a formula when it should be a Prop -/</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">func</span> <span class="n">_</span> <span class="n">t</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">to_bool</span> <span class="bp">$</span> <span class="bp">∃</span> <span class="n">i</span><span class="o">,</span> <span class="n">occurs_in_term</span> <span class="o">(</span><span class="n">t</span> <span class="n">i</span><span class="o">)</span>
</code></pre></div>



<a name="255495654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255495654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255495654">(Sep 30 2021 at 00:04)</a>:</h4>
<p>The general recommendation is to not do this. Use local notations and don't overload notations you want to use normally</p>



<a name="255495725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255495725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255495725">(Sep 30 2021 at 00:05)</a>:</h4>
<p>Lean 4 is much better at this kind of thing</p>



<a name="255495759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255495759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255495759">(Sep 30 2021 at 00:05)</a>:</h4>
<p>So just come up with different notation is what you're saying?</p>



<a name="255495769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255495769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255495769">(Sep 30 2021 at 00:05)</a>:</h4>
<p>yes</p>



<a name="255495777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255495777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255495777">(Sep 30 2021 at 00:06)</a>:</h4>
<p>Another notation related question</p>



<a name="255495902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255495902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255495902">(Sep 30 2021 at 00:06)</a>:</h4>
<p>Let's say I want to have something like v₁ recognized as the term var 1. Is there a way to do this with notation?</p>



<a name="255496184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255496184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255496184">(Sep 30 2021 at 00:09)</a>:</h4>
<p><code>notation `v` := var 1</code></p>



<a name="255496201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255496201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255496201">(Sep 30 2021 at 00:09)</a>:</h4>
<p>or even just <code>def v := var 1</code></p>



<a name="255496247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255496247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255496247">(Sep 30 2021 at 00:10)</a>:</h4>
<p>you will probably want to scope it</p>



<a name="255496403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255496403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255496403">(Sep 30 2021 at 00:12)</a>:</h4>
<p>Is there any way to make it so that 1 is in the subscript?</p>



<a name="255496448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255496448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255496448">(Sep 30 2021 at 00:12)</a>:</h4>
<p>I'm guessing probably not</p>



<a name="255497421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255497421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255497421">(Sep 30 2021 at 00:23)</a>:</h4>
<p>you can make <code>def v₁ := var 1</code> or <code>notation `v₁` := var 1</code> just the same</p>



<a name="255497499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255497499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255497499">(Sep 30 2021 at 00:24)</a>:</h4>
<p>you will have to repeat this for any other subscripts you want to use but generally you won't need more than 0-3 or so</p>



<a name="255497709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255497709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255497709">(Sep 30 2021 at 00:27)</a>:</h4>
<p>Oh that makes sense</p>



<a name="255497717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255497717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255497717">(Sep 30 2021 at 00:27)</a>:</h4>
<p>Thanks once again</p>



<a name="255508920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255508920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255508920">(Sep 30 2021 at 02:49)</a>:</h4>
<p>How would one define an example of a Structure with this definition? Here I am trying to give an interpretation to the language of number theory and I have defined the meaning of functions with a specific number of arguments but I am having trouble putting it together at the end</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">language</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">functions</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">relations</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span>

<span class="sd">/-- The language of number theory -/</span>
<span class="kd">inductive</span> <span class="n">NT_func</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">NT_func</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">NT_func</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">add</span> <span class="o">:</span> <span class="n">NT_func</span> <span class="mi">2</span>
<span class="bp">|</span> <span class="n">mul</span> <span class="o">:</span> <span class="n">NT_func</span> <span class="mi">2</span>

<span class="kd">inductive</span> <span class="n">NT_rel</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">lt</span> <span class="o">:</span> <span class="n">NT_rel</span> <span class="mi">2</span>

<span class="kd">def</span> <span class="n">NT</span> <span class="o">:</span> <span class="n">language</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="n">NT_func</span><span class="o">,</span> <span class="n">NT_rel</span><span class="o">⟩</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">language</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">Structure</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">A</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">functions</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">L.functions</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span>
<span class="o">(</span><span class="n">relations</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">L.relations</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">NT_func_zero</span> <span class="o">:</span> <span class="n">NT.functions</span> <span class="mi">0</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">NT_func.zero</span> <span class="n">n</span>   <span class="o">:=</span> <span class="mi">0</span>

<span class="kd">def</span> <span class="n">NT_func_one</span> <span class="o">:</span> <span class="n">NT.functions</span> <span class="mi">1</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">NT_func.succ</span> <span class="n">n</span>   <span class="o">:=</span> <span class="o">(</span><span class="n">n</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="kd">def</span> <span class="n">NT_func_two</span> <span class="o">:</span> <span class="n">NT.functions</span> <span class="mi">2</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">NT_func.add</span> <span class="n">args</span> <span class="o">:=</span> <span class="o">(</span><span class="n">args</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">args</span> <span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">NT_func.mul</span> <span class="n">args</span> <span class="o">:=</span> <span class="o">(</span><span class="n">args</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">args</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">NT_struct_func</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">NT.functions</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span>
</code></pre></div>



<a name="255509066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255509066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255509066">(Sep 30 2021 at 02:51)</a>:</h4>
<p>I would get rid of <code>NT_func_zero</code>, <code>NT_func_one</code> and <code>NT_func_two</code> and structure it like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">NT_struct_func</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">NT.functions</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">NT_func.zero</span> <span class="n">n</span>   <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">NT_func.succ</span> <span class="n">n</span>   <span class="o">:=</span> <span class="o">(</span><span class="n">n</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">NT_func.add</span> <span class="n">args</span> <span class="o">:=</span> <span class="o">(</span><span class="n">args</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">args</span> <span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">NT_func.mul</span> <span class="n">args</span> <span class="o">:=</span> <span class="o">(</span><span class="n">args</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">args</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>



<a name="255509142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255509142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255509142">(Sep 30 2021 at 02:52)</a>:</h4>
<p>I was trying something like that originally but I was having trouble getting it to work. So the purpose of the first _ is to pattern match on the int part? Does that determine the value of the implicit parameter n?</p>



<a name="255509234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255509234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255509234">(Sep 30 2021 at 02:54)</a>:</h4>
<p>Also is there a reason Lean can't seem to find an exponentiation operator for Nat?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">language</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">functions</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">relations</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span>

<span class="sd">/-- The language of number theory -/</span>
<span class="kd">inductive</span> <span class="n">NT_func</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">NT_func</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">NT_func</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">add</span> <span class="o">:</span> <span class="n">NT_func</span> <span class="mi">2</span>
<span class="bp">|</span> <span class="n">mul</span> <span class="o">:</span> <span class="n">NT_func</span> <span class="mi">2</span>
<span class="bp">|</span> <span class="n">exp</span> <span class="o">:</span> <span class="n">NT_func</span> <span class="mi">2</span>

<span class="kd">inductive</span> <span class="n">NT_rel</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">lt</span> <span class="o">:</span> <span class="n">NT_rel</span> <span class="mi">2</span>

<span class="kd">def</span> <span class="n">NT</span> <span class="o">:</span> <span class="n">language</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="n">NT_func</span><span class="o">,</span> <span class="n">NT_rel</span><span class="o">⟩</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">language</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">Structure</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">A</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">functions</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">L.functions</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span>
<span class="o">(</span><span class="n">relations</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">L.relations</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">NT_struct_func</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">NT.functions</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">NT_func.zero</span> <span class="n">n</span>   <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">NT_func.succ</span> <span class="n">n</span>   <span class="o">:=</span> <span class="o">(</span><span class="n">n</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">NT_func.add</span> <span class="n">args</span> <span class="o">:=</span> <span class="o">(</span><span class="n">args</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">args</span> <span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">NT_func.mul</span> <span class="n">args</span> <span class="o">:=</span> <span class="o">(</span><span class="n">args</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">args</span> <span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">NT_func.exp</span> <span class="n">args</span> <span class="o">:=</span> <span class="o">(</span><span class="n">args</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">^</span> <span class="o">(</span><span class="n">args</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>



<a name="255509282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255509282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255509282">(Sep 30 2021 at 02:54)</a>:</h4>
<p>It's not pattern matching on the int exactly; it's an "inaccessible parameter"</p>



<a name="255509299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255509299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255509299">(Sep 30 2021 at 02:55)</a>:</h4>
<p>which means it has to be in the pattern match but its value is determined by the other parameters</p>



<a name="255509403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255509403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255509403">(Sep 30 2021 at 02:56)</a>:</h4>
<p>You need to import <code>algebra.group_power</code> to get exponentiation</p>



<a name="255509466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255509466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255509466">(Sep 30 2021 at 02:57)</a>:</h4>
<p>So without marking the existence of an inaccessible parameter with _ Lean will just assume that n is still just a variable?</p>



<a name="255509537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255509537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255509537">(Sep 30 2021 at 02:58)</a>:</h4>
<p>You need to put something there since the pattern match has three arguments</p>



<a name="255509593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255509593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255509593">(Sep 30 2021 at 02:59)</a>:</h4>
<p>you can also put <code>.(0)</code> in the first case if you want to be specific about the value that lean is inferring it to</p>



<a name="255509601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255509601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255509601">(Sep 30 2021 at 02:59)</a>:</h4>
<p>Ok got it, thanks</p>



<a name="255509611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255509611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255509611">(Sep 30 2021 at 02:59)</a>:</h4>
<p>the <code>.</code> is to say that we aren't pattern matching on the nat</p>



<a name="255509687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255509687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255509687">(Sep 30 2021 at 03:00)</a>:</h4>
<p>but you will almost never see that syntax used because <code>_</code> always works in its place</p>



<a name="255510710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255510710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255510710">(Sep 30 2021 at 03:14)</a>:</h4>
<p>What is the reason for this type error?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group_power</span>

<span class="kd">structure</span> <span class="n">language</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">functions</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">relations</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span>

<span class="sd">/-- The language of number theory -/</span>
<span class="kd">inductive</span> <span class="n">NT_func</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">NT_func</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">NT_func</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">add</span> <span class="o">:</span> <span class="n">NT_func</span> <span class="mi">2</span>
<span class="bp">|</span> <span class="n">mul</span> <span class="o">:</span> <span class="n">NT_func</span> <span class="mi">2</span>
<span class="bp">|</span> <span class="n">exp</span> <span class="o">:</span> <span class="n">NT_func</span> <span class="mi">2</span>

<span class="kd">inductive</span> <span class="n">NT_rel</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">lt</span> <span class="o">:</span> <span class="n">NT_rel</span> <span class="mi">2</span>

<span class="kd">def</span> <span class="n">NT</span> <span class="o">:</span> <span class="n">language</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="n">NT_func</span><span class="o">,</span> <span class="n">NT_rel</span><span class="o">⟩</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">language</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">Structure</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">A</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">functions</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">L.functions</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span>
<span class="o">(</span><span class="n">relations</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">L.relations</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="sd">/-- The usual intepretation of Number Theory -/</span>
<span class="kd">def</span> <span class="n">NT_struct_func</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">NT.functions</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">NT_func.zero</span> <span class="n">n</span>   <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">NT_func.succ</span> <span class="n">n</span>   <span class="o">:=</span> <span class="o">(</span><span class="n">n</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">NT_func.add</span> <span class="n">args</span> <span class="o">:=</span> <span class="o">(</span><span class="n">args</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">args</span> <span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">NT_func.mul</span> <span class="n">args</span> <span class="o">:=</span> <span class="o">(</span><span class="n">args</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">args</span> <span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">NT_func.exp</span> <span class="n">args</span> <span class="o">:=</span> <span class="o">(</span><span class="n">args</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">^</span> <span class="o">(</span><span class="n">args</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">NT_struct_rel</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">NT.relations</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">NT_rel.lt</span> <span class="n">args</span>   <span class="o">:=</span> <span class="o">(</span><span class="n">args</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">args</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">NT_struct</span> <span class="o">:</span> <span class="n">Structure</span> <span class="n">NT</span> <span class="n">ℕ</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="n">NT_struct_func</span><span class="o">,</span> <span class="n">NT_struct_rel</span><span class="o">⟩</span>
</code></pre></div>



<a name="255510723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255510723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255510723">(Sep 30 2021 at 03:14)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">Structure.mk</span> <span class="n">NT_struct_func</span>
<span class="n">term</span>
  <span class="n">NT_struct_func</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">NT.functions</span> <span class="bp">?</span><span class="n">m_1</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="bp">?</span><span class="n">m_1</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">NT.functions</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℕLean</span>
</code></pre></div>



<a name="255510746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255510746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255510746">(Sep 30 2021 at 03:15)</a>:</h4>
<p>I would have thought there was no difference between these two types</p>



<a name="255510762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255510762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255510762">(Sep 30 2021 at 03:15)</a>:</h4>
<p>If I make n explicit it goes away</p>



<a name="255510999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255510999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255510999">(Sep 30 2021 at 03:18)</a>:</h4>
<p>This is how implicit arguments work. When you write <code>NT_struct_func</code> lean automatically inserts a <code>_</code> for the implicit argument <code>n</code> here, resulting in <code>@NT_struct_func _</code> which doesn't match the type expected by <code>NT_struct</code>.</p>



<a name="255511111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255511111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255511111">(Sep 30 2021 at 03:20)</a>:</h4>
<p>You can fix this by making the argument explicit like you did, or by using a "semi-implicit" binder <code>{{n : nat}}</code>, which acts like an implicit argument only if you supply the argument coming after <code>n</code> (here the relation), or by writing <code>@NT_struct_func</code> in <code>NT_struct</code></p>



<a name="255621583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20define%20a%20term%20assignment%20function/near/255621583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20to.20define.20a.20term.20assignment.20function.html#255621583">(Sep 30 2021 at 18:10)</a>:</h4>
<p>How would write an instance of has_repr for this? </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">language</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">functions</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">relations</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span>

<span class="kd">variable</span> <span class="n">L</span> <span class="o">:</span> <span class="n">language</span>

<span class="kd">inductive</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">var</span>           <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">func</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>  <span class="o">:</span> <span class="n">L.functions</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">term</span><span class="o">)</span> <span class="bp">→</span> <span class="n">term</span>

<span class="kn">open</span> <span class="n">term</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_repr</span> <span class="o">(</span><span class="n">term</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span>
<span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span>             <span class="o">:=</span> <span class="s2">"v"</span> <span class="bp">++</span> <span class="n">repr</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">func</span> <span class="n">fsymb</span> <span class="n">args</span><span class="o">)</span>   <span class="o">:=</span> <span class="o">(</span><span class="n">repr</span> <span class="n">fsymb</span><span class="o">)</span> <span class="bp">++</span> <span class="o">(</span><span class="n">repr</span> <span class="n">args</span><span class="o">)</span>
<span class="kd">end</span><span class="o">⟩</span>
<span class="kd">end</span><span class="o">⟩</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
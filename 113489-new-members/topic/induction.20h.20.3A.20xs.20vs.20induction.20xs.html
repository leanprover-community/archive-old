---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html">induction h : xs vs induction xs</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="323014139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323014139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> fkefjlwejlfk <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323014139">(Jan 23 2023 at 13:04)</a>:</h4>
<p>Dear all,</p>
<p>I am working on a large proof and have some problems with the <code>induction</code> tactic. <br>
I perform <code>induction</code> on a list <code>xs</code> which gives me two cases.</p>
<p>I am able to solve the first case (<code>list.nil</code>) if I use the notation <code>induction h : xs</code> because this introduces <code>h</code> which I can use for my proof. </p>
<p>I am able to solve the second case (<code>list.cons</code>) if I use the notation <code>induction xs</code>. However, if I use the <code>induction h : xs</code> syntax, it introduces a term in my induction hypothesis which isn't provable. But when I use <code>induction xs</code>, I lack the <code>h</code> term in the first case which makes it insolveable. </p>
<p>TL;DR Can I use a certain syntax so I have the behavior of <code>induction h : xs</code> in one case and the behavior of <code>induction xs</code> in the other case?</p>



<a name="323015024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323015024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323015024">(Jan 23 2023 at 13:08)</a>:</h4>
<p>I'm not entirely sure in your specific case, it would help to write a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>. You might have success with the <code>induction'</code> tactic, which should be smart enough to keep your goal provable.</p>



<a name="323015072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323015072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323015072">(Jan 23 2023 at 13:09)</a>:</h4>
<p><del>See <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#induction'">tactic#induction'</a></del></p>



<a name="323015457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323015457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323015457">(Jan 23 2023 at 13:10)</a>:</h4>
<p>See <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.interactive.induction'">docs#tactic.interactive.induction'</a> (apparently it hasn't been added to the mathlib tactic overview)</p>



<a name="323018619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323018619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> fkefjlwejlfk <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323018619">(Jan 23 2023 at 13:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs/near/323015024">said</a>:</p>
<blockquote>
<p>I'm not entirely sure in your specific case, it would help to write a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>. You might have success with the <code>induction'</code> tactic, which should be smart enough to keep your goal provable.</p>
</blockquote>
<p><code>induction'</code> also doesn't work. Generating a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> will get quite extensive because a lot of functions are deeply nested resulting in a complex <code>ih</code>. Isn't there a way to rewrite the induction hypothesis? It seems pretty odd to me that merely introducing <code>h</code> will break one of the cases.</p>



<a name="323022350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323022350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323022350">(Jan 23 2023 at 13:42)</a>:</h4>
<p>I think that what Anne is saying is that we don't really understand the problem, so it's difficult to help. If you have a working example you can post it. You can replace all proof by <code>sorry</code> to keep it small.</p>



<a name="323022454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323022454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323022454">(Jan 23 2023 at 13:42)</a>:</h4>
<p>But of course you cannot <code>sorry</code> definitions.</p>



<a name="323103991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323103991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> fkefjlwejlfk <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323103991">(Jan 23 2023 at 19:45)</a>:</h4>
<p><span class="user-mention" data-user-id="130384">@Riccardo Brasca</span>  <span class="user-mention" data-user-id="238446">@Anne Baanen</span>  I have constructed a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> that has the same problem :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">-&gt;</span> <span class="n">option</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">n</span> <span class="k">then</span> <span class="n">some</span> <span class="n">x</span> <span class="k">else</span> <span class="n">foo</span> <span class="n">xs</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">none</span>

<span class="kd">def</span> <span class="n">gen_list</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="o">:=</span>  <span class="o">[</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">]</span> <span class="bp">++</span> <span class="o">[</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">]</span> <span class="bp">++</span> <span class="o">[</span><span class="n">n</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">is_foo_able</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span>
<span class="k">match</span> <span class="o">(</span><span class="n">foo</span> <span class="n">n</span> <span class="o">(</span><span class="n">gen_list</span> <span class="n">n</span><span class="o">))</span> <span class="k">with</span>
<span class="bp">|</span> <span class="n">some</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="kd">end</span>


<span class="kd">lemma</span> <span class="n">foo_able</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">is_foo_able</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">tt</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">foo</span> <span class="n">n</span> <span class="o">(</span><span class="n">gen_list</span> <span class="n">n</span><span class="o">))</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">is_foo_able</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">cases'</span> <span class="n">hh</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">n</span> <span class="o">(</span><span class="n">gen_list</span> <span class="n">n</span><span class="o">),</span>  <span class="c1">-- This is the relevant line</span>
  <span class="o">{</span><span class="n">finish</span><span class="o">},</span>
  <span class="o">{</span>
    <span class="n">induction'</span> <span class="n">hh2</span> <span class="o">:</span>  <span class="n">gen_list</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">finish</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">apply</span> <span class="o">(</span><span class="n">ih</span> <span class="n">n</span><span class="o">),</span>
      <span class="n">finish</span><span class="o">,</span>
      <span class="n">finish</span><span class="o">,</span>
      <span class="c1">-- fails here</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>I have <code>induction' hh2 :  gen_list n</code>, in the first case this introduces <code>hh2 : gen_list n = nil</code> which can then be used to create a contradiction. In the second case though you get <code>hh2: gen_list n = hd :: x</code> and <code>ih: ∀ (n : ℕ), is_foo_able._match_1 (foo n (gen_list n)) = tt → ∀ (val : ℕ), foo n (gen_list n) = some val → gen_list n = x → some val = some n</code>, notice the <code>gen_list n = x</code> term in <code>ih</code>, this is obviously false and makes the induction hypotheses completely useless. </p>
<p>However, if I change <code>induction' hh2 :  gen_list n</code> to <code>induction'   gen_list n</code> then in the second case get <code>ih: ∀ (n : ℕ), is_foo_able._match_1 (foo n (gen_list n)) = tt → ∀ (val : ℕ), foo n (gen_list n) = some val → some val = some n</code> which can be used to proof the goal. However, in the first case we no longer have <code>hh2 : gen_list n = nil</code> so the contradiction can't be proven anymore. </p>
<p>This means that with one notation I can prove one case, and with the other notation I can proof the other case. I can't proof both cases :(</p>



<a name="323130992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323130992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323130992">(Jan 23 2023 at 22:34)</a>:</h4>
<p>Not sure but maybe you can try the <code>generalize h : gen_list n = l,</code> syntax in <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#generalize">tactic#generalize</a> first, then <code>induction l</code></p>



<a name="323221521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323221521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323221521">(Jan 24 2023 at 11:07)</a>:</h4>
<p>Thanks for the MWE, I get the issue now! However, my conclusion is that this is just not a thing that is provable through induction: <code>gen_list n</code> is a specific list of length 3, so what happens if you apply the inductive hypothesis four times? How should we express the relation between the list <code>x</code> in the inductive hypothesis and <code>gen_list n</code>?</p>



<a name="323323427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323323427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> fkefjlwejlfk <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323323427">(Jan 24 2023 at 18:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs/near/323221521">said</a>:</p>
<blockquote>
<p>Thanks for the MWE, I get the issue now! However, my conclusion is that this is just not a thing that is provable through induction: <code>gen_list n</code> is a specific list of length 3, so what happens if you apply the inductive hypothesis four times? How should we express the relation between the list <code>x</code> in the inductive hypothesis and <code>gen_list n</code>?</p>
</blockquote>
<p>The thing is, in my real world example (so not this <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>) the list is of an arbitrary length and has this exact problem. it just seems impossible to solve both cases sadly :(</p>



<a name="323323459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323323459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> fkefjlwejlfk <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323323459">(Jan 24 2023 at 18:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs/near/323130992">said</a>:</p>
<blockquote>
<p>Not sure but maybe you can try the <code>generalize h : gen_list n = l,</code> syntax in <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#generalize">tactic#generalize</a> first, then <code>induction l</code></p>
</blockquote>
<p>sadly results in the same problem..</p>



<a name="323329065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323329065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> fkefjlwejlfk <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323329065">(Jan 24 2023 at 18:51)</a>:</h4>
<p><span class="user-mention" data-user-id="238446">@Anne Baanen</span>  By the way any other way to proof this would be acceptable. I feel though like induction' would be the most natural way. In this case I could do a brute force proof but in the real problem the list is of arbitrary length.</p>



<a name="323346048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323346048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323346048">(Jan 24 2023 at 20:21)</a>:</h4>
<p>The general strategy of such proofs is to generalize the statement of what you're trying to prove so that it holds for an arbitrary list (not just the particular <code>gen_list n</code>) and then perform induction. The way to perform this step really depends on your actual situation, so I cannot comment on it from your MWE. Maybe an idea is to first try to understand mathematically why what you're proving is true, before writing it in Lean.</p>
<p>Your request to mix and match different induction principles from different induction invocations allows you to prove false things, so therefore it's not allowed.</p>



<a name="323349470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323349470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> fkefjlwejlfk <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323349470">(Jan 24 2023 at 20:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="111080">Floris van Doorn</span> <a href="#narrow/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs/near/323346048">said</a>:</p>
<blockquote>
<p>The general strategy of such proofs is to generalize the statement of what you're trying to prove so that it holds for an arbitrary list (not just the particular <code>gen_list n</code>) and then perform induction. The way to perform this step really depends on your actual situation, so I cannot comment on it from your MWE. Maybe an idea is to first try to understand mathematically why what you're proving is true, before writing it in Lean.</p>
<p>Your request to mix and match different induction principles from different induction invocations allows you to prove false things, so therefore it's not allowed.</p>
</blockquote>
<p>I still don't get this. What you are saying is if I use <code>induction'  xs</code> instead of <code>induction' h :  xs</code> it is no longer valid to assume that <code>gen_list n = nil</code> in case <code>nil</code>?   I have trouble understanding that part as it seems very counter intuitive</p>



<a name="323350152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323350152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323350152">(Jan 24 2023 at 20:47)</a>:</h4>
<p>Exactly. <br>
If you want an induction step where you don't want that the induction hypothesis depends on the assumption <code>gen_list n = x</code>, which you call "obviously false", then you also cannot assume it for the <code>nil</code> case. Otherwise you're doing a different induction in the <code>nil</code> and the <code>cons</code> case, and you can easily prove <code>false</code> if you do that.</p>



<a name="323351491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323351491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> fkefjlwejlfk <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323351491">(Jan 24 2023 at 20:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="111080">Floris van Doorn</span> <a href="#narrow/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs/near/323350152">said</a>:</p>
<blockquote>
<p>Exactly. <br>
If you want an induction step where you don't want that the induction hypothesis depends on the assumption <code>gen_list n = x</code>, which you call "obviously false", then you also cannot assume it for the <code>nil</code> case. Otherwise you're doing a different induction in the <code>nil</code> and the <code>cons</code> case, and you can easily prove <code>false</code> if you do that.</p>
</blockquote>
<p>Thank you for your answer, I am sorry if my "obviously false" comment came across wrong, what I meant by this is that this would have me proof "gen_list n = x" which is "obviously false" since we have "gen_list n = hd :: x" in our environment. So I guess the induction' strategy is completely out of the window then, unless I can somehow find a way to get an arbitrary list. Is this do-able in the <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> example? I am not completely sure when a list is considered completely arbitrary (I thought the list generated by <code>gen_list n </code>was considered arbitrary lol)</p>



<a name="323352719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323352719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323352719">(Jan 24 2023 at 21:01)</a>:</h4>
<p>If you have both "gen_list n = x" and "gen_list n = hd :: x" in environment, you can derive a contradiction by rewriting and apply_fun list.length, and then you can derive anything, in particular your goal.</p>



<a name="323353133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323353133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> fkefjlwejlfk <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323353133">(Jan 24 2023 at 21:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs/near/323352719">said</a>:</p>
<blockquote>
<p>If you have both "gen_list n = x" and "gen_list n = hd :: x" in environment, you can derive a contradiction by rewriting and apply_fun list.length, and then you can derive anything, in particular your goal.</p>
</blockquote>
<p>I mean we have <code>gen_list n = hd :: x</code> in our environment but we have to proof the goal <code>gen_list n = x</code></p>



<a name="323356472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323356472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323356472">(Jan 24 2023 at 21:24)</a>:</h4>
<p><span class="user-mention" data-user-id="579335">@fkefjlwejlfk</span> I can't speak to your original non-MWE, but the MWE can be proved thusly:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.basic</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">-&gt;</span> <span class="n">option</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">n</span> <span class="k">then</span> <span class="n">some</span> <span class="n">x</span> <span class="k">else</span> <span class="n">foo</span> <span class="n">xs</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">none</span>

<span class="kd">def</span> <span class="n">gen_list</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="o">:=</span>  <span class="o">[</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">]</span> <span class="bp">++</span> <span class="o">[</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">]</span> <span class="bp">++</span> <span class="o">[</span><span class="n">n</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">is_foo_able</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span>
<span class="k">match</span> <span class="o">(</span><span class="n">foo</span> <span class="n">n</span> <span class="o">(</span><span class="n">gen_list</span> <span class="n">n</span><span class="o">))</span> <span class="k">with</span>
<span class="bp">|</span> <span class="n">some</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">foo_able</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">is_foo_able</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">tt</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">foo</span> <span class="n">n</span> <span class="o">(</span><span class="n">gen_list</span> <span class="n">n</span><span class="o">))</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">is_foo_able</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">n</span> <span class="o">(</span><span class="n">gen_list</span> <span class="n">n</span><span class="o">)</span><span class="bp">;</span> <span class="n">rintro</span> <span class="o">⟨⟩,</span>
  <span class="n">revert</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">foo</span><span class="o">,</span> <span class="n">gen_list</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="323356534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323356534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323356534">(Jan 24 2023 at 21:24)</a>:</h4>
<p>it's not really a proof by induction as Floris said</p>



<a name="323356607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323356607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323356607">(Jan 24 2023 at 21:25)</a>:</h4>
<p>so if this doesn't capture the spirit of the question you should either make a more elaborate MWE or try to sketch what your theorem actually is</p>



<a name="323357247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323357247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323357247">(Jan 24 2023 at 21:30)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">foo_able</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">is_foo_able</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">tt</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">foo</span> <span class="n">n</span> <span class="o">(</span><span class="n">gen_list</span> <span class="n">n</span><span class="o">))</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">is_foo_able</span><span class="o">,</span> <span class="n">gen_list</span><span class="o">,</span> <span class="n">foo</span><span class="o">]</span>
</code></pre></div>



<a name="323357843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323357843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323357843">(Jan 24 2023 at 21:34)</a>:</h4>
<p>wait a minute...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">foo_able</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">n</span> <span class="o">(</span><span class="n">gen_list</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">gen_list</span><span class="o">,</span> <span class="n">foo</span><span class="o">]</span>
</code></pre></div>



<a name="323358278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/induction%20h%20%3A%20xs%20vs%20induction%20xs/near/323358278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs.html#323358278">(Jan 24 2023 at 21:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="579335">fkefjlwejlfk</span> <a href="#narrow/stream/113489-new-members/topic/induction.20h.20.3A.20xs.20vs.20induction.20xs/near/323351491">said</a>:</p>
<blockquote>
<p>I am not completely sure when a list is considered completely arbitrary (I thought the list generated by <code>gen_list n </code>was considered arbitrary lol)</p>
</blockquote>
<p>Generally we would say that a value is arbitrary if it is a variable in the context. So <code>n</code> is an "arbitrary" natural number in the sense that the theorem can be applied with any particular value of <code>n</code>, but <code>gen_list n</code> is the output of a construction, so not completely arbitrary. (In this case for example we can say that <code>gen_list n</code> always produces a list of length 3, which is clearly not true about every list.)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
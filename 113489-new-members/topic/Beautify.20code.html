---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Beautify.20code.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html">Beautify code</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="212930908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212930908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212930908">(Oct 10 2020 at 19:23)</a>:</h4>
<p>Any suggestions in how to make the following prettier?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">impl</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>

<span class="kn">open</span> <span class="n">term</span>

<span class="kd">def</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">select</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">as</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">as</span><span class="o">)</span> <span class="o">::</span> <span class="n">list.map</span> <span class="o">(</span><span class="n">bifunctor.snd</span> <span class="o">(</span><span class="n">list.cons</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">select</span> <span class="n">as</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">[]</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">ljt</span> <span class="o">:</span> <span class="n">list</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">env</span> <span class="n">t</span><span class="bp">@</span><span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">t</span> <span class="bp">∈</span> <span class="n">env</span> <span class="k">then</span> <span class="n">return</span> <span class="n">t</span> <span class="k">else</span> <span class="k">do</span>
  <span class="o">(</span><span class="n">impl</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">env</span><span class="o">)</span> <span class="bp">←</span> <span class="n">select</span> <span class="n">env</span> <span class="bp">|</span> <span class="n">alternative.failure</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">a</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">guard</span> <span class="bp">$</span> <span class="n">var</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">env</span><span class="o">,</span>
    <span class="n">ljt</span> <span class="o">(</span><span class="n">b</span> <span class="o">::</span> <span class="n">env</span><span class="o">)</span> <span class="n">t</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">impl</span> <span class="n">c</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">ljt</span> <span class="o">(</span><span class="n">impl</span> <span class="n">d</span> <span class="n">b</span> <span class="o">::</span> <span class="n">env</span><span class="o">)</span> <span class="o">(</span><span class="n">impl</span> <span class="n">c</span> <span class="n">d</span><span class="o">),</span>
    <span class="n">ljt</span> <span class="o">(</span><span class="n">b</span> <span class="o">::</span> <span class="n">env</span><span class="o">)</span> <span class="n">t</span>
  <span class="kd">end</span>
<span class="bp">|</span> <span class="n">env</span> <span class="n">t</span><span class="bp">@</span><span class="o">(</span><span class="n">impl</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">t</span> <span class="bp">∈</span> <span class="n">env</span> <span class="k">then</span> <span class="n">return</span> <span class="n">t</span> <span class="k">else</span> <span class="n">ljt</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">env</span><span class="o">)</span> <span class="n">b</span>
</code></pre></div>



<a name="212930954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212930954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212930954">(Oct 10 2020 at 19:24)</a>:</h4>
<p>I would like to make it more like the Haskell version:</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">import</span> <span class="nn">Control.Monad</span>
<span class="kr">import</span> <span class="nn">Data.Bifunctor</span>

<span class="kr">data</span> <span class="kt">Term</span>
    <span class="ow">=</span> <span class="kt">Var</span> <span class="kt">Char</span>
    <span class="o">|</span> <span class="kt">Impl</span> <span class="kt">Term</span> <span class="kt">Term</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="nf">ljt</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span>
<span class="nf">ljt</span> <span class="n">env</span> <span class="n">t</span>
    <span class="o">|</span> <span class="n">elem</span> <span class="n">t</span> <span class="n">env</span> <span class="ow">=</span> <span class="n">return</span> <span class="n">t</span>
<span class="nf">ljt</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Impl</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">ljt</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:</span> <span class="n">env</span><span class="p">)</span> <span class="n">b</span>
<span class="nf">ljt</span> <span class="n">env</span> <span class="n">t</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">(</span><span class="kt">Impl</span> <span class="n">a</span> <span class="n">b</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">select</span> <span class="n">env</span>
    <span class="kr">case</span> <span class="n">a</span> <span class="kr">of</span>
        <span class="kt">Var</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
            <span class="n">guard</span> <span class="o">$</span> <span class="n">elem</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">a</span><span class="p">)</span> <span class="n">env</span>
            <span class="n">ljt</span> <span class="p">(</span><span class="n">b</span> <span class="kt">:</span> <span class="n">env</span><span class="p">)</span> <span class="n">t</span>
        <span class="kt">Impl</span> <span class="n">c</span> <span class="n">d</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
            <span class="n">ljt</span> <span class="p">(</span><span class="kt">Impl</span> <span class="n">d</span> <span class="n">b</span> <span class="kt">:</span> <span class="n">env</span><span class="p">)</span> <span class="p">(</span><span class="kt">Impl</span> <span class="n">c</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">ljt</span> <span class="p">(</span><span class="n">b</span> <span class="kt">:</span> <span class="n">env</span><span class="p">)</span> <span class="n">t</span>

<span class="nf">select</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">])]</span>
<span class="nf">select</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span> <span class="kt">:</span> <span class="n">map</span> <span class="p">(</span><span class="n">second</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="p">))</span> <span class="p">(</span><span class="n">select</span> <span class="n">xs</span><span class="p">)</span>
<span class="nf">select</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">[]</span>
</code></pre></div>



<a name="212930975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212930975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212930975">(Oct 10 2020 at 19:25)</a>:</h4>
<p>It particularly bothers me that <code>if t ∈ env then return t else ...</code> gets written twice in the Lean version.</p>



<a name="212931055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212931055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212931055">(Oct 10 2020 at 19:26)</a>:</h4>
<p>(Also, if anyone has any clue on how to convince Lean that <code>ljt</code> terminates, any help would be highly appreciated. I got it from <a href="http://ceur-ws.org/Vol-2271/paper1.pdf">here</a>)</p>



<a name="212933151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212933151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212933151">(Oct 10 2020 at 20:24)</a>:</h4>
<p>Here's a hack using optional parameters, but it's uglier in another axis:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">control.bifunctor</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">impl</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>

<span class="kn">open</span> <span class="n">term</span>

<span class="kd">def</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">select</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">as</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">as</span><span class="o">)</span> <span class="o">::</span> <span class="n">list.map</span> <span class="o">(</span><span class="n">bifunctor.snd</span> <span class="o">(</span><span class="n">list.cons</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">select</span> <span class="n">as</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">[]</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">ljt</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">env</span> <span class="o">:</span> <span class="n">list</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="n">in_env</span> <span class="o">:</span> <span class="n">opt_param</span> <span class="n">bool</span> <span class="o">(</span><span class="n">t</span> <span class="bp">∈</span> <span class="n">env</span><span class="o">)),</span> <span class="n">list</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">env</span> <span class="n">t</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">return</span> <span class="n">t</span>
<span class="bp">|</span> <span class="n">env</span> <span class="n">t</span><span class="bp">@</span><span class="o">(</span><span class="n">impl</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">ljt</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">env</span><span class="o">)</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">env</span> <span class="n">t</span><span class="bp">@</span><span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="n">ff</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="o">(</span><span class="n">impl</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">env</span><span class="o">)</span> <span class="bp">←</span> <span class="n">select</span> <span class="n">env</span> <span class="bp">|</span> <span class="o">[],</span>
  <span class="k">match</span> <span class="n">a</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">guard</span> <span class="bp">$</span> <span class="n">var</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">env</span><span class="o">,</span>
                  <span class="n">ljt</span> <span class="o">(</span><span class="n">b</span> <span class="o">::</span> <span class="n">env</span><span class="o">)</span> <span class="n">t</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">impl</span> <span class="n">c</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">ljt</span> <span class="o">(</span><span class="n">impl</span> <span class="n">d</span> <span class="n">b</span> <span class="o">::</span> <span class="n">env</span><span class="o">)</span> <span class="o">(</span><span class="n">impl</span> <span class="n">c</span> <span class="n">d</span><span class="o">),</span>
    <span class="n">ljt</span> <span class="o">(</span><span class="n">b</span> <span class="o">::</span> <span class="n">env</span><span class="o">)</span> <span class="n">t</span>
  <span class="kd">end</span>
</code></pre></div>



<a name="212933974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212933974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212933974">(Oct 10 2020 at 20:49)</a>:</h4>
<p>Wow. I would have never though of that.</p>



<a name="212934019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212934019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212934019">(Oct 10 2020 at 20:50)</a>:</h4>
<p>Is <code>opt_param</code> used somewhere other than in tactics?</p>



<a name="212944169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212944169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212944169">(Oct 11 2020 at 02:04)</a>:</h4>
<p>It is used in structures to give default values for some arguments, e.g. <code>lt</code> in <a href="https://leanprover-community.github.io/mathlib_docs/find/preorder/src">src#preorder</a></p>



<a name="212944354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212944354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212944354">(Oct 11 2020 at 02:10)</a>:</h4>
<p>Assuming you don't care about termination, you can get closer to the haskell version by just doing this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">ljt</span> <span class="o">:</span> <span class="n">list</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">env</span> <span class="n">t</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">t</span> <span class="bp">∈</span> <span class="n">env</span> <span class="k">then</span> <span class="n">return</span> <span class="n">t</span> <span class="k">else</span>
  <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">impl</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">ljt</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">env</span><span class="o">)</span> <span class="n">b</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="o">(</span><span class="n">impl</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">env</span><span class="o">)</span> <span class="bp">←</span> <span class="n">select</span> <span class="n">env</span> <span class="bp">|</span> <span class="n">failure</span><span class="o">,</span>
    <span class="k">match</span> <span class="n">a</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
      <span class="n">guard</span> <span class="bp">$</span> <span class="n">var</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">env</span><span class="o">,</span>
      <span class="n">ljt</span> <span class="o">(</span><span class="n">b</span> <span class="o">::</span> <span class="n">env</span><span class="o">)</span> <span class="n">t</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">impl</span> <span class="n">c</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
      <span class="n">ljt</span> <span class="o">(</span><span class="n">impl</span> <span class="n">d</span> <span class="n">b</span> <span class="o">::</span> <span class="n">env</span><span class="o">)</span> <span class="o">(</span><span class="n">impl</span> <span class="n">c</span> <span class="n">d</span><span class="o">),</span>
      <span class="n">ljt</span> <span class="o">(</span><span class="n">b</span> <span class="o">::</span> <span class="n">env</span><span class="o">)</span> <span class="n">t</span>
    <span class="kd">end</span>
  <span class="kd">end</span>
</code></pre></div>



<a name="212975891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212975891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212975891">(Oct 11 2020 at 18:21)</a>:</h4>
<p>Thanks!</p>



<a name="212975904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212975904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212975904">(Oct 11 2020 at 18:21)</a>:</h4>
<p>I do care about termination. But the either versions look as far from being easy to convince Lean it terminates as it can be.</p>



<a name="212977275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212977275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212977275">(Oct 11 2020 at 19:00)</a>:</h4>
<p>I thought about it for a while and the termination condition is incredibly complex</p>



<a name="212977279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212977279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212977279">(Oct 11 2020 at 19:00)</a>:</h4>
<p>do you have an informal proof of termination?</p>



<a name="212981679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212981679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212981679">(Oct 11 2020 at 21:06)</a>:</h4>
<p>I've got an informal proof but I think to convince lean it might take quite a bit of refactoring of <code>ljt</code>, (for instance knowing that the <code>env</code> after the select is the original one minus an element), but I think the maths here is mostly straightforward (plus some standard results about wellorderings which I don't believe are in mathlib)</p>



<a name="212982579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212982579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212982579">(Oct 11 2020 at 21:30)</a>:</h4>
<p><span class="user-mention" data-user-id="298376">@Pedro Minicz</span> By the way, it doesn't seem you've translated the Prolog from the paper completely faithfully.  The cut operator <code>!</code> means to throw out all backtracking for the most recent choice point, and I'm not sure you can do that within the list monad.</p>
<p>This might be a more faithful rendition of the <code>ljb</code> algorithm (with no guarantees it's correct <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">control.bifunctor</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">impl</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>

<span class="kn">open</span> <span class="n">term</span>

<span class="kd">def</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">select</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">as</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">as</span><span class="o">)</span> <span class="o">::</span> <span class="n">list.map</span> <span class="o">(</span><span class="n">bifunctor.snd</span> <span class="o">(</span><span class="n">list.cons</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">select</span> <span class="n">as</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">[]</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">ljb</span> <span class="o">:</span> <span class="n">list</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">env</span> <span class="n">t</span><span class="bp">@</span><span class="o">(</span><span class="n">impl</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">t</span> <span class="bp">∈</span> <span class="n">env</span> <span class="k">then</span> <span class="n">tt</span> <span class="k">else</span> <span class="n">ljb</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">env</span><span class="o">)</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">env</span> <span class="n">t</span><span class="bp">@</span><span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">t</span> <span class="bp">∈</span> <span class="n">env</span> <span class="k">then</span> <span class="n">tt</span> <span class="k">else</span>
  <span class="k">let</span> <span class="n">imps</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="o">(</span><span class="n">impl</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">env2</span><span class="o">)</span> <span class="bp">←</span> <span class="n">select</span> <span class="n">env</span> <span class="bp">|</span> <span class="o">[],</span>
    <span class="k">match</span> <span class="n">a</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">impl</span> <span class="n">c</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span> <span class="n">guard</span> <span class="bp">$</span> <span class="n">ljb</span> <span class="o">(</span><span class="n">impl</span> <span class="n">d</span> <span class="n">b</span> <span class="o">::</span> <span class="n">env2</span><span class="o">)</span> <span class="n">a</span>
    <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">guard</span> <span class="bp">$</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">env2</span>
    <span class="kd">end</span><span class="o">,</span>
    <span class="n">return</span> <span class="o">(</span><span class="n">b</span> <span class="o">::</span> <span class="n">env2</span><span class="o">)</span>
  <span class="k">in</span> <span class="k">match</span> <span class="n">imps</span> <span class="k">with</span>
     <span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">ff</span>
     <span class="bp">|</span> <span class="o">(</span><span class="n">env2</span> <span class="o">::</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ljb</span> <span class="n">env2</span> <span class="n">t</span>
     <span class="kd">end</span>
</code></pre></div>



<a name="212984376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212984376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212984376">(Oct 11 2020 at 22:20)</a>:</h4>
<p>It has been a while since I've written the Haskell code, but I am pretty sure <code>!</code> in the Prolog only exists for performance reasons. But again, that was a while ago, so I may be miss remembering it.</p>



<a name="212984453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212984453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212984453">(Oct 11 2020 at 22:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Beautify.20code/near/212977279">said</a>:</p>
<blockquote>
<p>do you have an informal proof of termination?</p>
</blockquote>
<p>Only a half-baked one.</p>



<a name="212984522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212984522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212984522">(Oct 11 2020 at 22:25)</a>:</h4>
<p>I believe the amount of <code>impl</code>s in <code>env</code> + <code>t</code> can only get smaller or stay the same. I feel like working with <code>finset</code>s could make this clearer (or prove me wrong).</p>



<a name="212984524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212984524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212984524">(Oct 11 2020 at 22:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> <a href="#narrow/stream/113489-new-members/topic/Beautify.20code/near/212981679">said</a>:</p>
<blockquote>
<p>I've got an informal proof but I think to convince lean it might take quite a bit of refactoring of <code>ljt</code>, (for instance knowing that the <code>env</code> after the select is the original one minus an element), but I think the maths here is mostly straightforward (plus some standard results about well founded relations which I don't believe are in mathlib)</p>
</blockquote>
<p>I'd very interested in seeing it.</p>



<a name="212984526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212984526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212984526">(Oct 11 2020 at 22:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="298376">Pedro Minicz</span> <a href="#narrow/stream/113489-new-members/topic/Beautify.20code/near/212984524">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> <a href="#narrow/stream/113489-new-members/topic/Beautify.20code/near/212981679">said</a>:</p>
<blockquote>
<p>I've got an informal proof but I think to convince lean it might take quite a bit of refactoring of <code>ljt</code>, (for instance knowing that the <code>env</code> after the select is the original one minus an element), but I think the maths here is mostly straightforward (plus some standard results about well founded relations which I don't believe are in mathlib)</p>
</blockquote>
<p>I'd very interested in seeing it.</p>
</blockquote>
<p>Working on the lean version right now :)</p>



<a name="212984529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212984529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212984529">(Oct 11 2020 at 22:25)</a>:</h4>
<p>Is <code>finset</code> a monad? How hard would it be turn it into one?</p>



<a name="212984570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212984570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212984570">(Oct 11 2020 at 22:26)</a>:</h4>
<p>The cut operator is sometimes necessary. I don't think it's necessary here for correctness, but it seems like the run time would be horrendous without it.</p>



<a name="212984573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212984573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212984573">(Oct 11 2020 at 22:26)</a>:</h4>
<p>One of the saddest things about Haskell is that there is no (simple) <code>Set</code> monad.</p>



<a name="212984595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212984595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212984595">(Oct 11 2020 at 22:27)</a>:</h4>
<p>The only real change I made was to wrap up some of the <code>select</code> and sub-<code>ljb</code> code into its own list monad, then truncate it.</p>



<a name="212984645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212984645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212984645">(Oct 11 2020 at 22:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="298376">Pedro Minicz</span> <a href="#narrow/stream/113489-new-members/topic/Beautify.20code/near/212984529">said</a>:</p>
<blockquote>
<p>Is <code>finset</code> a monad? How hard would it be turn it into one?</p>
</blockquote>
<p>I think it already is one -- at least, there's <code>finset.bind</code> if I remember correctly.</p>



<a name="212984665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212984665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212984665">(Oct 11 2020 at 22:29)</a>:</h4>
<p>Actually, according to the docs there isn't a <code>monad</code> instance.  But <code>finset.bind</code> is indeed the right bind operator.</p>



<a name="212984722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212984722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212984722">(Oct 11 2020 at 22:30)</a>:</h4>
<p>Yes, there is one! Wow, I didn't find it while looking for it yesterday. There doesn't seem to be a monad instance (although, it may not be possible since <code>finset.bind : finset α → (α → finset β) → finset β</code> needs <code>[decidable_eq β]</code>).</p>



<a name="212984734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212984734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212984734">(Oct 11 2020 at 22:31)</a>:</h4>
<p>Maybe there is some hack-y way to get <code>do</code> notation...</p>



<a name="212985441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212985441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212985441">(Oct 11 2020 at 22:53)</a>:</h4>
<p>A termination proof can be found here: <a href="https://www.cs.cmu.edu/~fp/courses/atp/cmuonly/D92.pdf">https://www.cs.cmu.edu/~fp/courses/atp/cmuonly/D92.pdf</a> (also <a href="https://research-repository.st-andrews.ac.uk/bitstream/handle/10023/16793/Dyckhoff_2018_contraction_free_JSL_1680.pdf">https://research-repository.st-andrews.ac.uk/bitstream/handle/10023/16793/Dyckhoff_2018_contraction_free_JSL_1680.pdf</a>)</p>



<a name="212985555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212985555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212985555">(Oct 11 2020 at 22:56)</a>:</h4>
<p>alright I've got a working proof, minus the part which in that is referenced to [4], showing that the multiset ordering is wellfounded if the underlying partial order is</p>



<a name="212985624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212985624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212985624">(Oct 11 2020 at 22:58)</a>:</h4>
<p><a href="https://gist.github.com/b-mehta/ee89376db987b749bd5120a2180ce3df">https://gist.github.com/b-mehta/ee89376db987b749bd5120a2180ce3df</a></p>



<a name="212985627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212985627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212985627">(Oct 11 2020 at 22:58)</a>:</h4>
<p>it's pretty messy, I made a similar transformation to what Kyle did, but using Prop instead of bool</p>



<a name="212985633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212985633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212985633">(Oct 11 2020 at 22:58)</a>:</h4>
<p>I don't think this version will compute at all well, but it might give you a better idea of how to prove termination</p>



<a name="212985655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212985655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212985655">(Oct 11 2020 at 22:59)</a>:</h4>
<p>the two main points are to use the dershowitz-manna ordering, and that in the recursive steps you need to have access to the properties of the sub-formulae chosen (which <code>match</code> or <code>select</code> doesn't give you automatically)</p>



<a name="212998253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212998253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212998253">(Oct 12 2020 at 05:04)</a>:</h4>
<p>If you use <code>Prop</code>, it's pretty trivial to write this without a termination proof, since you can just use an inductive type</p>



<a name="212998255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212998255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212998255">(Oct 12 2020 at 05:04)</a>:</h4>
<p>it's probably clearer that way too</p>



<a name="212998277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212998277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212998277">(Oct 12 2020 at 05:05)</a>:</h4>
<p>This is a great example where it would be better to write the code first and the termination proof later</p>



<a name="212998331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212998331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212998331">(Oct 12 2020 at 05:06)</a>:</h4>
<p>it might be interesting to try applying that general recursion thing that Simon was working on (or using <code>roption</code> directly)</p>



<a name="212998995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212998995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212998995">(Oct 12 2020 at 05:22)</a>:</h4>
<p>yay:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">control.bifunctor</span> <span class="n">control.fix</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">impl</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>

<span class="kn">open</span> <span class="n">term</span>

<span class="kd">def</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">select</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">as</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">as</span><span class="o">)</span> <span class="o">::</span> <span class="n">list.map</span> <span class="o">(</span><span class="n">bifunctor.snd</span> <span class="o">(</span><span class="n">list.cons</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">select</span> <span class="n">as</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">[]</span>

<span class="kd">def</span> <span class="n">ljtF</span> <span class="o">(</span><span class="n">ljt</span> <span class="o">:</span> <span class="n">list</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">roption</span> <span class="o">(</span><span class="n">list</span> <span class="n">term</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">list</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">roption</span> <span class="o">(</span><span class="n">list</span> <span class="n">term</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">env</span> <span class="n">t</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">t</span> <span class="bp">∈</span> <span class="n">env</span> <span class="k">then</span> <span class="n">pure</span> <span class="o">[</span><span class="n">t</span><span class="o">]</span> <span class="k">else</span>
  <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">impl</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">ljt</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">env</span><span class="o">)</span> <span class="n">b</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">list.join</span> <span class="bp">&lt;$&gt;</span> <span class="o">(</span><span class="n">select</span> <span class="n">env</span><span class="o">)</span><span class="bp">.</span><span class="n">mmap</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">te</span><span class="o">,</span>
    <span class="k">match</span> <span class="n">te</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">impl</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="n">b</span><span class="o">,</span> <span class="n">env</span><span class="o">)</span> <span class="o">:=</span>
      <span class="k">if</span> <span class="n">var</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">env</span> <span class="k">then</span>
        <span class="n">ljt</span> <span class="o">(</span><span class="n">b</span> <span class="o">::</span> <span class="n">env</span><span class="o">)</span> <span class="n">t</span>
      <span class="k">else</span> <span class="n">pure</span> <span class="o">[]</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">impl</span> <span class="o">(</span><span class="n">impl</span> <span class="n">c</span> <span class="n">d</span><span class="o">)</span> <span class="n">b</span><span class="o">,</span> <span class="n">env</span><span class="o">)</span> <span class="o">:=</span>
      <span class="o">(</span><span class="bp">++</span><span class="o">)</span> <span class="bp">&lt;$&gt;</span> <span class="n">ljt</span> <span class="o">(</span><span class="n">impl</span> <span class="n">d</span> <span class="n">b</span> <span class="o">::</span> <span class="n">env</span><span class="o">)</span> <span class="o">(</span><span class="n">impl</span> <span class="n">c</span> <span class="n">d</span><span class="o">)</span>
           <span class="bp">&lt;*&gt;</span> <span class="n">ljt</span> <span class="o">(</span><span class="n">b</span> <span class="o">::</span> <span class="n">env</span><span class="o">)</span> <span class="n">t</span>
    <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">[]</span>
    <span class="kd">end</span><span class="o">)</span>
  <span class="kd">end</span>

<span class="kd">def</span> <span class="n">ljt</span> <span class="o">(</span><span class="n">env</span> <span class="o">:</span> <span class="n">list</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">term</span><span class="o">)</span> <span class="o">:</span> <span class="n">roption</span> <span class="o">(</span><span class="n">list</span> <span class="n">term</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">roption.fix</span> <span class="o">(</span><span class="n">list</span> <span class="n">term</span> <span class="bp">×</span> <span class="n">term</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">list</span> <span class="n">term</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">IH</span> <span class="o">⟨</span><span class="n">env</span><span class="o">,</span> <span class="n">t</span><span class="o">⟩,</span> <span class="n">ljtF</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">env</span> <span class="n">t</span><span class="o">,</span> <span class="n">IH</span> <span class="o">(</span><span class="n">env</span><span class="o">,</span> <span class="n">t</span><span class="o">))</span> <span class="n">env</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">env</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span>
</code></pre></div>



<a name="212998997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Beautify%20code/near/212998997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Beautify.20code.html#212998997">(Oct 12 2020 at 05:23)</a>:</h4>
<p>the monads really don't play well together though</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
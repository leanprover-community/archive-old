---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/type.20synonym.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20synonym.html">type synonym</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="247092154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20synonym/near/247092154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20synonym.html#247092154">(Jul 24 2021 at 20:41)</a>:</h4>
<p>I understand that when one wants to place two different structures of the same kind on the same type, and there is already one instance of the structure as a type class, then one (recommended?) way is to form a type synonym. Apparently one should be able to "copy" other relevant instances to the type synonym by <code>@derive</code>, but replace the instance that one wants to get rid of by something else. This sounds fine and well, but I had some issues with the syntax...</p>
<p>(Btw, sorry, I might have technicalities wrong above. Please point out mistakes you notice and I will correct to make this as generally useful to new members as possible.)</p>



<a name="247092159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20synonym/near/247092159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20synonym.html#247092159">(Jul 24 2021 at 20:41)</a>:</h4>
<p>Here is an example, in which I would like to introduce the weak topology on a normed space <code>E</code> --- instead of the default topology <code>instance</code> on <code>E</code>, which is the norm topology. My attempt below is to create a type synonym <code>weak E</code> (in fact <code>weak 𝕜 E</code> since I struggled with implicit arguments) which is just <code>E</code>, but will instead be equipped with the weak topology. I would also like <code>weak E</code> to inherit the same old <code>add_comm_group</code> and <code>module 𝕜</code> from <code>E</code> (it is only the topology I want to get rid of).</p>



<a name="247092165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20synonym/near/247092165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20synonym.html#247092165">(Jul 24 2021 at 20:41)</a>:</h4>
<p>This is an approximate <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> (the two questions are pretty much right at the start, the rest is included for context). As a summary, my two questions are:</p>
<ul>
<li>How to <code>derive</code> a <code>module 𝕜</code> structure on <code>weak 𝕜 E</code>?</li>
<li>How to get rid of using <code>@to_weak</code> with lots of <code>_</code>s?<ul>
<li>(The other direction, <code>to_ordinary</code>, seems to work just fine without the <code>@</code>!)</li>
</ul>
</li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">analysis.normed_space.dual</span>

<span class="kd">@[derive add_comm_group]</span> <span class="c1">-- Q : `@[derive [add_comm_group, module 𝕜]]` fails. How to state?</span>
<span class="kd">def</span> <span class="n">weak</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="n">E</span>

<span class="sd">/-- The canonical map `E → weak 𝕜 E`. -/</span>
<span class="kd">def</span> <span class="n">to_weak</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">weak</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="o">:=</span> <span class="n">id</span>

<span class="sd">/-- The canonical map `weak 𝕜 E → E`. -/</span>
<span class="kd">def</span> <span class="n">to_ordinary</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span> <span class="n">weak</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">E</span> <span class="o">:=</span> <span class="n">id</span>

<span class="kd">lemma</span> <span class="n">to_weak_injective</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">function.injective</span> <span class="o">(</span><span class="n">to_weak</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">weak</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">id</span>

<span class="kd">lemma</span> <span class="n">to_ordinary_injective</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">function.injective</span> <span class="o">(</span><span class="n">to_ordinary</span> <span class="o">:</span> <span class="n">weak</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">id</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">to_weak_to_ordinary</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">weak</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">to_weak</span> <span class="o">(</span><span class="n">to_ordinary</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">to_ordinary_to_weak</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">to_ordinary</span> <span class="o">(</span><span class="bp">@</span><span class="n">to_weak</span> <span class="bp">𝕜</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>
  <span class="c1">-- Q : Without the `@`-notation and lots of `_`s, the statement doesn't parse. How to fix?</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">to_weak_inj_iff</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">to_weak</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">to_weak</span> <span class="bp">𝕜</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">y</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">to_ordinary_inj_iff</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">weak</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">to_ordinary</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">to_ordinary</span> <span class="n">y</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">irreducible</span><span class="o">]</span> <span class="n">weak</span>

<span class="sd">/-- The type-level equivalence between `E` and `weak 𝕜 E`. -/</span>
<span class="kd">def</span> <span class="n">equiv_to_weak</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">≃</span> <span class="n">weak</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">to_weak</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">to_ordinary</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="n">to_ordinary_to_weak</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="n">to_weak_to_ordinary</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">equiv_to_weak_apply</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">E</span><span class="o">):</span>
  <span class="n">equiv_to_weak</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">to_weak</span> <span class="bp">𝕜</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">equiv_to_weak_symm_apply</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">weak</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">equiv_to_weak.symm</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">to_ordinary</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">unop_eq_iff_eq_op</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">weak</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">to_weak</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">to_ordinary</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">equiv_to_weak.apply_eq_iff_eq_symm_apply</span>

<span class="kd">lemma</span> <span class="n">op_eq_iff_eq_unop</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">weak</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">to_ordinary</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">to_weak</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">equiv_to_weak.symm.apply_eq_iff_eq_symm_apply</span>

<span class="kd">instance</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">weak</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span>
  <span class="o">[</span><span class="n">inhabited</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">weak</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">to_weak</span> <span class="o">(</span><span class="n">default</span> <span class="n">_</span><span class="o">)⟩</span>

<span class="kd">instance</span> <span class="n">weak.topology</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">weak</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">topological_space.induced</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">weak</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">normed_space.dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'</span> <span class="o">(</span><span class="n">to_ordinary</span> <span class="n">x</span><span class="o">)))</span> <span class="k">Pi</span><span class="bp">.</span><span class="n">topological_space</span>

<span class="kd">lemma</span> <span class="n">weak.test_continuous'</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">continuous</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">weak</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">normed_space.dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'</span> <span class="o">(</span><span class="n">to_ordinary</span> <span class="n">x</span><span class="o">)))</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">continuous_induced_dom</span> <span class="o">(</span><span class="n">weak</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">normed_space.dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">),</span> <span class="bp">𝕜</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">weak</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">normed_space.dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">),</span> <span class="n">x'</span> <span class="o">(</span><span class="n">to_ordinary</span> <span class="n">x</span><span class="o">)))</span> <span class="k">Pi</span><span class="bp">.</span><span class="n">topological_space</span>

<span class="kd">lemma</span> <span class="n">weak.test_continuous</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">normed_space.dual</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">continuous</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">weak</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">),</span> <span class="o">(</span><span class="n">x'</span> <span class="o">(</span><span class="n">to_ordinary</span> <span class="n">x</span><span class="o">)))</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">continuous_pi_iff.mp</span> <span class="o">(</span><span class="n">weak.test_continuous'</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">))</span> <span class="n">x'</span>

<span class="kd">theorem</span> <span class="n">to_weak_continuous</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
  <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">continuous</span> <span class="o">(</span><span class="bp">@</span><span class="n">to_weak</span> <span class="bp">𝕜</span> <span class="n">_</span> <span class="n">E</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">continuous_induced_rng</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">continuous_pi_iff.mpr</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">x'</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">continuous_linear_map.continuous</span> <span class="n">x'</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="247092361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20synonym/near/247092361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20synonym.html#247092361">(Jul 24 2021 at 20:47)</a>:</h4>
<p>Btw, the example is pretty much copy paste from <a href="https://leanprover-community.github.io/mathlib_docs/find/opposite">docs#opposite</a>, which was recommended as a good model of type synonyms in <a href="#narrow/stream/113489-new-members/topic/compare.20different.20actions/near/241678043">this conversation</a>.</p>



<a name="247092417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20synonym/near/247092417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20synonym.html#247092417">(Jul 24 2021 at 20:48)</a>:</h4>
<p>And I do realize that it should be possible to clean up by introducing <code>variables</code>, but the struggle with arguments was a part of my question in any case.</p>



<a name="247092622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20synonym/near/247092622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20synonym.html#247092622">(Jul 24 2021 at 20:54)</a>:</h4>
<p>Older viewers here will remember one answer to the first question -- the thing we used to do before <code>@derive</code> was a thing:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">module</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="n">weak</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">dunfold</span> <span class="n">weak</span><span class="o">,</span> <span class="n">apply_instance</span> <span class="o">}</span>
</code></pre></div>



<a name="247092629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20synonym/near/247092629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20synonym.html#247092629">(Jul 24 2021 at 20:54)</a>:</h4>
<p>I think <code>variables</code> does solve your problem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">analysis.normed_space.dual</span>

<span class="kd">variables</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>

<span class="kd">@[derive [add_comm_group, module 𝕜]</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">weak</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="n">E</span>
</code></pre></div>
<p>works fine for me. Otherwise, you can derive it by hand, as in the file <code>formal_multilinear_series</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">section</span> <span class="n">module</span>
<span class="c">/-</span><span class="cm"> `derive` is not able to find the module structure, probably because Lean is confused by the</span>
<span class="cm">dependent types. We register it explicitly. -/</span>
<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="n">reducible</span><span class="o">]</span> <span class="n">formal_multilinear_series</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">module</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="n">formal_multilinear_series</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">letI</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">module</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="n">continuous_multilinear_map</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">E</span><span class="o">)</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
    <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="kd">by</span> <span class="n">apply_instance</span><span class="o">,</span>
  <span class="n">apply_instance</span>
<span class="kd">end</span>
</code></pre></div>



<a name="247092652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20synonym/near/247092652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20synonym.html#247092652">(Jul 24 2021 at 20:55)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> , I think <code>dunfold</code> is bad as it introduces an <code>id</code> somewhere. Opening a section and using <code>local attribute [reducible]</code> avoids this.</p>



<a name="247092718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20synonym/near/247092718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20synonym.html#247092718">(Jul 24 2021 at 20:56)</a>:</h4>
<p>so those of us paying attention at the time clearly have an understanding of why the old method was removed and <code>derive</code> was introduced :-)</p>



<a name="247092728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20synonym/near/247092728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20synonym.html#247092728">(Jul 24 2021 at 20:57)</a>:</h4>
<p>Thank you Kevin and Sebastien for super fast replies! I'll study them. <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="247092732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20synonym/near/247092732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20synonym.html#247092732">(Jul 24 2021 at 20:57)</a>:</h4>
<p>Study mine and then forget it, apparently :-)</p>



<a name="247097263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/type%20synonym/near/247097263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/type.20synonym.html#247097263">(Jul 24 2021 at 22:45)</a>:</h4>
<p>If you use <code>dunfold weak, show_term { apply_instance }</code> then you can also replace the entire tactic with the result it prints out to avoid the id problem</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
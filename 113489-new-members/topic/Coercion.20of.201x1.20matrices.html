---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html">Coercion of 1x1 matrices</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="201063517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201063517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201063517">(Jun 16 2020 at 19:35)</a>:</h4>
<p>I'm trying to figure out how <code>has_lift</code> and <code>coe_*</code> work. Right now I have the following definitions. </p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">matrix</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">n</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">n</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">R</span><span class="o">]</span>

<span class="n">noncomputable</span> <span class="kn">instance</span> <span class="n">matrix_lift</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_lift</span> <span class="o">(</span><span class="n">matrix</span> <span class="n">n</span> <span class="n">n</span> <span class="n">R</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_eq_one</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">singleton_iff_unique_mem</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">choose</span> <span class="n">b</span> <span class="n">hb</span> <span class="kn">using</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="bp">⟨λ</span> <span class="n">M</span><span class="o">,</span> <span class="n">M</span> <span class="n">b</span> <span class="n">b</span><span class="bp">⟩</span>
<span class="kn">end</span>

<span class="n">noncomputable</span> <span class="kn">instance</span> <span class="n">matrix_lift_t</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_lift_t</span> <span class="o">(</span><span class="n">matrix</span> <span class="n">n</span> <span class="n">n</span> <span class="n">R</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_eq_one</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">singleton_iff_unique_mem</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">choose</span> <span class="n">b</span> <span class="n">hb</span> <span class="kn">using</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="bp">⟨λ</span> <span class="n">M</span><span class="o">,</span> <span class="n">M</span> <span class="n">b</span> <span class="n">b</span><span class="bp">⟩</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">coe_singleton</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">n</span> <span class="n">n</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">h</span> <span class="o">:</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">n</span><span class="o">}</span>
                      <span class="o">[</span><span class="n">has_lift_t</span> <span class="o">(</span><span class="n">matrix</span> <span class="n">n</span> <span class="n">n</span> <span class="n">R</span><span class="o">)</span> <span class="n">R</span><span class="o">]:</span>
                      <span class="o">(</span><span class="err">↑</span><span class="n">M</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="n">M</span> <span class="n">a</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>


<p>I would think <code>rfl</code>  would work, but there is a type mismatch. It also seems weird to me to be supplying a proof in the instance definition. Another issue is that I think using <code>[has_lift_t ...]</code> is non idiomatic, from looking at mathlib source.</p>



<a name="201064188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201064188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201064188">(Jun 16 2020 at 19:41)</a>:</h4>
<p>is the problem that your instances are noncomputable but your theorem is not?</p>



<a name="201064237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201064237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201064237">(Jun 16 2020 at 19:42)</a>:</h4>
<p>(I usually write <code>noncomputable theory</code> at the top of my file to avoid thinking about this)</p>



<a name="201064274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201064274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201064274">(Jun 16 2020 at 19:42)</a>:</h4>
<p>I think that in practice it may be more useful to assume <code>[unique n]</code> instead of <code>fintype.card n = 1</code>.</p>



<a name="201064332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201064332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201064332">(Jun 16 2020 at 19:42)</a>:</h4>
<p>Lots of problems here, but ultimately the result can never be true by <code>rfl</code> because it would mean that any two elements of <code>n</code> are definitionally equal.</p>



<a name="201064430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201064430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201064430">(Jun 16 2020 at 19:43)</a>:</h4>
<p>You are taking a very mathematician-like attitude here: there's just one element anyways, so let's pick it.</p>



<a name="201064628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201064628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201064628">(Jun 16 2020 at 19:45)</a>:</h4>
<p>This works, sort of, but you will have to justify yourself to Lean later.</p>



<a name="201070799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201070799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201070799">(Jun 16 2020 at 20:37)</a>:</h4>
<p>Thanks for the insight. Here's what I have currently. Seeing an error I haven't seen before, with "goals accomplished" yet red squiggly.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">matrix</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">n</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">n</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>

<span class="kn">instance</span> <span class="n">matrix_coe</span> <span class="o">[</span><span class="n">unique</span> <span class="n">n</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">matrix</span> <span class="n">n</span> <span class="n">n</span> <span class="n">R</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">default</span> <span class="n">n</span> <span class="k">in</span> <span class="bp">⟨λ</span> <span class="n">M</span><span class="o">,</span> <span class="n">M</span> <span class="n">a</span> <span class="n">a</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">coe_singleton</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">n</span> <span class="n">n</span> <span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">unique</span> <span class="n">n</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span>
                      <span class="o">(</span><span class="err">↑</span><span class="n">M</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="n">M</span> <span class="n">a</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">unique</span><span class="bp">.</span><span class="n">uniq</span> <span class="bp">_</span> <span class="n">a</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="c1">-- having a theorem that distributes the coe like `↑(A * B) = ↑A * ↑B`</span>
<span class="c1">-- is probably useful for what I&#39;m trying to prove</span>
<span class="c1">-- which is the commutativity of 1-dim matrices</span>

<span class="c1">-- this statement does not work because I don&#39;t have ↑ in the statement</span>
<span class="c1">-- so I can&#39;t use `rw coe_singleton` later</span>
<span class="c1">-- example (A : matrix (fin 1) (fin 1) ℝ) (B : matrix (fin 1) (fin 1) ℝ) :</span>
<span class="c1">--         A * B = B * A := sorry</span>

<span class="c1">-- this errors at the end with</span>
<span class="c1">--   tactic failed, result contains meta-variables</span>
<span class="c1">--   state:</span>
<span class="c1">--   no goals</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="err">↑</span><span class="n">A</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">B</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">B</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">A</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">unique</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span><span class="o">,</span>
  <span class="n">haveI</span><span class="o">:</span> <span class="n">has_lift_t</span> <span class="o">(</span><span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">coe_singleton</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">coe_singleton</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">default</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)),</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">default</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)),</span> <span class="c1">-- cursor on comma says &quot;goals accomplished&quot;</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201070961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201070961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201070961">(Jun 16 2020 at 20:39)</a>:</h4>
<p>Congratulations, you just got the "unproved invisible metavariable goal" achievement</p>



<a name="201070989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201070989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201070989">(Jun 16 2020 at 20:39)</a>:</h4>
<p>There's some tactic which will make the invisible goal appear, I always forget what it is.</p>



<a name="201071727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201071727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201071727">(Jun 16 2020 at 20:46)</a>:</h4>
<p><code>recover</code></p>



<a name="201071823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201071823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201071823">(Jun 16 2020 at 20:47)</a>:</h4>
<p><code>  recover, repeat {apply_instance},</code> finishes things properly. I don't really understand why this happens.</p>



<a name="201071984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201071984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201071984">(Jun 16 2020 at 20:48)</a>:</h4>
<p>I don't understand what the two <code>haveI</code>s could accomplish.</p>



<a name="201072091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201072091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201072091">(Jun 16 2020 at 20:49)</a>:</h4>
<p>Also, I'm not sure if you are proving what you want to prove.</p>



<a name="201072178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201072178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201072178">(Jun 16 2020 at 20:50)</a>:</h4>
<p>You could just apply <code>mul_comm</code> and be done.</p>



<a name="201072183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201072183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201072183">(Jun 16 2020 at 20:50)</a>:</h4>
<p>If <code>apply_instance</code> works then the thing you proved was already known to type class inference so you didn't need to add it with <code>haveI</code> (and probably you should have used <code>letI</code>?)</p>



<a name="201072235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201072235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201072235">(Jun 16 2020 at 20:50)</a>:</h4>
<p>The <code>haveI</code>'s were in fact the problem</p>



<a name="201072305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201072305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201072305">(Jun 16 2020 at 20:51)</a>:</h4>
<p><del><code>matrix X X R</code> might not be known to be a semigroup.</del>(it is)</p>



<a name="201072330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201072330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201072330">(Jun 16 2020 at 20:51)</a>:</h4>
<p>actually I guess I'm also not 100% sure what type <code>↑A</code> is--if you have the <code>has_coe</code> instance anyways, better to write <code>(A : ℝ)</code>.</p>



<a name="201072561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201072561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201072561">(Jun 16 2020 at 20:53)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">A</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">mul_comm</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201072625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201072625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201072625">(Jun 16 2020 at 20:54)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">mul_comm</span> <span class="bp">_</span> <span class="bp">_</span>
</code></pre></div>



<a name="201072647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201072647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201072647">(Jun 16 2020 at 20:54)</a>:</h4>
<p>Lean doesn't have a clue where you're coercing to, I think</p>



<a name="201072670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201072670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201072670">(Jun 16 2020 at 20:54)</a>:</h4>
<p>If you tell it explicitly, as Reid suggests, it's much happier</p>



<a name="201072768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201072768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201072768">(Jun 16 2020 at 20:55)</a>:</h4>
<p>and <code>example</code> is like <code>def</code> in that it uses the body of the definition to elaborate the stated type of the example, so maybe that is where your metavariable(s) came from?</p>



<a name="201072872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201072872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201072872">(Jun 16 2020 at 20:56)</a>:</h4>
<p>anyways, all of this is just dancing around the actual work, which is proving that multiplication of 1x1 matrices corresponds to multiplication in R</p>



<a name="201074116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201074116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201074116">(Jun 16 2020 at 21:06)</a>:</h4>
<p>Totally clear now:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">matrix</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">n</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">n</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>

<span class="kn">instance</span> <span class="n">matrix_coe</span> <span class="o">[</span><span class="n">unique</span> <span class="n">n</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">matrix</span> <span class="n">n</span> <span class="n">n</span> <span class="n">R</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">default</span> <span class="n">n</span> <span class="k">in</span> <span class="bp">⟨λ</span> <span class="n">M</span><span class="o">,</span> <span class="n">M</span> <span class="n">a</span> <span class="n">a</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">coe_singleton</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">n</span> <span class="n">n</span> <span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">unique</span> <span class="n">n</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span>
                      <span class="o">(</span><span class="err">↑</span><span class="n">M</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="n">M</span> <span class="n">a</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">unique</span><span class="bp">.</span><span class="n">uniq</span> <span class="bp">_</span> <span class="n">a</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
                   <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">A</span> <span class="o">:=</span>
<span class="n">mul_comm</span> <span class="bp">_</span> <span class="bp">_</span>
</code></pre></div>


<p>But thinking about how to formalize the proof that n x n matrices commute over the entirety of the space, is valid only for n &lt;= 1, one would need the theory of eigenvectors, which mathlib does not yet have. Correct?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
        <span class="n">n</span> <span class="bp">&lt;=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="201076788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201076788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201076788">(Jun 16 2020 at 21:31)</a>:</h4>
<p>If you want to show there are non-commuting matrices for n &gt;= 2, why not just look at an explicit example? Say</p>
<div class="codehilite"><pre><span></span><code><span class="mi">10</span> <span class="bp">*</span> <span class="mi">01</span>
<span class="mi">00</span>   <span class="mi">00</span>
</code></pre></div>



<a name="201078818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201078818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201078818">(Jun 16 2020 at 21:51)</a>:</h4>
<p>Sure, and show by induction ... . For a proof that did not rely on calculation, I was thinking about the one at <code>https://math.stackexchange.com/a/27832</code>, and then show that all matrices are equal to <code>c * I</code> for some scalar <code>c</code> only for <code>n = 0 \or n = 1</code>.</p>



<a name="201080439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201080439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201080439">(Jun 16 2020 at 22:10)</a>:</h4>
<p>You don't need any induction here. David's matrices are n x n</p>



<a name="201080489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201080489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201080489">(Jun 16 2020 at 22:11)</a>:</h4>
<p>It's just some "if first variable is 0 and second is 1 then 1 else 0" matrix</p>



<a name="201082692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201082692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201082692">(Jun 16 2020 at 22:37)</a>:</h4>
<p>I think you still need induction to show that <code>fin n</code> for <code>n &gt;= 2</code> has <code>has_zero</code> and <code>has_one</code> instances, so that those matrices can be defined via an <code>ite</code> call.</p>



<a name="201083908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201083908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201083908">(Jun 16 2020 at 22:53)</a>:</h4>
<p>This is not induction. You need to prove 0 &lt; n and 1 &lt; n but both of these follow directly from 2&lt;= n</p>



<a name="201083935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201083935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201083935">(Jun 16 2020 at 22:53)</a>:</h4>
<p>The ite doesn't care if its clause is never satisfied</p>



<a name="201084180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201084180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201084180">(Jun 16 2020 at 22:56)</a>:</h4>
<p>The time when you care is in the proof</p>



<a name="201115802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201115802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201115802">(Jun 17 2020 at 08:56)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> sorry, I had to sleep :-)</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">matrix</span><span class="bp">.</span><span class="kn">notation</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">nonzero</span> <span class="n">R</span><span class="o">]</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">))</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">))</span> <span class="n">R</span><span class="o">),</span>
          <span class="n">S</span> <span class="bp">*</span> <span class="n">T</span> <span class="bp">≠</span> <span class="n">T</span> <span class="bp">*</span> <span class="n">S</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">use</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="k">if</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">),</span>
  <span class="n">use</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="k">if</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">),</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">replace</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">congr_fun</span> <span class="o">(</span><span class="n">congr_fun</span> <span class="n">h</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">matrix</span><span class="bp">.</span><span class="n">mul</span><span class="o">,</span> <span class="n">matrix</span><span class="bp">.</span><span class="n">dot_product</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="bp">@</span><span class="n">zero_ne_one</span> <span class="n">R</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201115950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201115950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201115950">(Jun 17 2020 at 08:58)</a>:</h4>
<p>Poking around in the library a bit for the <code>has_one</code> issue revealed that the trick is to work with <code>fin (n+2)</code>.</p>



<a name="201116684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20of%201x1%20matrices/near/201116684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20of.201x1.20matrices.html#201116684">(Jun 17 2020 at 09:06)</a>:</h4>
<p>I'm a bit unhappy with that nonterminal <code>simp</code>: I'm slightly less unhappy, but still unhappy, with</p>
<div class="codehilite"><pre><span></span><code><span class="k">begin</span>
  <span class="n">use</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="k">if</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">),</span>
  <span class="n">use</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="k">if</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">),</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">replace</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">congr_fun</span> <span class="o">(</span><span class="n">congr_fun</span> <span class="n">h</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">ite</span> <span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">matrix</span><span class="bp">.</span><span class="n">mul</span><span class="o">,</span> <span class="n">matrix</span><span class="bp">.</span><span class="n">dot_product</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="bp">@</span><span class="n">zero_ne_one</span> <span class="n">R</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">h2</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
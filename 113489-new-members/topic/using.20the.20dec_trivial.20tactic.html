---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html">using the dec_trivial tactic</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="318391111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318391111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Sutherland <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318391111">(Dec 29 2022 at 10:33)</a>:</h4>
<p>I have an instanced of <code>decidable</code> for a given <code>Prop</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">has_no_rational_root_dec</span> <span class="o">(</span><span class="n">n</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">q</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">,</span> <span class="n">q</span><span class="bp">^</span><span class="n">e</span> <span class="bp">≠</span> <span class="bp">↑</span><span class="n">n</span><span class="o">)</span>
</code></pre></div>
<p>From <a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#decidable-propositions">here</a>,  I thought that I would then simply be able to do:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">q</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">,</span> <span class="n">q</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">≠</span> <span class="bp">↑</span><span class="mi">2</span> <span class="o">:=</span>  <span class="n">dec_trivial</span>
</code></pre></div>
<p>to show that the square root of 2 is irrational (the appropriate infered typeclass is <code>has_no_rational_root_dec 2 2</code>).  However, I get the following error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">exact</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">type</span> <span class="n">mismatch</span><span class="o">,</span> <span class="n">given</span> <span class="n">expression</span> <span class="n">has</span> <span class="n">type</span>
  <span class="n">true</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">as_true</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">),</span> <span class="n">q</span> <span class="bp">^</span> <span class="mi">2</span> <span class="bp">≠</span> <span class="bp">↑</span><span class="mi">2</span><span class="o">)</span>
<span class="n">state</span><span class="o">:</span>
<span class="bp">⊢</span> <span class="n">as_true</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">),</span> <span class="n">q</span> <span class="bp">^</span> <span class="mi">2</span> <span class="bp">≠</span> <span class="bp">↑</span><span class="mi">2</span><span class="o">)</span>
</code></pre></div>
<p>Can anyone advise on what I'm doing wrong? <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="318391561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318391561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318391561">(Dec 29 2022 at 10:36)</a>:</h4>
<p>Does your <code>decidable</code> instance use axioms? If you use LEM, for instance, this clearly can't work.</p>



<a name="318391597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318391597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318391597">(Dec 29 2022 at 10:36)</a>:</h4>
<p>Specifically, <code>has_no_rational_root_dec 2 2</code> needs to reduce to a constructor application</p>



<a name="318391666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318391666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318391666">(Dec 29 2022 at 10:37)</a>:</h4>
<p>A common mistake is not using <a href="https://leanprover-community.github.io/mathlib_docs/find/decidable_of_iff">docs#decidable_of_iff</a></p>



<a name="318399316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318399316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Sutherland <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318399316">(Dec 29 2022 at 11:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Thank you for your advice!</p>
<p>I have now eliminated any used of the <code>rw</code> tactic in all of the relevant <code>decidable</code> instances as well as anything that appears to be non-constructive. In particular, I had a use of <code>not_not.symm</code>, which I have now replaced with the use of <code>decidable.not_not</code>. </p>
<p>The relevant <code>decidable</code> instances are now as follows:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">neg_dec_of_dec</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">inst</span> <span class="o">:</span> <span class="n">decidable</span> <span class="n">p</span><span class="o">),</span> <span class="n">decidable</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">p</span> <span class="n">inst</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">@</span><span class="n">decidable.not_not</span> <span class="n">p</span> <span class="n">inst</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">inst</span> <span class="k">with</span> <span class="n">h'</span> <span class="n">h'</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">exact</span> <span class="n">is_true</span> <span class="n">h'</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">apply</span> <span class="n">is_false</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">h</span> <span class="n">h'</span><span class="o">,</span>
    <span class="o">},</span>
  <span class="kd">end</span>

<span class="kd">instance</span> <span class="n">is_perfect_pow_dec</span> <span class="o">(</span><span class="n">n</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">is_perfect_pow</span> <span class="n">n</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">decidable_of_iff</span> <span class="n">_</span> <span class="o">(</span><span class="n">iff.symm</span> <span class="bp">$</span> <span class="n">is_pp_equiv_lemma</span> <span class="n">n</span> <span class="n">e</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">has_no_rational_root_dec</span> <span class="o">(</span><span class="n">n</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">q</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">,</span> <span class="n">q</span><span class="bp">^</span><span class="n">e</span> <span class="bp">≠</span> <span class="bp">↑</span><span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="k">have</span> <span class="n">h₁</span><span class="o">:</span> <span class="o">(</span><span class="bp">¬∃</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">m</span> <span class="bp">^</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">¬∃</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="bp">^</span><span class="n">e</span><span class="o">),</span>
    <span class="o">{</span>
      <span class="n">split</span><span class="o">,</span>
      <span class="n">repeat</span> <span class="o">{</span>
        <span class="n">rintros</span> <span class="n">h</span> <span class="o">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">h'</span><span class="o">⟩,</span>
        <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">use</span> <span class="n">m</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">eq.symm</span> <span class="n">h'</span><span class="o">,</span>
      <span class="o">},</span>
    <span class="o">},</span>
    <span class="n">apply</span> <span class="bp">@</span><span class="n">decidable_of_iff</span> <span class="n">_</span> <span class="n">_</span>
      <span class="o">(</span><span class="n">rootn_not_pn_irr</span> <span class="n">e</span> <span class="n">n</span><span class="o">)</span>
        <span class="o">(</span>
          <span class="bp">@</span><span class="n">decidable_of_iff</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h₁</span>
            <span class="o">(</span>
              <span class="n">neg_dec_of_dec</span> <span class="n">_</span> <span class="o">(</span><span class="n">is_perfect_pow_dec</span> <span class="n">n</span> <span class="n">e</span><span class="o">)</span>
            <span class="o">)</span>
        <span class="o">),</span>
  <span class="kd">end</span>
</code></pre></div>
<p>where in a particular:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">rootn_not_pn_irr</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">e</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
  <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="bp">^</span><span class="n">e</span><span class="o">)</span> <span class="bp">↔</span>
    <span class="bp">∀</span> <span class="n">q</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">,</span> <span class="n">q</span><span class="bp">^</span><span class="n">e</span> <span class="bp">≠</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>
<p>and </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_pp_equiv_lemma</span> <span class="o">(</span><span class="n">n</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_perfect_pow</span> <span class="n">n</span> <span class="n">e</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">floor_root</span> <span class="n">e</span> <span class="n">n</span><span class="o">)</span><span class="bp">^</span><span class="n">e</span> <span class="bp">=</span> <span class="n">n</span>
</code></pre></div>
<p>However, despite these changes, the problem still persists...</p>



<a name="318399594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318399594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318399594">(Dec 29 2022 at 11:28)</a>:</h4>
<p>And <code>floor_root</code>?</p>



<a name="318399815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318399815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Sutherland <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318399815">(Dec 29 2022 at 11:30)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Yes sorry, the type of <code>floor_root</code> is as follows:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">floor_root</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
</code></pre></div>



<a name="318399840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318399840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318399840">(Dec 29 2022 at 11:30)</a>:</h4>
<p>It's okay to use axioms (like <code>propext</code>) inside the proof argument of <code>decidable_of_iff</code>--it's just the data part that needs to be able to reduce</p>



<a name="318399899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318399899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318399899">(Dec 29 2022 at 11:30)</a>:</h4>
<p>Yes and does it reduce (e.g. <code>#reduce floor_root 2 2</code>)?</p>



<a name="318400899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318400899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Sutherland <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318400899">(Dec 29 2022 at 11:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>  It appears that lean diverges when I run either of:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#reduce</span> <span class="n">floor_root</span> <span class="mi">2</span> <span class="mi">2</span>

<span class="k">#reduce</span> <span class="n">has_no_rational_root_dec</span> <span class="mi">2</span> <span class="mi">2</span>
</code></pre></div>
<p>However if I run:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">floor_root</span> <span class="mi">2</span> <span class="mi">2</span>

<span class="k">#eval</span> <span class="n">has_no_rational_root_dec</span> <span class="mi">2</span> <span class="mi">2</span>
</code></pre></div>
<p>I get:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">1</span>
</code></pre></div>
<p>and</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">tt</span>
</code></pre></div>
<p>respectively, as expected.</p>



<a name="318401121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318401121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Sutherland <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318401121">(Dec 29 2022 at 11:39)</a>:</h4>
<p>and furthermore, if I run:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">has_no_rational_root_dec</span> <span class="mi">4</span> <span class="mi">2</span>
</code></pre></div>
<p>I get <code>ff</code>. It appears to be working as expected.</p>



<a name="318401293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318401293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318401293">(Dec 29 2022 at 11:40)</a>:</h4>
<p>Yeah <code>#eval</code> is more powerful.</p>



<a name="318401342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318401342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318401342">(Dec 29 2022 at 11:40)</a>:</h4>
<p>Can you give a MWE containing <code>floor_root</code>? (it doesn't seem to exist in mathlib)</p>



<a name="318401802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318401802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Sutherland <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318401802">(Dec 29 2022 at 11:44)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Of course, thanks for helping!</p>
<p><code>floor_root</code>'s definition is a bit convoluted:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">floor_root_helper</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">m</span> <span class="bp">^</span> <span class="n">e</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">m</span> <span class="n">h'</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">h₁</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">^</span> <span class="n">e</span><span class="o">)</span>
  <span class="k">then</span> <span class="n">m</span>
  <span class="k">else</span>
    <span class="k">have</span> <span class="n">n</span> <span class="bp">-</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">^</span> <span class="n">e</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">m</span> <span class="bp">^</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">floor_root_helper_termination_lemma</span> <span class="n">e</span> <span class="n">n</span> <span class="n">m</span> <span class="n">h</span> <span class="o">(</span><span class="kd">by</span> <span class="n">linarith</span><span class="o">),</span>
    <span class="n">floor_root_helper</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">linarith</span><span class="o">)</span>
<span class="n">using_well_founded</span> <span class="o">{</span> <span class="n">rel_tac</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">measure_wf</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">m</span> <span class="bp">^</span> <span class="n">e</span><span class="o">⟩]</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">floor_root</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">e</span> <span class="n">n</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">≥</span> <span class="mi">1</span>
  <span class="k">then</span> <span class="n">floor_root_helper</span> <span class="n">e</span> <span class="n">h</span> <span class="n">n</span> <span class="mi">0</span>
    <span class="kd">begin</span>
      <span class="k">have</span> <span class="n">h₁</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">^</span> <span class="n">e</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">e</span><span class="o">,</span>
      <span class="o">{</span>
        <span class="n">exfalso</span><span class="o">,</span>
        <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="o">{</span>
        <span class="n">cases</span> <span class="n">e</span><span class="o">,</span>
        <span class="o">{</span>
          <span class="n">simp</span><span class="o">,</span>
        <span class="o">},</span>
        <span class="o">{</span>
          <span class="n">rw</span> <span class="n">pow_succ</span><span class="o">,</span>
          <span class="n">simp</span><span class="o">,</span>
        <span class="o">},</span>
      <span class="o">},</span>
      <span class="n">rw</span> <span class="n">h₁</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">zero_le</span> <span class="n">_</span><span class="o">,</span>
    <span class="kd">end</span>
  <span class="k">else</span> <span class="mi">1</span>
</code></pre></div>
<p>where in particular:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">floor_root_helper_termination_lemma</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">e</span> <span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">e</span> <span class="bp">≥</span> <span class="mi">1</span> <span class="bp">→</span>  <span class="n">n</span> <span class="bp">≥</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">^</span> <span class="n">e</span> <span class="bp">→</span>
    <span class="n">n</span> <span class="bp">-</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">^</span> <span class="n">e</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">m</span> <span class="bp">^</span> <span class="n">e</span>
</code></pre></div>



<a name="318401886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318401886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318401886">(Dec 29 2022 at 11:45)</a>:</h4>
<p>(Results provided by <code>#eval</code> aren't certified by the kernel)</p>



<a name="318401946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318401946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318401946">(Dec 29 2022 at 11:45)</a>:</h4>
<p>I think things defined by well-founded recursion just don't reduce</p>



<a name="318402583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318402583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Sutherland <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318402583">(Dec 29 2022 at 11:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I see, which I guess is probably helping it be more permissive here.</p>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> I see, so the only solution here would be to find some definition of <code>floor_root</code> that works purely by structural induction? Out of curiosity, do you know why this is the case? It seems somehow surprising as the proof of well-foundedness is not required to compute the result of the function.</p>



<a name="318402692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318402692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318402692">(Dec 29 2022 at 11:50)</a>:</h4>
<p>It is required though, because the definition is really by induction on that proof</p>



<a name="318402715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318402715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318402715">(Dec 29 2022 at 11:50)</a>:</h4>
<p>Or rather, it is required for the term to reduce</p>



<a name="318403347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318403347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318403347">(Dec 29 2022 at 11:54)</a>:</h4>
<p>Simpler <code>floor_root</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">floor_root'</span> <span class="o">(</span><span class="n">e</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">k</span> <span class="bp">^</span> <span class="n">e</span> <span class="bp">≤</span> <span class="n">n</span> <span class="k">then</span> <span class="n">k</span> <span class="k">else</span> <span class="n">floor_root'</span> <span class="n">k</span>

<span class="kd">def</span> <span class="n">floor_root</span> <span class="o">(</span><span class="n">e</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">floor_root'</span> <span class="n">e</span> <span class="n">n</span> <span class="n">n</span>
</code></pre></div>



<a name="318404098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318404098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Sutherland <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318404098">(Dec 29 2022 at 11:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> I think I'm missing something here, my understanding is that the proofs of well-foundedness here are only needed to guarantee that the reduction will converge, other than this, due to <code>Prop</code> erasure, they have no run-time existence? I'm not so familar with the exact difference between <code>#eval</code> and <code>#reduce</code> in this context.</p>
<p><span class="user-mention" data-user-id="456794">@Patrick Johnson</span> Thank you very much, with this simpler definition of <code>floor_root</code> using structural induction, the <code>dec_trivial</code> tactic now works! <span aria-label="tada" class="emoji emoji-1f389" role="img" title="tada">:tada:</span></p>



<a name="318404784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318404784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318404784">(Dec 29 2022 at 12:03)</a>:</h4>
<p><code>dec_trivial</code> isn't a tactic</p>



<a name="318404908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318404908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Sutherland <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318404908">(Dec 29 2022 at 12:04)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Yup, my bad! <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="318404995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318404995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318404995">(Dec 29 2022 at 12:04)</a>:</h4>
<p>It works by reducing a decidability instance, so it is all happening in the kernel</p>



<a name="318405026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318405026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318405026">(Dec 29 2022 at 12:04)</a>:</h4>
<p>i.e., there is no "run-time"; everything is happening with terms</p>



<a name="318405219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318405219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318405219">(Dec 29 2022 at 12:05)</a>:</h4>
<p>If you look at the term that comes out of a well-founded recursion proof (probably a bad idea in general) then it will be of the form <code>acc.rec</code> applied to the proof of accessibility</p>



<a name="318405764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318405764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318405764">(Dec 29 2022 at 12:08)</a>:</h4>
<p>In theory, this could still reduce if the proof of accessibility also reduces to constructors but I think Lean doesn't do this</p>



<a name="318405830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318405830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318405830">(Dec 29 2022 at 12:08)</a>:</h4>
<p>Technically, it is a tactic: <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#dec_trivial">tactic#dec_trivial</a>. There is also term-mode <code>dec_trivial</code>, which is essentially <a href="https://leanprover-community.github.io/mathlib_docs/find/of_as_true">docs#of_as_true</a>.</p>



<a name="318406056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318406056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Sutherland <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318406056">(Dec 29 2022 at 12:10)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Understood, thanks for explaining this to me :) </p>
<p>One last question if it's acceptable to go a little "off-topic", the instance <code>neg_dec_of_dec</code> above, it feels like there has to be a better way of doing that. Any suggestions? <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="318406112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318406112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318406112">(Dec 29 2022 at 12:10)</a>:</h4>
<p>I would think that it must already exist in mathlib...</p>



<a name="318406305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318406305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Sutherland <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318406305">(Dec 29 2022 at 12:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>  I would have thought so too, but have been able to find it, at least within mathlib3...</p>



<a name="318406436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318406436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318406436">(Dec 29 2022 at 12:12)</a>:</h4>
<p>It should be called <a href="https://leanprover-community.github.io/mathlib_docs/find/not.decidable">docs#not.decidable</a></p>



<a name="318406527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318406527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318406527">(Dec 29 2022 at 12:13)</a>:</h4>
<p>Bingo!</p>



<a name="318407151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318407151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Sutherland <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318407151">(Dec 29 2022 at 12:16)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> Thanks, that's perfect, I could have sworn I tried <code>library_search</code> before trying to prove this manually, but apparently not!</p>



<a name="318419754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318419754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318419754">(Dec 29 2022 at 13:36)</a>:</h4>
<p><code>library_search</code> can be hit and miss with definitions. It's really designed for theorems.</p>



<a name="318475427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20the%20dec_trivial%20tactic/near/318475427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20the.20dec_trivial.20tactic.html#318475427">(Dec 29 2022 at 19:29)</a>:</h4>
<p>Did you try <code>library_search</code> before or after the <code>intros p inst</code> line? Introducing all variables before calling <code>library_search</code> helps a lot.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Playing.20with.20free.20groups.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html">Playing with free groups</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="235657059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/235657059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#235657059">(Apr 22 2021 at 11:06)</a>:</h4>
<p>I tried to get back to my questions about free groups, and tried the following. Can some kind soul please help me out?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.free_group</span>

<span class="kd">def</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">free_group</span> <span class="n">bool</span>

<span class="kd">def</span> <span class="n">g1</span> <span class="o">:=</span> <span class="n">free_group.mk</span> <span class="o">[(</span><span class="n">tt</span><span class="o">,</span><span class="n">tt</span><span class="o">)]</span>
<span class="kd">def</span> <span class="n">g2</span> <span class="o">:=</span> <span class="n">free_group.mk</span> <span class="o">[(</span><span class="n">ff</span><span class="o">,</span><span class="n">tt</span><span class="o">)]</span>
<span class="kd">def</span> <span class="n">G1</span> <span class="o">:=</span> <span class="n">free_group.mk</span> <span class="o">[(</span><span class="n">tt</span><span class="o">,</span><span class="n">ff</span><span class="o">)]</span>
<span class="kd">def</span> <span class="n">G2</span> <span class="o">:=</span> <span class="n">free_group.mk</span> <span class="o">[(</span><span class="n">ff</span><span class="o">,</span><span class="n">ff</span><span class="o">)]</span>

<span class="kd">theorem</span> <span class="n">trivialthm1</span> <span class="o">:</span> <span class="n">g1</span><span class="bp">⁻¹</span> <span class="bp">=</span> <span class="n">G1</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="c1">-- this one is easy, it's by definition</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">trivialthm2</span> <span class="o">:</span> <span class="n">g1</span> <span class="bp">≠</span> <span class="n">g2</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="c1">-- this is easy too, the map bool -&gt; f is injective. Is there a way to golf it down to a single command?</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">free_group.of_injective</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">tauto</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">trivialthm3</span> <span class="o">:</span> <span class="n">g1</span> <span class="bp">≠</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="c1">-- this is hard (for me)</span>
  <span class="n">intro</span> <span class="n">j</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">free_group.reduce.sound</span> <span class="n">j</span><span class="o">,</span> <span class="c1">-- now goal is "false", and hypothesis is "free_group.reduce [(tt, tt)] = free_group.reduce list.nil"</span>
  <span class="c1">-- I want to say that these reductions are [(tt,tt)] and list.nil respectively, using free_group.reduce.cons</span>
  <span class="c1">-- and then say that the reductions are different, contradiction.</span>
  <span class="c1">-- I could do none of these things :(</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="235659261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/235659261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#235659261">(Apr 22 2021 at 11:26)</a>:</h4>
<p><code>cases k</code></p>



<a name="235662905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/235662905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#235662905">(Apr 22 2021 at 11:57)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">trivialthm2</span> <span class="o">:</span> <span class="n">g1</span> <span class="bp">≠</span> <span class="n">g2</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">bool.no_confusion</span> <span class="bp">$</span> <span class="n">free_group.of_injective</span> <span class="n">h</span>
</code></pre></div>



<a name="235665893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/235665893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#235665893">(Apr 22 2021 at 12:18)</a>:</h4>
<p>It's maybe nicer to directly define</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">g1</span> <span class="o">:=</span> <span class="n">free_group.of</span> <span class="n">tt</span>
<span class="n">g2</span> <span class="o">:=</span> <span class="n">free_group.of</span> <span class="n">ff</span>
<span class="n">G1</span> <span class="o">:=</span> <span class="n">g1</span><span class="bp">⁻¹</span>
<span class="n">G2</span> <span class="o">:=</span> <span class="n">g2</span><span class="bp">⁻¹</span>
</code></pre></div>
<p>For longer words you can just multiply the generators. The list stuff is sort of an implementation detail that you as an end-user shouldn't have to see. Of course <code>free_group.reduce.sound</code> will still give you an equality of lists (as it should), but you don't need to start with lists.</p>



<a name="235667622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/235667622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#235667622">(Apr 22 2021 at 12:29)</a>:</h4>
<p><del>Hooray, my speculative adding of <a href="https://leanprover-community.github.io/mathlib_docs/find/free_group.of_injective">docs#free_group.of_injective</a> turned out to be useful!</del> edit: looks like I didn't add that one after all</p>



<a name="235680239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/235680239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#235680239">(Apr 22 2021 at 13:49)</a>:</h4>
<p>Great, thanks a lot! now, harder: a free group on 3 generators! Am I creating a type with 3 elements in the correct way? (I know I could put everything into a "free_group \nat", but I'd also like to be able to define free groups of finite rank \ne 2). How do I tell lean that three's elements are distinct, and that there are exactly these three?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.free_group</span>

<span class="kd">inductive</span> <span class="n">three</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">x</span> <span class="o">:</span> <span class="n">three</span>
<span class="bp">|</span> <span class="n">y</span> <span class="o">:</span> <span class="n">three</span>
<span class="bp">|</span> <span class="n">z</span> <span class="o">:</span> <span class="n">three</span>

<span class="kd">def</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">free_group</span> <span class="n">three</span>

<span class="kd">def</span> <span class="n">g1</span> <span class="o">:=</span> <span class="n">free_group.of</span> <span class="n">three.x</span>
<span class="kd">def</span> <span class="n">g2</span> <span class="o">:=</span> <span class="n">free_group.of</span> <span class="n">three.y</span>
<span class="kd">def</span> <span class="n">g3</span> <span class="o">:=</span> <span class="n">free_group.of</span> <span class="n">three.z</span>

<span class="kd">theorem</span> <span class="n">trivialthm1</span> <span class="o">:</span> <span class="n">g1</span><span class="bp">*</span><span class="n">g2</span><span class="bp">*</span><span class="n">g2</span><span class="bp">⁻¹*</span><span class="n">g1</span><span class="bp">⁻¹</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>

<span class="kd">theorem</span> <span class="n">trivialthm2</span> <span class="o">:</span> <span class="n">g1</span> <span class="bp">≠</span> <span class="n">g2</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">free_group.of_injective</span> <span class="n">h</span>

<span class="kd">theorem</span> <span class="n">trivialthm3</span> <span class="o">:</span> <span class="n">g1</span> <span class="bp">≠</span> <span class="mi">1</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">free_group.reduce.sound</span> <span class="n">h</span>
<span class="c1">-- fails: needs to know "decidable_eq three"</span>
</code></pre></div>



<a name="235680443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/235680443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#235680443">(Apr 22 2021 at 13:50)</a>:</h4>
<p>You can use <code>fin 3</code></p>



<a name="235682283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/235682283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#235682283">(Apr 22 2021 at 13:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> <a href="#narrow/stream/113489-new-members/topic/Playing.20with.20free.20groups/near/235680443">said</a>:</p>
<blockquote>
<p>You can use <code>fin 3</code></p>
</blockquote>
<p>Very nice! So I'm happy with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">g1</span> <span class="o">:=</span> <span class="n">free_group.of</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">3</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">g2</span> <span class="o">:=</span> <span class="n">free_group.of</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">3</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">g3</span> <span class="o">:=</span> <span class="n">free_group.of</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">3</span><span class="o">)</span>
</code></pre></div>
<p>Now, something I don't understand (and could be unrelated): why is <code>def g2 := free_group.of (4 : fin 3)</code> legal? I guess types don't have cardinalities, but it seems I can coerce every natural into <code>fin 3</code>, meaning it has more than 3 elements!</p>



<a name="235682610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/235682610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#235682610">(Apr 22 2021 at 14:01)</a>:</h4>
<p><code>fin n</code> works modulo <code>n</code>, so <code>(0 : fin 3) = (3 : fin 3) = (6 : fin 3) = ...</code></p>



<a name="235682780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/235682780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#235682780">(Apr 22 2021 at 14:01)</a>:</h4>
<p>Actually Lean knows that <code>free_group A</code> has decidable equality whenever <code>A</code> does, so you can also write things like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">free_group</span>
<span class="kd">def</span> <span class="n">x</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="n">of</span> <span class="mi">0</span>
<span class="kd">def</span> <span class="n">y</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="n">of</span> <span class="mi">1</span>
<span class="kd">def</span> <span class="n">z</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="n">of</span> <span class="mi">2</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">≠</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
</code></pre></div>



<a name="235685003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/235685003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#235685003">(Apr 22 2021 at 14:13)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="130377">@David Wärn</span> ! That's two hole-in-one in a row!</p>



<a name="235689436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/235689436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#235689436">(Apr 22 2021 at 14:38)</a>:</h4>
<p>The original inductive definition of <code>three</code> would also have been fine -- if you prefix it with <code>@[derive decidable_eq]</code> then probably the proofs would work just the same. You can't push <code>dec_trivial</code> too far though. However an MSc student of mine, Chris Hughes, has been working on group theory algorithms in Lean and he has some working tactics which can solve equalities and inequalities even in finitely presented groups (of course this is not decidable in general, but the algorithm just has a go and often succeeds).</p>



<a name="235958145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/235958145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#235958145">(Apr 24 2021 at 09:53)</a>:</h4>
<p><span class="user-mention" data-user-id="263407">@Laurent Bartholdi</span> if you want a challenge, this recent work of  Gardam <a href="https://arxiv.org/abs/2102.11818">disproving the unit conjecture for group rings</a> got some <a href="https://www.quantamagazine.org/mathematician-disproves-group-algebra-unit-conjecture-20210412/">press coverage</a> recently and would probably be an interesting but feasible challenge to do in Lean. I talked to <span class="user-mention" data-user-id="110044">@Chris Hughes</span> about it who pointed out that it would not be immediately straightforward but the arguments seem to me to be very amenable to formalisation.</p>



<a name="236242308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236242308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236242308">(Apr 26 2021 at 21:01)</a>:</h4>
<p>That's a great idea! Unfortunately I'm again stuck at basics:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.free_group</span>
<span class="kn">import</span> <span class="n">algebra.monoid_algebra</span>

<span class="kn">open</span> <span class="n">free_group</span>

<span class="kd">def</span> <span class="n">x</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">of</span> <span class="mi">0</span>
<span class="kd">def</span> <span class="n">y</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">of</span> <span class="mi">1</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">dec_trivial</span>

<span class="kd">def</span> <span class="n">rx</span> <span class="o">:=</span> <span class="o">(</span><span class="n">monoid_algebra.of</span> <span class="n">ℤ</span> <span class="o">(</span><span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)))</span> <span class="n">x</span> <span class="c1">-- noncomputable!</span>
<span class="kd">def</span> <span class="n">ry</span> <span class="o">:=</span> <span class="o">(</span><span class="n">monoid_algebra.of</span> <span class="n">ℤ</span> <span class="o">(</span><span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)))</span> <span class="n">y</span> <span class="c1">-- noncomputable!</span>
<span class="c1">-- and: how do I avoid re-typing this "(monoid_algebra.of ℤ (free_group (fin 2)))"?</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">rx</span> <span class="bp">≠</span> <span class="n">ry</span> <span class="o">:=</span> <span class="n">dec_trivial</span> <span class="c1">-- understandably, fails</span>
</code></pre></div>
<p>If I can get this running, though, I think the Gardam paper will be easy to formalize. It's a matter of defining a group by 2x2 matrices, which we could do using (explicitly) invertible functions Z^2-&gt;Z^2, and have everything be evaluated by lean.</p>



<a name="236243009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236243009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236243009">(Apr 26 2021 at 21:04)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I should add that I convinced a few students to learn lean with me, and hopefully they'll soon be more expert than me. A suggestion I made was to formalize the ping-pong lemma (<a href="https://en.wikipedia.org/wiki/Ping-pong_lemma">https://en.wikipedia.org/wiki/Ping-pong_lemma</a>), at least in its simplest form (proving that an action of a free group is faithful). Do you see any objections to this project?</p>



<a name="236244628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236244628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236244628">(Apr 26 2021 at 21:11)</a>:</h4>
<p>Here is how to do what you want:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.free_group</span>
<span class="kn">import</span> <span class="n">algebra.monoid_algebra</span>
<span class="kd">noncomputable theory</span> <span class="c1">-- disables the noncomputable warning</span>
<span class="kn">open</span> <span class="n">free_group</span>

<span class="kd">def</span> <span class="n">x</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">of</span> <span class="mi">0</span>
<span class="kd">def</span> <span class="n">y</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">of</span> <span class="mi">1</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">dec_trivial</span>

<span class="kn">open</span> <span class="n">monoid_algebra</span> <span class="c1">-- so we can jsut write `of` below, slightly less copy pasting</span>
<span class="kd">def</span> <span class="n">rx</span> <span class="o">:=</span> <span class="n">of</span> <span class="n">ℤ</span> <span class="n">_</span> <span class="n">x</span>  <span class="c1">-- because lean knows where x and y live the free_group (fin 2) is duplicate information and you can leave that out with an underscore</span>
<span class="kd">def</span> <span class="n">ry</span> <span class="o">:=</span> <span class="n">of</span> <span class="n">ℤ</span> <span class="n">_</span> <span class="n">y</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">rx</span> <span class="bp">≠</span> <span class="n">ry</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">monoid_algebra.of_injective</span> <span class="n">h</span><span class="o">,</span> <span class="c1">-- key lemma</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">dec_trivial</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">)</span> <span class="n">this</span><span class="o">,</span>  <span class="c1">-- same idea as your first example, one we have a statement about the free group over fin 2 everything is checkable by lean</span>
<span class="kd">end</span>
</code></pre></div>



<a name="236248686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236248686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236248686">(Apr 26 2021 at 21:33)</a>:</h4>
<p><span class="user-mention" data-user-id="263407">@Laurent Bartholdi</span> this is what happened to me -- I introduced some students to Lean and after a while they started teaching it to me. <span class="user-mention" data-user-id="110044">@Chris Hughes</span> is an example -- Chris, do you think the ping pong lemma would be formalisable in a relatively straightforward manner?</p>



<a name="236248885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236248885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236248885">(Apr 26 2021 at 21:35)</a>:</h4>
<p>Re: the Gardam paper -- Chris already pointed out to me that if you're not careful then you might find it hard to prove that the unit he constructs is not of the form lambda*g, i.e. you'll need to prove that various elements of your group are distinct. There seemed to be two ways of thinking about the group in the paper -- one as an extension of Z/2 x Z/2 by Z^3 and another as some explicit finite presentation. I don't know a maths proof that these two groups are equal (but I didn't look at the paper carefully and I don't know this stuff at all -- Chris has been doing his MSc project with me on finitely generated groups in Lean so might well know more)</p>



<a name="236251318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236251318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236251318">(Apr 26 2021 at 21:58)</a>:</h4>
<p>Another simple result about free groups, which I think would be nice to see in Lean, is the fact that the free group on two generators contains as a subgroup a free group on infinitely many generators</p>



<a name="236251616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236251616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236251616">(Apr 26 2021 at 22:01)</a>:</h4>
<p>I think proving the ping pong lemma should be fairly easy. It actually looks easier than proving associativity of multiplication of the free product. I do think that working with free groups is generally extremely challenging, there are a lot of arguments about the normal form that are intuitive on paper but very challenging to formalize. There are a bunch of questions about the best approach to this stuff. I think it might even be sensible to work mostly with binary coproducts, and then transfer to larger coproducts. Binary coproducts can be implemented as a subtype of <code>H × list (G × H) × G</code>, with the stipulation that none of the pairs in the list is <code>1</code>. The element <code>(h₁, [(g₂, h₂)], g₃) </code> would represent the element  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub><msub><mi>g</mi><mn>2</mn></msub><msub><mi>h</mi><mn>2</mn></msub><msub><mi>g</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">h_1g_2h_2g_3</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. You could also just do the list of pairs and stipulate that the first and last elements are allowed to be one. It would require a lot of work to really work out how to properly reason with free groups. An elegant proof of associativity of multiplication of reduced words would be a nice start.</p>



<a name="236252352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236252352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236252352">(Apr 26 2021 at 22:08)</a>:</h4>
<p>I do think the current interface for free groups isn't anywhere near enough to reason about normal forms. I have some [code](<a href="https://github.com/ChrisHughes24/single_relation/tree/master/src/coprod">https://github.com/ChrisHughes24/single_relation/tree/master/src/coprod</a> about normal forms of coproducts of groups, but the associativity proof is messy and it's not mathlib ready. I don't have time right now to work on it, but I certainly wouldn't be offended if someone else PRed it or modified it.</p>



<a name="236252492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236252492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236252492">(Apr 26 2021 at 22:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> <a href="#narrow/stream/113489-new-members/topic/Playing.20with.20free.20groups/near/236251318">said</a>: </p>
<blockquote>
<p>Another simple result about free groups, which I think would be nice to see in Lean, is the fact that the free group on two generators contains as a subgroup a free group on infinitely many generators </p>
</blockquote>
<p>The argument I know for this is that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(2)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span> is isomorphic to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi mathvariant="double-struck">Z</mi><mo stretchy="false">)</mo><mo>⋊</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">F(\mathbb{Z}) \rtimes \mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin amsrm">⋊</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> acts on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi mathvariant="double-struck">Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(\mathbb{Z})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mclose">)</span></span></span></span> by extending the left regular action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> on itself. This is all really easy in Lean right now.</p>



<a name="236253542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236253542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236253542">(Apr 26 2021 at 22:18)</a>:</h4>
<p>Huh, I wasn't aware of this argument. I suppose you just show that <code>left (of 0)</code> and <code>right 1</code> freely generate this semidirect product? Anyway I agree it shouldn't be difficult. The argument I had in mind was to consider the kernel of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>→</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">F(2) \to \mathbb Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">Z</span></span></span></span> sending <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, using <a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup_is_free_of_is_free">docs#subgroup_is_free_of_is_free</a>, and doing a bit of work to show that the set of generators is really <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msup><mi>y</mi><mi>n</mi></msup><mi>x</mi><msup><mi>y</mi><mrow><mo>−</mo><mi>n</mi></mrow></msup><mo>∣</mo><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">Z</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{y^n x y^{-n} \mid n \in \mathbb Z\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.021331em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Z</span><span class="mclose">}</span></span></span></span> (it's this picture where you have an infinite path and a loop at every vertex).</p>



<a name="236253714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236253714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236253714">(Apr 26 2021 at 22:20)</a>:</h4>
<p>My favourite theorem about finitely generated free groups is that a subgroup of index n is also f.g. free and the Euler characteristic 2g-2 gets multiplied by n, e.g. an index 2 subgroup of F(2) must be free on 3 generators. The proof I know is topological.</p>



<a name="236254107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236254107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236254107">(Apr 26 2021 at 22:24)</a>:</h4>
<p>You can deduce this from what's currently in mathlib without too much effort! I did so <a href="https://github.com/dwarn/nielsen-schreier-2/blob/e51a8c6511d374dc584698c7fa236a5be47e7dbe/src/index_formula.lean#L79">here</a> (except you need to perform some subtractions to get the usual version with finite ranks)</p>



<a name="236254149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236254149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236254149">(Apr 26 2021 at 22:25)</a>:</h4>
<p>I mean mathlib now has the "free" part, you just need to do a bit more work to get the formula relating rank and index</p>



<a name="236254179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236254179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236254179">(Apr 26 2021 at 22:25)</a>:</h4>
<p>Oh nice -- a constructive version!</p>



<a name="236254195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236254195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236254195">(Apr 26 2021 at 22:25)</a>:</h4>
<p>I had no clue that the formula for the group's size was because of Euler's characteristic - that's really cool</p>



<a name="236258166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236258166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236258166">(Apr 26 2021 at 23:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110044">Chris Hughes</span> <a href="#narrow/stream/113489-new-members/topic/Playing.20with.20free.20groups/near/236252352">said</a>:</p>
<blockquote>
<p>I do think the current interface for free groups isn't anywhere near enough to reason about normal forms. I have some <a href="https://github.com/ChrisHughes24/single_relation/tree/master/src/coprod">code</a> about normal forms of coproducts of groups, but the associativity proof is messy and it's not mathlib ready. I don't have time right now to work on it, but I certainly wouldn't be offended if someone else PRed it or modified it.</p>
</blockquote>
<p>There's a reasonably nice way to do this, where you take the set of reduced words and act on it one letter at a time, but mabye this is as complicated as what you currently have? Suppose we want to construct <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∐</mo><mi>i</mi></msub><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\coprod_i G_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∐</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. For <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> a reduced word and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∈</mo><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">g \in G_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, define the reduced word given by prepending <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> (this is your <code>rcons</code>). Then show that this determines an action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> on the set of reduced words. It's obviously faithful, by acting on the empty word. So for each <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> we can view <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> as a subgroup of the symmetric group on the reduced words. Then take the subgroup generated by all of these, and show it bijects with the set of reduced words</p>



<a name="236258260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236258260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236258260">(Apr 26 2021 at 23:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Playing.20with.20free.20groups/near/236254179">said</a>:</p>
<blockquote>
<p>Oh nice -- a constructive version!</p>
</blockquote>
<p>It's not completely constructive since taking spanning trees in the infinite-index case is verboten</p>



<a name="236262984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236262984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236262984">(Apr 26 2021 at 23:58)</a>:</h4>
<p>I proved that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(Z)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span></span></span></span> embeds into <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(2)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span> <a href="https://gist.github.com/ChrisHughes24/6829f57b86cb00b1067011f673c472b4">https://gist.github.com/ChrisHughes24/6829f57b86cb00b1067011f673c472b4</a> Nowhere near as pretty as I'd like. There's some missing simp lemmas in the library about how a bunch of stuff like <code>mul_action.to_perm</code> behave.</p>



<a name="236264648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236264648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236264648">(Apr 27 2021 at 00:16)</a>:</h4>
<p>It's a special case of a more general argument saying <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>∗</mo><mi>H</mi><mo>≅</mo><mo stretchy="false">(</mo><msub><mo>∐</mo><mrow><mi>h</mi><mo>∈</mo><mi>H</mi></mrow></msub><mi>G</mi><mo stretchy="false">)</mo><mo>⋊</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">G \ast H \cong (\coprod_{h \in H} G) \rtimes H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.07708em;vertical-align:-0.32708000000000004em;"></span><span class="mopen">(</span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∐</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.18639799999999984em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.08125em;">H</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32708000000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin amsrm">⋊</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span></p>



<a name="236506364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236506364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236506364">(Apr 28 2021 at 13:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Playing.20with.20free.20groups/near/236244628">said</a>:</p>
<blockquote>
<p>Here is how to do what you want:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.free_group</span>
<span class="kn">import</span> <span class="n">algebra.monoid_algebra</span>
<span class="kd">noncomputable theory</span> <span class="c1">-- disables the noncomputable warning</span>
<span class="kn">open</span> <span class="n">free_group</span>

<span class="kd">def</span> <span class="n">x</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">of</span> <span class="mi">0</span>
<span class="kd">def</span> <span class="n">y</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">of</span> <span class="mi">1</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">dec_trivial</span>

<span class="kn">open</span> <span class="n">monoid_algebra</span> <span class="c1">-- so we can jsut write `of` below, slightly less copy pasting</span>
<span class="kd">def</span> <span class="n">rx</span> <span class="o">:=</span> <span class="n">of</span> <span class="n">ℤ</span> <span class="n">_</span> <span class="n">x</span>  <span class="c1">-- because lean knows where x and y live the free_group (fin 2) is duplicate information and you can leave that out with an underscore</span>
<span class="kd">def</span> <span class="n">ry</span> <span class="o">:=</span> <span class="n">of</span> <span class="n">ℤ</span> <span class="n">_</span> <span class="n">y</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">rx</span> <span class="bp">≠</span> <span class="n">ry</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">monoid_algebra.of_injective</span> <span class="n">h</span><span class="o">,</span> <span class="c1">-- key lemma</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">dec_trivial</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">)</span> <span class="n">this</span><span class="o">,</span>  <span class="c1">-- same idea as your first example, one we have a statement about the free group over fin 2 everything is checkable by lean</span>
<span class="kd">end</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Great! however, I'm stuck now an inch further:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">monoid_algebra</span> <span class="n">ℤ</span> <span class="o">(</span><span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)))</span><span class="bp">.</span><span class="n">support</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">rx.support</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">rx</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">rx</span> <span class="n">x</span> <span class="bp">≠</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">monoid_algebra</span> <span class="n">ℤ</span> <span class="o">(</span><span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)))</span> <span class="n">x</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>It seems to me that, generally speaking, it's good to argue about supports of elements in a group ring. However, I find it hard to dec_trivial away any of the examples, such as the next-to-last one.</p>
<p>As I understand it, elements of a group ring are functions, so it makes sense to evaluate them. This is what I try in the last example : show two functions differ because they have different values at x.</p>



<a name="236563482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236563482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236563482">(Apr 28 2021 at 19:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> <a href="#narrow/stream/113489-new-members/topic/Playing.20with.20free.20groups/near/236258166">said</a>:</p>
<blockquote>
<p>There's a reasonably nice way to do this, where you take the set of reduced words and act on it one letter at a time, but mabye this is as complicated as what you currently have? Suppose we want to construct <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∐</mo><mi>i</mi></msub><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\coprod_i G_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∐</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. For <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> a reduced word and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∈</mo><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">g \in G_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, define the reduced word given by prepending <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> (this is your <code>rcons</code>). Then show that this determines an action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> on the set of reduced words. It's obviously faithful, by acting on the empty word. So for each <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> we can view <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> as a subgroup of the symmetric group on the reduced words. Then take the subgroup generated by all of these, and show it bijects with the set of reduced words</p>
</blockquote>
<p>I second this -- the reference is [van der Waerden, B. L. Free products of groups. Amer. J. Math. 70 (1948), 527–528. <a href="https://doi.org/10.2307/2372196]">https://doi.org/10.2307/2372196]</a>.  The article really feels like van der Waerden had formalization in mind!</p>



<a name="236572448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236572448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236572448">(Apr 28 2021 at 20:24)</a>:</h4>
<p>Thanks for this reference! I only knew it as a folklore idea, so it's nice to see the reference. I wrote up a definition of coproducts in PR  <a href="https://github.com/leanprover-community/mathlib/issues/7395">#7395</a> using some of these ideas. It turned out quite nice.</p>



<a name="236575348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236575348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236575348">(Apr 28 2021 at 20:46)</a>:</h4>
<p>For supports in the monoid algebra: there is a lemma called <code>finsupp.support_single_ne_zero</code> which should do what you want. Note the it relies on the non-obvious fact <code>1 ≠ 0</code>. <code>simp</code> can help you with the second sorry if you let it know what <code>rx</code> is (e.g. <code>simp [rx]</code>)</p>



<a name="236651096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236651096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236651096">(Apr 29 2021 at 10:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> <a href="#narrow/stream/113489-new-members/topic/Playing.20with.20free.20groups/near/236575348">said</a>:</p>
<blockquote>
<p>For supports in the monoid algebra: there is a lemma called <code>finsupp.support_single_ne_zero</code> which should do what you want. Note the it relies on the non-obvious fact <code>1 ≠ 0</code>. <code>simp</code> can help you with the second sorry if you let it know what <code>rx</code> is (e.g. <code>simp [rx]</code>)</p>
</blockquote>
<p>I just feel I managed to conquer Mt Everest:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">x_ne_y</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">dec_trivial</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">rx</span> <span class="bp">+</span> <span class="n">ry</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">finsupp.nonzero_iff_exists</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">rx</span><span class="o">,</span><span class="n">ry</span><span class="o">],</span>
  <span class="n">rw</span> <span class="n">finsupp.single_apply</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">x_ne_y.symm</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>
<p>Is there a better way to do this? In particular, how do I avoid putting "simp" everywhere?</p>



<a name="236655811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236655811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236655811">(Apr 29 2021 at 11:14)</a>:</h4>
<p>A shorter proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">rx</span> <span class="bp">+</span> <span class="n">ry</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">rx</span><span class="o">,</span> <span class="n">ry</span><span class="o">,</span> <span class="n">monoid_algebra.of_apply</span><span class="o">,</span> <span class="n">monoid_algebra.of_apply</span><span class="o">,</span> <span class="n">finsupp.nonzero_iff_exists</span><span class="o">],</span>
  <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp.add_apply</span><span class="o">,</span> <span class="n">finsupp.single_eq_same</span><span class="o">,</span><span class="n">finsupp.single_eq_of_ne</span> <span class="n">x_ne_y.symm</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">one_ne_zero</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="236656566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236656566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236656566">(Apr 29 2021 at 11:21)</a>:</h4>
<p>Or a different strategy:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">rx</span> <span class="bp">+</span> <span class="n">ry</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">dunfold</span> <span class="n">rx</span> <span class="n">ry</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">monoid_algebra.of_apply</span><span class="o">,</span> <span class="n">monoid_algebra.of_apply</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="bp">←</span><span class="n">eq_neg_iff_add_eq_zero</span><span class="o">,</span>
    <span class="bp">←</span><span class="n">finsupp.single_neg</span><span class="o">,</span> <span class="n">finsupp.single_eq_single_iff</span><span class="o">],</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">x_ne_y</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>
<p>where <a href="https://leanprover-community.github.io/mathlib_docs/find/finsupp.single_eq_single_iff">docs#finsupp.single_eq_single_iff</a> does most of the work</p>



<a name="236830399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236830399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236830399">(Apr 30 2021 at 13:03)</a>:</h4>
<p>OK, my next attempt: a new tactic! There are 2 things I could not find in the documentation: how to use a tactic variable (here "elt"), and how to construct on-the-fly a proof of equality / inequality of group elements:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">group_ring_ne_zero_at</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">g</span><span class="o">]</span> <span class="o">(</span><span class="n">elt</span> <span class="o">:</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">monoid_algebra.of_apply</span> <span class="o">},</span>
          <span class="n">rw</span> <span class="n">finsupp.nonzero_iff_exists</span><span class="o">,</span>
          <span class="n">use</span> <span class="n">x</span><span class="o">,</span> <span class="c1">-- here "use elt" does not work :(</span>
          <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">finsupp.add_apply</span> <span class="o">},</span>
          <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp.single_eq_same</span><span class="o">,</span><span class="n">finsupp.single_eq_of_ne</span> <span class="n">x_ne_y.symm</span><span class="o">]</span> <span class="o">},</span> <span class="c1">-- I want the tactic to look up the variable of the present term, and try to prove (by dec_trivial) that they're equal or unequal</span>
          <span class="n">simp</span>
         <span class="o">]</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">rx</span> <span class="bp">+</span> <span class="n">rx</span> <span class="bp">+</span> <span class="n">ry</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">rx</span><span class="o">,</span> <span class="n">ry</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">group_ring_ne_zero_at</span> <span class="n">x</span>
<span class="kd">end</span>
</code></pre></div>



<a name="236831168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236831168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236831168">(Apr 30 2021 at 13:09)</a>:</h4>
<p>Yes, it's unfortunately the case that you can't use antiquotations to embed variables inside <code>`[...]</code> blocks.</p>



<a name="236831212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236831212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236831212">(Apr 30 2021 at 13:09)</a>:</h4>
<p>Instead you need to lean the distinction between "interactive" tactics and non-interactive tactics, and use these "under the hood" tactics.</p>



<a name="236831327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236831327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236831327">(Apr 30 2021 at 13:10)</a>:</h4>
<p>If you jump-to-definition on <code>use</code>, you'll see that it immediately calls <code>tactic.use</code>, which is the underlying non-interactive tactic.</p>



<a name="236831452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236831452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236831452">(Apr 30 2021 at 13:11)</a>:</h4>
<p>However you'll see that <code>use</code> doesn't take a <code>g</code>, of course, it takes a <code>list pexpr</code>.</p>



<a name="236831521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236831521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236831521">(Apr 30 2021 at 13:11)</a>:</h4>
<p><code>pexpr</code> is a "pre-expression": a "meta" representation of some mathematical term.</p>



<a name="236831639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236831639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236831639">(Apr 30 2021 at 13:12)</a>:</h4>
<p>When you actually use <code>use</code> inside a <code>begin ... end</code> block the parser takes care of converting what you thinking of as "the actual mathematical thing <code>x</code>" into this <code>pexpr</code> representation of it.</p>



<a name="236831686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236831686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236831686">(Apr 30 2021 at 13:13)</a>:</h4>
<p>(Of course, Lean itself knows nothing about "the actual mathematical thing", and is just manipulating <code>pexpr</code> and <code>expr</code> objects in the C++ code.)</p>



<a name="236831789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236831789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236831789">(Apr 30 2021 at 13:13)</a>:</h4>
<p>So if you want to do this too in your tactic you'll need to learn a bit about the parser, and take <code>pexpr</code> arguments as appropriate.</p>



<a name="236831874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236831874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236831874">(Apr 30 2021 at 13:14)</a>:</h4>
<p>Explaining all that is perhaps beyond the scope of this thread, but you should watch Rob Lewis' excellent tutorial from LFTCM2020, and its associated exercises.</p>



<a name="236831916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/236831916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#236831916">(Apr 30 2021 at 13:14)</a>:</h4>
<p><a href="https://www.youtube.com/playlist?list=PLlF-CfQhukNnq2kDCw2P_vI5AfXN7egP2">https://www.youtube.com/playlist?list=PLlF-CfQhukNnq2kDCw2P_vI5AfXN7egP2</a></p>



<a name="243110341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/243110341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#243110341">(Jun 18 2021 at 02:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> <a href="#narrow/stream/113489-new-members/topic/Playing.20with.20free.20groups/near/235682780">said</a>:</p>
<blockquote>
<p>Actually Lean knows that <code>free_group A</code> has decidable equality whenever <code>A</code> does, so you can also write things like</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">free_group</span>
<span class="kd">def</span> <span class="n">x</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="n">of</span> <span class="mi">0</span>
<span class="kd">def</span> <span class="n">y</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="n">of</span> <span class="mi">1</span>
<span class="kd">def</span> <span class="n">z</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="n">of</span> <span class="mi">2</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">≠</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
</code></pre></div><br>
</p>
</blockquote>
<p>i'm trying to do proofs with free groups and was wondering what the "of" notation means, and where else it could be used? or if you could link me somewhere? also, does <code>free_group.of</code> and <code>of</code> do the same things?<br>
could you also explain how <code>fin 3</code> is implemented?</p>



<a name="243111119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/243111119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#243111119">(Jun 18 2021 at 02:52)</a>:</h4>
<p>If the namespace <code>free_group</code> is open (which will happen if we run <code>open free_group</code>) then yes <code>of</code> will very likely be shorthand for <code>free_group.of</code></p>



<a name="243111211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/243111211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#243111211">(Jun 18 2021 at 02:54)</a>:</h4>
<p>Does the docstring at <a href="https://leanprover-community.github.io/mathlib_docs/find/free_group.of">docs#free_group.of</a> help?</p>



<a name="243111312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/243111312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#243111312">(Jun 18 2021 at 02:57)</a>:</h4>
<p><code>fin 3</code> is a simple to use type with only 3 terms/elements, a term of <code>fin 3</code> is a natural number <code>n</code> and a proof that <code>n</code> is less than 3. As the proofs don't change which terms are equal you can just think of these terms as the number 0,1,2.</p>



<a name="243111383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/243111383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#243111383">(Jun 18 2021 at 02:58)</a>:</h4>
<p>So <code>of 0</code> is the generator corresponding to the number 0 of the free group generated by the terms 0, 1, 2</p>



<a name="243111390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/243111390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#243111390">(Jun 18 2021 at 02:58)</a>:</h4>
<p>Where these terms have no relations between them in the free group</p>



<a name="243112497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/243112497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#243112497">(Jun 18 2021 at 03:24)</a>:</h4>
<p>that helps a lot, thanks. is <code>def g1 := free_group.of tt</code> creating a <code>list (g1 x tt)</code>? and is <code>list (g1 x ff)</code> its inverse?</p>



<a name="243112819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/243112819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#243112819">(Jun 18 2021 at 03:32)</a>:</h4>
<p>actually, is it the generator corresponding to the bool true of the free group?</p>



<a name="243112930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/243112930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#243112930">(Jun 18 2021 at 03:34)</a>:</h4>
<p>Yeah the second thing, its just a single term of type <code>free_group bool</code></p>



<a name="243113301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/243113301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#243113301">(Jun 18 2021 at 03:44)</a>:</h4>
<p>ok. is there a difference between using<code>tt</code> or <code>ff</code>?</p>



<a name="243113374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/243113374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#243113374">(Jun 18 2021 at 03:45)</a>:</h4>
<p>The terms <code>tt</code> (true) and <code>ff</code> (false) are the two distinct terms of <code>bool</code> so the corresponding <code>of tt</code> and <code>of ff</code> are terms of <code>free_group bool</code>that are not equal.</p>



<a name="243695979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/243695979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Holly Liu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#243695979">(Jun 23 2021 at 18:48)</a>:</h4>
<p>i was wondering where <code>quot.mk</code> is defined? i found the following snippet at <a href="https://github.com/leanprover-community/lean/blob/a5822ea47ebc52eec6323d8f1b60f6ec025daf99/library/init/data/quot.lean#L93">https://github.com/leanprover-community/lean/blob/a5822ea47ebc52eec6323d8f1b60f6ec025daf99/library/init/data/quot.lean#L93</a> that uses <code>mk</code> in the definition of <code>mk</code>, which I am a bit confused about.  </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">mk</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">s</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">quotient</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">quot.mk</span> <span class="n">setoid.r</span> <span class="n">a</span>
</code></pre></div>



<a name="243696174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/243696174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#243696174">(Jun 23 2021 at 18:50)</a>:</h4>
<p><code>quot</code> is a bit special, it's added by the command <code>init_quotient</code> <a href="https://github.com/leanprover-community/lean/blob/a5822ea47ebc52eec6323d8f1b60f6ec025daf99/library/init/core.lean#L162">here</a>.</p>



<a name="243696304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/243696304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#243696304">(Jun 23 2021 at 18:51)</a>:</h4>
<p>Section <a href="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#quotients">11.4 of TPiL</a> is about quotient types in Lean.</p>



<a name="243720978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Playing%20with%20free%20groups/near/243720978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Playing.20with.20free.20groups.html#243720978">(Jun 23 2021 at 22:28)</a>:</h4>
<p>This is <a href="https://leanprover-community.github.io/mathlib_docs/find/quotient.mk">docs#quotient.mk</a> being defined in terms of <code>quot.mk</code>, which is defined by magic at start-up in an unconventional way.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/recursive.20function.20on.20finset.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html">recursive function on finset</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="262248793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262248793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew  Souther <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262248793">(Nov 21 2021 at 16:32)</a>:</h4>
<p>I am trying to define voting systems in Lean, so that I can formalize theorems about these voting systems. I am hoping to define recursive voting systems like <a href="https://en.wikipedia.org/wiki/Instant-runoff_voting">Instant Runoff Voting</a> which iteratively remove candidates until a winner is chosen. </p>
<p>In particular, I am working to define "Simple Stable Voting" in Lean.  Here is the <a href="https://arxiv.org/pdf/2108.00542v1.pdf">paper</a> I am looking at, and here is a <a href="/user_uploads/3121/iPgzgnHOYw2HIKWFJ4DPx4lK/simple-stable-voting.png">description</a>  of the voting system from that paper: </p>
<div class="message_inline_image"><a href="/user_uploads/3121/iPgzgnHOYw2HIKWFJ4DPx4lK/simple-stable-voting.png" title="description"><img src="/user_uploads/3121/iPgzgnHOYw2HIKWFJ4DPx4lK/simple-stable-voting.png"></a></div><p>I have sketched up a rough framework for defining this kind of voting system in Lean (<a href="/user_uploads/3121/1oBUKayyO1iiHLTFz_s7ku_o/stable_voting_mwe.lean">mwe with more explanation</a>): </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.finite</span>

<span class="kd">structure</span> <span class="n">election_profile</span> <span class="o">(</span><span class="n">χ</span> <span class="n">υ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">candidates</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">χ</span><span class="o">)</span>
<span class="o">(</span><span class="n">voters</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">υ</span><span class="o">)</span>
<span class="o">(</span><span class="n">ballots</span> <span class="o">:</span> <span class="n">υ</span> <span class="bp">→</span> <span class="n">χ</span> <span class="bp">→</span> <span class="n">χ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>


<span class="kd">def</span> <span class="n">simple_stable_voting</span> <span class="o">{</span><span class="n">χ</span> <span class="n">υ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">election_profile</span> <span class="n">χ</span> <span class="n">υ</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">χ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">prof</span><span class="o">,</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">prof</span> <span class="k">with</span> <span class="n">X</span> <span class="n">V</span> <span class="n">R</span><span class="bp">ᵢ</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>I figure I will need to perform some kind of induction on the <code>finset</code> <code>X</code>. I have tried to read through Chapter 8 on recursion and induction in <em>TPIL</em>, and I think I understand how to define simple recursive functions on natural numbers, but I have no clue where to start when it comes to defining a recursive function on a <code>finset</code>.</p>



<a name="262248880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262248880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew  Souther <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262248880">(Nov 21 2021 at 16:34)</a>:</h4>
<p>I assume I will need to handle three cases. If the set of candidates is empty, then the function outputs a junk value (the empty set) because you can't pick a winner from 0 candidates. If there is one candidate, then the function should output a <code>finset</code> with only that candidate as a winner. Then, I need to perform some kind of recursion on this base case to handle further cases.</p>



<a name="262248901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262248901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262248901">(Nov 21 2021 at 16:35)</a>:</h4>
<p>You probably want to induct on the size of the finset</p>



<a name="262248958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262248958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262248958">(Nov 21 2021 at 16:36)</a>:</h4>
<p>Normally you could use <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.induction">docs#finset.induction</a> but in this case you want to remove a particular element from the set (the losing candidate) in the recursive call</p>



<a name="262249223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262249223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew  Souther <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262249223">(Nov 21 2021 at 16:42)</a>:</h4>
<p>Hm, let's say I define <code>n</code> to be the size of <code>X</code> like this: <code>n : ℕ := X.card</code>. How can I actually induct on that natural number in this case? Like I understand how to use the <code>induction</code> tactic or apply the <code>finset.induction_on</code> lemma when I am trying to prove a proposition, but I don't understand how to use these things so well when I'm trying to define a function</p>



<a name="262249299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262249299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew  Souther <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262249299">(Nov 21 2021 at 16:44)</a>:</h4>
<p>For example, Lean doesn't like this because Lean fails to create a new goal: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">simple_stable_voting</span> <span class="o">{</span><span class="n">χ</span> <span class="n">υ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">election_profile</span> <span class="n">χ</span> <span class="n">υ</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">χ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">prof</span><span class="o">,</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">prof</span> <span class="k">with</span> <span class="n">X</span> <span class="n">V</span> <span class="n">R</span><span class="bp">ᵢ</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">X.card</span> <span class="k">with</span> <span class="n">hX</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="262249391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262249391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262249391">(Nov 21 2021 at 16:46)</a>:</h4>
<p>Random idea, but maybe you can first define the voting system on <code>list</code>?</p>



<a name="262249431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262249431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew  Souther <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262249431">(Nov 21 2021 at 16:47)</a>:</h4>
<p>Like handle a list of candidates instead of a finset of candidates, because <code>list</code> is a more primitive object, so induction might be a bit easier?</p>



<a name="262249494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262249494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew  Souther <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262249494">(Nov 21 2021 at 16:49)</a>:</h4>
<p>Maybe that could be a good first step to wrap my head around this stuff.</p>



<a name="262249555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262249555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262249555">(Nov 21 2021 at 16:50)</a>:</h4>
<p><code>let</code>/<code>set</code> screws up <code>induction</code> because it doesn't know how to deal with <code>let</code> variables in the context. Use <code>generalize</code> instead:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">simple_stable_voting</span> <span class="o">{</span><span class="n">χ</span> <span class="n">υ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">election_profile</span> <span class="n">χ</span> <span class="n">υ</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">χ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">prof</span><span class="o">,</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">prof</span> <span class="k">with</span> <span class="n">X</span> <span class="n">V</span> <span class="n">R</span><span class="bp">ᵢ</span><span class="o">,</span>
  <span class="n">generalize</span> <span class="n">h</span> <span class="o">:</span> <span class="n">X.card</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span> <span class="n">generalizing</span> <span class="n">X</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="262249656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262249656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew  Souther <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262249656">(Nov 21 2021 at 16:52)</a>:</h4>
<p>Exciting, thank you Mario!!! I will play with this and see if it turns out fruitful.</p>



<a name="262249832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262249832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew  Souther <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262249832">(Nov 21 2021 at 16:56)</a>:</h4>
<p>Actually, another quick question. Is there an easy way to split off the <code>X.card=0</code> case AND the <code>X.card=1</code> case before proceeding with the recursion? Similar to this example in TPIL: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">nat</span>

<span class="kd">def</span> <span class="n">sub2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">zero</span>            <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">zero</span><span class="o">)</span>     <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span> <span class="n">a</span>
</code></pre></div>



<a name="262249912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262249912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262249912">(Nov 21 2021 at 16:59)</a>:</h4>
<p>You can do <code>cases n with d</code> just before the induction and you'll be left with n=0 and n=succ(d), and then you can do <code>cases d with t</code> and you'll be left with the cases d=0 and d=succ(t).</p>



<a name="262253012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262253012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262253012">(Nov 21 2021 at 18:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="366882">Andrew  Souther</span> <a href="#narrow/stream/113489-new-members/topic/recursive.20function.20on.20finset/near/262249431">said</a>:</p>
<blockquote>
<p>Like handle a list of candidates instead of a finset of candidates, because <code>list</code> is a more primitive object, so induction might be a bit easier?</p>
</blockquote>
<p>Yes. Once you do this, you then have to prove your algorithm doesn't depend on the order the list was in, and then you can make it a function on <code>multiset</code>s.</p>



<a name="262262804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262262804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262262804">(Nov 21 2021 at 21:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="366882">Andrew  Souther</span> has marked this topic as unresolved.</p>



<a name="262262823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262262823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew  Souther <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262262823">(Nov 21 2021 at 21:57)</a>:</h4>
<p>Is it ok to unresolve? Or is it encouraged to open a new conversation?</p>



<a name="262262831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262262831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew  Souther <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262262831">(Nov 21 2021 at 21:57)</a>:</h4>
<p>I just want to ask further questions about the definition Kyle posted above</p>



<a name="262262875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262262875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262262875">(Nov 21 2021 at 21:58)</a>:</h4>
<p>back in the old days (last month or so) it was impossible to resolve questions, and I think half of us are still just ignoring this feature. So just keep going.</p>



<a name="262263060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262263060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew  Souther <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262263060">(Nov 21 2021 at 22:01)</a>:</h4>
<p>I am just trying to prove some simple lemmas using this definition, get a sense what the difficulties are, so perhaps that can inform a cleaner definition going forward.</p>
<p>First, I am trying to prove that when there is only one candidate, <code>simple_stable_voting</code> simply outputs the set of candidates. This is the second "case" in teh recursive definition of the function. </p>
<p>I have found that <code>finish</code> does the job, but I want to be more explicit: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.finite</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">structure</span> <span class="n">election_profile</span> <span class="o">(</span><span class="n">χ</span> <span class="n">υ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">candidates</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">χ</span><span class="o">)</span>
<span class="o">(</span><span class="n">cpos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">candidates.card</span><span class="o">)</span>
<span class="o">(</span><span class="n">voters</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">υ</span><span class="o">)</span>
<span class="o">(</span><span class="n">vpos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">voters.card</span><span class="o">)</span>
<span class="o">(</span><span class="n">ballots</span> <span class="o">:</span> <span class="n">υ</span> <span class="bp">→</span> <span class="n">χ</span> <span class="bp">→</span> <span class="n">χ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="n">s.nonempty</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">finset.card_pos</span><span class="o">,</span>
  <span class="n">apply_instance</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">simple_stable_voting'</span> <span class="o">{</span><span class="n">χ</span> <span class="n">υ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">voters</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">υ</span><span class="o">)</span> <span class="o">(</span><span class="n">ballots</span> <span class="o">:</span> <span class="n">υ</span> <span class="bp">→</span> <span class="n">χ</span> <span class="bp">→</span> <span class="n">χ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">χ</span><span class="o">]</span>
  <span class="o">[</span><span class="bp">∀</span> <span class="n">v</span><span class="o">,</span> <span class="n">decidable_rel</span> <span class="o">(</span><span class="n">ballots</span> <span class="n">v</span><span class="o">)]</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">candidates</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">χ</span><span class="o">)</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="n">candidates.card</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">cpos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">),</span> <span class="n">finset</span> <span class="n">χ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">_</span> <span class="n">_</span> <span class="n">cpos</span> <span class="o">:=</span> <span class="o">(</span><span class="n">nat.not_lt_zero</span> <span class="n">_</span> <span class="n">cpos</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="n">candidates</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">candidates</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="n">cands</span> <span class="n">hn</span> <span class="n">cpos</span> <span class="o">:=</span>
<span class="k">let</span>
  <span class="c1">-- whether c wins when candidate rem is removed</span>
  <span class="n">still_wins</span> <span class="o">(</span><span class="n">c</span> <span class="n">rem</span> <span class="o">:</span> <span class="n">χ</span><span class="o">)</span> <span class="o">(</span><span class="n">rem_prop</span> <span class="o">:</span> <span class="n">rem</span> <span class="bp">∈</span> <span class="n">cands</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
    <span class="n">c</span> <span class="bp">∈</span> <span class="n">simple_stable_voting'</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">cands.erase</span> <span class="n">rem</span><span class="o">)</span>
          <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finset.card_erase_of_mem</span><span class="o">,</span> <span class="n">hn</span><span class="o">]</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">rem_prop</span><span class="o">],</span> <span class="o">})</span>
          <span class="o">(</span><span class="kd">by</span> <span class="n">omega</span><span class="o">),</span>
  <span class="c1">-- the margin for candidate c vs c'</span>
  <span class="n">margin</span> <span class="o">(</span><span class="n">c</span> <span class="n">c'</span> <span class="o">:</span> <span class="n">χ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">voters.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="n">ballots</span> <span class="n">v</span> <span class="n">c</span> <span class="n">c'</span><span class="o">))</span><span class="bp">.</span><span class="n">card</span> <span class="bp">-</span> <span class="o">(</span><span class="n">voters.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="n">ballots</span> <span class="n">v</span> <span class="n">c'</span> <span class="n">c</span><span class="o">))</span><span class="bp">.</span><span class="n">card</span><span class="o">,</span>
  <span class="c1">-- the set of pairs (c, c') of candidates such that when c' is removed, c is a winner.</span>
  <span class="n">viable</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">χ</span> <span class="bp">×</span> <span class="n">χ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">finset.image</span> <span class="n">coe</span> <span class="bp">$</span>
    <span class="o">(</span><span class="n">cands.product</span> <span class="n">cands</span><span class="o">)</span><span class="bp">.</span><span class="n">attach.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">cands.product</span> <span class="n">cands</span><span class="o">),</span>
      <span class="n">still_wins</span> <span class="n">p.1.1</span> <span class="n">p.1.2</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">p</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">p_property</span><span class="o">,</span> <span class="n">exact</span> <span class="n">p_property.2</span><span class="o">,</span> <span class="o">})),</span>
  <span class="c1">-- find the maximal margin (using 0 if viable is somehow empty)</span>
  <span class="n">best_margin</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">hn</span> <span class="o">:</span> <span class="n">viable.nonempty</span> <span class="k">then</span> <span class="n">viable.sup'</span> <span class="n">hn</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">margin</span> <span class="n">p.1</span> <span class="n">p.2</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>
<span class="k">in</span> <span class="n">finset.image</span> <span class="n">prod.fst</span> <span class="bp">$</span> <span class="n">viable.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">margin</span> <span class="n">p.1</span> <span class="n">p.2</span> <span class="bp">=</span> <span class="n">best_margin</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">simple_stable_voting</span> <span class="o">{</span><span class="n">χ</span> <span class="n">υ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">prof</span> <span class="o">:</span> <span class="n">election_profile</span> <span class="n">χ</span> <span class="n">υ</span><span class="o">)</span>
  <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">χ</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">v</span><span class="o">,</span> <span class="n">decidable_rel</span> <span class="o">(</span><span class="n">prof.ballots</span> <span class="n">v</span><span class="o">)]</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">χ</span> <span class="o">:=</span>
<span class="n">simple_stable_voting'</span> <span class="n">prof.voters</span> <span class="n">prof.ballots</span> <span class="n">prof.candidates.card</span> <span class="n">prof.candidates</span> <span class="n">rfl</span> <span class="n">prof.cpos</span>

<span class="kd">lemma</span> <span class="n">ssv_singleton</span> <span class="o">{</span><span class="n">χ</span> <span class="n">υ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">prof</span> <span class="o">:</span> <span class="n">election_profile</span> <span class="n">χ</span> <span class="n">υ</span><span class="o">)</span> <span class="o">(</span><span class="n">hcands</span> <span class="o">:</span> <span class="n">prof.candidates.card</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">χ</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">v</span><span class="o">,</span> <span class="n">decidable_rel</span> <span class="o">(</span><span class="n">prof.ballots</span> <span class="n">v</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">simple_stable_voting</span> <span class="n">prof</span> <span class="bp">=</span> <span class="n">prof.candidates</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">unfold</span> <span class="n">simple_stable_voting</span><span class="bp">;</span> <span class="n">finish</span>
</code></pre></div>



<a name="262263119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262263119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew  Souther <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262263119">(Nov 21 2021 at 22:02)</a>:</h4>
<p>After unfolding <code>simple_stable_voting</code>, how can I actually use <code>hcands</code> to convince Lean we are on that second case of the definition where the number of candidates equals 1?</p>



<a name="262263310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262263310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262263310">(Nov 21 2021 at 22:07)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ssv_singleton</span> <span class="o">{</span><span class="n">χ</span> <span class="n">υ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">prof</span> <span class="o">:</span> <span class="n">election_profile</span> <span class="n">χ</span> <span class="n">υ</span><span class="o">)</span> <span class="o">(</span><span class="n">hcands</span> <span class="o">:</span> <span class="n">prof.candidates.card</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">χ</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">v</span><span class="o">,</span> <span class="n">decidable_rel</span> <span class="o">(</span><span class="n">prof.ballots</span> <span class="n">v</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">simple_stable_voting</span> <span class="n">prof</span> <span class="bp">=</span> <span class="n">prof.candidates</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">simple_stable_voting</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">simple_stable_voting'</span><span class="o">,</span> <span class="n">hcands</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="262263381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262263381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262263381">(Nov 21 2021 at 22:08)</a>:</h4>
<p><code>simp only</code> works too. You're dancing around "motive is not type correct" here if you try to do it manually.</p>



<a name="262263481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262263481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262263481">(Nov 21 2021 at 22:10)</a>:</h4>
<p><code>#print prefix simple_stable_voting'</code> gives you access to the things the simplifier knows and which it's hiding from you; looks like <code>simple_stable_voting'._main.equations._eqn_2</code> is what you want.</p>



<a name="262263651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262263651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262263651">(Nov 21 2021 at 22:14)</a>:</h4>
<p>You have some complex inductive definition, it's usually best to let the simplifier deal with these foundational issues.</p>



<a name="262263898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262263898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262263898">(Nov 21 2021 at 22:19)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ssv_singleton</span> <span class="o">{</span><span class="n">χ</span> <span class="n">υ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">prof</span> <span class="o">:</span> <span class="n">election_profile</span> <span class="n">χ</span> <span class="n">υ</span><span class="o">)</span> <span class="o">(</span><span class="n">hcands</span> <span class="o">:</span> <span class="n">prof.candidates.card</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">χ</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">v</span><span class="o">,</span> <span class="n">decidable_rel</span> <span class="o">(</span><span class="n">prof.ballots</span> <span class="n">v</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">simple_stable_voting</span> <span class="n">prof</span> <span class="bp">=</span> <span class="n">prof.candidates</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">simple_stable_voting</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">simple_stable_voting'._main.equations._eqn_2</span> <span class="n">prof.voters</span> <span class="n">prof.ballots</span> <span class="n">_</span> <span class="n">hcands</span> <span class="o">(</span><span class="n">dec_trivial</span><span class="o">),</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">hcands</span><span class="o">],</span>
  <span class="n">congr'</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="262264086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursive%20function%20on%20finset/near/262264086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursive.20function.20on.20finset.html#262264086">(Nov 21 2021 at 22:23)</a>:</h4>
<p>If you instead of <code>simp only [hcands]</code> you write <code>show_term {simp only [hcands]}</code> you can see the explicit argument it finds. Oh -- <code>refl</code> works instead of <code>congr'</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
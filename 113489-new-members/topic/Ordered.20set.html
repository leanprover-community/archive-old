---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Ordered.20set.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html">Ordered set</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="245989031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245989031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245989031">(Jul 14 2021 at 17:04)</a>:</h4>
<p>Is there a notion of a (totally) ordered set in Mathlib?<br>
I'm not a mathematician, so I basically think of this as a list without duplicates. But I'm guessing a more mathy version would be a set together with a linear order (?).</p>



<a name="245989153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245989153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245989153">(Jul 14 2021 at 17:05)</a>:</h4>
<p>A list such that <a href="https://leanprover-community.github.io/mathlib_docs/find/list.sorted">docs#list.sorted</a></p>



<a name="245989246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245989246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245989246">(Jul 14 2021 at 17:06)</a>:</h4>
<p>or you can encode it using a <a href="https://leanprover-community.github.io/mathlib_docs/find/order_embedding">docs#order_embedding</a></p>



<a name="245990180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245990180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245990180">(Jul 14 2021 at 17:13)</a>:</h4>
<p>or just <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_order">docs#linear_order</a></p>



<a name="245990196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245990196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245990196">(Jul 14 2021 at 17:13)</a>:</h4>
<p>Oh, turns out I actually do only need a partial order <span aria-label="see no evil" class="emoji emoji-1f648" role="img" title="see no evil">:see_no_evil:</span></p>



<a name="245990253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245990253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245990253">(Jul 14 2021 at 17:14)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/partial_order">docs#partial_order</a></p>



<a name="245990972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245990972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245990972">(Jul 14 2021 at 17:18)</a>:</h4>
<p><span class="user-mention" data-user-id="260507">@Heather Macbeth</span> I'm not sure if I can use <a href="https://leanprover-community.github.io/mathlib_docs/find/partial_order">docs#partial_order</a> for my use case.<br>
I'm trying to define a proposition that defines when an ordered set is a topological ordering over a graph:<br>
Currently, instead of using "ordered set", I use a <code>list</code> and also force it to be nodup:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">list.is_topo_over</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">ι</span> <span class="n">δ</span> <span class="n">ε</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="n">l.nodup</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">i'</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">,</span> <span class="n">g.has_path_from_to</span> <span class="n">i</span> <span class="n">i'</span> <span class="bp">→</span> <span class="o">(</span><span class="n">l.index_of</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">l.index_of</span> <span class="n">i'</span><span class="o">)</span>
</code></pre></div>



<a name="245991067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245991067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245991067">(Jul 14 2021 at 17:19)</a>:</h4>
<p>Imports?</p>



<a name="245991341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245991341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245991341">(Jul 14 2021 at 17:21)</a>:</h4>
<p>This should be sufficient:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">list.is_topo_over</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">ι</span> <span class="n">δ</span> <span class="n">ε</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="n">l.nodup</span> <span class="bp">∧</span> <span class="n">l.pairwise</span> <span class="n">g.has_path_from_to</span>
</code></pre></div>



<a name="245991415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245991415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245991415">(Jul 14 2021 at 17:21)</a>:</h4>
<p>I guess this would be an MWE:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">graph</span> <span class="o">:=</span> <span class="o">(</span><span class="n">unimportant</span><span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">graph.has_path_from_to</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="n">i'</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">g.unimportant</span> <span class="bp">=</span> <span class="n">i</span>

<span class="kd">def</span> <span class="n">list.is_topo_over</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="n">l.nodup</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">i'</span> <span class="bp">∈</span> <span class="n">nat</span><span class="o">,</span> <span class="n">g.has_path_from_to</span> <span class="n">i</span> <span class="n">i'</span> <span class="bp">→</span> <span class="o">(</span><span class="n">l.index_of</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">l.index_of</span> <span class="n">i'</span><span class="o">)</span>
</code></pre></div>



<a name="245991586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245991586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245991586">(Jul 14 2021 at 17:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/Ordered.20set/near/245991341">said</a>:</p>
<blockquote>
<p>This should be sufficient:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">list.is_topo_over</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">ι</span> <span class="n">δ</span> <span class="n">ε</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="n">l.nodup</span> <span class="bp">∧</span> <span class="n">l.pairwise</span> <span class="n">g.has_path_from_to</span>
</code></pre></div><br>
</p>
</blockquote>
<p>So <code>list</code> with <code>nodup</code> is basically the notion of ordered set?</p>



<a name="245991649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245991649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245991649">(Jul 14 2021 at 17:23)</a>:</h4>
<p>that's a finite ordered set</p>



<a name="245991754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245991754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245991754">(Jul 14 2021 at 17:24)</a>:</h4>
<p>Yes, I forgot the finite part.</p>



<a name="245992121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245992121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245992121">(Jul 14 2021 at 17:27)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.nodup</span>

<span class="kd">structure</span> <span class="n">graph</span> <span class="o">:=</span> <span class="o">(</span><span class="n">unimportant</span><span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">graph.has_path_from_to</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="n">i'</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">g.unimportant</span> <span class="bp">=</span> <span class="n">i</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">list.is_topo_over</span>  <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="n">l.nodup</span> <span class="bp">∧</span> <span class="n">l.pairwise</span> <span class="n">g.has_path_from_to</span>

<span class="kn">open</span> <span class="n">list</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">l.length</span><span class="o">)</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">l.length</span><span class="o">)</span> <span class="o">(</span><span class="n">ho</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">l.is_topo_over</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">g.has_path_from_to</span> <span class="o">(</span><span class="n">l.nth_le</span> <span class="n">n</span> <span class="n">hn</span><span class="o">)</span> <span class="o">(</span><span class="n">l.nth_le</span> <span class="n">m</span> <span class="n">hm</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">pairwise_iff_nth_le.mp</span> <span class="n">h.right</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">ho</span>
</code></pre></div>



<a name="245992194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245992194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245992194">(Jul 14 2021 at 17:27)</a>:</h4>
<p>Have you proved that <code>g.has_path_from_to</code> gives a partial order instance on <code>ι</code>?  If so, Yakov's code can be written as something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">list.is_topo_over</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">ι</span> <span class="n">δ</span> <span class="n">ε</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">l.pairwise</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span>
</code></pre></div>



<a name="245992280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245992280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245992280">(Jul 14 2021 at 17:28)</a>:</h4>
<p>It gives a partial order instance on the subtype given by elements of l</p>



<a name="245992405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245992405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245992405">(Jul 14 2021 at 17:29)</a>:</h4>
<p>Because when you have a preorder (defined using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span>), mathlib automatically makes the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span> relation for you: <a href="https://leanprover-community.github.io/mathlib_docs/find/preorder.to_has_lt">docs#preorder.to_has_lt</a></p>



<a name="245992630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245992630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245992630">(Jul 14 2021 at 17:31)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">graph.induced_order</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">//</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span> <span class="bp">∨</span> <span class="n">g.has_path_from_to</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span>
  <span class="n">lt</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">g.has_path_from_to</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span>
  <span class="n">le_refl</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">or.inl</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">le_trans</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">lt_iff_le_not_le</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">le_antisymm</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span> <span class="o">}</span>
</code></pre></div>



<a name="245992708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245992708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245992708">(Jul 14 2021 at 17:31)</a>:</h4>
<p>I don't understand how ...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">l.pairwise</span> <span class="n">g.has_path_from_to</span>
</code></pre></div>
<p>... is the same as ...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∀</span> <span class="n">i</span> <span class="n">i'</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">,</span> <span class="n">g.has_path_from_to</span> <span class="n">i</span> <span class="n">i'</span> <span class="bp">→</span> <span class="o">(</span><span class="n">l.index_of</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">l.index_of</span> <span class="n">i'</span><span class="o">)</span>
</code></pre></div>
<p>The docs for <a href="https://leanprover-community.github.io/mathlib_docs/find/list.pairwise">docs#list.pairwise</a> state that "<code>pairwise R l</code> means that all the elements with earlier indexes are <code>R</code>-related to all the elements with later indexes." But in the <code>∀</code>-based definition, <code>i</code> having a smaller index than <code>i'</code> doesn't necessarily mean that there's a path from <code>i</code> to <code>i'</code> (I think). It's rather the other way around.</p>



<a name="245992846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245992846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245992846">(Jul 14 2021 at 17:32)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/list.pairwise_iff_nth_le">docs#list.pairwise_iff_nth_le</a> is precisely what your <code>index_of</code> based statement implies.</p>



<a name="245993071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245993071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245993071">(Jul 14 2021 at 17:33)</a>:</h4>
<p><code>index_of</code> is an iso iff the list is nodup. So I'd just use <code>pairwise</code> for your Prop def, and require <code>nodup</code> when you're proving things about it.</p>



<a name="245993432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245993432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245993432">(Jul 14 2021 at 17:36)</a>:</h4>
<p>Hm, I still don't see the equivalence of the two definitions. I'll try to find a counterexample.</p>



<a name="245993521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245993521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245993521">(Jul 14 2021 at 17:37)</a>:</h4>
<p>I see the issue here. You said <code>∀ i i' ∈ nat</code> while I am saying <code>∀ i i' ∈ l</code>.</p>



<a name="245993558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245993558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245993558">(Jul 14 2021 at 17:37)</a>:</h4>
<p>Oh that's just a typo ^^'</p>



<a name="245993756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245993756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245993756">(Jul 14 2021 at 17:38)</a>:</h4>
<p>Do you agree that if <code>l.index_of i = n</code> then <code>l.nth n = some i</code>?</p>



<a name="245993827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245993827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245993827">(Jul 14 2021 at 17:39)</a>:</h4>
<p>Yes :)</p>



<a name="245994033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245994033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245994033">(Jul 14 2021 at 17:40)</a>:</h4>
<p>So we can just refer to the elements of <code>l</code> using <code>l.nth_le</code>. <a href="https://leanprover-community.github.io/mathlib_docs/find/list.pairwise_iff_nth_le">docs#list.pairwise_iff_nth_le</a> states that if a list is <code>pairwise R</code>, then <code>R (nth_le n _) (nth_le m _)</code> for <code>n &lt; m</code>. That means that for all elements <code>x y</code> in <code>l</code>, <code>R x y</code> if <code>x</code> comes before <code>y</code> in <code>l</code>.</p>



<a name="245994370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245994370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245994370">(Jul 14 2021 at 17:43)</a>:</h4>
<p>As a counterexample: Let's assume <code>g : graph</code> with:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">g.has_path_from_to</span> <span class="mi">10</span> <span class="mi">20</span>
<span class="n">g.has_path_from_to</span> <span class="mi">10</span> <span class="mi">30</span>
</code></pre></div>
<p>Then by the <code>∀</code>-based definition both <code>[10, 20, 30]</code> and <code>[10, 30, 20]</code> are topos over <code>g</code>.<br>
But by the <code>pairwise</code>-based definition there is no topo over <code>g</code>.<br>
Is this right?</p>



<a name="245994548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245994548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245994548">(Jul 14 2021 at 17:44)</a>:</h4>
<p>Is your path transitive?</p>



<a name="245994586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245994586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245994586">(Jul 14 2021 at 17:44)</a>:</h4>
<p>Yes, but the edges are directed :D <br>
I.e. <code>g.has_path_from_to x y</code> doesn't imply <code>g.has_path_from_to y x</code>.</p>



<a name="245994919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245994919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245994919">(Jul 14 2021 at 17:47)</a>:</h4>
<p><code>[10, 20, 30].pairwise R</code> means <code>10 R 20, 10 R 30, 20 R 30</code>. <code>pairwise</code> makes no requirement or statement about whether <code>R</code> is symmetric or not.</p>



<a name="245995190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245995190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245995190">(Jul 14 2021 at 17:49)</a>:</h4>
<p>Yes exactly, but in the case of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">g.has_path_from_to</span> <span class="mi">10</span> <span class="mi">20</span>
<span class="n">g.has_path_from_to</span> <span class="mi">10</span> <span class="mi">30</span>
</code></pre></div>
<p>The <code>20 R 30</code> part isn't true, but <code>[10, 20, 30]</code> should be valid.</p>



<a name="245995368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245995368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245995368">(Jul 14 2021 at 17:50)</a>:</h4>
<p>Aha, I see, I had the implication the wrong way.</p>



<a name="245995478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245995478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245995478">(Jul 14 2021 at 17:51)</a>:</h4>
<p>Thanks for taking the time anyway. Very much appreciated! <span aria-label="pray" class="emoji emoji-1f64f" role="img" title="pray">:pray:</span></p>



<a name="245995682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245995682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245995682">(Jul 14 2021 at 17:53)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/is_preorder">docs#is_preorder</a>, when your operate on the subtype of elements of <code>l</code>?</p>



<a name="245995745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245995745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245995745">(Jul 14 2021 at 17:53)</a>:</h4>
<p>or I guess even strong, <a href="https://leanprover-community.github.io/mathlib_docs/find/is_partial_order">docs#is_partial_order</a>?</p>



<a name="245996508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245996508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245996508">(Jul 14 2021 at 17:59)</a>:</h4>
<p>I think again I have the implication wrong. So I think what you had originally is good, but should use</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&lt;</span> <span class="n">l.length</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;</span> <span class="n">l.length</span><span class="o">),</span> <span class="n">g.has_path_from_to</span> <span class="o">(</span><span class="n">l.nth_le</span> <span class="n">n</span> <span class="o">‹</span><span class="n">_</span><span class="o">›)</span> <span class="o">(</span><span class="n">l.nth_le</span> <span class="n">m</span> <span class="o">‹</span><span class="n">_</span><span class="o">›)</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span>
</code></pre></div>



<a name="245998440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245998440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245998440">(Jul 14 2021 at 18:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/Ordered.20set/near/245996508">said</a>:</p>
<blockquote>
<p>I think again I have the implication wrong. So I think what you had originally is good, but should use</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&lt;</span> <span class="n">l.length</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;</span> <span class="n">l.length</span><span class="o">),</span> <span class="n">g.has_path_from_to</span> <span class="o">(</span><span class="n">l.nth_le</span> <span class="n">n</span> <span class="o">‹</span><span class="n">_</span><span class="o">›)</span> <span class="o">(</span><span class="n">l.nth_le</span> <span class="n">m</span> <span class="o">‹</span><span class="n">_</span><span class="o">›)</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span>
</code></pre></div><br>
</p>
</blockquote>
<p>What's the benefit of ...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&lt;</span> <span class="n">l.length</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;</span> <span class="n">l.length</span><span class="o">),</span> <span class="n">g.has_path_from_to</span> <span class="o">(</span><span class="n">l.nth_le</span> <span class="n">n</span> <span class="o">‹</span><span class="n">_</span><span class="o">›)</span> <span class="o">(</span><span class="n">l.nth_le</span> <span class="n">m</span> <span class="o">‹</span><span class="n">_</span><span class="o">›)</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span>
</code></pre></div>
<p>... over ...?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∀</span> <span class="n">i</span> <span class="n">i'</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">,</span> <span class="n">g.has_path_from_to</span> <span class="n">i</span> <span class="n">i'</span> <span class="bp">→</span> <span class="o">(</span><span class="n">l.index_of</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">l.index_of</span> <span class="n">i'</span><span class="o">)</span>
</code></pre></div>



<a name="245998760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/245998760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#245998760">(Jul 14 2021 at 18:17)</a>:</h4>
<p>The index_of version will be only useful if the list is nodup. Plus there are many more lemmas about <code>nth_le</code> than <code>index_of</code></p>



<a name="246000018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/246000018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#246000018">(Jul 14 2021 at 18:26)</a>:</h4>
<p>The contravariant version of <a href="https://leanprover-community.github.io/mathlib_docs/find/relator.lift_fun">docs#relator.lift_fun</a> would be useful here</p>



<a name="246000508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/246000508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#246000508">(Jul 14 2021 at 18:30)</a>:</h4>
<p>In the meantime, a convoluted way to say something about your list:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">l.length</span><span class="o">),</span> <span class="n">g.has_path_from_to</span> <span class="o">(</span><span class="n">l.nth_le</span> <span class="n">i</span> <span class="n">i.is_lt</span><span class="o">)</span> <span class="o">(</span><span class="n">l.nth_le</span> <span class="n">j</span> <span class="n">j.is_lt</span><span class="o">))</span> <span class="bp">⇒</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">))</span> <span class="n">id</span> <span class="n">id</span>
</code></pre></div>



<a name="246001106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/246001106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#246001106">(Jul 14 2021 at 18:35)</a>:</h4>
<p>Your phrasing was</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="o">(</span><span class="n">g.has_path_from_to</span> <span class="bp">⇒</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">list.index_of</span> <span class="n">i</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">list.index_of</span> <span class="n">i</span> <span class="n">l</span><span class="o">)</span>
</code></pre></div>



<a name="246001127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Ordered%20set/near/246001127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Ordered.20set.html#246001127">(Jul 14 2021 at 18:36)</a>:</h4>
<p>It's too bad that <code>l.index_of</code> is inferred to do the wrong thing.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html">Michael Stoll / confusion with addition</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="272282679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272282679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272282679">(Feb 17 2022 at 16:13)</a>:</h4>
<p>Hi, I am Michael Stoll; I am a math professor working in Arithmetic Geometry with a focus on how to compute things like rational points. I've been tangentially interested in formalizing math for a while and decided that I would now try it a bit more seriously (by supervising students formalizing stuff <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>). To get a feeling for what working with Lean is like, I've been playing around a bit. Doing so, I encountered the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.rat.basic</span>
<span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kn">namespace</span> <span class="n">experiment</span>

<span class="kd">def</span> <span class="n">Q_or_R</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">ℚ</span>
<span class="bp">|</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">ℝ</span>

<span class="kd">@[instance]</span>
<span class="kd">def</span> <span class="n">ring_Q_or_R</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="n">Q_or_R</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">real.ring</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">Q_or_R</span><span class="o">,</span> <span class="n">exact</span> <span class="n">comm_ring.to_ring</span> <span class="n">ℚ</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">comm</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Q_or_R</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h₁</span> <span class="o">:=</span> <span class="o">(</span><span class="n">ring_Q_or_R</span> <span class="n">b</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h₁.add_comm</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">comm'</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Q_or_R</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">(</span><span class="n">ring_Q_or_R</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">add_comm</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">experiment</span>
</code></pre></div>
<p>In the attempted proof of lemma <code>comm</code>, I get an error message at the last step, which says</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">type</span> <span class="n">ascription</span><span class="o">,</span> <span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">eq</span> <span class="o">(</span><span class="n">experiment.Q_or_R</span> <span class="n">b</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add</span> <span class="o">(</span><span class="n">experiment.Q_or_R</span> <span class="n">b</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">add_semigroup.to_has_add</span> <span class="o">(</span><span class="n">experiment.Q_or_R</span> <span class="n">b</span><span class="o">)</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">add_semigroup.mk</span> <span class="o">(</span><span class="n">experiment.Q_or_R</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">ring.add</span> <span class="o">(</span><span class="n">experiment.Q_or_R</span> <span class="n">b</span><span class="o">)</span> <span class="n">h₁</span><span class="o">)</span> <span class="n">_</span><span class="o">))</span>
       <span class="n">x</span>
       <span class="n">y</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add</span> <span class="o">(</span><span class="n">experiment.Q_or_R</span> <span class="n">b</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">add_semigroup.to_has_add</span> <span class="o">(</span><span class="n">experiment.Q_or_R</span> <span class="n">b</span><span class="o">)</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">add_semigroup.mk</span> <span class="o">(</span><span class="n">experiment.Q_or_R</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">ring.add</span> <span class="o">(</span><span class="n">experiment.Q_or_R</span> <span class="n">b</span><span class="o">)</span> <span class="n">h₁</span><span class="o">)</span> <span class="n">_</span><span class="o">))</span>
       <span class="n">y</span>
       <span class="n">x</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">eq</span> <span class="o">(</span><span class="n">experiment.Q_or_R</span> <span class="n">b</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add</span> <span class="o">(</span><span class="n">experiment.Q_or_R</span> <span class="n">b</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">distrib.to_has_add</span> <span class="o">(</span><span class="n">experiment.Q_or_R</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">ring.to_distrib</span> <span class="o">(</span><span class="n">experiment.Q_or_R</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">experiment.ring_Q_or_R</span> <span class="n">b</span><span class="o">)))</span>
       <span class="n">x</span>
       <span class="n">y</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add</span> <span class="o">(</span><span class="n">experiment.Q_or_R</span> <span class="n">b</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">distrib.to_has_add</span> <span class="o">(</span><span class="n">experiment.Q_or_R</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">ring.to_distrib</span> <span class="o">(</span><span class="n">experiment.Q_or_R</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">experiment.ring_Q_or_R</span> <span class="n">b</span><span class="o">)))</span>
       <span class="n">y</span>
       <span class="n">x</span><span class="o">)</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">b</span> <span class="o">:</span> <span class="n">bool</span><span class="o">,</span>
<span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Q_or_R</span> <span class="n">b</span><span class="o">,</span>
<span class="n">h₁</span> <span class="o">:</span> <span class="n">ring</span> <span class="o">(</span><span class="n">Q_or_R</span> <span class="n">b</span><span class="o">),</span>
<span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b_1</span> <span class="o">:</span> <span class="n">Q_or_R</span> <span class="n">b</span><span class="o">),</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b_1</span> <span class="bp">=</span> <span class="n">b_1</span> <span class="bp">+</span> <span class="n">a</span>
<span class="bp">⊢</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">x</span>
</code></pre></div>
<p>whereas the proof of <code>comm'</code> goes through.</p>
<p>Can someone explain what is going on here? And, perhaps more importantly, what is the correct way of getting Lean to realize that <code>Q_or_R b</code> is a ring (or a field...) and should be treated as such?</p>



<a name="272283769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272283769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272283769">(Feb 17 2022 at 16:21)</a>:</h4>
<p>What you are trying to do it is probably a little complicated. If you really want to play with something that is <code>ℝ</code> or <code>ℚ</code> you can try to copy what it is done for <a href="https://leanprover-community.github.io/mathlib_docs/find/is_R_or_C">docs#is_R_or_C</a>.</p>
<p>Have you a specific reason to do that? Otherwise I would suggest to just go with <code>ℚ</code>, or any field/ring.</p>



<a name="272285003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272285003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272285003">(Feb 17 2022 at 16:30)</a>:</h4>
<p>What I am really trying to do is having something like <code>completion_of_ℚ v</code>, where v is something encoding a place of ℚ (which can be infinite, then the completion is ℝ, or finite, then it is the field ℚ_p of p-adic numbers for some prime number p).<br>
Thanks for the pointer. To the beginner's eye, the definition of <code>is_R_or_C</code> does also look fairly complicated...<br>
But I also would like to understand what is going on behind the scenes in my example. Why does <code>comm'</code> work, while <code>comm</code> does not? One would think that both proofs are equivalent.</p>



<a name="272285101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272285101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272285101">(Feb 17 2022 at 16:31)</a>:</h4>
<p>Note that <code>is_R_or_C</code> really axiomatizes a set of properties possessed by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">C</span></span></span></span>, rather than making an inductive type which puts the two together.</p>



<a name="272285620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272285620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272285620">(Feb 17 2022 at 16:35)</a>:</h4>
<p><span class="user-mention" data-user-id="479359">@Michael Stoll</span> Note that <code>completion</code> of a valuation already exists. Are you looking for a way to uniformly treat these completions? Presumably you would need to prove theorems about complete (normed?) fields, or something like that.</p>



<a name="272286067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272286067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272286067">(Feb 17 2022 at 16:39)</a>:</h4>
<p>As a very basic first step, I would like to be able to do computations in these fields in a uniform way (i.e., using rw with field axioms or the ring tactic). Since mathlib has (reals and) p-adic fields, the necessary properties for each individual field should be available, so I would hope that one can just use that in some way.</p>



<a name="272286118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272286118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272286118">(Feb 17 2022 at 16:39)</a>:</h4>
<p>As a general trick, if <code>exact foo</code> doesn't work, you can try <code>convert foo</code>, that transforms what went wrong in goals. If you get like 28 goals, then it means something is probably false.</p>



<a name="272286142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272286142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272286142">(Feb 17 2022 at 16:39)</a>:</h4>
<p><span class="user-mention" data-user-id="479359">@Michael Stoll</span> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">comm</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Q_or_R</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">h₁</span> <span class="o">:=</span> <span class="o">(</span><span class="n">ring_Q_or_R</span> <span class="n">b</span><span class="o">),</span> <span class="c1">-- `let` instead of `have`</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h₁.add_comm</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="272286215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272286215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272286215">(Feb 17 2022 at 16:40)</a>:</h4>
<p>You need <code>let</code>, because <code>ring</code> includes the <em>data</em> about addition/mutliplication/etc...</p>



<a name="272286242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272286242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272286242">(Feb 17 2022 at 16:40)</a>:</h4>
<p><code>have</code> is only for propositions, it forgets all the data.</p>



<a name="272286336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272286336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272286336">(Feb 17 2022 at 16:41)</a>:</h4>
<p>OK, thanks!</p>



<a name="272286491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272286491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272286491">(Feb 17 2022 at 16:42)</a>:</h4>
<p>(Right now, I'm struggling to prove that <code>¬1 = 0</code> where 0 and 1 are rationals...)</p>



<a name="272287482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272287482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272287482">(Feb 17 2022 at 16:48)</a>:</h4>
<p><code>norm_num</code> is your friend!</p>



<a name="272287689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272287689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272287689">(Feb 17 2022 at 16:50)</a>:</h4>
<p>I doubt <code>is_R_or_C</code> is a model to follow. It's mostly a bunch of ad hoc axioms put together. I hope we get rid of it eventually.</p>



<a name="272287815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272287815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272287815">(Feb 17 2022 at 16:51)</a>:</h4>
<p>I agree <code>is_R_or_C</code> is not optimal, but its existence shows it's not easy to work with something that "is <code>ℝ</code> or <code>ℂ</code>".</p>



<a name="272288101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272288101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272288101">(Feb 17 2022 at 16:53)</a>:</h4>
<p><code>norm_num</code> does not appear to work here: <code>norm_num failed to simplify</code>.</p>



<a name="272288284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272288284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272288284">(Feb 17 2022 at 16:54)</a>:</h4>
<p>can you post a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>?</p>



<a name="272288416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272288416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272288416">(Feb 17 2022 at 16:55)</a>:</h4>
<p>Sorry, I realized that my 0 and 1 are living somewhere else (in a completion of ℚ ...).</p>



<a name="272288419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272288419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272288419">(Feb 17 2022 at 16:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition/near/272287689">said</a>:</p>
<blockquote>
<p>I doubt <code>is_R_or_C</code> is a model to follow. It's mostly a bunch of ad hoc axioms put together. I hope we get rid of it eventually.</p>
</blockquote>
<p>It could probably be replaced by something like <code>has_imaginary_unit</code> that provides <code>I</code> and some prop typeclasses, but it looks like a lot of effort for not a whole lot of gains.</p>



<a name="272289141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272289141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272289141">(Feb 17 2022 at 17:00)</a>:</h4>
<p>Or "simultaneously a a finite-dimensional extension field of <code>ℝ</code> and a <code>star_ring</code>, with the <code>star</code> fixing only <code>ℝ</code>", but again <br>
<span class="user-mention silent" data-user-id="311453">Frédéric Dupuis</span> <a href="#narrow/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition/near/272288419">said</a>:</p>
<blockquote>
<p>it looks like a lot of effort for not a whole lot of gains.</p>
</blockquote>



<a name="272289562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272289562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272289562">(Feb 17 2022 at 17:03)</a>:</h4>
<p>BTW <span class="user-mention" data-user-id="479359">@Michael Stoll</span> maybe you can just define <code>Q_or_R</code> as an inductive type with only two constructors, one for <code>ℚ</code> and one for <code>ℝ</code>. (It's morally the same as you have now.)</p>



<a name="272289600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272289600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272289600">(Feb 17 2022 at 17:03)</a>:</h4>
<p>Is there a theorem somewhere that 1 ≠ 0 in a field?</p>



<a name="272289699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272289699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272289699">(Feb 17 2022 at 17:04)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/zero_ne_one">docs#zero_ne_one</a></p>



<a name="272289739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272289739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272289739">(Feb 17 2022 at 17:04)</a>:</h4>
<p>With some <code>symm</code></p>



<a name="272289765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272289765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272289765">(Feb 17 2022 at 17:04)</a>:</h4>
<p>Even better, we have <a href="https://leanprover-community.github.io/mathlib_docs/find/one_ne_zero">docs#one_ne_zero</a></p>



<a name="272289789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272289789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272289789">(Feb 17 2022 at 17:04)</a>:</h4>
<p><span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> I'm essentially doing this in my actual code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">completion_of_ℚ</span> <span class="o">:</span> <span class="n">plcℚ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">infty</span> <span class="o">:=</span> <span class="n">ℝ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">finpl</span> <span class="n">p</span> <span class="n">h</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">exactI</span> <span class="n">padic</span> <span class="n">p</span>
</code></pre></div>



<a name="272290030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272290030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272290030">(Feb 17 2022 at 17:06)</a>:</h4>
<p>Thanks again. I guess I should have searched for "one_ne_zero" or similar in the docs...</p>



<a name="272290165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272290165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272290165">(Feb 17 2022 at 17:07)</a>:</h4>
<p>Yes, understanding the name convention is an important skill... at the beginning it's not very easy to get used to it, but it works very well</p>



<a name="272328792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272328792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272328792">(Feb 17 2022 at 21:47)</a>:</h4>
<p>We have some docs on it at <a href="https://leanprover-community.github.io/contribute/naming.html">https://leanprover-community.github.io/contribute/naming.html</a>, using this and the search in vscode (essentially grep with regex) and finally <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#library_search">tactic#library_search</a> are the most efficient ways of finding lemmas (maybe even in that order!)</p>



<a name="272354296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272354296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272354296">(Feb 18 2022 at 02:59)</a>:</h4>
<p>I haven't seen a lot of success on types defined via coproducts or their equivalent. So I'm interested to hear about your progress and results!</p>



<a name="272354847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272354847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272354847">(Feb 18 2022 at 03:06)</a>:</h4>
<p>The sensitivity conjecture proof does something in the same vein, <a href="https://github.com/leanprover-community/mathlib/blob/master/archive/sensitivity.lean#L148">https://github.com/leanprover-community/mathlib/blob/master/archive/sensitivity.lean#L148</a> and following</p>



<a name="272355009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272355009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272355009">(Feb 18 2022 at 03:09)</a>:</h4>
<p>That's cool, thanks Reid! But a little different, since many of the proofs are valid through induction on the index, not just casing on tt ff</p>



<a name="272355298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272355298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272355298">(Feb 18 2022 at 03:14)</a>:</h4>
<p>Is it the case there is some result where the results of the finite completions lead to a proof of the infinite completions?</p>



<a name="272445426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272445426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272445426">(Feb 18 2022 at 19:22)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> I'm still very much at the beginning and trying to find my way. I'll post something here when I have results (but more likely, I'll post some more questions before I get there...).</p>



<a name="272495159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272495159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272495159">(Feb 19 2022 at 05:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition/near/272355298">said</a>:</p>
<blockquote>
<p>Is it the case there is some result where the results of the finite completions lead to a proof of the infinite completions?</p>
</blockquote>
<p>There are some connections, yes! For example <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∏</mo><mi>v</mi></msub><mtext>∥</mtext><mi>x</mi><msub><mtext>∥</mtext><mi>v</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">∏_{v} ∥x∥_v = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0017em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∥</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> runs over all the finite and infinite valuations. In other words, if you have a rational number, and you take the product of all it's <code>p</code>-adic norms, then you get <code>∥(x : ℝ)∥⁻¹</code>.</p>



<a name="272495292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272495292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272495292">(Feb 19 2022 at 05:37)</a>:</h4>
<p>This means that you can compute one of the norms, if you know all the others. A more high-brow version of this is true for quadratic forms over <code>ℚ</code>: if you know all the Hilbert symbols are all-but-one of the completions, then you can compute the final one. And this is actually useful! It is an important ingredient in Ancona's proof of Grothendieck's "standard conjecture of Hodge type" for abelian fourfolds. (This was a recent advancement after decades of "no progress at all".)</p>



<a name="272507795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272507795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272507795">(Feb 19 2022 at 09:58)</a>:</h4>
<p>Hilbert symbols (and in particular, their product formula) are actually what I am after here.</p>



<a name="272514165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272514165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272514165">(Feb 19 2022 at 12:02)</a>:</h4>
<p>Just over Qp or general local fields?</p>



<a name="272534482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272534482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272534482">(Feb 19 2022 at 18:38)</a>:</h4>
<p>Over ℚ_p and ℝ for starters.</p>



<a name="272609821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272609821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272609821">(Feb 20 2022 at 18:59)</a>:</h4>
<p>Here is a question related to <code>ite</code>. Say, I have a term containing <code>ite P a b</code> and I have an assumption <code>h : P</code> in my state. I would like to rewrite <code>ite P a b</code> into <code>a</code>. So I was looking for a lemma in mathlib that says something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ite_left_of_cond</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">P</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">ite</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>so that I can do <code>rw ite_left_of_cond P x y h</code>. But this does not seem to exist in this form.<br>
It is not hard to prove this from what is in mathlib (from <code>ite_eq_iff</code>, say), but I was wondering why such an obvious-looking statement is not there. The statements that are there (like, e.g., <code>ite_eq_left_iff</code>) have, to my inexperienced eyes, a more conrived and less easy-to-use appearance.<br>
But maybe there is a better way to do what I want, and that's why nobody misses <code>ite_left_of_cond</code>?</p>



<a name="272610065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272610065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272610065">(Feb 20 2022 at 19:02)</a>:</h4>
<p>I usually reach for <code>simp [h]</code> first, then maybe try to find the right lemma later. It ends up being <a href="https://leanprover-community.github.io/mathlib_docs/find/if_pos">docs#if_pos</a></p>
<p>A way to find it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">lemma</span> <span class="n">ite_left_of_cond</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">P</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="n">ite</span> <span class="n">P</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">library_search</span>
<span class="kd">end</span>
</code></pre></div>



<a name="272610090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272610090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272610090">(Feb 20 2022 at 19:03)</a>:</h4>
<p><code>library_search</code> timed out on this.</p>



<a name="272610166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272610166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272610166">(Feb 20 2022 at 19:05)</a>:</h4>
<p>Did you have the decidability assumption?</p>



<a name="272610177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272610177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272610177">(Feb 20 2022 at 19:05)</a>:</h4>
<p>Thanks for the pointer to <code>if_pos</code>. Why are some statements dealing with <code>ite</code> named <code>if_...</code> rather than <code>ite_...</code>? It doesn't make it easier to find what you need...</p>



<a name="272610181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272610181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272610181">(Feb 20 2022 at 19:05)</a>:</h4>
<p>Did you run the code I posted, or did you try it with yours?  With mine, I made sure to put the <code>h : P</code> before the colon.</p>



<a name="272610257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272610257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272610257">(Feb 20 2022 at 19:07)</a>:</h4>
<p>OK, sorry, I missed the subtle difference between having he assumption before or after the colon.</p>



<a name="272610276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272610276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272610276">(Feb 20 2022 at 19:07)</a>:</h4>
<p>The way <code>library_search</code> works, as I understand it, is that it tries to <code>apply</code> everything in the entire library, which is why there's a difference here.</p>



<a name="272610367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272610367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272610367">(Feb 20 2022 at 19:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition/near/272610177">said</a>:</p>
<blockquote>
<p>Thanks for the pointer to <code>if_pos</code>. Why are some statements dealing with <code>ite</code> named <code>if_...</code> rather than <code>ite_...</code>? It doesn't make it easier to find what you need...</p>
</blockquote>
<p>It might be because things like <code>if_true</code> are in core; mathlib is much better at sticking to the naming conventions.</p>



<a name="272611834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272611834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272611834">(Feb 20 2022 at 19:40)</a>:</h4>
<p>(In fact, <code>if_pos</code> and <code>if_neg</code> are in core as well.)</p>



<a name="272612199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Michael%20Stoll%20/%20confusion%20with%20addition/near/272612199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition.html#272612199">(Feb 20 2022 at 19:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/113489-new-members/topic/Michael.20Stoll.20.2F.20confusion.20with.20addition/near/272610177">said</a>:</p>
<blockquote>
<p>Why are some statements dealing with <code>ite</code> named <code>if_...</code> rather than <code>ite_...</code>?</p>
</blockquote>
<p>There's notation for <code>ite P x y</code> that's commonly used: <code>if P then x else y</code>.  You can find lemmas having to do with <code>if h : P then x else y</code> under <code>dif</code> or <code>dite</code>, too, for "dependent if" or "dependent if-then-else".</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html">From exists_unique to a function</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="216638517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216638517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216638517">(Nov 13 2020 at 16:46)</a>:</h4>
<p>Hello,</p>
<p>I'm sorry that this question is quite similar to another one that I asked a while ago. I'd like to fix the code below:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">noncomputable theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="o">{</span><span class="bp">Ω</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">L</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="bp">Ω</span> <span class="bp">→</span> <span class="n">L</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>

<span class="kd">axiom</span> <span class="n">basic_general</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">=</span> <span class="n">B</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">L</span><span class="o">,</span> <span class="n">p</span> <span class="n">A</span> <span class="n">ℓ</span><span class="o">)</span>
<span class="kd">axiom</span> <span class="n">basic_neq</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">L</span><span class="o">,</span> <span class="n">p</span> <span class="n">A</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">B</span> <span class="n">ℓ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">line_through_points</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span> <span class="n">L</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">exact</span> <span class="n">classical.some</span> <span class="n">basic_general</span><span class="o">,</span> <span class="c1">-- this doesn't work</span>
    <span class="o">},</span>
    <span class="o">{</span>
        <span class="n">exact</span> <span class="n">classical.some</span> <span class="o">(</span><span class="n">basic_neq</span> <span class="n">h</span><span class="o">),</span>  <span class="c1">-- this doesn't work, either</span>
    <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">line_through_left</span> <span class="o">:</span> <span class="n">p</span> <span class="n">A</span> <span class="o">(</span><span class="n">line_through_points</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>  <span class="c1">-- how to prove this? should use classical.some_spec...</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">line_through_right</span> <span class="o">:</span> <span class="n">p</span> <span class="n">B</span> <span class="o">(</span><span class="n">line_through_points</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>  <span class="c1">-- how to prove this? should use classical.some_spec...</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">line_unique</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">A</span> <span class="n">ℓ</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">B</span> <span class="n">ℓ</span> <span class="bp">→</span> <span class="n">ℓ</span> <span class="bp">=</span> <span class="n">line_through_points</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>Essentially, I have two axioms (or lemmas, whatever) that guarantee the existence of a line through two points. If the points are distinct, then the line is unique. From this I would like to have a function that outputs a line in any case (when the points are equal, it will be one of the possibly infinitely many, I don't care). It is then in <code>line_unique</code> that the hypothesis of the points being different will get used.</p>
<p>I (think that I) know that <code>by_cases</code> shouldn't be used because I am constructing data, but I don't know how to do it properly. Any hints?</p>
<p>Thank you.</p>



<a name="216639592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216639592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216639592">(Nov 13 2020 at 16:53)</a>:</h4>
<p>doesn't <code>basic_general</code> need to take <code>h</code>?</p>



<a name="216639808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216639808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216639808">(Nov 13 2020 at 16:55)</a>:</h4>
<p>Wait, <code>basic_general</code> is inconsistent</p>



<a name="216640015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216640015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216640015">(Nov 13 2020 at 16:56)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span> <span class="k">let</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">f</span><span class="o">⟩</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">basic_general</span> <span class="n">unit</span> <span class="n">unit</span> <span class="o">()</span> <span class="o">()</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">false</span><span class="o">)</span> <span class="n">rfl</span> <span class="k">in</span> <span class="n">f</span>
</code></pre></div>



<a name="216640051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216640051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216640051">(Nov 13 2020 at 16:56)</a>:</h4>
<p>it seems unlikely that you want <code>p</code> to be a <code>variable</code> here</p>



<a name="216640250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216640250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216640250">(Nov 13 2020 at 16:58)</a>:</h4>
<p><code>basic_ne</code> is also inconsistent for a similar reason</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span> <span class="k">let</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">basic_neq</span> <span class="n">bool</span> <span class="n">unit</span> <span class="n">ff</span> <span class="n">tt</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">false</span><span class="o">)</span> <span class="n">bool.ff_ne_tt</span> <span class="k">in</span> <span class="n">f</span>
</code></pre></div>



<a name="216640289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216640289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216640289">(Nov 13 2020 at 16:58)</a>:</h4>
<p>A cleaner setup is to first prove a <code>lemma</code> that for any points <code>A B</code>, there is a line through <code>A</code> and <code>B</code></p>



<a name="216640350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216640350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216640350">(Nov 13 2020 at 16:59)</a>:</h4>
<p>use <code>classical.some</code> on that to define <code>line_through_points</code>, and <code>classical.some_spec</code> to prove the next two lemmas</p>



<a name="216640387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216640387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216640387">(Nov 13 2020 at 16:59)</a>:</h4>
<p>and for the last one you don't care what the definition of <code>line_through_points A B</code> is as long as you know it's also a line through <code>A</code> and <code>B</code></p>



<a name="216647757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216647757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216647757">(Nov 13 2020 at 17:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function/near/216640051">said</a>:</p>
<blockquote>
<p>it seems unlikely that you want <code>p</code> to be a <code>variable</code> here</p>
</blockquote>
<p>Sorry, I wanted a constant there. This is me failing to write a proper MWE...</p>



<a name="216649721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216649721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216649721">(Nov 13 2020 at 18:09)</a>:</h4>
<p>You edited your code above (changing a variable to a constant) so now Mario's observations don't apply, but neither do most of your comments. The first thing that you say doesn't work is easily fixed, the second thing you say doesn't work now works, and the things you say you can't prove now don't even compile.</p>



<a name="216650038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216650038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216650038">(Nov 13 2020 at 18:11)</a>:</h4>
<p>I'm working now on  doing what <span class="user-mention" data-user-id="110032">@Reid Barton</span> suggested. Just changed it back so now everything still applies...</p>



<a name="216650204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216650204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216650204">(Nov 13 2020 at 18:12)</a>:</h4>
<p>(deleted)</p>



<a name="216650380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216650380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216650380">(Nov 13 2020 at 18:14)</a>:</h4>
<p>When Ali Sever set all this up in Lean he didn't ever need to use a constant.</p>



<a name="216650496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216650496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216650496">(Nov 13 2020 at 18:15)</a>:</h4>
<p>Constants and axioms are dangerous.</p>



<a name="216650512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216650512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216650512">(Nov 13 2020 at 18:15)</a>:</h4>
<p>Yes, I am trying to set it up so that advanced results can be proved easily. This is the MWE I cooked up to ask the question.</p>



<a name="216650651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216650651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216650651">(Nov 13 2020 at 18:16)</a>:</h4>
<p>I have set it up in a structure (actually a class). The axioms originally were non-constructive, then I thought it would be easier to work with them if they were constructive. But now I think the best is to have them non-construtive, and then have some constructive functions and lemmas.</p>



<a name="216650781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216650781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216650781">(Nov 13 2020 at 18:17)</a>:</h4>
<p>Yeah, Ali used a class. This then somehow reduces the question "is there actually a model of what you're doing" to "can you prove these theorems about <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>"</p>



<a name="216650872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216650872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216650872">(Nov 13 2020 at 18:18)</a>:</h4>
<p>I also thought that it would be nice that <code>line_through_points</code> didn't need them to be different (a bit similar to the 1/0 issue). This way, in constructing proofs (a la Euclid) I'd say things like "take the line throught these two points", later on I'll see whether I need it to be unique (and use they are different) or not.</p>



<a name="216651526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216651526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216651526">(Nov 13 2020 at 18:23)</a>:</h4>
<p>So far I have this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">noncomputable theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="o">{</span><span class="bp">Ω</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">}</span>
<span class="kd">constant</span> <span class="n">p</span> <span class="o">:</span> <span class="bp">Ω</span> <span class="bp">→</span> <span class="n">L</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="kd">constant</span> <span class="n">basic_general</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span><span class="bp">=</span><span class="n">B</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">L</span><span class="o">,</span> <span class="n">p</span> <span class="n">A</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">B</span> <span class="n">ℓ</span><span class="o">)</span>

<span class="kd">constant</span> <span class="n">basic_neq</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">L</span><span class="o">,</span> <span class="n">p</span> <span class="n">A</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">B</span> <span class="n">ℓ</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">exists_line_through_points</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">L</span><span class="o">,</span> <span class="n">p</span> <span class="n">A</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">B</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">exact</span> <span class="n">basic_general</span> <span class="n">h</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
        <span class="n">apply</span> <span class="n">exists_of_exists_unique</span> <span class="o">(</span><span class="n">basic_neq</span> <span class="n">h</span><span class="o">),</span>
    <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">line_through_points</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span> <span class="n">L</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">exact</span> <span class="n">classical.some</span> <span class="o">(</span><span class="n">exists_line_through_points</span> <span class="n">A</span> <span class="n">B</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">line_through_left</span> <span class="o">:</span> <span class="n">p</span> <span class="n">A</span> <span class="o">(</span><span class="n">line_through_points</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">line_through_right</span> <span class="o">:</span> <span class="n">p</span> <span class="n">B</span> <span class="o">(</span><span class="n">line_through_points</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">line_unique</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">A</span> <span class="n">ℓ</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">B</span> <span class="n">ℓ</span> <span class="bp">→</span> <span class="n">ℓ</span> <span class="bp">=</span> <span class="n">line_through_points</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="216651592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216651592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216651592">(Nov 13 2020 at 18:23)</a>:</h4>
<p>But <code>line_through_left</code> doesn't typecheck, it says it doesn't know how to synthethize placeholder.</p>



<a name="216651764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216651764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216651764">(Nov 13 2020 at 18:24)</a>:</h4>
<p>Do you understand the full error message?</p>



<a name="216651847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216651847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216651847">(Nov 13 2020 at 18:25)</a>:</h4>
<p><code>line_through_points A B</code> gives</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">line_through_points</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="bp">Ω</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">},</span> <span class="bp">Ω</span> <span class="bp">→</span> <span class="bp">Ω</span> <span class="bp">→</span> <span class="n">L</span>
<span class="n">don't</span> <span class="n">know</span> <span class="n">how</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">placeholder</span>
<span class="n">context</span><span class="o">:</span>
<span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span>
<span class="bp">⊢</span> <span class="kt">Type</span>
</code></pre></div>



<a name="216651938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216651938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216651938">(Nov 13 2020 at 18:26)</a>:</h4>
<p>Try to be the compiler. The error message is correct.</p>



<a name="216652293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216652293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216652293">(Nov 13 2020 at 18:29)</a>:</h4>
<p>To me, line_through_points takes two terms of type Omega and spits out a term of type L.</p>



<a name="216652384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216652384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216652384">(Nov 13 2020 at 18:29)</a>:</h4>
<p>Your axioms are still not correct:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span> <span class="k">match</span> <span class="bp">@</span><span class="n">basic_general</span> <span class="n">unit</span> <span class="n">empty</span> <span class="o">()</span> <span class="o">()</span> <span class="n">rfl</span> <span class="k">with</span> <span class="kd">end</span>
</code></pre></div>



<a name="216652462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216652462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216652462">(Nov 13 2020 at 18:30)</a>:</h4>
<p>To Lean, <code>line_through_points</code> takes two types Omega and L, which Lean is supposed to guess because they are in <code>{}</code>s, and then two terms of type Omega (meaning that Lean can easily guess Omega) and then it's supposed to return a term of type L, but you didn't tell Lean what L was, and there's no way it can guess.</p>



<a name="216652573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216652573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216652573">(Nov 13 2020 at 18:31)</a>:</h4>
<p>the problem is that <code>p</code> is too general, it quantifies over all possible types</p>



<a name="216652654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216652654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216652654">(Nov 13 2020 at 18:31)</a>:</h4>
<p>you probably want Omega and L to be constants too</p>



<a name="216652661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216652661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216652661">(Nov 13 2020 at 18:31)</a>:</h4>
<p>I think that <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> and <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> are pointing to the same issue: I did a terrible mwe</p>



<a name="216652713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216652713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216652713">(Nov 13 2020 at 18:31)</a>:</h4>
<p>does the real version look like this?</p>



<a name="216652847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216652847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216652847">(Nov 13 2020 at 18:32)</a>:</h4>
<p>usually an MWE is made by deleting irrelevant things from the real example, so I wouldn't expect a <code>constant</code> to become a <code>variable</code></p>



<a name="216652887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216652887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216652887">(Nov 13 2020 at 18:32)</a>:</h4>
<p>Not at all. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">noncomputable theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">def</span> <span class="n">pts</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mem</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_pts</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mem</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="n">S</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span> <span class="o">:=</span>  <span class="kd">by</span> <span class="n">refl</span>

<span class="kd">notation</span> <span class="n">p</span> <span class="bp">`</span><span class="n">xor</span><span class="bp">`</span> <span class="n">q</span> <span class="o">:=</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">q</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">q</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">p</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">xor3</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">q</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">p</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">r</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">PreHilbertPlane</span> <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">Line</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
    <span class="o">(</span><span class="n">belongs</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Line</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
    <span class="o">(</span><span class="n">between</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

    <span class="o">(</span><span class="kd">notation</span> <span class="n">A</span> <span class="bp">`∈`</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">belongs</span> <span class="n">A</span> <span class="n">ℓ</span><span class="o">)</span>

    <span class="c1">-- I1: there is a unique line passing through two distinct points.</span>
    <span class="o">(</span><span class="n">I1'</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span><span class="o">)</span> <span class="o">,</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span>

    <span class="c1">-- I2: any line contains at least two points.</span>
    <span class="o">(</span><span class="n">I2'</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span>

    <span class="c1">-- I3: there exists 3 non-collinear points.</span>
    <span class="o">(</span><span class="n">I3'</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">C</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">))))</span>

<span class="kn">namespace</span> <span class="n">PreHilbertPlane</span>
<span class="kd">variables</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">PreHilbertPlane</span> <span class="bp">Ω</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="bp">Ω</span> <span class="o">(</span><span class="n">Line</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">belongs</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="n">Line.has_coe</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">Line</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">pts</span><span class="o">⟩</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_coe_to_mem</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">Ω</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>

<span class="kd">def</span> <span class="n">points_between</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">Ω</span> <span class="o">:=</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="bp">Ω</span> <span class="bp">|</span> <span class="n">between</span> <span class="n">A</span> <span class="n">P</span> <span class="n">B</span><span class="o">}</span>
<span class="kd">notation</span> <span class="n">A</span> <span class="bp">`*`</span> <span class="n">B</span> <span class="bp">`*`</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">PreHilbertPlane.between</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span>

<span class="c1">-- Put the axioms in terms of this has_mem</span>
<span class="kd">lemma</span> <span class="n">I1</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span><span class="o">),</span> <span class="o">(</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="o">:=</span> <span class="n">I1'</span> <span class="n">h</span>
<span class="kd">lemma</span> <span class="n">I2</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">I2'</span> <span class="n">ℓ</span>
<span class="kd">lemma</span> <span class="n">I3</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span><span class="o">,</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">C</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">I3'</span>


<span class="kd">def</span> <span class="n">collinear</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span><span class="o">),</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">C</span> <span class="bp">∈</span> <span class="n">ℓ</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">collinear_iff</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">}</span> <span class="o">:</span>
    <span class="n">collinear</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span><span class="o">,</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">C</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">rw</span> <span class="n">collinear</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">intersect</span> <span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">A</span><span class="o">,</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">r</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">s</span>

<span class="kd">def</span> <span class="n">parallel</span> <span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">r</span> <span class="bp">=</span> <span class="n">s</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">intersect</span> <span class="n">r</span> <span class="n">s</span><span class="o">)</span>
<span class="kd">notation</span> <span class="n">r</span> <span class="bp">`||`</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">parallel</span> <span class="n">r</span> <span class="n">s</span>

<span class="kd">end</span> <span class="n">PreHilbertPlane</span>

<span class="kn">open</span> <span class="n">PreHilbertPlane</span>

<span class="sd">/-- A segment is created by giving two points. -/</span>
<span class="kd">structure</span> <span class="n">Segment</span> <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span>
<span class="kd">notation</span> <span class="n">A</span> <span class="bp">`⬝`</span><span class="o">:</span><span class="mi">100</span> <span class="n">B</span> <span class="o">:=</span> <span class="n">Segment.mk</span> <span class="n">A</span> <span class="n">B</span>

<span class="kn">namespace</span> <span class="n">Segment</span>
<span class="kd">variables</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">PreHilbertPlane</span> <span class="bp">Ω</span><span class="o">]</span>

<span class="sd">/--</span>
<span class="sd">When thought of as a set, it is the the set consisting of the endpoints</span>
<span class="sd">and all the points between them</span>
<span class="sd">-/</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="bp">Ω</span> <span class="o">(</span><span class="n">Segment</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">P</span> <span class="n">S</span><span class="o">,</span> <span class="n">P</span> <span class="bp">=</span> <span class="n">S.A</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">=</span> <span class="n">S.B</span> <span class="bp">∨</span> <span class="n">S.A</span> <span class="bp">*</span> <span class="n">P</span> <span class="bp">*</span> <span class="n">S.B</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="n">has_coe_to_set</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">Segment</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">pts</span><span class="o">⟩</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_coe_to_mem_pts</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Segment</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">P</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">Ω</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">P</span> <span class="bp">=</span> <span class="n">S.A</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">=</span> <span class="n">S.B</span> <span class="bp">∨</span> <span class="n">S.A</span> <span class="bp">*</span> <span class="n">P</span> <span class="bp">*</span> <span class="n">S.B</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_pts</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Segment</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">P</span> <span class="bp">∈</span> <span class="n">S</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">P</span> <span class="bp">=</span> <span class="n">S.A</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">=</span> <span class="n">S.B</span> <span class="bp">∨</span> <span class="n">S.A</span> <span class="bp">*</span> <span class="n">P</span> <span class="bp">*</span> <span class="n">S.B</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>

<span class="kd">end</span> <span class="n">Segment</span>


<span class="kd">structure</span> <span class="n">Ray</span> <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">):=</span>
    <span class="o">(</span><span class="n">origin</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">(</span><span class="n">target</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span>
<span class="kd">notation</span> <span class="n">A</span> <span class="bp">`=&gt;`</span> <span class="n">B</span> <span class="o">:=</span> <span class="n">Ray.mk</span> <span class="n">A</span> <span class="n">B</span>

<span class="kn">namespace</span> <span class="n">Ray</span>
<span class="kd">variables</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">PreHilbertPlane</span> <span class="bp">Ω</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="bp">Ω</span> <span class="o">(</span><span class="n">Ray</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">P</span> <span class="n">r</span><span class="o">,</span> <span class="n">P</span> <span class="bp">=</span> <span class="n">r.origin</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">collinear</span> <span class="n">r.origin</span> <span class="n">P</span> <span class="n">r.target</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">r.origin</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">P</span><span class="bp">⬝</span><span class="n">r.target</span><span class="o">))⟩</span>

<span class="kd">instance</span> <span class="n">has_coe_to_set</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">Ray</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">pts</span><span class="o">⟩</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_coe_to_mem_pts</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">Ray</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">P</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">Ω</span><span class="o">)</span> <span class="bp">↔</span>
    <span class="n">P</span> <span class="bp">=</span> <span class="n">r.origin</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">collinear</span> <span class="n">r.origin</span> <span class="n">P</span> <span class="n">r.target</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">r.origin</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">P</span><span class="bp">⬝</span><span class="n">r.target</span><span class="o">))</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_pts</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">Ray</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">P</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="n">r</span> <span class="bp">↔</span> <span class="n">P</span> <span class="bp">=</span> <span class="n">r.origin</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">collinear</span> <span class="n">r.origin</span> <span class="n">P</span> <span class="n">r.target</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">r.origin</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">P</span><span class="bp">⬝</span><span class="n">r.target</span><span class="o">))</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>

<span class="kd">end</span> <span class="n">Ray</span>

<span class="kd">structure</span> <span class="n">Angle</span> <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span>
<span class="kd">notation</span> <span class="bp">`∟`</span><span class="o">:</span><span class="mi">100</span> <span class="o">:=</span> <span class="n">Angle.mk</span>

<span class="kn">namespace</span> <span class="n">Angle</span>
<span class="kd">variables</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">PreHilbertPlane</span> <span class="bp">Ω</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">nondegenerate</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Angle</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">¬</span> <span class="n">collinear</span> <span class="n">a.A</span> <span class="n">a.x</span> <span class="n">a.B</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="bp">Ω</span> <span class="o">(</span><span class="n">Angle</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">P</span> <span class="n">a</span><span class="o">,</span> <span class="n">P</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">a.x</span><span class="bp">=&gt;</span><span class="n">a.A</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">a.x</span><span class="bp">=&gt;</span><span class="n">a.B</span><span class="o">)⟩</span>

<span class="kd">instance</span> <span class="n">has_coe_to_set</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">Angle</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">pts</span><span class="o">⟩</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_coe_to_mem_pts</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Angle</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">P</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">Ω</span><span class="o">)</span> <span class="bp">↔</span>
    <span class="n">P</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">a.x</span><span class="bp">=&gt;</span><span class="n">a.A</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">a.x</span><span class="bp">=&gt;</span><span class="n">a.B</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_pts</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Angle</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">P</span> <span class="bp">∈</span> <span class="n">a</span> <span class="bp">↔</span>
    <span class="n">P</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">a.x</span><span class="bp">=&gt;</span><span class="n">a.A</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">a.x</span><span class="bp">=&gt;</span><span class="n">a.B</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>

<span class="kd">end</span> <span class="n">Angle</span>

<span class="kd">class</span> <span class="n">HilbertPlane</span> <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">PreHilbertPlane</span> <span class="n">Point</span> <span class="o">:=</span>
    <span class="c">/-</span><span class="cm"> Betweenness is symmetric -/</span>
    <span class="o">(</span><span class="n">B11</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">C</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">A</span><span class="o">))</span>
    <span class="c">/-</span><span class="cm"> If A * B * C then the three points are distinct and collinear. -/</span>
    <span class="o">(</span><span class="n">B12</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">collinear</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">))</span>
    <span class="c">/-</span><span class="cm"> Given two distinct points A, B, there is a third point C such that A * B * C.-/</span>
    <span class="o">(</span><span class="n">B2</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">C</span><span class="o">,</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)</span>
    <span class="c">/-</span><span class="cm"> Given 3 distinct collinear points A B C, exactly one of them is between the other two.-/</span>
    <span class="o">(</span><span class="n">B3</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">collinear</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span>
        <span class="n">xor3</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">C</span> <span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">C</span> <span class="bp">*</span> <span class="n">B</span><span class="o">))</span>

    <span class="o">(</span><span class="n">B4</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="n">Point</span><span class="o">}</span> <span class="o">{</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span><span class="o">}</span> <span class="c1">-- Pasch</span>
        <span class="o">(</span><span class="n">hnc</span><span class="o">:</span> <span class="bp">¬</span> <span class="n">collinear</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span>
        <span class="o">(</span><span class="n">hnAl</span><span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">))</span> <span class="o">(</span><span class="n">hnBl</span><span class="o">:</span> <span class="bp">¬</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">(</span><span class="n">hnCl</span><span class="o">:</span> <span class="bp">¬</span> <span class="n">C</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span>
        <span class="o">(</span><span class="n">hDl</span><span class="o">:</span> <span class="n">D</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">(</span><span class="n">hADB</span><span class="o">:</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">D</span> <span class="bp">*</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
            <span class="o">(</span><span class="bp">∃</span> <span class="n">E</span> <span class="o">,</span>  <span class="n">E</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">E</span> <span class="bp">*</span> <span class="n">C</span><span class="o">))</span> <span class="n">xor</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">E</span><span class="o">,</span> <span class="n">E</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">B</span> <span class="bp">*</span> <span class="n">E</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)))</span>

    <span class="o">(</span><span class="n">seg_cong</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Segment</span> <span class="n">Point</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
    <span class="o">(</span><span class="kd">notation</span> <span class="n">X</span> <span class="bp">`≅`</span><span class="o">:</span><span class="mi">50</span> <span class="n">Y</span> <span class="o">:=</span> <span class="n">seg_cong</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span>
    <span class="o">(</span><span class="n">ang_cong</span> <span class="o">:</span> <span class="n">Angle</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Angle</span> <span class="n">Point</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
    <span class="o">(</span><span class="kd">notation</span> <span class="n">X</span> <span class="bp">`≃`</span><span class="o">:</span><span class="mi">50</span> <span class="n">Y</span> <span class="o">:=</span> <span class="n">ang_cong</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span>

    <span class="c">/-</span><span class="cm"> Given a segment AB and a ray C-&gt;D, there is a unique point E on C-&gt;D such that</span>
<span class="cm">        AB ≅ CE. -/</span>
    <span class="o">(</span><span class="n">C1</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Segment</span> <span class="n">Point</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">Ray</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span>
        <span class="bp">∃!</span> <span class="n">E</span><span class="o">,</span> <span class="o">(</span><span class="n">E</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">((</span><span class="n">S.A</span><span class="bp">⬝</span><span class="n">S.B</span><span class="o">)</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">r.origin</span><span class="bp">⬝</span><span class="n">E</span><span class="o">)))</span>
    <span class="c">/-</span><span class="cm"> Congruence of segments is reverse-transitive -/</span>
    <span class="o">(</span><span class="n">C21</span> <span class="o">(</span><span class="n">S</span> <span class="n">T</span> <span class="n">U</span><span class="o">):</span> <span class="o">(</span><span class="n">S</span> <span class="bp">≅</span> <span class="n">T</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">S</span> <span class="bp">≅</span> <span class="n">U</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">T</span> <span class="bp">≅</span> <span class="n">U</span><span class="o">))</span>
    <span class="c">/-</span><span class="cm"> Congruence of segments is reflexive.</span>
<span class="cm">       Note that this together with C21 implies symmetry of congruence. -/</span>
    <span class="o">(</span><span class="n">C22</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">≅</span> <span class="n">S</span><span class="o">)</span>
    <span class="c">/-</span><span class="cm"> Congruence of segments respects the notion of sum of segments -/</span>
    <span class="o">(</span><span class="n">C3</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="n">E</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">D</span> <span class="bp">*</span> <span class="n">E</span> <span class="bp">*</span> <span class="n">F</span><span class="o">)</span> <span class="bp">→</span>
        <span class="o">((</span><span class="n">A</span><span class="bp">⬝</span><span class="n">B</span><span class="o">)</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">D</span><span class="bp">⬝</span><span class="n">E</span><span class="o">))</span> <span class="bp">→</span> <span class="o">((</span><span class="n">B</span><span class="bp">⬝</span><span class="n">C</span><span class="o">)</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">E</span><span class="bp">⬝</span><span class="n">F</span><span class="o">))</span> <span class="bp">→</span> <span class="o">((</span><span class="n">A</span><span class="bp">⬝</span><span class="n">C</span><span class="o">)</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">D</span><span class="bp">⬝</span><span class="n">F</span><span class="o">)))</span>
    <span class="c">/-</span><span class="cm"> Given a nondegenerate angle α, a segment AB, and a point s,</span>
<span class="cm">       construct a point E on the same side as s, such that ∟EAB ≃ α. -/</span>
    <span class="o">(</span><span class="n">C4</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">Angle</span> <span class="n">Point</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Ray</span> <span class="n">Point</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span>
        <span class="o">(</span><span class="n">hα</span> <span class="o">:</span> <span class="n">α.nondegenerate</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">collinear</span> <span class="n">s</span> <span class="n">S.origin</span> <span class="n">S.target</span><span class="o">)</span>
        <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="n">S.origin</span> <span class="bp">≠</span> <span class="n">S.target</span><span class="o">)</span> <span class="o">:</span>  <span class="bp">∃!</span> <span class="n">E</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span>
        <span class="o">(</span><span class="bp">∟</span> <span class="n">E</span> <span class="n">S.origin</span> <span class="n">S.target</span> <span class="bp">≃</span> <span class="n">α</span><span class="o">)</span> <span class="bp">∧</span>
         <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">E</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span><span class="o">),</span> <span class="n">S.origin</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">S.target</span> <span class="bp">∈</span> <span class="n">ℓ</span>
         <span class="bp">→</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span>
    <span class="c">/-</span><span class="cm"></span>
<span class="cm">    (C4spec (α : Angle Point) (S : Ray Point) (s : Point)</span>
<span class="cm">        (hα : α.nondegenerate) (hs : ¬ collinear s S.origin S.target)</span>
<span class="cm">        (hr : S.origin ≠ S.target) : (∟ (C4 α S s hα hs hr) S.origin S.target ≃ α) ∧</span>
<span class="cm">        (∀ (x : Point), ((C4 α S s hα hs hr) * x * s) → ¬ x ∈ line_through hr))</span>
<span class="cm">    (C4uniq (α : Angle Point) (S : Ray Point) (s : Point) (Z : Point)</span>
<span class="cm">        (hBAC : α.nondegenerate) (hs : ¬ collinear s S.origin S.target) (hr : S.origin ≠ S.target) :</span>
<span class="cm">         (∟ Z S.origin S.target ≃ α) →</span>
<span class="cm">         ((∀ (x : Point), (Z * x * s) → ¬ x ∈ line_through hr)) →</span>
<span class="cm">         pts (S.origin=&gt;Z) = pts (S.origin=&gt;(C4 α S s hBAC hs hr)))</span>
<span class="cm">    -/</span>
    <span class="c">/-</span><span class="cm"> Congruence of angles is reverse-transitive.-/</span>
    <span class="o">(</span><span class="n">C5</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="n">Angle</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">≃</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">≃</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">≃</span> <span class="n">γ</span><span class="o">)</span>
    <span class="c">/-</span><span class="cm"> Given triangles T and T', if they have two sides and their middle angle</span>
<span class="cm">       congruent, then the third sides and the other two angles are also congruent.-/</span>
    <span class="o">(</span><span class="n">C6</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">A'</span> <span class="n">B'</span> <span class="n">C'</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span><span class="bp">⬝</span><span class="n">B</span> <span class="bp">≅</span> <span class="n">A'</span><span class="bp">⬝</span><span class="n">B'</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">A</span><span class="bp">⬝</span><span class="n">C</span> <span class="bp">≅</span> <span class="n">A'</span><span class="bp">⬝</span><span class="n">C'</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∟</span> <span class="n">B</span> <span class="n">A</span> <span class="n">C</span> <span class="bp">≃</span> <span class="bp">∟</span> <span class="n">B'</span> <span class="n">A'</span> <span class="n">C'</span><span class="o">)</span> <span class="bp">→</span>
        <span class="o">(</span><span class="n">B</span><span class="bp">⬝</span><span class="n">C</span> <span class="bp">≅</span> <span class="n">B'</span><span class="bp">⬝</span><span class="n">C'</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∟</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="bp">≃</span> <span class="bp">∟</span> <span class="n">A'</span> <span class="n">B'</span> <span class="n">C'</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∟</span> <span class="n">A</span> <span class="n">C</span> <span class="n">B</span> <span class="bp">≃</span> <span class="bp">∟</span> <span class="n">A'</span> <span class="n">C'</span> <span class="n">B'</span><span class="o">))</span>

<span class="kd">class</span> <span class="n">EuclideanPlane</span> <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">HilbertPlane</span> <span class="n">Point</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">parallel_postulate</span> <span class="o">{</span><span class="n">ℓ</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Line</span><span class="o">}</span> <span class="o">:</span>
        <span class="o">(</span><span class="n">intersect</span> <span class="n">r</span> <span class="n">s</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">r</span> <span class="bp">||</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">s</span> <span class="bp">||</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">r</span> <span class="bp">=</span> <span class="n">s</span><span class="o">))</span>

<span class="kn">namespace</span> <span class="n">HilbertPlane</span>

<span class="kd">notation</span> <span class="n">X</span> <span class="bp">`≅`</span><span class="o">:</span><span class="mi">50</span> <span class="n">Y</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">HilbertPlane.seg_cong</span> <span class="n">X</span> <span class="n">Y</span>
<span class="kd">notation</span> <span class="n">X</span> <span class="bp">`≃`</span><span class="o">:</span><span class="mi">50</span> <span class="n">Y</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">HilbertPlane.ang_cong</span> <span class="n">X</span> <span class="n">Y</span>


<span class="kd">structure</span> <span class="n">Triangle</span> <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span>
<span class="kd">notation</span> <span class="bp">`▵`</span><span class="o">:</span><span class="mi">100</span> <span class="o">:=</span> <span class="n">Triangle.mk</span>

<span class="kn">namespace</span> <span class="n">Triangle</span>
<span class="kd">variables</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">HilbertPlane</span> <span class="bp">Ω</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">nondegenerate</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">Triangle</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">¬</span> <span class="n">collinear</span> <span class="n">T.A</span> <span class="n">T.B</span> <span class="n">T.C</span>

<span class="kd">def</span> <span class="n">congruent_triangles</span> <span class="o">(</span><span class="n">T</span> <span class="n">R</span> <span class="o">:</span> <span class="n">Triangle</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">T.A</span><span class="bp">⬝</span><span class="n">T.B</span> <span class="bp">≅</span> <span class="n">R.A</span><span class="bp">⬝</span><span class="n">R.B</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">T.A</span><span class="bp">⬝</span><span class="n">T.C</span> <span class="bp">≅</span> <span class="n">R.A</span><span class="bp">⬝</span><span class="n">R.C</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">T.B</span><span class="bp">⬝</span><span class="n">T.C</span> <span class="bp">≅</span> <span class="n">R.B</span><span class="bp">⬝</span><span class="n">R.C</span><span class="o">)</span>
    <span class="bp">∧</span> <span class="o">(</span><span class="bp">∟</span> <span class="n">T.B</span> <span class="n">T.A</span> <span class="n">T.C</span> <span class="bp">≃</span> <span class="bp">∟</span> <span class="n">R.B</span> <span class="n">R.A</span> <span class="n">R.C</span><span class="o">)</span>
    <span class="bp">∧</span> <span class="o">(</span><span class="bp">∟</span> <span class="n">T.A</span> <span class="n">T.C</span> <span class="n">T.B</span> <span class="bp">≃</span> <span class="bp">∟</span> <span class="n">R.A</span> <span class="n">R.C</span> <span class="n">R.B</span><span class="o">)</span>
    <span class="bp">∧</span> <span class="o">(</span><span class="bp">∟</span> <span class="n">T.C</span> <span class="n">T.B</span> <span class="n">T.A</span> <span class="bp">≃</span> <span class="bp">∟</span> <span class="n">R.C</span> <span class="n">R.B</span> <span class="n">R.A</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="bp">Ω</span> <span class="o">(</span><span class="n">Triangle</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">P</span> <span class="n">T</span><span class="o">,</span> <span class="n">P</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">T.A</span><span class="bp">⬝</span><span class="n">T.B</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">T.B</span><span class="bp">⬝</span><span class="n">T.C</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">T.A</span><span class="bp">⬝</span><span class="n">T.C</span><span class="o">)⟩</span>

<span class="kd">instance</span> <span class="n">has_coe_to_set</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">Triangle</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">pts</span><span class="o">⟩</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_coe_to_mem_pts</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">Triangle</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">P</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">Ω</span><span class="o">)</span> <span class="bp">↔</span>
    <span class="n">P</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">T.A</span><span class="bp">⬝</span><span class="n">T.B</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">T.B</span><span class="bp">⬝</span><span class="n">T.C</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">T.A</span><span class="bp">⬝</span><span class="n">T.C</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_pts</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">Triangle</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">P</span> <span class="bp">∈</span> <span class="n">T</span> <span class="bp">↔</span>
    <span class="n">P</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">T.A</span><span class="bp">⬝</span><span class="n">T.B</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">T.B</span><span class="bp">⬝</span><span class="n">T.C</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="o">(</span><span class="n">T.A</span><span class="bp">⬝</span><span class="n">T.C</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>

<span class="kd">end</span> <span class="n">Triangle</span>

<span class="kd">end</span> <span class="n">HilbertPlane</span>
</code></pre></div>



<a name="216652929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216652929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216652929">(Nov 13 2020 at 18:33)</a>:</h4>
<p>So what's the actual question?</p>



<a name="216652990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216652990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216652990">(Nov 13 2020 at 18:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function/near/216652847">said</a>:</p>
<blockquote>
<p>usually an MWE is made by deleting irrelevant things from the real example, so I wouldn't expect a <code>constant</code> to become a <code>variable</code></p>
</blockquote>
<p>I guess I was trying to aks a question and provide an example to illustrate, and I messed up.</p>



<a name="216653001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216653001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216653001">(Nov 13 2020 at 18:33)</a>:</h4>
<p>aha, so you should probably delete unneeded fields from the structure and using <code>sorry</code> for the lemmas</p>



<a name="216653307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216653307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216653307">(Nov 13 2020 at 18:35)</a>:</h4>
<p>You can change those <code>by refl</code> tactic proofs to <code>iff.rfl</code> term proofs (I remark this in passing while I'm waiting for the question :D )</p>



<a name="216653311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216653311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216653311">(Nov 13 2020 at 18:35)</a>:</h4>
<p>(working on this)...</p>



<a name="216654577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216654577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216654577">(Nov 13 2020 at 18:44)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">noncomputable theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">def</span> <span class="n">pts</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mem</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_pts</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mem</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">pts</span> <span class="n">S</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span> <span class="o">:=</span>  <span class="kd">by</span> <span class="n">refl</span>

<span class="kd">class</span> <span class="n">PreHilbertPlane</span> <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">Line</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
    <span class="o">(</span><span class="n">belongs</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Line</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
    <span class="o">(</span><span class="n">between</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

    <span class="o">(</span><span class="kd">notation</span> <span class="n">A</span> <span class="bp">`∈`</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">belongs</span> <span class="n">A</span> <span class="n">ℓ</span><span class="o">)</span>

    <span class="c1">-- I1: there is a unique line passing through two distinct points.</span>
    <span class="o">(</span><span class="n">I1'</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span><span class="o">)</span> <span class="o">,</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span>

    <span class="c1">-- I3: there exists 3 non-collinear points.</span>
    <span class="o">(</span><span class="n">I3'</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">C</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">))))</span>

<span class="kn">namespace</span> <span class="n">PreHilbertPlane</span>
<span class="kd">variables</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">PreHilbertPlane</span> <span class="bp">Ω</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="bp">Ω</span> <span class="o">(</span><span class="n">Line</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">belongs</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="n">Line.has_coe</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">Line</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">pts</span><span class="o">⟩</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_coe_to_mem</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">Ω</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refl</span>

<span class="c1">-- Put the axioms in terms of this has_mem</span>
<span class="kd">lemma</span> <span class="n">I1</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span><span class="o">),</span> <span class="o">(</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="o">:=</span> <span class="n">I1'</span> <span class="n">h</span>
<span class="kd">lemma</span> <span class="n">I3</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span><span class="o">,</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">C</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">I3'</span>

<span class="kd">end</span> <span class="n">PreHilbertPlane</span>

<span class="kn">open</span> <span class="n">PreHilbertPlane</span>
<span class="kd">variables</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">PreHilbertPlane</span> <span class="bp">Ω</span><span class="o">]</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">ℓ</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">I11</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span><span class="o">),</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">exists_of_exists_unique</span> <span class="o">(</span><span class="n">I1</span> <span class="n">h</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">I12</span>
    <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hAr</span><span class="o">:</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">hBr</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">hAs</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hBs</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">apply</span> <span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">I1</span> <span class="n">h</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">tauto</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">there_are_two_points</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">rcases</span> <span class="n">I3</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span> <span class="o">⟨</span><span class="n">C</span><span class="o">,</span> <span class="o">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">⟩⟩⟩⟩,</span>
    <span class="n">use</span> <span class="o">[</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">],</span>
    <span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">line_through_points</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span><span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">line_through_points_left</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">}:</span> <span class="n">A</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">line_through_points</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">line_through_points_right</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">}:</span> <span class="n">B</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">line_through_points</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">line_unique</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">→</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">→</span> <span class="n">ℓ</span> <span class="bp">=</span> <span class="n">line_through_points</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>The question: I'd like to fill in the sorrys. But after what <span class="user-mention" data-user-id="110032">@Reid Barton</span> suggested maybe I can work it out myself!</p>



<a name="216656406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216656406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216656406">(Nov 13 2020 at 18:56)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">exists_point_ne</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span> <span class="n">C</span><span class="o">,</span> <span class="n">hBC</span><span class="o">⟩</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">there_are_two_points</span> <span class="bp">Ω</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">subst</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">hBC</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">line_through_points_aux</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span> <span class="o">{</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span> <span class="bp">//</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">classical.indefinite_description</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">subst</span> <span class="n">B</span><span class="o">,</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">exists_point_ne</span> <span class="n">A</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">ℓ</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">I11</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">ℓ</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">I11</span> <span class="n">h</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">line_through_points</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span> <span class="o">:=</span> <span class="o">(</span><span class="n">line_through_points_aux</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>

<span class="kd">lemma</span> <span class="n">line_through_points_left</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">}:</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">line_through_points</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">line_through_points_aux</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span>

<span class="kd">lemma</span> <span class="n">line_through_points_right</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">}:</span> <span class="n">B</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">line_through_points</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">line_through_points_aux</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span>

<span class="kd">lemma</span> <span class="n">line_unique</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">→</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">→</span> <span class="n">ℓ</span> <span class="bp">=</span> <span class="n">line_through_points</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">ab</span> <span class="n">al</span> <span class="n">bl</span><span class="o">,</span> <span class="n">I12</span> <span class="n">ab</span> <span class="n">al</span> <span class="n">bl</span> <span class="n">line_through_points_left</span> <span class="n">line_through_points_right</span>
</code></pre></div>



<a name="216660104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216660104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216660104">(Nov 13 2020 at 19:27)</a>:</h4>
<p>I didn't know about indefinite_description!</p>



<a name="216661729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216661729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216661729">(Nov 13 2020 at 19:34)</a>:</h4>
<p>you can also use <code>classical.choice</code> instead, it's basically the same proof</p>



<a name="216661885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216661885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216661885">(Nov 13 2020 at 19:36)</a>:</h4>
<p>to use <code>some</code> and <code>some_spec</code> you would factor the proof a little differently:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">line_through_points_aux</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span><span class="o">,</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">subst</span> <span class="n">B</span><span class="o">,</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">exists_point_ne</span> <span class="n">A</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">ℓ</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">I11</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">ℓ</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">I11</span> <span class="n">h</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">line_through_points</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span> <span class="o">:=</span> <span class="n">classical.some</span> <span class="o">(</span><span class="n">line_through_points_aux</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">line_through_points_left</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">}:</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">line_through_points</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">classical.some_spec</span> <span class="o">(</span><span class="n">line_through_points_aux</span> <span class="n">A</span> <span class="n">B</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span>

<span class="kd">lemma</span> <span class="n">line_through_points_right</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">}:</span> <span class="n">B</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">line_through_points</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">classical.some_spec</span> <span class="o">(</span><span class="n">line_through_points_aux</span> <span class="n">A</span> <span class="n">B</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span>
</code></pre></div>



<a name="216670491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216670491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216670491">(Nov 13 2020 at 20:45)</a>:</h4>
<p>How come</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">line_through_points_aux</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span> <span class="o">{</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span> <span class="bp">//</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">classical.indefinite_description</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">subst</span> <span class="n">B</span><span class="o">,</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">exists_point_ne</span> <span class="n">A</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">ℓ</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">I11</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">ℓ</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">I11</span> <span class="n">h</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>is clearly not best practice, making a definition in tactic mode and using eq.rec etc, and yet you don't run into any trouble? The some/some_spec route I completely understand and this would have been the route I would have taken.</p>



<a name="216671076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216671076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216671076">(Nov 13 2020 at 20:50)</a>:</h4>
<p>Because you never plan to look at the definition again anyways, just use the information encoded in the type</p>



<a name="216671161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216671161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216671161">(Nov 13 2020 at 20:50)</a>:</h4>
<p>it could be <code>@[irreducible] def</code></p>



<a name="216671362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216671362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216671362">(Nov 13 2020 at 20:52)</a>:</h4>
<p>Aah I see! You don't need to use any properties of the term the function produces, other than the fact that its type is its type.</p>



<a name="216721926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216721926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216721926">(Nov 14 2020 at 10:49)</a>:</h4>
<p>Here is my solution (the first lemma should be written in a much shorter way, I know). Thanks so much for all the discussion. This is helping me in understanding the differences between Prop and Type.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">exists_line_through_points</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span><span class="o">),</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">subst</span> <span class="n">h</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">,</span> <span class="n">C</span> <span class="bp">≠</span> <span class="n">D</span> <span class="o">:=</span> <span class="n">there_are_two_points</span><span class="o">,</span>
        <span class="n">obtain</span> <span class="o">⟨</span><span class="n">C</span><span class="o">,</span> <span class="n">D</span><span class="o">,</span> <span class="n">hCD</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">H</span><span class="o">,</span>
        <span class="n">by_cases</span> <span class="n">hAC</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">C</span><span class="o">,</span>
        <span class="o">{</span>
            <span class="n">subst</span> <span class="n">hAC</span><span class="o">,</span>
            <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span><span class="o">,</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">D</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">I11</span> <span class="n">hCD</span><span class="o">,</span>
            <span class="n">obtain</span> <span class="o">⟨</span><span class="n">ℓ</span><span class="o">,</span> <span class="n">hAℓ</span><span class="o">,</span> <span class="n">hCℓ</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h2</span><span class="o">,</span>
            <span class="n">use</span> <span class="n">ℓ</span><span class="o">,</span>
            <span class="n">tauto</span><span class="o">,</span>
        <span class="o">},</span>
        <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span><span class="o">,</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">C</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="o">:=</span> <span class="n">I11</span> <span class="n">hAC</span><span class="o">,</span>
        <span class="n">obtain</span> <span class="o">⟨</span><span class="n">ℓ</span><span class="o">,</span> <span class="n">hAℓ</span><span class="o">,</span> <span class="n">hCℓ</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h2</span><span class="o">,</span>
        <span class="n">use</span> <span class="n">ℓ</span><span class="o">,</span>
        <span class="n">tauto</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
        <span class="n">exact</span> <span class="n">I11</span> <span class="n">h</span><span class="o">,</span>
    <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">line_through_points</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span> <span class="o">:=</span>
    <span class="n">classical.some</span> <span class="o">(</span><span class="n">exists_line_through_points</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">line_through_points_left</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">line_through_points</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
     <span class="o">(</span><span class="n">classical.some_spec</span> <span class="o">(</span><span class="n">exists_line_through_points</span> <span class="n">A</span> <span class="n">B</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span>

<span class="kd">lemma</span> <span class="n">line_through_points_right</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">}</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">line_through_points</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">classical.some_spec</span> <span class="o">(</span><span class="n">exists_line_through_points</span> <span class="n">A</span> <span class="n">B</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span>

<span class="kd">lemma</span> <span class="n">points_mem_of_line_through_points</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">line_through_points</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">line_through_points</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">⟨</span><span class="n">line_through_points_left</span><span class="o">,</span> <span class="n">line_through_points_right</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">line_unique</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">→</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">→</span> <span class="n">ℓ</span> <span class="bp">=</span> <span class="n">line_through_points</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:=</span>
    <span class="bp">λ</span> <span class="n">h</span> <span class="n">hAℓ</span> <span class="n">hBℓ</span><span class="o">,</span> <span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">I1</span> <span class="n">h</span><span class="o">)</span> <span class="o">⟨</span><span class="n">hAℓ</span><span class="o">,</span> <span class="n">hBℓ</span><span class="o">⟩</span> <span class="n">points_mem_of_line_through_points</span>
</code></pre></div>



<a name="216722449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/216722449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#216722449">(Nov 14 2020 at 10:59)</a>:</h4>
<p>Maybe you could factor out a lemma that there exists a line through one point for the first</p>



<a name="217008571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/217008571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#217008571">(Nov 17 2020 at 14:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function/near/216671362">said</a>:</p>
<blockquote>
<p>Aah I see! You don't need to use any properties of the term the function produces, other than the fact that its type is its type.</p>
</blockquote>
<p>Does this mean that you should mark the <code>def</code> a <code>lemma</code>, even though doing so is obviously unusual?</p>



<a name="217010588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/217010588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#217010588">(Nov 17 2020 at 14:41)</a>:</h4>
<p>I don't think this is the case. I think the tactic here works because <code>classical.indefinite_description</code> constructs data out of a <code>p : Line Ω → Prop</code> term and a <code>(h : ∃ x, p x)</code> term, which is the supplied proof. The <code>apply classical.indefinite_description</code> step takes care of inferring the <code>p</code> data, and the rest (the Prop term) can be done via tactics as usual.</p>



<a name="217018767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/From%20exists_unique%20to%20a%20function/near/217018767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/From.20exists_unique.20to.20a.20function.html#217018767">(Nov 17 2020 at 15:38)</a>:</h4>
<p>That's also because that <code>def</code> is equivalent to the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">line_through_points_aux</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:</span> <span class="o">{</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Line</span> <span class="bp">Ω</span> <span class="bp">//</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℓ</span><span class="o">}</span> <span class="o">:=</span>
<span class="n">classical.indefinite_description</span> <span class="n">_</span> <span class="o">(</span><span class="n">dite</span> <span class="o">(</span><span class="n">A</span> <span class="bp">=</span> <span class="n">B</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">exists.elim</span> <span class="o">(</span><span class="n">exists_point_ne</span> <span class="n">A</span><span class="o">)</span>
        <span class="o">(</span><span class="bp">λ</span> <span class="n">C</span> <span class="n">hne</span><span class="o">,</span> <span class="n">exists.elim</span> <span class="o">(</span><span class="n">I11</span> <span class="n">hne</span><span class="o">)</span>
            <span class="o">(</span><span class="bp">λ</span> <span class="n">ℓ</span> <span class="o">⟨</span><span class="n">hA</span><span class="o">,</span> <span class="n">hC</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">hA</span><span class="o">,</span> <span class="n">h</span> <span class="bp">▸</span> <span class="n">hA</span><span class="o">⟩)))</span>
    <span class="n">I11</span><span class="o">)</span>
</code></pre></div>
<p>and my understanding is that <code>subst</code> and <code>obtain</code> are term-friendly.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html">Lynn's has_duplicate exercise</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="193218502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193218502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lynn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193218502">(Apr 07 2020 at 17:04)</a>:</h4>
<p>Hey, I decided on a neat exercise for myself and figured I'd make a topic for all the questions I have along the way.</p>
<p>I defined some types:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fin</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">list</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>
<span class="kn">open</span> <span class="n">fin</span>
<span class="kn">open</span> <span class="n">vector</span>

<span class="n">def</span> <span class="n">duplicate</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span><span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span><span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span><span class="o">:</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span> <span class="bp">∧</span> <span class="n">nth</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">nth</span> <span class="n">v</span> <span class="n">j</span>
<span class="n">def</span> <span class="n">has_duplicate</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span><span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span><span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span><span class="o">(</span><span class="n">i</span> <span class="n">j</span><span class="o">:</span><span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">duplicate</span> <span class="n">v</span> <span class="n">i</span> <span class="n">j</span>
</pre></div>


<p>The exercise, for now, is: I want to prove that <code>has_duplicate</code> is a decidable property of vectors.</p>
<p>So, I started writing an instance for the <code>decidable</code> class. Here's my proof so far.</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">dec_duplicate</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span><span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span><span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">has_duplicate</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="c1">-- I&#39;ll perform induction on the list inside the vector.</span>
  <span class="n">cases</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">v_val</span><span class="o">,</span>

  <span class="c1">-- Empty list case: there is no duplicate because i cannot even exist.</span>
  <span class="n">suffices</span> <span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">has_duplicate</span> <span class="bp">⟨</span><span class="n">list</span><span class="bp">.</span><span class="n">nil</span><span class="o">,</span> <span class="n">v_property</span><span class="bp">⟩</span> <span class="o">),</span> <span class="k">from</span> <span class="o">(</span><span class="n">is_false</span> <span class="n">f</span><span class="o">),</span>
  <span class="n">intro</span> <span class="n">p</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">p</span> <span class="k">with</span> <span class="n">i</span> <span class="n">p</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">v_property</span><span class="o">,</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">v_property</span> <span class="n">at</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">i</span><span class="bp">.</span><span class="n">elim0</span><span class="o">,</span>

  <span class="c1">-- TODO: recursive case:</span>
  <span class="c1">--   1. If head ∈ tail, there&#39;s a duplicate.</span>
  <span class="c1">--   2. Otherwise, decide if there&#39;s a duplicate in the tail.</span>
  <span class="c1">--     a. If there is, show it is also in this list.</span>
  <span class="c1">--     b. If not, show that head ∉ tail means the full list has no duplicate either.</span>
<span class="kn">end</span>
</pre></div>


<p>This brings me to my first question:</p>
<p>For step 2, I figured I'll need to write something like <code>let foo := dec_duplicate (tail v)</code>. But I can't actually use <code>dec_duplicate</code> like that; I guess instance names can't be used like that.</p>
<p>What should I write instead, to recurse and decide if the tail has a duplicate, and split on the <code>is_false</code> and <code>is_true</code> cases?</p>
<p>I found examples of expressions using <code>decidable.cases_on</code> (or is it <code>rec_on</code>?) but I don't know how to make it useful for my tactic proof.</p>



<a name="193220003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193220003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193220003">(Apr 07 2020 at 17:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="247532">Lynn</span> <a href="#narrow/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise/near/193218502" title="#narrow/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise/near/193218502">said</a>:</p>
<blockquote>
<p>Hey, I decided on a neat exercise for myself and figured I'd make a topic for all the questions I have along the way.</p>
</blockquote>
<p>That's a good idea! It seems to be one of the best ways to learn Lean.</p>



<a name="193220011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193220011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193220011">(Apr 07 2020 at 17:16)</a>:</h4>
<p>This is definitely not my area of expertise, but I think you will need to use <code>induction</code> and not <code>cases</code> on your list.</p>



<a name="193220116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193220116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193220116">(Apr 07 2020 at 17:17)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="k">begin</span>
  <span class="c1">-- I&#39;ll perform induction on the list inside the vector.</span>
  <span class="n">cases</span> <span class="n">v</span> <span class="k">with</span> <span class="n">L</span> <span class="n">hL</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">L</span> <span class="k">with</span> <span class="n">a</span> <span class="n">M</span> <span class="n">h</span><span class="o">,</span>

  <span class="o">{</span> <span class="c1">-- Empty list case: there is no duplicate because i cannot even exist.</span>
    <span class="n">suffices</span> <span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">has_duplicate</span> <span class="bp">⟨</span><span class="n">list</span><span class="bp">.</span><span class="n">nil</span><span class="o">,</span> <span class="n">hL</span><span class="bp">⟩</span> <span class="o">),</span> <span class="k">from</span> <span class="o">(</span><span class="n">is_false</span> <span class="n">f</span><span class="o">),</span>
    <span class="n">intro</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">p</span> <span class="k">with</span> <span class="n">i</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="n">hL</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">hL</span> <span class="n">at</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">i</span><span class="bp">.</span><span class="n">elim0</span><span class="o">},</span>

  <span class="o">{</span> <span class="bp">...</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>



<a name="193220243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193220243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193220243">(Apr 07 2020 at 17:18)</a>:</h4>
<p>But actually I suspect that what you're trying to prove isn't true. If L is a list of length 2 then deciding whether L has duplicates is the same as deciding equality on alpha. So I think you'll need to add <code>[decidable_eq \alpha]</code></p>



<a name="193220362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193220362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193220362">(Apr 07 2020 at 17:19)</a>:</h4>
<p>No this won't work either because your inductive hypothesis is useless the way I suggested.</p>



<a name="193220567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193220567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193220567">(Apr 07 2020 at 17:21)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fin</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">list</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>
<span class="kn">open</span> <span class="n">fin</span>
<span class="kn">open</span> <span class="n">vector</span>

<span class="n">def</span> <span class="n">duplicate</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span><span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span><span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span><span class="o">:</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span> <span class="bp">∧</span> <span class="n">nth</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">nth</span> <span class="n">v</span> <span class="n">j</span>
<span class="n">def</span> <span class="n">has_duplicate</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span><span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span><span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span><span class="o">(</span><span class="n">i</span> <span class="n">j</span><span class="o">:</span><span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">duplicate</span> <span class="n">v</span> <span class="n">i</span> <span class="n">j</span>
<span class="kn">instance</span> <span class="n">dec_duplicate</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span><span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span><span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">has_duplicate</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="c1">-- I&#39;ll perform induction on the list inside the vector.</span>
  <span class="n">cases</span> <span class="n">v</span> <span class="k">with</span> <span class="n">L</span> <span class="n">hL</span><span class="o">,</span>
  <span class="n">revert</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">L</span> <span class="k">with</span> <span class="n">a</span> <span class="n">M</span> <span class="n">h</span><span class="o">,</span>

  <span class="o">{</span> <span class="c1">-- Empty list case: there is no duplicate because i cannot even exist.</span>
    <span class="n">intros</span> <span class="n">n</span> <span class="n">hL</span><span class="o">,</span>
    <span class="n">suffices</span> <span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">has_duplicate</span> <span class="bp">⟨</span><span class="n">list</span><span class="bp">.</span><span class="n">nil</span><span class="o">,</span> <span class="n">hL</span><span class="bp">⟩</span> <span class="o">),</span> <span class="k">from</span> <span class="o">(</span><span class="n">is_false</span> <span class="n">f</span><span class="o">),</span>
    <span class="n">intro</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">p</span> <span class="k">with</span> <span class="n">i</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="n">hL</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">hL</span> <span class="n">at</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">i</span><span class="bp">.</span><span class="n">elim0</span><span class="o">},</span>

  <span class="c1">-- TODO: recursive case:</span>
  <span class="c1">--   1. If head ∈ tail, there&#39;s a duplicate.</span>
  <span class="c1">--   2. Otherwise, decide if there&#39;s a duplicate in the tail.</span>
  <span class="c1">--     a. If there is, show it is also in this list.</span>
  <span class="c1">--     b. If not, show that head ∉ tail means the full list has no duplicate either.</span>
<span class="kn">end</span>
</pre></div>


<p>This looks more promising</p>



<a name="193221243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193221243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193221243">(Apr 07 2020 at 17:26)</a>:</h4>
<p>So now <code>h</code> is your <code>dec_duplicate (tail v)</code>.  Actually you might want to write <code>replace h := h rfl</code> to get the actual instance. <code>decidable.cases_on</code> is just <code>cases</code> again. You can do <code>cases h</code> to split into the two cases of a duplicate or not.</p>



<a name="193229858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193229858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lynn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193229858">(Apr 07 2020 at 18:39)</a>:</h4>
<p>Thank you! How would I split into cases on some other “decision”? For example for step 1 now I want to do something like <code>cases (list.mem a M),</code> but that's apparently not it.</p>



<a name="193229985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193229985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lynn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193229985">(Apr 07 2020 at 18:40)</a>:</h4>
<p><code>revert n,</code> is an interesting trick.</p>



<a name="193230230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193230230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193230230">(Apr 07 2020 at 18:42)</a>:</h4>
<p>Really n is a red herring. You can just do everything with lists rather than vectors. If you don't revert n then you end up with an induction hypothesis saying "if the length of L is n then [blah]" and then another hypothesis saying "the length of L isn't n", which is what makes the induction hypo useless. The only reason you can't get rid of n completely is that you have these <code>fin n</code> things in the defnition.</p>



<a name="193230530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193230530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193230530">(Apr 07 2020 at 18:45)</a>:</h4>
<p>Well, I'm a mathematician so I would just write <code>classical</code> and then <code>by_cases h : a \in M</code> but then again if I'm assuming <code>classical</code> then I can just prove the entire theorem by the law of the excluded middle. You can case on an inductive type but I think that if you're being constructive then you can't case on a Prop.</p>



<a name="193230713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193230713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193230713">(Apr 07 2020 at 18:46)</a>:</h4>
<p>To be quite frank I don't even know if what you're doing is possible -- I don't ever think about this kind of question.</p>



<a name="193230784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193230784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193230784">(Apr 07 2020 at 18:47)</a>:</h4>
<p>Maybe first you should prove <code>a \in M</code> is decidable? Then you'll be able to do cases on it.</p>



<a name="193230826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193230826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lynn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193230826">(Apr 07 2020 at 18:47)</a>:</h4>
<p><code>mem</code> has a "decidable" instance in <a href="https://github.com/leanprover-community/lean/blob/master/library/init/data/list/basic.lean" title="https://github.com/leanprover-community/lean/blob/master/library/init/data/list/basic.lean">https://github.com/leanprover-community/lean/blob/master/library/init/data/list/basic.lean</a></p>



<a name="193230951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193230951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193230951">(Apr 07 2020 at 18:48)</a>:</h4>
<p>oh that's great, then you should definitely be able to case on it. It's just that I would always use LEM at this point because I am uncultured :-)</p>



<a name="193230963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193230963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lynn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193230963">(Apr 07 2020 at 18:48)</a>:</h4>
<p>I think I just <em>syntactically</em> don't know how to make use of that fact. <code>cases (list.mem a M)</code> gives me <code>cases tactic failed, it is not applicable to the given hypothesis</code></p>



<a name="193230999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193230999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lynn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193230999">(Apr 07 2020 at 18:48)</a>:</h4>
<p>I guess <code>cases</code> should be followed by the name of a hypothesis and not an expression</p>



<a name="193231080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193231080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lynn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193231080">(Apr 07 2020 at 18:49)</a>:</h4>
<p>and, ha, I like to be constructive when I can so I'm gonna try to stick to it here <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span></p>



<a name="193231285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193231285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193231285">(Apr 07 2020 at 18:50)</a>:</h4>
<div class="codehilite"><pre><span></span>  <span class="k">have</span> <span class="n">haM</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">haM</span> <span class="k">with</span> <span class="n">haMf</span> <span class="n">haMt</span><span class="o">,</span>
</pre></div>


<p>works but there will be a more elegant way of doing it I'm sure. You need someone who actually has a clue about constructive stuff.</p>



<a name="193231345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193231345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193231345">(Apr 07 2020 at 18:51)</a>:</h4>
<p>Oh -- <code>by_cases haM : a ∈ M,</code> works fine.</p>



<a name="193231604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193231604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lynn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193231604">(Apr 07 2020 at 18:53)</a>:</h4>
<p>awesome, that tactic is exactly what I was looking for!</p>



<a name="193236857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193236857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lynn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193236857">(Apr 07 2020 at 19:34)</a>:</h4>
<p>maybe it'll be easier to work with something like this?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">duplicate</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span><span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">il</span><span class="o">:</span><span class="n">i</span><span class="bp">&lt;</span><span class="n">l</span><span class="bp">.</span><span class="n">length</span><span class="o">}</span> <span class="o">{</span><span class="n">jl</span><span class="o">:</span><span class="n">j</span><span class="bp">&lt;</span><span class="n">l</span><span class="bp">.</span><span class="n">length</span><span class="o">}</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">nth_le</span> <span class="n">l</span> <span class="n">i</span> <span class="n">il</span> <span class="bp">=</span> <span class="n">nth_le</span> <span class="n">l</span> <span class="n">j</span> <span class="n">jl</span><span class="o">)</span>
</pre></div>



<a name="193236992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193236992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193236992">(Apr 07 2020 at 19:35)</a>:</h4>
<p>That would be my gut feeling (but my gut is not good at this stuff). Now you won't have to do the revert n dance.</p>



<a name="193237106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193237106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193237106">(Apr 07 2020 at 19:36)</a>:</h4>
<p>There is still some way to go however -- this is a neat little puzzle.</p>



<a name="193237115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193237115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lynn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193237115">(Apr 07 2020 at 19:36)</a>:</h4>
<p>I'm a little surprised lean can't make placeholders in </p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">has_duplicate</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span><span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span><span class="o">(</span><span class="n">i</span> <span class="n">j</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">),</span> <span class="bp">∃</span><span class="o">(</span><span class="n">il</span><span class="o">:</span><span class="n">i</span><span class="bp">&lt;</span><span class="n">l</span><span class="bp">.</span><span class="n">length</span><span class="o">),</span> <span class="bp">∃</span><span class="o">(</span><span class="n">jl</span><span class="o">:</span><span class="n">j</span><span class="bp">&lt;</span><span class="n">l</span><span class="bp">.</span><span class="n">length</span><span class="o">),</span> <span class="n">duplicate</span> <span class="n">l</span> <span class="n">i</span> <span class="n">j</span>
</pre></div>


<p><a href="/user_uploads/3121/PneQ0XDHTwRT90iRDho_ggsh/image.png" title="image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/PneQ0XDHTwRT90iRDho_ggsh/image.png" title="image.png"><img src="/user_uploads/3121/PneQ0XDHTwRT90iRDho_ggsh/image.png"></a></div>



<a name="193237142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193237142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193237142">(Apr 07 2020 at 19:36)</a>:</h4>
<p>You don't need <code>decidable_eq</code> to define this <code>Prop</code></p>



<a name="193237284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193237284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193237284">(Apr 07 2020 at 19:37)</a>:</h4>
<p>Probably you should make <code>il</code> and <code>jl</code> explicit.</p>



<a name="193237641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193237641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193237641">(Apr 07 2020 at 19:40)</a>:</h4>
<p>If you're using the old web editor, <a href="https://leanprover-community.github.io/lean-web-editor/" title="https://leanprover-community.github.io/lean-web-editor/">this one is better</a> (it has some bugfixes)</p>



<a name="193237694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193237694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193237694">(Apr 07 2020 at 19:40)</a>:</h4>
<p>You'll need decidable_eq to prove anything about it but you don't need it for the prop itself (my bad)</p>



<a name="193237754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193237754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193237754">(Apr 07 2020 at 19:41)</a>:</h4>
<p>As for the placeholders, it all depends on which bit of Lean is being asked to fill them.</p>



<a name="193250902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193250902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lynn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193250902">(Apr 07 2020 at 21:29)</a>:</h4>
<p>What's <code>cong : {f : t -&gt; u} -&gt; (a = b) -&gt; (f a = f b)</code>  called in Lean?</p>



<a name="193251632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193251632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193251632">(Apr 07 2020 at 21:36)</a>:</h4>
<p><code>congr_arg</code></p>



<a name="193251761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193251761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193251761">(Apr 07 2020 at 21:38)</a>:</h4>
<p>And <code>f</code> is an explicit argument of <code>congr_arg</code>.</p>



<a name="193251992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193251992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lynn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193251992">(Apr 07 2020 at 21:40)</a>:</h4>
<p>hooray, I did it! <a href="https://gist.github.com/lynn/18aafb4f04b5e9289693e8a58bec532f" title="https://gist.github.com/lynn/18aafb4f04b5e9289693e8a58bec532f">https://gist.github.com/lynn/18aafb4f04b5e9289693e8a58bec532f</a></p>



<a name="193252453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193252453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lynn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193252453">(Apr 07 2020 at 21:46)</a>:</h4>
<p>It's a bit of a mess. I'll think about how to clean it up and what I struggled with. If anything looks totally silly about the way I used (or didn't use) my tactics then let me know. <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span> </p>
<p>One thing I wondered is: sometimes I want to treat the hole that <code>existsi</code> is going to fill as a subgoal, and apply tactics to it. I used <code>have temp : write_out_the_whole_type_here, (tactics for the goal), existsi temp</code> a few times. Is there a better way (ideally one that doesn't make me write out the type)?</p>



<a name="193252497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193252497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lynn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193252497">(Apr 07 2020 at 21:46)</a>:</h4>
<p>another is: is there a better way to get all the variables out of a <code>∃(i:ℕ)(il:i&lt;l.length) (j:ℕ)(jl:j&lt;l.length), …</code> hypothesis than my</p>
<div class="codehilite"><pre><span></span>  <span class="n">cases</span> <span class="n">p</span> <span class="k">with</span> <span class="n">i</span> <span class="n">p</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">p</span> <span class="k">with</span> <span class="n">il</span> <span class="n">p</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">p</span> <span class="k">with</span> <span class="n">j</span> <span class="n">p</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">p</span> <span class="k">with</span> <span class="n">jl</span> <span class="n">p</span><span class="o">,</span>
</pre></div>



<a name="193252858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193252858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193252858">(Apr 07 2020 at 21:50)</a>:</h4>
<p>you might find the mathlib tactic docs interesting, e.g. <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#rcases" title="https://leanprover-community.github.io/mathlib_docs/tactics.html#rcases">https://leanprover-community.github.io/mathlib_docs/tactics.html#rcases</a></p>



<a name="193253408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193253408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193253408">(Apr 07 2020 at 21:55)</a>:</h4>
<p>for your <code>existsi</code> question, i sometimes use <code>refine</code>, e.g. </p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="c1">-- two goals!</span>
<span class="kn">end</span>
</pre></div>



<a name="193254325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193254325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193254325">(Apr 07 2020 at 22:05)</a>:</h4>
<p>The way I would prove that this predicate is decidable is by proving it is equivalent to (the negation of)<code>list.pairwise (\ne)</code></p>



<a name="193258135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Lynn%27s%20has_duplicate%20exercise/near/193258135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Lynn's.20has_duplicate.20exercise.html#193258135">(Apr 07 2020 at 22:55)</a>:</h4>
<p><code>rcases p with ⟨i, i1, j, j1⟩</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
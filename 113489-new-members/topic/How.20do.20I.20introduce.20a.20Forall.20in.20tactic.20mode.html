---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html">How do I introduce a Forall in tactic mode</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="218049007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218049007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218049007">(Nov 27 2020 at 01:04)</a>:</h4>
<p>In this proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">x</span> <span class="n">pxr</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h2x</span> <span class="o">:=</span> <span class="n">h2</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">pxr</span> <span class="n">h2x</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hp</span><span class="o">,</span>
    <span class="n">sorry</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>at the <code>sorry</code>, my goal state is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">2</span> <span class="n">goals</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span><span class="o">,</span>
<span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">?</span><span class="n">m_1</span>
<span class="bp">⊢</span> <span class="n">r</span>

<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span>
<span class="bp">⊢</span> <span class="n">α</span>
</code></pre></div>
<p>In the first goal, I would like to generalize <code>hp : p ?m_1</code> to be <code> (∀ (x : α), p x) </code>.  What is the tactic-mode syntax to introduce the <code>∀</code>?</p>



<a name="218049196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218049196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218049196">(Nov 27 2020 at 01:09)</a>:</h4>
<p>I'm not sure this makes any sense. <code>hp</code> says "p of some explicit element of alpha is true". I'm not sure what you mean by "generalize" but neither <code>hp</code> nor what you want to "generalize" it to imply the other.</p>



<a name="218049280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218049280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218049280">(Nov 27 2020 at 01:11)</a>:</h4>
<p>PS I'm not sure running <code>constructor</code> on an exists goal is buying you much. You still have the same problem (constructing an element of alpha and proving it satisfies p) but you now have two goals, one of which is not a prop and the other of which has a metavariable in.</p>



<a name="218050804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218050804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Donald Sebastian Leung <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218050804">(Nov 27 2020 at 01:55)</a>:</h4>
<p>Is this even true though? For the reverse implication, if the type of <code>x</code> is empty then no witness can be produced for proving the exists statement.</p>



<a name="218055432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218055432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218055432">(Nov 27 2020 at 04:09)</a>:</h4>
<p><span class="user-mention" data-user-id="314358">@Donald Sebastian Leung</span> , it's an exercise in <a href="https://leanprover.github.io/theorem_proving_in_lean/quantifiers_and_equality.html#the-existential-quantifier">section 4.4</a>.  I just assumed it was true.</p>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, I have been able to use <code>constructor</code> for other exercises in this set, as a way of eliminating the quantifier in existential goals.  For example</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">r</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">x</span> <span class="n">pxr</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">px</span> <span class="o">:=</span> <span class="n">pxr.left</span><span class="o">,</span>
      <span class="n">constructor</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">px</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">x</span> <span class="n">pxr</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">pxr.right</span><span class="o">,</span>
    <span class="o">}</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">x</span> <span class="n">px</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hpxr</span> <span class="o">:=</span> <span class="n">and.intro</span> <span class="n">px</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hpxr</span><span class="o">,</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>and</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">∨</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">x</span> <span class="n">pxqx</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">pxqx</span> <span class="k">with</span> <span class="n">px</span> <span class="n">qx</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">left</span><span class="o">,</span>
      <span class="n">constructor</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">px</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">right</span><span class="o">,</span>
      <span class="n">constructor</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">qx</span><span class="o">,</span>
    <span class="o">},</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">px</span> <span class="n">qx</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">cases</span> <span class="n">px</span> <span class="k">with</span> <span class="n">x</span> <span class="n">px</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">pxqx</span> <span class="o">:=</span> <span class="n">or.intro_left</span> <span class="o">(</span><span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="n">px</span><span class="o">,</span>
      <span class="n">constructor</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">pxqx</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">cases</span> <span class="n">qx</span> <span class="k">with</span> <span class="n">x</span> <span class="n">qx</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">pxqx</span> <span class="o">:=</span> <span class="n">or.intro_right</span> <span class="o">(</span><span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="n">qx</span><span class="o">,</span>
      <span class="n">constructor</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">pxqx</span><span class="o">,</span>
    <span class="o">},</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218055487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218055487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218055487">(Nov 27 2020 at 04:10)</a>:</h4>
<p>I think you have to use <code>variable a : α</code> as in your earlier question today.</p>



<a name="218055550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218055550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218055550">(Nov 27 2020 at 04:12)</a>:</h4>
<p>Of the exercises in Chapter 4 that deal with quantifiers, I am down to a number of them where I have subgoals of form <code>p ?m_1</code> and <code>α</code>.  These involve less successful uses of <code>constructor</code> than the above examples.   The failure points are where you see <code>sorry</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">classical</span>
<span class="kn">open</span> <span class="n">data.nat.basic</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">¬</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">x</span> <span class="n">px</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">npx</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">npx</span> <span class="n">px</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="n">sorry</span><span class="o">,</span>
    <span class="n">sorry</span><span class="o">,</span>
  <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">sorry</span><span class="o">,</span>
    <span class="n">sorry</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">fx</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">x</span> <span class="n">npx</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">px</span> <span class="o">:=</span> <span class="n">fx</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">npx</span> <span class="n">px</span><span class="o">,</span>
  <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">x</span> <span class="n">pxr</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h2x</span> <span class="o">:=</span> <span class="n">h2</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">pxr</span> <span class="n">h2x</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hp</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">intro</span><span class="o">,</span>
    <span class="n">sorry</span><span class="o">,</span>
    <span class="n">sorry</span><span class="o">,</span>
  <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">r</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">x</span> <span class="n">rpx</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">px</span> <span class="o">:=</span> <span class="n">rpx</span> <span class="n">h2</span><span class="o">,</span>
      <span class="n">sorry</span>
    <span class="o">},</span>
    <span class="n">sorry</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">h2</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">h1</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">h2</span> <span class="k">with</span> <span class="n">x</span> <span class="n">px</span><span class="o">,</span>
      <span class="n">sorry</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="n">sorry</span><span class="o">,</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218055626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218055626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218055626">(Nov 27 2020 at 04:15)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> I will try adding an evidence of nonempty set variable in scope.</p>



<a name="218055631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218055631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218055631">(Nov 27 2020 at 04:15)</a>:</h4>
<p>The TPIL section there says:</p>
<blockquote>
<p>Notice that the declaration variable a : α amounts to the assumption that there is at least one element of type α. This assumption is needed in the second example, as well as in the last two.</p>
</blockquote>



<a name="218055647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218055647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218055647">(Nov 27 2020 at 04:15)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> .</p>



<a name="218108922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218108922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218108922">(Nov 27 2020 at 16:26)</a>:</h4>
<p>I am farther along by using <code>assume</code> but stuck on the reverse implication in this proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kd">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">r</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">x</span> <span class="n">rpx</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">hr</span><span class="o">:</span> <span class="n">r</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">px</span> <span class="o">:=</span> <span class="n">rpx</span> <span class="n">hr</span><span class="o">,</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">px</span><span class="o">,</span> <span class="c1">-- this works</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">hr</span><span class="o">:</span> <span class="n">r</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">epx</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">hr</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">epx</span> <span class="k">with</span> <span class="n">x</span> <span class="n">px</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">px</span><span class="o">,</span> <span class="c1">-- this doesn't</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>The goal state before the second <code>constructor</code> is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">⊢</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">x</span>
</code></pre></div>
<p>The second <code>constructor</code> eliminates the existential quantifier in <code>⊢ ∃ (x : α), r → p x</code> and leaves behind the <code>p ?m_1</code>.  Because the <code>p ?m_1</code> is the result of eliminating an existential, I assume that proving <code>p x</code> for any <code>x</code> should resolve it. The goal state becomes</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">2</span> <span class="n">goals</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">),</span>
<span class="n">hr</span> <span class="o">:</span> <span class="n">r</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">px</span> <span class="o">:</span> <span class="n">p</span> <span class="n">x</span>
<span class="bp">⊢</span> <span class="n">p</span> <span class="bp">?</span><span class="n">m_1</span>

<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">⊢</span> <span class="n">α</span>
</code></pre></div>
<p>The <code>exact px</code> results in error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">type</span> <span class="n">ascription</span><span class="o">,</span> <span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="n">p</span> <span class="n">x</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">p</span> <span class="bp">?</span><span class="n">m_1</span>
</code></pre></div>
<p>Any further hints would be greatly appreciated!</p>



<a name="218109337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218109337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218109337">(Nov 27 2020 at 16:31)</a>:</h4>
<p>I think you have to use <code>variable a : α</code> as in your earlier question yesterday.</p>



<a name="218109656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218109656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218109656">(Nov 27 2020 at 16:34)</a>:</h4>
<p><code>by_cases r</code> I think is the missing step</p>



<a name="218110134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218110134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218110134">(Nov 27 2020 at 16:39)</a>:</h4>
<p>But you also need <code>include a</code> to make the variable available to use</p>



<a name="218110258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218110258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218110258">(Nov 27 2020 at 16:40)</a>:</h4>
<p>I'd recommend you drop this weird <code>variable a : \a</code> stuff and use <code>[inhabited α]</code> + <code>default α</code> instead</p>



<a name="218110314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218110314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218110314">(Nov 27 2020 at 16:40)</a>:</h4>
<p>I think this is from TPIL or some equivalent book</p>



<a name="218113524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218113524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218113524">(Nov 27 2020 at 17:17)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> the <code>variable a : α</code> is there in the quoted code above.  Also yes, this  is an exercise in TPIL.</p>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span>  thank you for your suggestions, I will try them.  Also, in <a href="#narrow/stream/113489-new-members/topic/Need.20help.20with.20exists.2Eintro">this thread</a>, I was recommended to introduce <code>variable a : α</code> as evidence that <code>α</code> is a non-empty set. I was very firmly corrected for suggesting that there was anything confusing at all about it.</p>



<a name="218113812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218113812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218113812">(Nov 27 2020 at 17:20)</a>:</h4>
<p>I think there is some wonkiness to <code>variable a : α</code> and how that gets included in <code>example</code> vs <code>lemma my_example</code>. I think it might have to also do with <code>include a</code>. For the examples where you really need the <code>a</code>, you could write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">...</span>
</code></pre></div>
<p>and that would for sure be available.</p>



<a name="218114038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218114038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218114038">(Nov 27 2020 at 17:23)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> has hit the nail on the head - <code>lemma</code> determines it's type (which includes its arguments) from the stuff to the left of the <code>:=</code> alone, whereas <code>def</code> / <code>example</code> look at their definition to work out what they need to pull in as arguments</p>



<a name="218114195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218114195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218114195">(Nov 27 2020 at 17:24)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">some_type</span> <span class="o">:=</span> <span class="n">some_value</span>  <span class="c1">-- means foo (x : X) if `x` is included in either some_type or some_value</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">foo'</span> <span class="o">:</span> <span class="n">some_type</span> <span class="o">:=</span> <span class="n">some_value</span>  <span class="c1">-- means foo (x : X) if `x` is included in some_type, ignores some_value</span>
</code></pre></div>



<a name="218115666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218115666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218115666">(Nov 27 2020 at 17:43)</a>:</h4>
<p>In TPiL, the need for <code>include</code> is mentioned at <a href="https://leanprover.github.io/theorem_proving_in_lean/tactics.html#entering-tactic-mode">the end of Section 5.1</a> (the first section of the chapter discussing tactics), which I linked yesterday. </p>
<p>By the way, Patrick's point yesterday was not at all to correct you for saying that "there was anything confusing at all about it", but instead that the very different and much more extreme "I just don't think anybody would get it without expert assistance" is not consistent with evidence. Sorry for harping on this, but I believe that if you bring up past conversations, it's important that they are presented accurately.</p>



<a name="218117247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218117247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218117247">(Nov 27 2020 at 18:04)</a>:</h4>
<p>It might also be worth pointing out that some of the confusion is probably coming from the Zulip chat, since at this particular point in TPiL, the reader isn't supposed to know anything about typeclasses or <code>inhabited</code> or <code>nonempty</code>, so the setup presented in the book with the <code>variable</code> trick  is pedagogically justifiable, even though it's not how most lean users might state that the type has an element. So when people like myself yesterday  respond to Lars' question with "just use a typeclass", it obfuscates the goal of the using the quantifiers correctly.</p>
<p>As opposed to this section of TPiL being particularly hard to navigate</p>



<a name="218120291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218120291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218120291">(Nov 27 2020 at 18:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode/near/218114038">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> has hit the nail on the head - <code>lemma</code> determines it's type (which includes its arguments) from the stuff to the left of the <code>:=</code> alone, whereas <code>def</code> / <code>example</code> look at their definition to work out what they need to pull in as arguments</p>
</blockquote>
<p>Actually regardless of <code>def</code> vs <code>lemma</code> Lean will include any variable mentioned in the proof--but not inside a tactic block because those can't be run until after we know what the type is.</p>



<a name="218137111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218137111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218137111">(Nov 27 2020 at 23:50)</a>:</h4>
<p>Thank you all, I finally got it.  I think this uses the smallest number of techniques required to prove this example in tactic mode.  I'd love to see a shorter tactic mode proof using fewer kinds of tactics.  It definitely requires both the <code>variable a : α</code> and <code>include a</code> to prove this example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kd">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kn">include</span> <span class="n">a</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">r</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">x</span> <span class="n">rpx</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">hr</span><span class="o">:</span> <span class="n">r</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">px</span> <span class="o">:=</span> <span class="n">rpx</span> <span class="n">hr</span><span class="o">,</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">px</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">by_cases</span> <span class="n">hr</span><span class="o">:</span> <span class="n">r</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">expx</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">hr</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">expx</span> <span class="k">with</span> <span class="n">x</span> <span class="n">rpx</span><span class="o">,</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">intro</span> <span class="n">r_again</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">rpx</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">by_cases</span> <span class="n">hr1</span><span class="o">:</span> <span class="n">r</span><span class="o">,</span>
      <span class="o">{</span>
        <span class="n">exfalso</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">hr</span> <span class="n">hr1</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="o">{</span>
        <span class="n">constructor</span><span class="o">,</span>
        <span class="o">{</span>
          <span class="n">intro</span> <span class="n">hr2</span><span class="o">,</span>
          <span class="n">exfalso</span><span class="o">,</span>
          <span class="n">exact</span> <span class="n">hr</span> <span class="n">hr2</span><span class="o">,</span>
        <span class="o">},</span>
        <span class="n">exact</span> <span class="n">a</span><span class="o">,</span>
      <span class="o">},</span>
    <span class="o">},</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218139349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218139349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218139349">(Nov 28 2020 at 00:51)</a>:</h4>
<p>Your <code>by_cases hr1</code> and the block below it is pointless</p>



<a name="218139354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218139354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218139354">(Nov 28 2020 at 00:51)</a>:</h4>
<p>You already have a proof of r</p>



<a name="218139675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218139675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218139675">(Nov 28 2020 at 01:00)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">r</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span> <span class="o">{</span>
    <span class="n">rintros</span> <span class="o">⟨</span><span class="n">w</span><span class="o">,</span> <span class="n">H</span><span class="o">⟩,</span>
    <span class="n">intro</span> <span class="n">h_r</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">w</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H</span> <span class="n">h_r</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">by_cases</span> <span class="n">h_r</span> <span class="o">:</span> <span class="n">r</span><span class="o">,</span>
    <span class="o">{</span> <span class="c1">-- case 1 : r</span>
      <span class="n">replace</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">h_r</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">w</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">w</span><span class="o">,</span> <span class="n">intro</span> <span class="n">_</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span><span class="o">,},</span>
   <span class="c1">-- case 2 : not r</span>
    <span class="n">use</span> <span class="n">a</span><span class="o">,</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218140778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218140778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218140778">(Nov 28 2020 at 01:31)</a>:</h4>
<p><span class="user-mention" data-user-id="319223">@Logan Murphy</span> your proof doesn't go through in the context provided by the "try it!" of <a href="https://leanprover.github.io/theorem_proving_in_lean/quantifiers_and_equality.html#the-existential-quantifier">section 4.4</a>.   It doesn't know <code>rintros</code> or <code>w</code> or <code>H</code>.</p>
<p><a href="/user_uploads/3121/fIVmyuOXhuEMq-5MMlDFmNhX/Screenshot-from-2020-11-27-20-28-25.png">Screenshot-from-2020-11-27-20-28-25.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/fIVmyuOXhuEMq-5MMlDFmNhX/Screenshot-from-2020-11-27-20-28-25.png" title="Screenshot-from-2020-11-27-20-28-25.png"><img src="/user_uploads/3121/fIVmyuOXhuEMq-5MMlDFmNhX/Screenshot-from-2020-11-27-20-28-25.png"></a></div>



<a name="218140790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218140790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218140790">(Nov 28 2020 at 01:31)</a>:</h4>
<p>You have to add <code>import tactic</code> at the top since <code>rintros</code> is a tactic from mathlib.</p>



<a name="218141558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218141558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218141558">(Nov 28 2020 at 01:53)</a>:</h4>
<p>Yes, sorry Lars. <code>rintros</code>  slightly simplifies regular <code>intros</code> by letting you introduce the witness and proof components of the exisential seperately, rather than having to destruct them manually once they're in the proof context (also applies to other  structures beyond existentials) .</p>



<a name="218141619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218141619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218141619">(Nov 28 2020 at 01:55)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="319223">@Logan Murphy</span> I'm happy to learn new tactics.</p>



<a name="218143672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218143672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218143672">(Nov 28 2020 at 02:54)</a>:</h4>
<p>Here is another where I want to introduce a <code>∀</code> in tactic mode:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kn">include</span> <span class="n">a</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">sorry</span><span class="o">,</span>
    <span class="n">sorry</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hxa</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">x</span> <span class="n">npx</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">px</span> <span class="o">:=</span> <span class="n">hxa</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">npx</span> <span class="n">px</span><span class="o">,</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>Just before the first <code>sorry</code>, the goal state is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">2</span> <span class="n">goals</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="bp">¬∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span>
<span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">?</span><span class="n">m_1</span>
<span class="bp">⊢</span> <span class="n">false</span>

<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="bp">¬∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span>
<span class="bp">⊢</span> <span class="n">α</span>
</code></pre></div>
<p>We have </p>
<p><code>h1 : p ?m_1</code></p>
<p>The <code>?m_1</code> is arbitrary.  It seems like it should be possible to rewrite this to </p>
<p><code>∀ (x : α), p x,</code></p>
<p>Is there a tactic or rewrite rule/theorem for this?  I couldn't find a <code>forall.intro</code> in mathlib.</p>



<a name="218144163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218144163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218144163">(Nov 28 2020 at 03:05)</a>:</h4>
<p>When you invoke <code>constructor</code>, you have a goal of the form <code>∃ (x : α), ¬p x</code>, so you're breaking it up into two goals, one for the witness and one for the predicate. You haven't told lean what witness to use, hence the metavariable <code>?m_1</code>.  </p>
<p>In tactic mode, the more  "canonical way" to do this is as follows  (using the rewrite tactic <code>rw</code>, which is in chapter 5 of TPil)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">open</span> <span class="n">classical</span>


<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kn">include</span> <span class="n">a</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">not_forall</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">w</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">existsi</span> <span class="n">w</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hxa</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">x</span> <span class="n">npx</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">px</span> <span class="o">:=</span> <span class="n">hxa</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">npx</span> <span class="n">px</span><span class="o">,</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218144182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218144182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218144182">(Nov 28 2020 at 03:05)</a>:</h4>
<p>But you haven't "introduced" a <code>forall</code> here, you've just introduced a premise containing a negated <code>forall</code>, which is equivalent to an existential, hence the rewrite.</p>



<a name="218144230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218144230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218144230">(Nov 28 2020 at 03:07)</a>:</h4>
<p>But again, in chapter 4 of TPiL I don't think you're expected to know about tactic mode, hence the rewrite</p>



<a name="218144488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218144488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218144488">(Nov 28 2020 at 03:13)</a>:</h4>
<p>alternatively, rather than using <code>constructor</code>, once you have a witness, you should either use <code>use</code> or, especially for an existential, <code>existsi</code>, which I think is just a more usable tactic version of <code>exists.intro</code></p>



<a name="218146891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218146891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218146891">(Nov 28 2020 at 04:29)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="319223">@Logan Murphy</span> .  I was using <code>constructor</code> because it is one of the tactics in <a href="https://leanprover.github.io/theorem_proving_in_lean/tactics.html#more-tactics">Chapter 5</a>  that work with quantifiers.  <code>not_forall</code> is not mentioned in <a href="https://leanprover.github.io/theorem_proving_in_lean/theorem_proving_in_lean.pdf">TPIL</a>.   It becomes necessary at this point to start reading the <code>mathlib</code> docs.  <code>rw</code> is introduced in the Natural Number Game along with a selection of <code>rw</code>-applicable equivalences from <code>mathlib</code>.  <code>mathlib</code> is not mentioned inTPIL.</p>
<p>I guess we kind of come up against the limits of tactic mode around quantifiers.  Trying to unpack <code>not_forall</code> leads to term-mode proofs:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">theorem</span> <span class="n">decidable.not_forall</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">[</span><span class="n">decidable</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">p</span> <span class="n">x</span><span class="o">)]</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">not.decidable_imp_symm</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">nx</span> <span class="n">x</span><span class="o">,</span> <span class="n">nx.decidable_imp_symm</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span>
 <span class="n">not_forall_of_exists_not</span><span class="o">⟩</span>

<span class="kd">theorem</span> <span class="n">not_forall_of_exists_not</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hn</span><span class="o">⟩</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">hn</span> <span class="o">(</span><span class="n">h</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">not.decidable_imp_symm</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">a</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span><span class="n">a</span> <span class="bp">→</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">decidable.not_imp_symm</span>

<span class="kn">protected</span> <span class="kd">theorem</span> <span class="n">decidable.not_imp_symm</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">a</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">a</span> <span class="bp">→</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">decidable.by_contradiction</span> <span class="bp">$</span> <span class="n">hb</span> <span class="bp">∘</span> <span class="n">h</span>
</code></pre></div>
<p>It seems that I should only be using tactic mode up to a certain point and then to really use Lean I have to start thinking in term mode.</p>



<a name="218155349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218155349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218155349">(Nov 28 2020 at 08:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="364351">Lars Ericson</span> <a href="#narrow/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode/near/218146891">said</a>:</p>
<blockquote>
<p>It becomes necessary at this point to start reading the <code>mathlib</code> docs.</p>
</blockquote>
<p>why? you can prove those lemmas without mathlib!</p>
<p><span class="user-mention silent" data-user-id="364351">Lars Ericson</span> <a href="#narrow/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode/near/218146891">said</a>:</p>
<blockquote>
<p>It seems that I should only be using tactic mode up to a certain point and then to really use Lean I have to start thinking in term mode.</p>
</blockquote>
<p>not necessarily, but knowing term mode is useful. mathlib typically uses that style because it's faster and shorter.</p>



<a name="218155566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218155566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218155566">(Nov 28 2020 at 09:04)</a>:</h4>
<p>i think the left-to-right proof requires classical reasoning, btw.</p>



<a name="218155636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218155636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218155636">(Nov 28 2020 at 09:07)</a>:</h4>
<p>Using <code>not_forall</code> is cheating, that's the lemma you're proving</p>



<a name="218163366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218163366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218163366">(Nov 28 2020 at 12:59)</a>:</h4>
<p>Yes, my bad, you could just do the rewrite and the start and be done</p>



<a name="218164368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218164368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218164368">(Nov 28 2020 at 13:26)</a>:</h4>
<p>I have two questions regarding</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">exact</span> <span class="n">not_forall</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Q1: This doesn't need <code>open classical</code>.  Does that mean this doesn't need <code>em</code>, or that <code>em</code> comes with <code>import tactic</code>?</p>
<p>Q2:  The type of <code>not_forall</code> is <code>not_forall {α : Sort u_1} {p : α → Prop}</code>.  It's not letting me do this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">not_forall</span> <span class="n">α</span> <span class="n">p</span>
</code></pre></div>
<p>or this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">not_forall</span>
</code></pre></div>
<p>or this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">exact</span> <span class="n">not_forall</span> <span class="n">α</span> <span class="n">p</span>
</code></pre></div>
<p>or this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>  <span class="bp">λ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u_1</span><span class="o">},</span> <span class="bp">λ</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">},</span> <span class="n">not_forall</span> <span class="n">α</span> <span class="n">p</span>
</code></pre></div>
<p>What is the syntax to apply a theorem in tactic mode in this case?</p>



<a name="218164422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218164422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218164422">(Nov 28 2020 at 13:27)</a>:</h4>
<p>Q1: <code>open</code> is just for namespacing</p>



<a name="218164481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218164481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218164481">(Nov 28 2020 at 13:28)</a>:</h4>
<p><code>open classical</code> just means instead of <code>classical.foo</code> you can write <code>foo</code></p>



<a name="218164557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218164557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218164557">(Nov 28 2020 at 13:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="364351">Lars Ericson</span> <a href="#narrow/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode/near/218164368">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">not_forall</span>
</code></pre></div><br>
</p>
</blockquote>
<p>This one's correct. If it's not working then your setup is not as described.</p>



<a name="218164691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218164691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218164691">(Nov 28 2020 at 13:34)</a>:</h4>
<p><code>import</code> and <code>open</code> and using classical axioms are three unrelated things.<br>
(You have to import an axiom to use it but the ones used for classical logic are automatically imported implicitly.)</p>



<a name="218164865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218164865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218164865">(Nov 28 2020 at 13:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="364351">Lars Ericson</span> <a href="#narrow/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode/near/218164368">said</a>:</p>
<blockquote>
<p>Q1: This doesn't need <code>open classical</code>.  Does that mean this doesn't need <code>em</code>, or that <code>em</code> comes with <code>import tactic</code>?</p>
</blockquote>
<p>the proof of <code>not_forall</code> uses classical reasoning, specifically the statement that all propositions are decidable, which turns the statement of <code>decidable.not_forall</code> into <code>not_forall</code>. this is explained at the end of TPIL in chapter 11.<br>
but to prove the statement, you don't need such big guns and can also just use <code>em</code>.</p>



<a name="218164929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218164929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218164929">(Nov 28 2020 at 13:43)</a>:</h4>
<p><span class="user-mention" data-user-id="221921">@Marc Huisinga</span> that was my question, does it require <code>em</code>.  If so does that mean that the theorem is not constructive?</p>



<a name="218164943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218164943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218164943">(Nov 28 2020 at 13:44)</a>:</h4>
<p>Yeah, I believe that's right</p>



<a name="218164979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218164979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218164979">(Nov 28 2020 at 13:44)</a>:</h4>
<p>yup! the de morgan rules don't hold in full symmetry for constructive logic. three hold, one doesn't.</p>
<p>the exercise also tells you that part of the exercise is to figure out which ones to prove using classical reasoning :)</p>



<a name="218164993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218164993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218164993">(Nov 28 2020 at 13:45)</a>:</h4>
<p>You can use <code>#print axioms not_forall</code> to see that it uses <code>classical.choice</code>, which is used to prove excluded middle</p>



<a name="218165047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218165047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218165047">(Nov 28 2020 at 13:47)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>  thanks for the new command <code>#print axioms</code>.  Also, you are right, this works, I don't know why I was having trouble before:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">not_forall</span>
</code></pre></div>



<a name="218165293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218165293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218165293">(Nov 28 2020 at 13:55)</a>:</h4>
<p>So I'm trying to work this out again from scratch.  I am starting here, but I have a syntax problem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">not_forall_implies_exist_not</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>  <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="k">#check</span> <span class="n">not_forall_implies_exist_not</span> <span class="n">α</span> <span class="c1">-- works</span>
<span class="k">#check</span> <span class="n">not_forall_implies_exist_not</span> <span class="n">α</span> <span class="n">p</span> <span class="c1">-- doesn't work</span>
</code></pre></div>
<p>It won't let me apply the <code>lemma</code> in the second <code>check</code>. It raises this error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">function</span> <span class="n">expected</span> <span class="n">at</span>
  <span class="n">not_forall_implies_exist_not</span> <span class="n">α</span>
<span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="o">(</span><span class="bp">¬∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">?</span><span class="n">m_1</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">¬?</span><span class="n">m_1</span> <span class="n">x</span>
</code></pre></div>
<p>I am trying to break down my task as follows:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">not_forall_implies_exist_not</span> <span class="n">α</span> <span class="n">p</span><span class="o">,</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>but I'm stuck on the syntax.  I am modelling this after a similar use in Chapter 3, which didn't raise any errors:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">definition_imply</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">):</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">theorem</span> <span class="n">imply_definition</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">):</span> <span class="o">(</span><span class="bp">¬</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">theorem</span> <span class="n">implication</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">):</span> <span class="o">(</span><span class="bp">¬</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">imply_definition</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">definition_imply</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218165354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218165354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218165354">(Nov 28 2020 at 13:56)</a>:</h4>
<p>note the curly brackets</p>



<a name="218165364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218165364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218165364">(Nov 28 2020 at 13:56)</a>:</h4>
<p>(<a href="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#implicit-arguments">https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#implicit-arguments</a>)</p>



<a name="218165625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218165625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218165625">(Nov 28 2020 at 14:04)</a>:</h4>
<p><span class="user-mention" data-user-id="221921">@Marc Huisinga</span> I don't understand the hint.  I have curly brackets in the lemma statement.  The form of the statement is exactly like <a href="https://github.com/leanprover-community/mathlib/blob/801dea942a57af8d083ff60fa7a89707aec81063/src/logic/basic.lean#L710">not_forall</a>.  However, this doesn't work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kn">include</span> <span class="n">a</span>

<span class="kd">theorem</span> <span class="n">not_forall_implies_exist_not</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>  <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">not_forall_implies_exist_not</span><span class="o">,</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>giving error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">type</span> <span class="n">ascription</span><span class="o">,</span> <span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span><span class="o">),</span> <span class="n">α</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">},</span> <span class="o">(</span><span class="bp">¬∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">x</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="o">(</span><span class="bp">¬∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">x</span><span class="o">)</span>
<span class="n">state</span><span class="o">:</span>
<span class="mi">2</span> <span class="n">goals</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="bp">⊢</span> <span class="o">(</span><span class="bp">¬∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">x</span><span class="o">)</span>

<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="bp">⊢</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>



<a name="218165656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218165656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218165656">(Nov 28 2020 at 14:05)</a>:</h4>
<p>I don't understand what you're expecting to achieve by moving the whole statement of the example into a lemma</p>



<a name="218165700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218165700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218165700">(Nov 28 2020 at 14:06)</a>:</h4>
<p>since both statements are the same, it's unlikely you can prove one by doing <code>split</code> and then using the other</p>



<a name="218165704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218165704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218165704">(Nov 28 2020 at 14:06)</a>:</h4>
<p>I guess you didn't mean to write <code>↔</code> in <code>not_forall_implies_exist_not</code></p>



<a name="218165742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218165742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218165742">(Nov 28 2020 at 14:08)</a>:</h4>
<p><span class="user-mention" data-user-id="364351">@Lars Ericson</span> you should learn to read the error messages. It's getting to the point where you should be able to do this. Many of your recent questions are "why does this not work, the error says "Lean was expecting X but you gave it Y"", and really this is the answer to your question.</p>



<a name="218165778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218165778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218165778">(Nov 28 2020 at 14:09)</a>:</h4>
<p>In particular for this question, the error will be on <code>exact</code>, the goal is exactly what X says, what you gave it after the <code>exact</code> is exactly what Y says, and you are asking why it doesn't work.</p>



<a name="218166043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218166043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218166043">(Nov 28 2020 at 14:17)</a>:</h4>
<p>Lean is also very sensitive to details and context--I think trying to look at what mathlib does isn't going to help you at this point.</p>



<a name="218166284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218166284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218166284">(Nov 28 2020 at 14:24)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> because I am stuck doing it all in one place, I find it helpful to break it down into lemmas for each direction.  I know it is the same, but subproceduralizing helps me think.</p>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I fixed one thing which was I was using <code>↔</code> when I meant <code>→ </code>.  However, with this fix, it still doesn't match.  This should be fine:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kn">include</span> <span class="n">a</span>

<span class="kd">lemma</span> <span class="n">exist_not_implies_not_forall</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>  <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">lemma</span> <span class="n">not_forall_implies_exist_not</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>  <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">not_forall_implies_exist_not</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">exist_not_implies_not_forall</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>but it is giving me this error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">type</span> <span class="n">ascription</span><span class="o">,</span> <span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span><span class="o">),</span> <span class="n">α</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">},</span> <span class="o">(</span><span class="bp">¬∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">x</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="o">(</span><span class="bp">¬∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>If I simplify the example further:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kn">include</span> <span class="n">a</span>

<span class="kd">lemma</span> <span class="n">exist_not_implies_not_forall</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>  <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="k">#check</span> <span class="n">exist_not_implies_not_forall</span>         <span class="c1">-- works</span>
<span class="k">#check</span> <span class="n">exist_not_implies_not_forall</span> <span class="n">α</span>       <span class="c1">-- works</span>
<span class="k">#check</span> <span class="n">exist_not_implies_not_forall</span> <span class="n">α</span> <span class="n">p</span>     <span class="c1">-- doesn't work</span>
</code></pre></div>
<p>Then the first two <code>#check</code>s work and the third does not, giving error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">exist_not_implies_not_forall</span> <span class="n">α</span> <span class="n">p</span>
<span class="n">term</span>
  <span class="n">p</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">α</span>
</code></pre></div>
<p>I  do not understand this error message.</p>



<a name="218166296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218166296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218166296">(Nov 28 2020 at 14:24)</a>:</h4>
<p>did you see <span class="user-mention" data-user-id="221921">@Marc Huisinga</span>'s message above?</p>



<a name="218166299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218166299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218166299">(Nov 28 2020 at 14:25)</a>:</h4>
<p>do you know what <code>{p : α → Prop}</code> means?</p>



<a name="218166314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218166314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218166314">(Nov 28 2020 at 14:25)</a>:</h4>
<p>I think it means that <code>p</code> can be inferred and that <code>p</code> has type <code>α → Prop</code>.</p>



<a name="218166322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218166322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218166322">(Nov 28 2020 at 14:25)</a>:</h4>
<p>There are three kinds of brackets in Lean. <code>()</code> means "the user supplies this". <code>{}</code> means "The user does not supply this, a system called the unification system will deal with it". And <code>[]</code> means "the user does not supply this, a system called the type class inference system will supply it".</p>



<a name="218166362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218166362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218166362">(Nov 28 2020 at 14:26)</a>:</h4>
<p><del>You supplied p, but it was in <code>{}</code> brackets so the system had already supplied it.</del> (actually, Lean hadn't even got to <code>p</code> yet, as Marc points out)</p>



<a name="218166383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218166383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218166383">(Nov 28 2020 at 14:27)</a>:</h4>
<p>Changing '{}' to '()' I still get an error on the 3rd <code>#check</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kn">include</span> <span class="n">a</span>

<span class="kd">lemma</span> <span class="n">exist_not_implies_not_forall</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>  <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="k">#check</span> <span class="n">exist_not_implies_not_forall</span>         <span class="c1">-- works</span>
<span class="k">#check</span> <span class="n">exist_not_implies_not_forall</span> <span class="n">α</span>       <span class="c1">-- works</span>
<span class="k">#check</span> <span class="n">exist_not_implies_not_forall</span> <span class="n">α</span> <span class="n">p</span>     <span class="c1">-- doesn't work</span>
</code></pre></div>
<p>The error is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">exist_not_implies_not_forall</span> <span class="n">α</span> <span class="n">p</span>
<span class="n">term</span>
  <span class="n">p</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">α</span>
</code></pre></div>



<a name="218166385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218166385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218166385">(Nov 28 2020 at 14:27)</a>:</h4>
<p>this is not actually the problem here <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> , the problem is the <code>include a</code>.</p>



<a name="218166437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218166437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218166437">(Nov 28 2020 at 14:28)</a>:</h4>
<p>OK removing the <code>include a</code> makes it work and now I am confused.</p>



<a name="218166438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218166438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218166438">(Nov 28 2020 at 14:28)</a>:</h4>
<p>I think you should learn the really useful trick <code>#check @exist_not_implies_not_forall</code>. It tells you what all the inputs are.</p>



<a name="218166446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218166446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218166446">(Nov 28 2020 at 14:28)</a>:</h4>
<p>You can now remove/add <code>include a</code> and see how the output of that <code>#check</code> changes.</p>



<a name="218166447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218166447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218166447">(Nov 28 2020 at 14:28)</a>:</h4>
<p>and, more generally, reading Lean's output rather than thinking in binary "works/doesn't work"</p>



<a name="218166503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218166503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218166503">(Nov 28 2020 at 14:30)</a>:</h4>
<p>The <code>#check @...</code> thing was a game-changer for me. I used to struggle with <code>#check</code>. There are some instances when it throws up a very weird error. But adding the <code>@</code> makes everything much clearer.</p>



<a name="218166521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218166521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218166521">(Nov 28 2020 at 14:31)</a>:</h4>
<p>OK without <code>include a</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">exist_not_implies_not_forall</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>with <code>include a</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">exist_not_implies_not_forall</span> <span class="o">:</span>  <span class="bp">∀</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">),</span> <span class="n">α</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>so in that case it wants <code>a</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="n">exist_not_implies_not_forall</span> <span class="n">α</span> <span class="n">a</span> <span class="n">p</span>
</code></pre></div>



<a name="218166587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218166587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218166587">(Nov 28 2020 at 14:32)</a>:</h4>
<p>So finally I am home</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kd">lemma</span> <span class="n">exist_not_implies_not_forall</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>  <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">not_forall_implies_exist_not</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>  <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">not_forall_implies_exist_not</span> <span class="n">α</span> <span class="n">p</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">exist_not_implies_not_forall</span> <span class="n">α</span> <span class="n">p</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218166615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218166615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218166615">(Nov 28 2020 at 14:33)</a>:</h4>
<p>You could delete <code>variable a : α</code> too, since it's not needed for this theorem</p>



<a name="218166663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218166663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218166663">(Nov 28 2020 at 14:34)</a>:</h4>
<p><span class="user-mention" data-user-id="364351">@Lars Ericson</span> by writing <code>include a</code>, you made <code>a : α</code> a parameter to <code>exist_not_implies_not_forall</code>. <br>
to repeat some stuff from TPIL:<br>
<code>variable (foo : bar)</code> means that all the following definitions will take (foo : bar) as argument <em>if</em> <code>foo</code> is used either in the signature of the <code>def</code> or the <em>term</em> of the <code>def</code> supplied after <code>:=</code>.<br>
for technical reasons, this doesn't work well if the term after <code>:=</code> is supplied in tactic mode (explained in section 5.1), so you need to tell lean explicitly to make it a parameter, using <code>include</code>.</p>



<a name="218166722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218166722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218166722">(Nov 28 2020 at 14:36)</a>:</h4>
<p>unfortunately, in this case you did not actually want it as a parameter :)</p>



<a name="218168284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218168284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218168284">(Nov 28 2020 at 15:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode/near/218166322">said</a>:</p>
<blockquote>
<p>There are three kinds of brackets in Lean. <code>()</code> means "the user supplies this". <code>{}</code> means "The user does not supply this, a system called the unification system will deal with it". And <code>[]</code> means "the user does not supply this, a system called the type class inference system will supply it".</p>
</blockquote>
<p>There are actually five. Number four is <code>{{}}</code> aka <code>⦃⦄</code>, which means that they are not supplied by the user, and the system only inserts them if other arguments after are inserted by the user, and number five is <code>aux_decl</code> which has no user level syntax and is used to insert the fake signature of a recursive function inside its own body, as well as to compile matches and destructuring lets (you might have seen things in the context called <code>_match</code> and <code>_let_match</code> before).</p>



<a name="218168330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218168330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218168330">(Nov 28 2020 at 15:16)</a>:</h4>
<p>/me takes off pedant hat</p>



<a name="218168403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218168403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218168403">(Nov 28 2020 at 15:18)</a>:</h4>
<p>lean4 now also has the <code> </code> brackets: <a href="https://github.com/leanprover/lean4/blob/master/src/Init/System/IO.lean#L31">https://github.com/leanprover/lean4/blob/master/src/Init/System/IO.lean#L31</a></p>



<a name="218168944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218168944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218168944">(Nov 28 2020 at 15:33)</a>:</h4>
<p>I can't figure out what this is referring to</p>



<a name="218169010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218169010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218169010">(Nov 28 2020 at 15:35)</a>:</h4>
<p><code>ε</code> and <code>α</code> are not quantified at all</p>



<a name="218169015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218169015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218169015">(Nov 28 2020 at 15:35)</a>:</h4>
<p>Wasn't there another type of bracket like <code>(+ ... +)</code> which gives a hint to the simplifier?</p>



<a name="218169195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218169195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218169195">(Nov 28 2020 at 15:40)</a>:</h4>
<p>Ah, you are thinking of <code>(: ... :)</code> which is a hint to the e-matcher</p>



<a name="218169197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218169197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218169197">(Nov 28 2020 at 15:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> can you show me how to use <code>let</code> and <code>match</code> inside a <code>begin end</code>?  <code>match</code> has its own <code>end</code>.  <a href="https://leanprover.github.io/theorem_proving_in_lean/quantifiers_and_equality.html#the-existential-quantifier">Chapter 4</a> doesn't have an example of use of <code>let</code> or <code>match</code> inside a tactic-mode <code>begin end</code> proof.</p>



<a name="218169206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218169206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218169206">(Nov 28 2020 at 15:41)</a>:</h4>
<p>There is a tactic called <code>let</code>, you can use it just like <code>have</code></p>



<a name="218169207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218169207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218169207">(Nov 28 2020 at 15:41)</a>:</h4>
<p>there is no <code>match</code> tactic, but <code>rcases</code> does most of what <code>match</code> can do</p>



<a name="218169325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218169325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218169325">(Nov 28 2020 at 15:45)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> <code>(: ... :)</code> isn't actually a binder, it surrounds a <em>subterm</em> of an expression, and I'm not sure exactly how it's encoded, probably as a macro</p>



<a name="218170338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218170338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218170338">(Nov 28 2020 at 16:13)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> as one of my subgoals I have re-proved this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">foo1</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}:</span> <span class="o">((</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">b</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span> <span class="n">x</span> <span class="n">hpx</span><span class="o">,</span> <span class="n">h</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hpx</span><span class="o">⟩</span>
</code></pre></div>
<p>with this tactic-mode proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">foo1</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}:</span> <span class="o">((</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h1</span> <span class="o">(</span><span class="n">exists.intro</span> <span class="n">x</span> <span class="n">h2</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>
<p>Is there a more elegant purely tactic-mode proof which uses <code>let</code> or <code>rcases</code>?</p>



<a name="218171327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218171327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218171327">(Nov 28 2020 at 16:42)</a>:</h4>
<p>there is no let or match in the term proof either</p>



<a name="218171347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218171347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218171347">(Nov 28 2020 at 16:43)</a>:</h4>
<p>you can replace the <code>intro assume intro</code> with just <code>intros h1 x h2</code> but if a proof is just <code>intros, exact</code> then there isn't really a point in using tactic mode</p>



<a name="218172458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218172458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218172458">(Nov 28 2020 at 17:13)</a>:</h4>
<p>I would like to dig into <code>not_forall</code> and pull out one side of it.   The definition below of <code>my_not_forall</code> is exactly like <a href="https://github.com/leanprover-community/mathlib/blob/801dea942a57af8d083ff60fa7a89707aec81063/src/logic/basic.lean#L710">not_forall</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span>

<span class="k">#check</span> <span class="n">α</span>  <span class="c1">-- gives α : Sort u_1</span>
<span class="k">#check</span> <span class="n">not_forall</span>  <span class="c1">-- gives not_forall : (¬∀ (x : ?M_1), ?M_2 x) ↔ ∃ (x : ?M_1), ¬?M_2 x</span>
<span class="k">#check</span> <span class="n">decidable.not_forall</span>   <span class="c1">-- gives decidable.not_forall : (¬∀ (x : ?M_1), ?M_2 x) ↔ ∃ (x : ?M_1), ¬?M_2 x</span>

<span class="kd">theorem</span> <span class="n">my_not_forall</span><span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">decidable.not_forall_not</span>
</code></pre></div>
<p>however I am getting error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Display</span> <span class="n">GoalDisplay</span> <span class="n">Messages</span>
<span class="mi">10</span><span class="o">:</span><span class="mi">52</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span>
<span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">⊢</span> <span class="n">decidable</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>It seems I am missing a <code>decidable</code> constructor which gets inferred when it is in <code>mathlib</code> but not here?  Is there a way to fix this?  I really want to get down to this part:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">not.decidable_imp_symm</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">nx</span> <span class="n">x</span><span class="o">,</span> <span class="n">nx.decidable_imp_symm</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span>
</code></pre></div>
<p>of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">decidable.not_forall</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">[</span><span class="n">decidable</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">p</span> <span class="n">x</span><span class="o">)]</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">not.decidable_imp_symm</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">nx</span> <span class="n">x</span><span class="o">,</span> <span class="n">nx.decidable_imp_symm</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span>
 <span class="n">not_forall_of_exists_not</span><span class="o">⟩</span>
</code></pre></div>
<p>but it seems like I need to wrap things with <code>decidable</code> constructor at some point to get down into <code>not.decidable_imp_symm</code> and <code>nx.decidable_imp_symm </code>.</p>



<a name="218172877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218172877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218172877">(Nov 28 2020 at 17:24)</a>:</h4>
<p>you might want to try to prove it regularly instead and wait with this until you've read chapter 11. the mathlib proof uses an attribute that makes all propositions decidable (as a result of em).<br>
trying to do this with typeclasses and decidability should be very confusing if you haven't read the corresponding sections.</p>



<a name="218173283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218173283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218173283">(Nov 28 2020 at 17:37)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="221921">@Marc Huisinga</span> I am stuck here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span>
<span class="kd">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kn">include</span> <span class="n">a</span>

<span class="kd">lemma</span> <span class="n">not_forall_implies_exist_not</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>  <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span>  <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">by_contra</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h3</span><span class="o">,</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>with goal state</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">h1</span> <span class="o">:</span> <span class="bp">¬∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span>
<span class="n">h2</span> <span class="o">:</span> <span class="bp">¬∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">x</span><span class="o">,</span>
<span class="n">h3</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span>
<span class="bp">⊢</span> <span class="n">false</span>
</code></pre></div>
<p>I will wait on this <code>sorry</code>  until after Chapter 11.</p>



<a name="218173441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218173441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218173441">(Nov 28 2020 at 17:41)</a>:</h4>
<p>don't use <code>a</code>, it's a red herring</p>



<a name="218173505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218173505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218173505">(Nov 28 2020 at 17:43)</a>:</h4>
<p>You have two things in your context that imply <code>false</code>. One of them will get you more or less back to where you started, so try the other one</p>



<a name="218173584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218173584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218173584">(Nov 28 2020 at 17:45)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">by_contra</span> <span class="n">foobar</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">foobar</span>
</code></pre></div>
<p>is basically doing nothing.</p>



<a name="218173715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218173715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218173715">(Nov 28 2020 at 17:49)</a>:</h4>
<p>here's another hint (not the full proof, but close):</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">not_forall_implies_exist_not</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>  <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span>  <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">by_contra</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="c1">-- we'd really like to use h2 now. we already have an x! how could we get ¬p x?</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="218174084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218174084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218174084">(Nov 28 2020 at 17:58)</a>:</h4>
<p>I looked in TPIL again and it actually <a href="https://leanprover.github.io/theorem_proving_in_lean/quantifiers_and_equality.html#the-existential-quantifier">spells out the proof in term mode</a>, I just have to understand this and maybe term-mode-ify it for extra self-brownie-points.  This is what is done inside <code>mathlib</code>, the <code>r</code> is unified with <code>false</code>.  <strong>Note</strong>: This uses and requires the red herring:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">((</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span>  <span class="o">:=</span>
  <span class="k">assume</span> <span class="n">h1</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span><span class="o">,</span>
    <span class="k">show</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">r</span><span class="o">,</span> <span class="k">from</span>
      <span class="n">by_cases</span>
        <span class="o">(</span><span class="k">assume</span> <span class="n">hap</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h'</span><span class="o">,</span> <span class="n">h1</span> <span class="n">hap</span><span class="o">⟩)</span>
        <span class="o">(</span><span class="k">assume</span> <span class="n">hnap</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span>
          <span class="n">by_contra</span>
            <span class="o">(</span><span class="k">assume</span> <span class="n">hnex</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">r</span><span class="o">,</span>
              <span class="k">have</span> <span class="n">hap</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span>
                <span class="k">assume</span> <span class="n">x</span><span class="o">,</span>
                <span class="n">by_contra</span>
                  <span class="o">(</span><span class="k">assume</span> <span class="n">hnp</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span>
                    <span class="k">have</span> <span class="n">hex</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">r</span><span class="o">,</span>
                      <span class="k">from</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="k">assume</span> <span class="n">hp</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">hp</span> <span class="n">hnp</span><span class="o">)⟩,</span>
                    <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">hnex</span> <span class="n">hex</span><span class="o">),</span>
              <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">hnap</span> <span class="n">hap</span><span class="o">))</span>
</code></pre></div>



<a name="218174159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218174159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218174159">(Nov 28 2020 at 18:00)</a>:</h4>
<p>This proof uses 10 levels of indents/abstraction to get it done.  I don't know if it can be done in fewer levels.</p>



<a name="218174689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218174689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218174689">(Nov 28 2020 at 18:15)</a>:</h4>
<p>yeah, don't use term mode and it will solve your indent problem</p>



<a name="218174709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218174709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218174709">(Nov 28 2020 at 18:16)</a>:</h4>
<p>I can tell you that you don't need three choicy things (by_cases, by_contra, by_contra)</p>



<a name="218174948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218174948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218174948">(Nov 28 2020 at 18:22)</a>:</h4>
<p>The proof in mathlib doesn't look like this at all, it doesn't use the implies r version</p>



<a name="218174957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218174957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218174957">(Nov 28 2020 at 18:23)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">theorem</span> <span class="n">decidable.not_forall</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">[</span><span class="n">decidable</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">p</span> <span class="n">x</span><span class="o">)]</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">not.decidable_imp_symm</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">nx</span> <span class="n">x</span><span class="o">,</span> <span class="n">nx.decidable_imp_symm</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span>
 <span class="n">not_forall_of_exists_not</span><span class="o">⟩</span>
</code></pre></div>



<a name="218175144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218175144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218175144">(Nov 28 2020 at 18:29)</a>:</h4>
<p>(also, the <code>((∀ x, p x) → r) → (∃ x, p x → r)</code> proof is much trickier than what you want to prove!)</p>



<a name="218179643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218179643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218179643">(Nov 28 2020 at 20:29)</a>:</h4>
<p>Letting the code in TPIL and NNG do most of the work, I got this proof, but the ending is weird:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kn">include</span> <span class="n">a</span>
<span class="kn">include</span> <span class="n">r</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span> <span class="o">:=</span>
  <span class="k">assume</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">p</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)⟩,</span>
    <span class="k">assume</span> <span class="n">h2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">r</span><span class="o">,</span> <span class="k">from</span>  <span class="n">hb</span> <span class="o">(</span><span class="n">h2</span> <span class="n">b</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">aprf_to_eprf</span> <span class="o">:</span> <span class="o">((</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">false</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">false</span><span class="o">)</span>  <span class="o">:=</span>
  <span class="k">assume</span> <span class="n">h1</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">false</span><span class="o">,</span>
    <span class="k">show</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span>
      <span class="n">by_cases</span>
        <span class="o">(</span><span class="k">assume</span> <span class="n">hap</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h'</span><span class="o">,</span> <span class="n">h1</span> <span class="n">hap</span><span class="o">⟩)</span>
        <span class="o">(</span><span class="k">assume</span> <span class="n">hnap</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span>
          <span class="n">by_contra</span>
            <span class="o">(</span><span class="k">assume</span> <span class="n">hnex</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">false</span><span class="o">,</span>
              <span class="k">have</span> <span class="n">hap</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span>
                <span class="k">assume</span> <span class="n">x</span><span class="o">,</span>
                <span class="n">by_contra</span>
                  <span class="o">(</span><span class="k">assume</span> <span class="n">hnp</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span>
                    <span class="k">have</span> <span class="n">hex</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">false</span><span class="o">,</span>
                      <span class="k">from</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="k">assume</span> <span class="n">hp</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">hp</span> <span class="n">hnp</span><span class="o">)⟩,</span>
                    <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">hnex</span> <span class="n">hex</span><span class="o">),</span>
              <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">hnap</span> <span class="n">hap</span><span class="o">))</span>

<span class="kd">lemma</span> <span class="n">not_iff_imp_false</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">false</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">lemma</span> <span class="n">not_forall_implies_exist_not</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>  <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span>  <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">not_iff_imp_false</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:=</span> <span class="n">aprf_to_eprf</span> <span class="n">α</span> <span class="n">p</span> <span class="n">a</span> <span class="n">r</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h2</span> <span class="k">with</span> <span class="n">x</span> <span class="n">pxf</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">not_iff_imp_false</span> <span class="n">at</span> <span class="n">pxf</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">exists.intro</span> <span class="n">x</span> <span class="n">pxf</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">α</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">r</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">α</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">r</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218180167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218180167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218180167">(Nov 28 2020 at 20:44)</a>:</h4>
<p><span class="user-mention" data-user-id="364351">@Lars Ericson</span> can you prove it from my hint? if not, i can give you one more step :)</p>



<a name="218180260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218180260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218180260">(Nov 28 2020 at 20:47)</a>:</h4>
<p><span class="user-mention" data-user-id="221921">@Marc Huisinga</span> here is my whole proof for the original exercise.  I will go back and look harder at your hint now.  Don't give me the extra step yet.  Note my  setup leads to a proof with some strange artifacts like having to say</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">exact</span> <span class="n">α</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">r</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">α</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">r</span><span class="o">,</span>
</code></pre></div>
<p>and invoke with lots of arguments<code>exact not_forall_implies_exist_not α a r p</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kn">include</span> <span class="n">a</span>
<span class="kn">include</span> <span class="n">r</span>

<span class="kd">theorem</span> <span class="n">apxf_to_epxf</span> <span class="o">:</span> <span class="o">((</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">false</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">false</span><span class="o">)</span>  <span class="o">:=</span>
  <span class="k">assume</span> <span class="n">h1</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">false</span><span class="o">,</span>
    <span class="k">show</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span>
      <span class="n">by_cases</span>
        <span class="o">(</span><span class="k">assume</span> <span class="n">hap</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h'</span><span class="o">,</span> <span class="n">h1</span> <span class="n">hap</span><span class="o">⟩)</span>
        <span class="o">(</span><span class="k">assume</span> <span class="n">hnap</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span>
          <span class="n">by_contra</span>
            <span class="o">(</span><span class="k">assume</span> <span class="n">hnex</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">false</span><span class="o">,</span>
              <span class="k">have</span> <span class="n">hap</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span>
                <span class="k">assume</span> <span class="n">x</span><span class="o">,</span>
                <span class="n">by_contra</span>
                  <span class="o">(</span><span class="k">assume</span> <span class="n">hnp</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span>
                    <span class="k">have</span> <span class="n">hex</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">false</span><span class="o">,</span>
                      <span class="k">from</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="k">assume</span> <span class="n">hp</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">hp</span> <span class="n">hnp</span><span class="o">)⟩,</span>
                    <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">hnex</span> <span class="n">hex</span><span class="o">),</span>
              <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">hnap</span> <span class="n">hap</span><span class="o">))</span>

<span class="kd">lemma</span> <span class="n">not_iff_imp_false</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">false</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">lemma</span> <span class="n">not_forall_implies_exist_not</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>  <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span>  <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">not_iff_imp_false</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:=</span> <span class="n">apxf_to_epxf</span> <span class="n">α</span> <span class="n">p</span> <span class="n">a</span> <span class="n">r</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h2</span> <span class="k">with</span> <span class="n">x</span> <span class="n">pxf</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">not_iff_imp_false</span> <span class="n">at</span> <span class="n">pxf</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">exists.intro</span> <span class="n">x</span> <span class="n">pxf</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">α</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">r</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">α</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">r</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">exist_not_implies_not_forall</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>  <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">x</span> <span class="n">npx</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:=</span> <span class="n">h1</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">npx</span> <span class="n">h2</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">not_forall_implies_exist_not</span> <span class="n">α</span> <span class="n">a</span> <span class="n">r</span> <span class="n">p</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">exist_not_implies_not_forall</span> <span class="n">α</span> <span class="n">a</span> <span class="n">r</span> <span class="n">p</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218180582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218180582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218180582">(Nov 28 2020 at 20:56)</a>:</h4>
<p>btw:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kn">include</span> <span class="n">a</span>

<span class="kd">theorem</span> <span class="n">apxf_to_epxf</span> <span class="o">:</span> <span class="o">((</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">false</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">false</span><span class="o">)</span>  <span class="o">:=</span>
  <span class="k">assume</span> <span class="n">h1</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">false</span><span class="o">,</span>
    <span class="k">show</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span>
      <span class="n">by_cases</span>
        <span class="o">(</span><span class="k">assume</span> <span class="n">hap</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h'</span><span class="o">,</span> <span class="n">h1</span> <span class="n">hap</span><span class="o">⟩)</span>
        <span class="o">(</span><span class="k">assume</span> <span class="n">hnap</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span>
          <span class="n">by_contra</span>
            <span class="o">(</span><span class="k">assume</span> <span class="n">hnex</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">false</span><span class="o">,</span>
              <span class="k">have</span> <span class="n">hap</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span>
                <span class="k">assume</span> <span class="n">x</span><span class="o">,</span>
                <span class="n">by_contra</span>
                  <span class="o">(</span><span class="k">assume</span> <span class="n">hnp</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span>
                    <span class="k">have</span> <span class="n">hex</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">false</span><span class="o">,</span>
                      <span class="k">from</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="k">assume</span> <span class="n">hp</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">hp</span> <span class="n">hnp</span><span class="o">)⟩,</span>
                    <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">hnex</span> <span class="n">hex</span><span class="o">),</span>
              <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">hnap</span> <span class="n">hap</span><span class="o">))</span>

<span class="kd">lemma</span> <span class="n">not_forall_implies_exist_not</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>  <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span>  <span class="o">:=</span>
<span class="n">apxf_to_epxf</span> <span class="n">_</span> <span class="n">_</span> <span class="n">a</span>
</code></pre></div>



<a name="218180930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218180930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218180930">(Nov 28 2020 at 21:06)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="221921">@Marc Huisinga</span> .  What is the extra hint?  I only got this far with the first hint and I'm stuck:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">not_forall_implies_exist_not2</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>  <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span>  <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">by_contra</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="c1">-- we'd really like to use h2 now. we already have an x! how could we get ¬p x?</span>
  <span class="n">exfalso</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h3</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218181013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218181013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218181013">(Nov 28 2020 at 21:08)</a>:</h4>
<p>one thing you need to learn for these kinds of proofs is when something you're trying to do is a bad idea. <br>
for instance, if you're looping it's a bad idea. or using <code>by_contra h, apply h</code>. in this case you're destroying perfectly fine context information with <code>exfalso</code>!</p>



<a name="218181042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218181042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218181042">(Nov 28 2020 at 21:09)</a>:</h4>
<p>Actually <code>finish</code> still works after <code>exfalso</code> ;-)</p>



<a name="218181091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218181091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218181091">(Nov 28 2020 at 21:10)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> that doesn't surprise me at all, given that you've still got h1 and h2.</p>



<a name="218181116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218181116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218181116">(Nov 28 2020 at 21:11)</a>:</h4>
<p><span class="user-mention" data-user-id="364351">@Lars Ericson</span> could you maybe do something other than <code>exfalso</code> to get <code>¬p x</code>?</p>



<a name="218182099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218182099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218182099">(Nov 28 2020 at 21:33)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="221921">@Marc Huisinga</span> I got it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">negneg</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬¬</span><span class="n">p</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">by_contra</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="n">h1</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">not_forall_implies_exist_not2</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>  <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span>  <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">by_contra</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h3</span><span class="o">:</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">x</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h4</span> <span class="o">:=</span> <span class="n">exists.intro</span> <span class="n">x</span> <span class="n">h3</span><span class="o">,</span>
  <span class="n">exfalso</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h2</span> <span class="n">h4</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">negneg</span> <span class="o">(</span><span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="n">h3</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218182397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218182397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218182397">(Nov 28 2020 at 21:40)</a>:</h4>
<p>shorter (without the cumbersome double-negation departure that you could have also avoided had you done <code>by_cases h3 : p x</code> instead):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">not_forall_implies_exist_not</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>  <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span>  <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">by_contra</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">by_contra</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h2</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218182424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20do%20I%20introduce%20a%20Forall%20in%20tactic%20mode/near/218182424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/How.20do.20I.20introduce.20a.20Forall.20in.20tactic.20mode.html#218182424">(Nov 28 2020 at 21:41)</a>:</h4>
<p>term mode:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">not_forall_implies_exist_not'</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>  <span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span>  <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h1</span><span class="o">,</span> <span class="n">by_contradiction</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h2</span><span class="o">,</span> <span class="n">h1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">by_contradiction</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h2</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩)))</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
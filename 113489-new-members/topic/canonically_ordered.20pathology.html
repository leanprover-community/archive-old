---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/canonically_ordered.20pathology.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html">canonically_ordered pathology</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="225129909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225129909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225129909">(Feb 04 2021 at 08:14)</a>:</h4>
<p>Dear All,</p>
<p>the doc-strings for <code>canonically_ordered_comm_semiring</code> says:</p>
<blockquote>
<p>A canonically ordered commutative semiring is an ordered, commutative semiring in which <code>a ≤ b</code> iff there exists <code>c</code> with <code>b = a + c</code>. This is satisfied by the natural numbers, for example, but not the integers or other ordered groups.</p>
</blockquote>
<p>However, it does not seem like a <code>canonically_ordered_comm_semiring</code> is actually an <code>ordered_semiring</code>.  At least, Lean could not generate the instance in this example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ordered_ring</span>

<span class="kd">instance</span> <span class="n">cosr</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">canonically_ordered_comm_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>
<p>Playing with it a bit, it seems that the left/right cancellative properties of addition cause problems.  I do not know enough pathological examples of <code>ordered_semiring</code>s or <code>canonically_ordered_comm_semiring</code> to form an opinion on whether the instance above can be proven.</p>
<p>Any ideas?</p>
<p>Thank you very much!</p>



<a name="225130083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225130083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225130083">(Feb 04 2021 at 08:17)</a>:</h4>
<p>(In case people are curious, this is an offspring of trying to prove </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">add_le_mul</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">canonically_ordered_comm_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a2</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">b2</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span>
</code></pre></div>
<p>While I only care about the case in which <code>α = ℕ</code>, a case that I <em>can</em> prove, I was trying to port this to mathlib in greater generality.)</p>



<a name="225130236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225130236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225130236">(Feb 04 2021 at 08:19)</a>:</h4>
<p>you don't need <code>nontrivial</code> for that, right?</p>



<a name="225130433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225130433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225130433">(Feb 04 2021 at 08:22)</a>:</h4>
<p>I think your lemma should be true in any <code>ordered_semiring</code>, you don't need the <code>canonical</code> either, do you?</p>



<a name="225130568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225130568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225130568">(Feb 04 2021 at 08:24)</a>:</h4>
<p>I may not need either one of these assumptions, but I did assume <code>nontrivial</code> in the lemma that I intend to use to prove my application.</p>
<p>In my actual proof, I wanted to use the implication "<code>a \leq b</code> means that there exists a <code>c</code> such that <code>b = a + c</code>", hence the <code>canonical</code>!</p>



<a name="225130837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225130837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225130837">(Feb 04 2021 at 08:28)</a>:</h4>
<p>To fully disclose my arguments, see the code below!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">algebra.ordered_ring</span>

<span class="kd">lemma</span> <span class="n">add_le_mul_two_add</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span>
  <span class="o">(</span><span class="n">a2</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">b0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">calc</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
      <span class="n">add_le_add_left</span> <span class="o">(</span><span class="n">add_le_add</span> <span class="n">a2</span> <span class="o">(</span><span class="n">le_mul_of_one_le_left</span> <span class="n">b0</span> <span class="o">(</span><span class="n">one_le_two.trans</span> <span class="n">a2</span><span class="o">)))</span> <span class="n">a</span>
             <span class="bp">...</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
      <span class="n">le_trans</span> <span class="o">(</span><span class="n">le_trans</span> <span class="o">(</span><span class="n">le_of_eq</span> <span class="o">(</span><span class="n">add_assoc</span> <span class="n">a</span> <span class="n">a</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">rfl.ge</span> <span class="o">(</span><span class="n">add_le_add_right</span>
      <span class="o">(</span><span class="n">le_of_eq</span> <span class="o">(</span><span class="n">mul_two</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span> <span class="n">_</span><span class="o">)))</span> <span class="o">(</span><span class="n">le_of_eq</span> <span class="o">(</span><span class="n">mul_add</span> <span class="n">a</span> <span class="mi">2</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span>


<span class="c1">-- the lemma that I really care about, that works</span>
<span class="kd">lemma</span> <span class="n">add_le_mul</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">a2</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">b2</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">le_iff_exists_add.mp</span> <span class="n">b2</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">exact</span> <span class="n">add_le_mul_two_add</span> <span class="n">a2</span> <span class="n">k.zero_le</span>
<span class="kd">end</span>

<span class="c1">-- how I would like to port it to mathlib, possibly with different assumptions, since now the exact line fails</span>
<span class="kd">lemma</span> <span class="n">add_le_mul_canonical</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">canonically_ordered_comm_semiring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">a2</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">b2</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">le_iff_exists_add.mp</span> <span class="n">b2</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">exact</span> <span class="n">add_le_mul_two_add</span> <span class="n">a2</span> <span class="n">k.zero_le</span>
<span class="kd">end</span>
</code></pre></div>



<a name="225130857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225130857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225130857">(Feb 04 2021 at 08:28)</a>:</h4>
<p>There's been quite some discussion about this lemma on the Discord. Without subtraction it's not clear how to prove it but conversely we don't know enough weird ordered semirings to know if there's a counterexample. It's true if 2a&lt;=2b implies a&lt;=b but we think we know canonically ordered semirings where this fails, except that these semirings do not satisfy additive cancellation. The trick is to start with a ring like the naturals and then if S is a random subset of the naturals to add extra "ghost" elements to the ring, one for each element of S, such that addition of non-ghost 0 and multiplication by non-ghost 1 are the identity maps but the answer to everything else is the non-ghost number, so for example 2+2=non-ghost 4 whether the original 2s are ghosts or not</p>



<a name="225131154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225131154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225131154">(Feb 04 2021 at 08:32)</a>:</h4>
<p>I think <a href="https://github.com/leanprover-community/mathlib/issues/6034">#6034</a> resolves the nontrivial comment.</p>



<a name="225131174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225131174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225131174">(Feb 04 2021 at 08:32)</a>:</h4>
<p>I was wondering about something like <code>N+N/2</code>, where you have <code>(1,0)+(1,0)=(1,1)+(1,1)</code>.</p>
<p>I am not sure though whether you need a total order, or not... I do not know enough about these canonically_[stuff].</p>



<a name="225131269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225131269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225131269">(Feb 04 2021 at 08:33)</a>:</h4>
<p>For canonically ordered comm semirings can't you just write a=2+x and b=2+y and deduce it from the fact that a+b+(x+y+xy)=ab?</p>



<a name="225131370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225131370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225131370">(Feb 04 2021 at 08:34)</a>:</h4>
<p>Canonically ordered stuff us easy because it just means that the order is determined by the addition</p>



<a name="225131391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225131391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225131391">(Feb 04 2021 at 08:34)</a>:</h4>
<p>Ok, I will try with your version!</p>



<a name="225131437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225131437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225131437">(Feb 04 2021 at 08:35)</a>:</h4>
<p>The problem with canonically ordered things is that essentially nothing is canonically ordered, eg the integers aren't canonically ordered</p>



<a name="225131438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225131438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225131438">(Feb 04 2021 at 08:35)</a>:</h4>
<p>(Note that I added the canonically_ordered <em>after</em> I tried to use the previous lemma, so I have actually not really thought about canonically_ordered things...)</p>



<a name="225131565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225131565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225131565">(Feb 04 2021 at 08:37)</a>:</h4>
<p>If you have a multiplication, you could try to use squares to make canonically_ordered things more applicable?  I am thinking along the lines of sums of squares are non-negative...  Anyway, this is a separate issue!</p>



<a name="225131590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225131590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225131590">(Feb 04 2021 at 08:37)</a>:</h4>
<p>The moment there's a nontrivial solution to a+b=0 you're not canonically ordered. However things like 2&lt;=a and 2&lt;=b implies a+b&lt;=ab are true for any totally ordered semiring because then wlog a&lt;=b and so a+b&lt;=2b&lt;=ab</p>



<a name="225131695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225131695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225131695">(Feb 04 2021 at 08:38)</a>:</h4>
<p>I don't think I know a single example of an ordered semiring which isn't canonically ordered or totally ordered though</p>



<a name="225131770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225131770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225131770">(Feb 04 2021 at 08:39)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">add_le_mul₁</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_ordered_semiring</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a2</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">ab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">have</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">,</span> <span class="k">from</span>
<span class="k">calc</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">zero_lt_two</span>
   <span class="bp">...</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">:</span> <span class="n">a2</span>
   <span class="bp">...</span> <span class="bp">≤</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ab</span><span class="o">,</span>
<span class="k">calc</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span> <span class="o">:</span> <span class="n">add_le_add_right</span> <span class="n">ab</span> <span class="n">b</span>
       <span class="bp">...</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:</span> <span class="o">(</span><span class="n">two_mul</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
       <span class="bp">...</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:</span> <span class="o">(</span><span class="n">mul_le_mul_right</span> <span class="n">this</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">a2</span>

<span class="kd">lemma</span> <span class="n">add_le_mul₂</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_ordered_semiring</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">b2</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">ba</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">have</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span>
<span class="k">calc</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">zero_lt_two</span>
   <span class="bp">...</span> <span class="bp">≤</span> <span class="n">b</span> <span class="o">:</span> <span class="n">b2</span>
   <span class="bp">...</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ba</span><span class="o">,</span>
<span class="k">calc</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">a</span> <span class="o">:</span> <span class="n">add_le_add_left</span> <span class="n">ba</span> <span class="n">a</span>
       <span class="bp">...</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">2</span> <span class="o">:</span> <span class="o">(</span><span class="n">mul_two</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
       <span class="bp">...</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:</span> <span class="o">(</span><span class="n">mul_le_mul_left</span> <span class="n">this</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">b2</span>

<span class="kd">lemma</span> <span class="n">add_le_mul</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_ordered_semiring</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a2</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">b2</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">hab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">add_le_mul₁</span> <span class="n">a2</span> <span class="n">hab</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">push_neg</span> <span class="n">at</span> <span class="n">hab</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">add_le_mul₂</span> <span class="n">b2</span> <span class="n">hab.le</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="225131784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225131784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225131784">(Feb 04 2021 at 08:39)</a>:</h4>
<p>This assumes linearity...</p>



<a name="225131792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225131792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225131792">(Feb 04 2021 at 08:39)</a>:</h4>
<p>But not commutativity</p>



<a name="225131796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225131796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225131796">(Feb 04 2021 at 08:39)</a>:</h4>
<p>Does <code>ℕ ⊕ (ℤ / 2)</code> with the partial order induced by projection onto the first component fail to be an ordered semiring?</p>



<a name="225131803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225131803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225131803">(Feb 04 2021 at 08:39)</a>:</h4>
<p>Maybe the complexes with a&lt;=b iff b-a is a non-negative real? No idea</p>



<a name="225131929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225131929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225131929">(Feb 04 2021 at 08:41)</a>:</h4>
<p>Johan you should just use wlog for add_le_mul to save code duplication</p>



<a name="225132011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132011">(Feb 04 2021 at 08:42)</a>:</h4>
<p>Can <code>wlog</code> do that without assume <code>comm</code>?</p>



<a name="225132018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132018">(Feb 04 2021 at 08:42)</a>:</h4>
<p>Oh! No! I'd not spotted that you didn't assume commutativity. Sorry</p>



<a name="225132021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132021">(Feb 04 2021 at 08:42)</a>:</h4>
<p>Dunno...</p>



<a name="225132054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132054">(Feb 04 2021 at 08:43)</a>:</h4>
<p>I guess I can remove the <code>\_2</code> version by using the opposite ring</p>



<a name="225132094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132094">(Feb 04 2021 at 08:43)</a>:</h4>
<p>What the heck is Z/2? How do you do multiplication on that?</p>



<a name="225132184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132184">(Feb 04 2021 at 08:44)</a>:</h4>
<p>I meant the commutative ring with exactly two elements.  I may be missing something very basic, though...</p>



<a name="225132185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132185">(Feb 04 2021 at 08:44)</a>:</h4>
<p>I guess he means <code>zmod 2</code>?</p>



<a name="225132217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132217">(Feb 04 2021 at 08:45)</a>:</h4>
<p>And what is the partial order induced by the first component? Does it really satisfy the partial order axiom a&lt;=b and b&lt;=a implies a=b?</p>



<a name="225132256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132256">(Feb 04 2021 at 08:45)</a>:</h4>
<p>Aah, Z mod 2 :-) But what is the order?</p>



<a name="225132290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132290">(Feb 04 2021 at 08:45)</a>:</h4>
<p>It's not canonically ordered because there are nontrivial solutions to a+b=0</p>



<a name="225132335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132335">(Feb 04 2021 at 08:46)</a>:</h4>
<p>Maybe it does not work, but I had in mind (x,y) \leq (x',y') iff<br>
x &lt; x'<br>
or<br>
x = x' and they are actually equal</p>



<a name="225132345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132345">(Feb 04 2021 at 08:46)</a>:</h4>
<p>I believe it might be the lex order</p>



<a name="225132407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132407">(Feb 04 2021 at 08:47)</a>:</h4>
<p>No, lex is a total order</p>



<a name="225132425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132425">(Feb 04 2021 at 08:47)</a>:</h4>
<p>Ok, so this example is not canonically ordered!  I have tried to unfold all the properties of canonically_ordered, but I am constantly missing some...</p>



<a name="225132442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132442">(Feb 04 2021 at 08:47)</a>:</h4>
<p>And here you're saying (X,0) and (X,1) are incomparable</p>



<a name="225132455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132455">(Feb 04 2021 at 08:47)</a>:</h4>
<p>Ah, you are right about lex!  I want to make incomparable the two different elements with the same first component.  Anyway, this does not work!</p>



<a name="225132456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132456">(Feb 04 2021 at 08:47)</a>:</h4>
<p><code>(0,0) &lt; (0,1)</code>? But <code>(0,1) + (0,1) = (0,0)</code>, right?</p>



<a name="225132508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132508">(Feb 04 2021 at 08:48)</a>:</h4>
<p>I think 00 and 01 are incomparable?</p>



<a name="225132513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132513">(Feb 04 2021 at 08:48)</a>:</h4>
<p>aha, ok</p>



<a name="225132531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132531">(Feb 04 2021 at 08:48)</a>:</h4>
<p>This might be an ordered semiring</p>



<a name="225132539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132539">(Feb 04 2021 at 08:48)</a>:</h4>
<p>Yes, (0,0) incomp with (0,1), but still (0,1)+(0,1)=(0,0)...</p>



<a name="225132541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132541">(Feb 04 2021 at 08:48)</a>:</h4>
<p>Which isn't canonically or totally ordered</p>



<a name="225132556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132556">(Feb 04 2021 at 08:49)</a>:</h4>
<p>Is that a problem?</p>



<a name="225132597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132597">(Feb 04 2021 at 08:49)</a>:</h4>
<p>No, I am floating on the surface of definitions and I remember you saying that a non-trivial sol to a+b=0 was a problem... ahahha</p>



<a name="225132619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132619">(Feb 04 2021 at 08:49)</a>:</h4>
<p>Rather irritatingly it seems to satisfy 2&lt;=a and 2&lt;=b implies a+b&lt;=ab though</p>



<a name="225132743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132743">(Feb 04 2021 at 08:51)</a>:</h4>
<p>This is somewhat frustrating.  I may have to write all the definitions down on a piece of paper, since chasing them around with <code>extends</code> makes it very hard for me to remember what we are assuming and what not!</p>



<a name="225132756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132756">(Feb 04 2021 at 08:51)</a>:</h4>
<p>Canonical order is easy Damiano. From the ring axioms you can easily check that a&lt;=b iff exists c such that b=a+c is reflexive and transitive, but you don't get antisymmetry usually</p>



<a name="225132851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132851">(Feb 04 2021 at 08:52)</a>:</h4>
<p>And any questions about &lt;= just immediately translate into questions about algebra with no &lt;=</p>



<a name="225132888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132888">(Feb 04 2021 at 08:53)</a>:</h4>
<p>Eg 2&lt;=a and 2&lt;=b implies a+b&lt;=ab is easy</p>



<a name="225132915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132915">(Feb 04 2021 at 08:53)</a>:</h4>
<p>The problem is that it's basically never antisymmetric</p>



<a name="225132934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225132934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225132934">(Feb 04 2021 at 08:53)</a>:</h4>
<p>Ok, canonically ordered implies that you cannot keep adding non-zero elements to an element and get back to a place you already visited.  I am on board with this!</p>



<a name="225133006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225133006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225133006">(Feb 04 2021 at 08:54)</a>:</h4>
<p>Canonically ordered means that the order is not there</p>



<a name="225133143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225133143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225133143">(Feb 04 2021 at 08:55)</a>:</h4>
<p>(I am going to have to meet with a student in 5 mins, but I am finding this discussion strangely interesting!)</p>



<a name="225133238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225133238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225133238">(Feb 04 2021 at 08:56)</a>:</h4>
<p>I think we still have the question as to whether add_le_mul is true in a general commutative ordered semiring</p>



<a name="225133263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225133263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225133263">(Feb 04 2021 at 08:57)</a>:</h4>
<p>Or maybe even not commutative... <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="225133272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225133272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225133272">(Feb 04 2021 at 08:57)</a>:</h4>
<p>I suspect not but I don't have enough good examples</p>



<a name="225133450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225133450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225133450">(Feb 04 2021 at 08:59)</a>:</h4>
<p>What about Z+Z/3 and (2,1)+(2,1) not le (4,1)?</p>



<a name="225133455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225133455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225133455">(Feb 04 2021 at 08:59)</a>:</h4>
<p>I need to go now!</p>



<a name="225133457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225133457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225133457">(Feb 04 2021 at 08:59)</a>:</h4>
<p>But independent of that, the question of whether a canonically ordered comm semiring is an ordered semiring should be resolved because either there's a missing instance or there's an argument that we have our axioms wrong.</p>



<a name="225133530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225133530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225133530">(Feb 04 2021 at 09:00)</a>:</h4>
<p>But (2,1) isn't &gt;= 2</p>



<a name="225133544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225133544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225133544">(Feb 04 2021 at 09:00)</a>:</h4>
<p>Aaargh!!</p>



<a name="225133552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225133552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225133552">(Feb 04 2021 at 09:00)</a>:</h4>
<p>At least in the order we were discussing</p>



<a name="225133593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225133593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225133593">(Feb 04 2021 at 09:00)</a>:</h4>
<p>Just make it &gt;= 2 maybe?</p>



<a name="225133613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225133613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225133613">(Feb 04 2021 at 09:01)</a>:</h4>
<p>Yes, that was the order I had in mind...  My example does not work... again!</p>



<a name="225133619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225133619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225133619">(Feb 04 2021 at 09:01)</a>:</h4>
<p>The problem is that this might also cause problems at 4</p>



<a name="225134005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225134005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225134005">(Feb 04 2021 at 09:05)</a>:</h4>
<p>Maybe R=nat x nat with (a,b)&lt;=(c,d) iff either a&lt;c or (a=c and b=0) is an ordered semiring. If so then we're good because a=b=(2,1) would be a counterexample</p>



<a name="225134165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225134165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225134165">(Feb 04 2021 at 09:06)</a>:</h4>
<p>Hmm it doesn't work because a&lt;=b implies a+c&lt;=b+c fails. I'm assuming that's an axiom!</p>



<a name="225134246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225134246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225134246">(Feb 04 2021 at 09:07)</a>:</h4>
<p>Maybe drop random stuff like (0,0)&lt;(0,1) too?</p>



<a name="225135315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225135315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225135315">(Feb 04 2021 at 09:18)</a>:</h4>
<p>If anyone can actually extract all the axioms and make <span class="user-mention" data-user-id="345260">@Andrej Bauer</span>s alg work on this that might shed some light, <a href="https://github.com/andrejbauer/alg">https://github.com/andrejbauer/alg</a> as we're only working with semirings there may exist finite examples?</p>



<a name="225135316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225135316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225135316">(Feb 04 2021 at 09:18)</a>:</h4>
<p>I want to say the following: define a relation on nat x nat^2 (with the obvious ring structure) by demanding (a,b)&lt;=(c,d) if a&lt;=c and b=d, and also (2,00)&lt;=(2,01) and (2,00)&lt;=(2,10). Now take the smallest preorder structure which extends this and makes N x N^2 into a preordered semiring. Three things can happen. Either it's not an ordered semiring, in which case the argument that it isn't can be turned into a proof of add_le_mul for ordered semirings. Or it is an ordered semiring and (4,11)&lt;=(4,00) (this to me is unlikely) and then this will also turn into a proof for ordered semirings. Or, finally, it is an ordered semiring and (4,11) is not &lt;= (4,00), which gives us our counterexample.</p>



<a name="225135398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225135398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225135398">(Feb 04 2021 at 09:19)</a>:</h4>
<p>Something still looks wrong with what I've said</p>



<a name="225135556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225135556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225135556">(Feb 04 2021 at 09:21)</a>:</h4>
<p>what does <code>gpt</code> say?</p>



<a name="225136043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225136043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225136043">(Feb 04 2021 at 09:26)</a>:</h4>
<p>Lol</p>



<a name="225136241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225136241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225136241">(Feb 04 2021 at 09:28)</a>:</h4>
<p>I want to say the following: define a relation on nat x nat^2 (with the obvious ring structure) by demanding (a,b)&lt;=(c,d) if a&lt;=c and b=d, and also (2,00)&lt;=(2,01) and (2,00)&lt;=(2,10). Now take the smallest preorder structure which extends this and makes N x N^2 into a preordered semiring. Three things can happen. Either it's not an ordered semiring, in which case the argument that it isn't can be turned into a proof of add_le_mul for ordered semirings. Or it is an ordered semiring and (4,11)&lt;=(4,00) (this to me is unlikely) and then this will also turn into a proof for ordered semirings. Or, finally, it is an ordered semiring and (4,11) is not &lt;= (4,00), which gives us our counterexample.</p>



<a name="225136293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225136293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225136293">(Feb 04 2021 at 09:28)</a>:</h4>
<p>Oh my mistake is that (2,0) is not 2 in nat X nat with the obvious ring structure</p>



<a name="225136856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225136856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225136856">(Feb 04 2021 at 09:34)</a>:</h4>
<p>But I think that one can still make this strategy work. Consider the polynomial ring N[a,b] with the usual ring structure. Now define f&lt;=g if  g in f+nat, and also say 2&lt;=a and 2&lt;=b. Now take the smallest pre-order extending this and making it into a preordered semiring, and then take the smallest quotient making it an ordered semiring. Either this is a counterexample or there is no counterexample</p>



<a name="225137147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225137147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225137147">(Feb 04 2021 at 09:37)</a>:</h4>
<p>I like the idea of using Bauer's tool. Is antisymmetry ok? It's an implication</p>



<a name="225137264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225137264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225137264">(Feb 04 2021 at 09:38)</a>:</h4>
<p>My meeting is over.</p>
<p>Kevin, I like your approach!<br>
About finite examples: I need to look whether ordered semirings must have some form of assumption saying that 1+1+... never repeats.</p>



<a name="225137364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225137364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225137364">(Feb 04 2021 at 09:39)</a>:</h4>
<p>Yeah I just played with it a bit and you can specify <code>not  (..)</code>, <code>a -&gt; b</code>, <code>a &lt;-&gt; b</code>, and <code>exists z, y = x + z</code> all fine, I'm just not sure what the complete list of axioms we need is!</p>



<a name="225137659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225137659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225137659">(Feb 04 2021 at 09:42)</a>:</h4>
<p><code>#print ordered_semiring</code> should give you a full list, right?</p>



<a name="225137747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225137747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225137747">(Feb 04 2021 at 09:43)</a>:</h4>
<p>indeed!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="n">ordered_semiring</span>

<span class="kd">@[class, protect_proj list.nil.{0} name]</span>
<span class="kd">structure</span> <span class="n">ordered_semiring</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">fields</span><span class="o">:</span>
<span class="n">ordered_semiring.add</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">],</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="n">ordered_semiring.add_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c_1</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c_1</span><span class="o">)</span>
<span class="n">ordered_semiring.zero</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">],</span> <span class="n">α</span>
<span class="n">ordered_semiring.zero_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span>
<span class="n">ordered_semiring.add_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span>
<span class="n">ordered_semiring.add_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span>
<span class="n">ordered_semiring.mul</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">],</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="n">ordered_semiring.mul_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c_1</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c_1</span><span class="o">)</span>
<span class="n">ordered_semiring.one</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">],</span> <span class="n">α</span>
<span class="n">ordered_semiring.one_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span>
<span class="n">ordered_semiring.mul_one</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">a</span>
<span class="n">ordered_semiring.zero_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="n">ordered_semiring.mul_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="n">ordered_semiring.left_distrib</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c_1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c_1</span>
<span class="n">ordered_semiring.right_distrib</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">c_1</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c_1</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c_1</span>
<span class="n">ordered_semiring.add_left_cancel</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c_1</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c_1</span>
<span class="n">ordered_semiring.add_right_cancel</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c_1</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">c_1</span>
<span class="n">ordered_semiring.le</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">],</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="n">ordered_semiring.lt</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">],</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="n">ordered_semiring.le_refl</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">a</span>
<span class="n">ordered_semiring.le_trans</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c_1</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c_1</span>
<span class="n">ordered_semiring.lt_iff_le_not_le</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">],</span>
  <span class="n">auto_param</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">∧</span> <span class="bp">¬</span><span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">name.mk_string</span> <span class="s2">"order_laws_tac"</span> <span class="n">name.anonymous</span><span class="o">)</span>
<span class="n">ordered_semiring.le_antisymm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span>
<span class="n">ordered_semiring.add_le_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">c_1</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c_1</span> <span class="bp">+</span> <span class="n">b</span>
<span class="n">ordered_semiring.le_of_add_le_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c_1</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c_1</span>
<span class="n">ordered_semiring.zero_le_one</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">],</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="mi">1</span>
<span class="n">ordered_semiring.mul_lt_mul_of_pos_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">c_1</span> <span class="bp">→</span> <span class="n">c_1</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c_1</span> <span class="bp">*</span> <span class="n">b</span>
<span class="n">ordered_semiring.mul_lt_mul_of_pos_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">c_1</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c_1</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c_1</span>
</code></pre></div>



<a name="225137865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225137865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225137865">(Feb 04 2021 at 09:45)</a>:</h4>
<p>Ok, but most of these are easy: the ones with 0 and 1 we know!</p>



<a name="225138041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225138041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225138041">(Feb 04 2021 at 09:46)</a>:</h4>
<p>Ok I can't do this alg thing now but if nobody else does I'll try tomorrow (who knows maybe someone will have a non brute force genuine math proof by then <span aria-label="grimacing" class="emoji emoji-1f62c" role="img" title="grimacing">:grimacing:</span> )</p>



<a name="225138107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225138107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225138107">(Feb 04 2021 at 09:47)</a>:</h4>
<p>Removing the axioms having to do with <code>ring</code> (associative, distributive,...), the ones with <code>0</code> and <code>1</code> and order relation:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="n">ordered_semiring</span>

<span class="kd">@[class, protect_proj list.nil.{0} name]</span>
<span class="kd">structure</span> <span class="n">ordered_semiring</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">fields</span><span class="o">:</span>
<span class="n">ordered_semiring.add_left_cancel</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span>
  <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c_1</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c_1</span>
<span class="n">ordered_semiring.add_le_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span>
  <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">c_1</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c_1</span> <span class="bp">+</span> <span class="n">b</span>
<span class="n">ordered_semiring.le_of_add_le_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span>
  <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c_1</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c_1</span>
<span class="n">ordered_semiring.zero_le_one</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">],</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="mi">1</span>
<span class="n">ordered_semiring.mul_lt_mul_of_pos_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span>
  <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">c_1</span> <span class="bp">→</span> <span class="n">c_1</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c_1</span> <span class="bp">*</span> <span class="n">b</span>
<span class="n">ordered_semiring.mul_lt_mul_of_pos_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span>
  <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">c_1</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c_1</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c_1</span>
</code></pre></div>



<a name="225138927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225138927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225138927">(Feb 04 2021 at 09:55)</a>:</h4>
<p>In particular, such rings have characteristic zero: if <code>n, m</code> are natural numbers, then <code>n+m=m</code>implies <code>n = 0</code> by writing <code>n+m=n+0</code> and using one of the <code>add_cancel</code>.</p>



<a name="225138971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225138971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225138971">(Feb 04 2021 at 09:55)</a>:</h4>
<p>So a non-trivial ordered ring is necessarily infinite.</p>



<a name="225139025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225139025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225139025">(Feb 04 2021 at 09:56)</a>:</h4>
<p>Can Lean find the <code>char_zero</code> instance?</p>



<a name="225139043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225139043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225139043">(Feb 04 2021 at 09:56)</a>:</h4>
<p>hmmm, I am not sure what <code>char_zero</code> in lean means...</p>



<a name="225139046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225139046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225139046">(Feb 04 2021 at 09:56)</a>:</h4>
<p>let me try</p>



<a name="225139155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225139155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225139155">(Feb 04 2021 at 09:57)</a>:</h4>
<p>I cannot find <code>char_zero</code>...  should I import something?</p>



<a name="225139206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225139206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225139206">(Feb 04 2021 at 09:58)</a>:</h4>
<p>(I'll make some tea in the meanwhile!)</p>



<a name="225139255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225139255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225139255">(Feb 04 2021 at 09:58)</a>:</h4>
<div class="codehilite" data-code-language="Bash"><pre><span></span><code>$ rg -l char_zero
test/norm_num.lean
scripts/style-exceptions.txt
docs/undergrad.yaml
docs/overview.yaml
test/ring.lean
src/field_theory/separable.lean
src/field_theory/polynomial_galois_group.lean
src/algebra/char_zero.lean
src/algebra/field_power.lean
src/algebra/invertible.lean
src/tactic/norm_num.lean
archive/imo/imo1962_q4.lean
src/data/quaternion.lean
src/ring_theory/roots_of_unity.lean
src/algebra/char_p/basic.lean
src/algebra/algebra/basic.lean
src/algebra/module/basic.lean
src/algebra/algebra/tower.lean
src/ring_theory/polynomial/cyclotomic.lean
src/analysis/normed_space/basic.lean
src/data/polynomial/derivative.lean
src/data/num/lemmas.lean
src/data/int/char_zero.lean
src/ring_theory/witt_vector/witt_polynomial.lean
src/linear_algebra/affine_space/independent.lean
src/linear_algebra/affine_space/midpoint.lean
src/linear_algebra/affine_space/combination.lean
src/data/complex/basic.lean
src/data/complex/is_R_or_C.lean
src/data/padics/padic_numbers.lean
src/data/padics/padic_integers.lean
src/data/rat/cast.lean
src/data/real/ennreal.lean
src/data/zsqrtd/basic.lean
</code></pre></div>



<a name="225139346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225139346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225139346">(Feb 04 2021 at 09:59)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- src/algebra/char_zero.lean</span>
<span class="kd">@[priority 100]</span> <span class="c1">-- see Note [lower instance priority]</span>
<span class="kd">instance</span> <span class="n">linear_ordered_semiring.to_char_zero</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">linear_ordered_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">char_zero</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">nat.strict_mono_cast.injective</span><span class="o">⟩</span>
</code></pre></div>



<a name="225139354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225139354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225139354">(Feb 04 2021 at 09:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/canonically_ordered.20pathology/near/225139155">said</a>:</p>
<blockquote>
<p>I cannot find <code>char_zero</code>...  should I import something?</p>
</blockquote>
<p>Search in VS Code for <code>char_zero</code>, find any file which uses it, open that file, wait for the orange bars to go away, and then right click on it to find where it's defined.</p>



<a name="225139399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225139399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225139399">(Feb 04 2021 at 10:00)</a>:</h4>
<p>So Lean knows it for linear ordered semirings...</p>



<a name="225139545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225139545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225139545">(Feb 04 2021 at 10:01)</a>:</h4>
<p>If you don't like waiting for orange bars... just use <code>grep</code> (-;</p>



<a name="225139617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225139617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225139617">(Feb 04 2021 at 10:01)</a>:</h4>
<p>Just guess that it's defined as a <code>class</code>, and grep for <code>class char_zero</code>.</p>



<a name="225139635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225139635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225139635">(Feb 04 2021 at 10:01)</a>:</h4>
<p>But <code>grep</code> won't find where the definition is, it will just print a gazillion times when it's used. Then you have to start guessing about whether it's a structure or class or a def.</p>



<a name="225139728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225139728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225139728">(Feb 04 2021 at 10:02)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">$</span> <span class="n">rg</span> <span class="s2">"class char_zero"</span>
<span class="n">src</span><span class="bp">/</span><span class="n">algebra</span><span class="bp">/</span><span class="n">char_zero.lean</span>
<span class="mi">14</span><span class="o">:</span><span class="kd">class</span> <span class="n">char_zero</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
</code></pre></div>



<a name="225139743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225139743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225139743">(Feb 04 2021 at 10:02)</a>:</h4>
<p>Aah right, if you can guess it's a class then you might be fine. Except that things like topological_space are a class but are defined as a structure</p>



<a name="225139882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225139882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225139882">(Feb 04 2021 at 10:03)</a>:</h4>
<p>If you use the <code>-l</code> flag, then the gazillion times it's used will be reduced to the dozen filenames where it's used. Often I can guess which filename is the most "elementary" and likely contains the def'n.</p>



<a name="225139970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225139970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225139970">(Feb 04 2021 at 10:04)</a>:</h4>
<p>I like the -l trick!</p>



<a name="225140011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140011">(Feb 04 2021 at 10:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/canonically_ordered.20pathology/near/225138927">said</a>:</p>
<blockquote>
<p>In particular, such rings have characteristic zero: if <code>n, m</code> are natural numbers, then <code>n+m=m</code>implies <code>n = 0</code> by writing <code>n+m=n+0</code> and using one of the <code>add_cancel</code>.<br>
So a non-trivial ordered ring is necessarily infinite.</p>
</blockquote>
<p>Does char_zero imply infinite in this setting? It needn't in general right, adding 1 can just be absorbative into itself (<code>1+1=1</code>)?</p>



<a name="225140077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140077">(Feb 04 2021 at 10:05)</a>:</h4>
<p>Is <code>fin n</code> an ordered semiring?</p>



<a name="225140090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140090">(Feb 04 2021 at 10:05)</a>:</h4>
<p>I think that I can prove that n+m=n implies m=0, though...</p>



<a name="225140236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140236">(Feb 04 2021 at 10:06)</a>:</h4>
<p>because that isn't true in <code>fin n</code></p>



<a name="225140273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140273">(Feb 04 2021 at 10:07)</a>:</h4>
<p>(this is not Z/n, this is the stupid addition where big+big=n-1)</p>



<a name="225140297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140297">(Feb 04 2021 at 10:07)</a>:</h4>
<p>I think that the proof above shows that fin n is not an ordered semiring</p>



<a name="225140317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140317">(Feb 04 2021 at 10:07)</a>:</h4>
<p>It's the quotient of nat by the relation n-1=n=n+1=n+2=.... Why is this not an ordered semiring?</p>



<a name="225140430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140430">(Feb 04 2021 at 10:08)</a>:</h4>
<p>n+1=n implies n+1=n+0 and you cancel n</p>



<a name="225140439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140439">(Feb 04 2021 at 10:08)</a>:</h4>
<p>Yeah this cancellative property is way stronger than my internal model of what an ordered semiring is!</p>



<a name="225140470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140470">(Feb 04 2021 at 10:09)</a>:</h4>
<p>Cancellation is an axiom for ordered semiring? :-/</p>



<a name="225140497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140497">(Feb 04 2021 at 10:09)</a>:</h4>
<p>Yes, the axioms are further up in the thread</p>



<a name="225140507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140507">(Feb 04 2021 at 10:09)</a>:</h4>
<p>Is ordered semiring just something which some mathlib dev just made up? It's not like there's a Wikipedia page on it.</p>



<a name="225140596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140596">(Feb 04 2021 at 10:10)</a>:</h4>
<p>I do not know the source of the concept: I did not know it before yesterday evening!</p>



<a name="225140678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140678">(Feb 04 2021 at 10:11)</a>:</h4>
<p>And I only looked at all the axioms on the same place after Johan's suggestion of <code>print</code>ing them!</p>



<a name="225140726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140726">(Feb 04 2021 at 10:11)</a>:</h4>
<p>In mathlib it extends <code>ordered_cancel_add_comm_monoid</code>. In the few references I can find on the internet, this is not mentioned. The definition in mathlib does not really seem to match the docstring.</p>



<a name="225140807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140807">(Feb 04 2021 at 10:12)</a>:</h4>
<p>sounds like we are in for a giant refactor <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span></p>



<a name="225140838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140838">(Feb 04 2021 at 10:13)</a>:</h4>
<p>I do not see the point of the class at all</p>



<a name="225140857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140857">(Feb 04 2021 at 10:13)</a>:</h4>
<p>And just to prove that the sum is less than the product...</p>



<a name="225140915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140915">(Feb 04 2021 at 10:14)</a>:</h4>
<p>But for this <code>add_mul</code> thing, this cancellation axiom presents a big problem for my strategy.</p>



<a name="225140960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225140960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225140960">(Feb 04 2021 at 10:14)</a>:</h4>
<p>The idea is this. Construct the "universal commutative ordered semiring with 2&lt;=a and 2&lt;=b" and check it there.</p>



<a name="225141094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225141094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225141094">(Feb 04 2021 at 10:16)</a>:</h4>
<p>Now I had imagined that this would not be too hard. Here's a sketch of what I had in mind. First start with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\N[a,b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> and assume <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0&lt;1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">2\leq a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">2\leq b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>. Certainly there are orders making this into an ordered semiring, for example you can map into the reals sending a to [random transcendental number bigger than 2] and b to [random independent transcendental bigger than 2] and then pull the order back.</p>



<a name="225141125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225141125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225141125">(Feb 04 2021 at 10:17)</a>:</h4>
<p>From this perspective, the cancellation axioms appear very strange.  However, I am perfectly happy to assume existence of opposites and it seems a weak condition to assume</p>



<a name="225141223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225141223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225141223">(Feb 04 2021 at 10:18)</a>:</h4>
<p>Now I suspect that the order structures on a fixed semiring making it into an ordered semiring will form a lattice with arbitrary infs (just intersect the relations). So we can look at the intersection of all the orders satisfying 0&lt;1 and 2&lt;=a and 2&lt;=b.</p>



<a name="225141309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225141309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225141309">(Feb 04 2021 at 10:19)</a>:</h4>
<p>The intersection is an "abstract" way of constructing the minimal ordering, but as we all know there is also a "constructive" way of constructing this minimal order, by defining an inductive prop &lt;=, throwing in 0&lt;1 and 2&lt;=a and 2&lt;=b as constructors, and also one constructor for each axiom.</p>



<a name="225141457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225141457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225141457">(Feb 04 2021 at 10:21)</a>:</h4>
<p>Now the idea was that each constructor "makes stuff bigger", and in particular any proof of a+b&lt;=ab will have to only use facts about things smaller than ab in some appropriate order, where the axiom constructors all say (small &lt;='s implies big &lt;=)</p>



<a name="225141574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225141574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225141574">(Feb 04 2021 at 10:22)</a>:</h4>
<p>However <code>le_of_add_le_add_left</code> does not satisfy this "well-foundedness" property, meaning that I cannot eliminate proving a+b&lt;=ab from a+b+a^100+37b^100 &lt;= ab+a^100+37b^100 :-(</p>



<a name="225142020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225142020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225142020">(Feb 04 2021 at 10:28)</a>:</h4>
<p>Anyway, this seems to answer the original question in this thread. As far as I can see, <code>fin 2</code> is (or more precisely can be made into) a perfectly good <code>canonically_ordered_comm_semiring</code> which isn't an <code>ordered_semiring</code> as far as mathlib is concerned. Do people agree?</p>



<a name="225142057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225142057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225142057">(Feb 04 2021 at 10:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/canonically_ordered.20pathology/near/225140273">said</a>:</p>
<blockquote>
<p>(this is not Z/n, this is the stupid addition where big+big=n-1)</p>
</blockquote>
<p>I thought addition on fin was defeq to addition on zmod, even though we discussed changing it</p>



<a name="225142067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225142067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225142067">(Feb 04 2021 at 10:29)</a>:</h4>
<p>sure, maybe, but right now I'm talking about the stupid addition</p>



<a name="225142172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225142172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225142172">(Feb 04 2021 at 10:30)</a>:</h4>
<p>(my view on this is that <code>fin n</code> shouldn't really even have an addition, if you're adding things in fin n then you're not thinking about fin n correctly and should be using another type)</p>



<a name="225142202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225142202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225142202">(Feb 04 2021 at 10:31)</a>:</h4>
<p>Yakov is working on a refactor that will give <code>fin n</code> the absorbing addition.</p>



<a name="225142220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225142220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225142220">(Feb 04 2021 at 10:31)</a>:</h4>
<p>absorbing means max?</p>



<a name="225142227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225142227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225142227">(Feb 04 2021 at 10:31)</a>:</h4>
<p>I think it makes sense to have that structure in mathlib. I don't care how it's called.</p>



<a name="225142236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225142236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225142236">(Feb 04 2021 at 10:31)</a>:</h4>
<p>no it means "add, but if it's bigger than n-1 then just let it be n-1"</p>



<a name="225142311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225142311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225142311">(Feb 04 2021 at 10:32)</a>:</h4>
<p>ah, <del>max</del> min (a+b) (n-1), then?</p>



<a name="225142328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225142328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225142328">(Feb 04 2021 at 10:32)</a>:</h4>
<p><code>min</code>?</p>



<a name="225142329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225142329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225142329">(Feb 04 2021 at 10:32)</a>:</h4>
<p>same for mul. It's the quotient of the semiring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span> by the relation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn><mo>=</mo><mi>n</mi><mo>=</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">n-1=n=n+1+...</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.10556em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></p>



<a name="225142358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225142358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225142358">(Feb 04 2021 at 10:32)</a>:</h4>
<p>This relation preserves + and * but does not come from an ideal.</p>



<a name="225142582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225142582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225142582">(Feb 04 2021 at 10:35)</a>:</h4>
<p>Ok, so the consensus seems to be to avoid <code>ordered_semiring</code>, right?  If so, then I might go with Johan's proof for <code>linear_ordered_semiring</code>.  Does this seem like a good choice?</p>



<a name="225142604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225142604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225142604">(Feb 04 2021 at 10:35)</a>:</h4>
<p>The relevant PR is <a href="https://github.com/leanprover-community/mathlib/issues/6031">#6031</a>: I should have mentioned this earlier...</p>



<a name="225142760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225142760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225142760">(Feb 04 2021 at 10:37)</a>:</h4>
<p>(Johan, since this is your proof, feel free to make your own PR, if you prefer!)</p>



<a name="225143069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225143069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225143069">(Feb 04 2021 at 10:41)</a>:</h4>
<p>It seems to me that the current status of the questions on this thread are: (1) I am claiming that <code>fin n</code> with this absorbing structure will be a canonically ordered comm_semiring which isn't an ordered_semiring in mathlib's sense, answering the original question. (2) The definition of ordered semiring in mathlib seems to have no reference, and contains <code>le_of_add_le_add_left</code>. In the literature I cannot find any examples of where <code>le_of_add_le_add_left</code> is an axiom for ordered semirings (indeed it's hard to find many mentions of ordered semirings in the literature; note that <code>le_of_add_le_add_left</code> is not unreasonable for ordered rings because we have additive inverses so it's implied by a&lt;=b-&gt;a+c&lt;=b+c, which is a reasonable axiom). (3) Mathlib's ordered semirings are hence arguably pathological objects so it's perhaps not worth wasting time asking questions about them right now until (2) is resolved, thus both the original question in this thread, and asking whether <code>add_le_mul</code> is true for mathlib's ordered semirings, are pathological questions right now (and don't deserve attention until we have some evidence that <code>le_of_add_le_add_left</code> is a relevant axiom), and (4) we still don't know the answer to whether <code>add_le_mul</code> is true in what people on the internet think an ordered_semiring is but I have sketched what I think is an approach which will lead to a counterexample above. On the other hand add_le_mul is true for canonically ordered semirings and totally ordered semirings, and given that mathlib's ordered semirings are pathological right now, this resolves all the non-pathological questions that can be asked about mathlib's structures right now.</p>



<a name="225144219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225144219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225144219">(Feb 04 2021 at 10:54)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> If you are making other PRs in this area, please include it. I'm too busy with teaching <span aria-label="see no evil" class="emoji emoji-1f648" role="img" title="see no evil">:see_no_evil:</span></p>



<a name="225147018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225147018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225147018">(Feb 04 2021 at 11:26)</a>:</h4>
<p>The literature on ordered semirings is sparse and, in stark contrast to the usual conventions, no two definitions of an ordered semiring in the literature coincide. Gan and Jiang (Journal of Math Research and Exposition, in 2011 -- I've never heard of this journal BTW) define it but have as one of their axioms 0&lt;=c for all c. Faible and Peis (2006, random preprint on internet so approach with caution) define it but demand that ab&lt;=a (they're thinking about lattices). Ayutthaya and Pibaljommee give the definition which I expect in an article in 2015 in International Journal of Maths and Maths Sciences (another journal I don't think I've heard of) , i.e. a&lt;=b implies a+x&lt;=b+x, ax&lt;=bx and xa&lt;=xb (oh -- they don't demand x&gt;=0 for the latter so probably they have 0 as their minimal element again) , but don't demand a 1 (or this cancellation axiom). Rao, Kumar, Venkateswarlu and Kumar (Mathematica Maravica 2018, never heard of it either) give a related definition of ordered Gamma-semiring with three axioms, two of which are identical, and none of which involve cancellation. Tentative conclusions are that the mathematical community doesn't have a standard convention for what an ordered semiring is, but nowhere in the literature (such as it is) can I find any mention of cancellation for + and &lt;=.</p>



<a name="225148202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225148202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225148202">(Feb 04 2021 at 11:39)</a>:</h4>
<p><a href="https://github.com/leanprover/lean/commit/362f972edab4bc4fdb5e3085c2f1f4f32abee096">https://github.com/leanprover/lean/commit/362f972edab4bc4fdb5e3085c2f1f4f32abee096</a></p>
<p>So Leo added them in 2016, extending ordered_mul_cancel_comm_monoid and then renaming mul to add (so the assumption was there right from the start).</p>



<a name="225149434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225149434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225149434">(Feb 04 2021 at 11:54)</a>:</h4>
<p>Thanks for this, Kevin!</p>
<p>In the meanwhile, I proved that <code>ordered_semiring</code> has <code>char_zero</code>: turns out, it was almost already there!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.char_zero</span>

<span class="kd">instance</span> <span class="n">char_zero_ordered_semiring</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">char_zero</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">cast_injective</span> <span class="o">:=</span> <span class="n">injective_of_increasing</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span>  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">),</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="n">coe</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">xy</span><span class="o">,</span> <span class="n">nat.cast_lt.mpr</span> <span class="n">xy</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>



<a name="225149526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225149526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225149526">(Feb 04 2021 at 11:55)</a>:</h4>
<p>The <code>nontrivial</code> PR just got merged, so now we can start removing assumptions still!  <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p>



<a name="225149750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225149750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225149750">(Feb 04 2021 at 11:58)</a>:</h4>
<p>I think that instance might be bad, because there might be a <a href="https://leanprover-community.github.io/mathlib_docs/find/char_zero.nontrivial">docs#char_zero.nontrivial</a> instance that forms a loop?</p>



<a name="225150712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225150712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225150712">(Feb 04 2021 at 12:09)</a>:</h4>
<p>I was not planning of making a PR with this instance, but I would like to understand what would be the issue with <code>nontrivial</code>.  What is it that would form a loop?</p>
<p>The link you sent does not work for me.</p>



<a name="225150894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225150894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225150894">(Feb 04 2021 at 12:12)</a>:</h4>
<p>Char 0 implies non-trivial, and if this is also an instance then you might end up with the type class inference system (the thing which looks at the instances) finding an ordered semiring and then going into a loop constantly proving non-trivial -&gt; char_zero -&gt; non-trivial -&gt; char_zero -&gt; ... when trying to do something else. But my understanding of the actual computer program which runs the type class inference system (it's a C++ program in core Lean) is very poor, so I don't know whether this kind of thing is likely to happen or not.</p>



<a name="225151040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225151040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225151040">(Feb 04 2021 at 12:13)</a>:</h4>
<p>Ah, I see!  I understand now what the potential issue could be.</p>
<p>Do you think that this might explain why the instance is not there?</p>



<a name="225151496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225151496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225151496">(Feb 04 2021 at 12:19)</a>:</h4>
<p>I think you could certainly add it as a lemma</p>



<a name="225151530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225151530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225151530">(Feb 04 2021 at 12:20)</a>:</h4>
<p>There's no harm in making it a lemma (you could try <code>library_search</code> to see if it's already there) but Eric is pointing out that there might be a problem with it being an instance (which is nothing more than a def or lemma plus an <code>@[instance]</code> tag).</p>



<a name="225151655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225151655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225151655">(Feb 04 2021 at 12:21)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/injective_of_increasing">docs#injective_of_increasing</a> <code>(λ (a b : ℕ), a &lt; b)  (λ (a b : R), a &lt; b) coe (λ x y xy, nat.cast_lt.mpr xy</code> looks like it might be a <code>strict_monotone</code> statement that already exists somewhere</p>



<a name="225152002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225152002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225152002">(Feb 04 2021 at 12:25)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.char_zero</span>

<span class="kd">lemma</span> <span class="n">char_zero_ordered_semiring</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">char_zero</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">cast_injective</span> <span class="o">:=</span> <span class="n">nat.strict_mono_cast.injective</span> <span class="o">}</span>
</code></pre></div>



<a name="225152117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225152117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225152117">(Feb 04 2021 at 12:26)</a>:</h4>
<p><code>nat.strict_mono_cast.injective</code></p>



<a name="225152368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225152368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225152368">(Feb 04 2021 at 12:29)</a>:</h4>
<p>Updated!</p>



<a name="225152464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225152464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225152464">(Feb 04 2021 at 12:30)</a>:</h4>
<p>However, I am not sure whether to PR this, partly since I would not know where to put it: the ordered_semiring file does not import char_zero and in char_zero there are no examples...</p>



<a name="225152568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225152568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225152568">(Feb 04 2021 at 12:31)</a>:</h4>
<p>Right next to <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_ordered_semiring.to_char_zero">docs#linear_ordered_semiring.to_char_zero</a>  would make sense</p>



<a name="225152682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225152682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225152682">(Feb 04 2021 at 12:32)</a>:</h4>
<p>Indeed, <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_ordered_semiring.to_char_zero/src">src#linear_ordered_semiring.to_char_zero</a> has exactly your proof, so probably it makes senes to add <code>lemma ordered_semiring.to_char_zero</code>, and redefine <code>instance linear_ordered_semiring.to_char_zero  := semiring.to_char_zero</code></p>



<a name="225157251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225157251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225157251">(Feb 04 2021 at 13:17)</a>:</h4>
<p>PR <a href="https://github.com/leanprover-community/mathlib/issues/6038">#6038</a>!</p>



<a name="225164082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225164082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225164082">(Feb 04 2021 at 14:14)</a>:</h4>
<p>Regarding refactoring fin, first we have to rip out the fin ops definitions in core. They're used to define unsigned, which is what makes all of expr naming work. When <a href="https://github.com/leanprover-community/lean/issues/527">lean#527</a> is merged, the actual mathlib refactor of fin can start.</p>



<a name="225167778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225167778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225167778">(Feb 04 2021 at 14:43)</a>:</h4>
<p>I think I've got a construction of a <code>ordered_semiring</code> in which <code>2a &lt;= 2b -&gt; a &lt;= b</code> fails, I'm trying to check it in Lean at the moment</p>



<a name="225177718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225177718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225177718">(Feb 04 2021 at 15:50)</a>:</h4>
<p>In the meanwhile, I also pushed Johan's proof: PR <a href="https://github.com/leanprover-community/mathlib/issues/6043">#6043</a>.</p>



<a name="225199762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225199762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225199762">(Feb 04 2021 at 18:14)</a>:</h4>
<p>Yeah, I've got a <code>ordered_comm_semiring</code> in which <code>2a &lt;= 2b -&gt; a &lt;= b</code> fails</p>



<a name="225199800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225199800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225199800">(Feb 04 2021 at 18:15)</a>:</h4>
<p>I <em>think</em> I can make it into a canonically ordered one too</p>



<a name="225199944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225199944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225199944">(Feb 04 2021 at 18:16)</a>:</h4>
<p>Is it <code>fin n</code> as suggested above?</p>



<a name="225200102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225200102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225200102">(Feb 04 2021 at 18:17)</a>:</h4>
<p>No</p>



<a name="225200109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225200109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225200109">(Feb 04 2021 at 18:17)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[derive [comm_semiring]</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">subsemiring.closure</span> <span class="o">({</span><span class="mi">1</span><span class="bp">.</span><span class="mi">5</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℚ</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">K</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x.1</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">preorder</span> <span class="n">K</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">),</span>
  <span class="n">le_refl</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">or.inl</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">le_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">xy</span> <span class="n">yz</span><span class="o">,</span>
  <span class="kd">begin</span>
    <span class="n">rcases</span> <span class="n">xy</span> <span class="k">with</span> <span class="o">(</span><span class="n">rfl</span> <span class="bp">|</span> <span class="n">_</span><span class="o">),</span> <span class="o">{</span> <span class="n">apply</span> <span class="n">yz</span> <span class="o">},</span>
    <span class="n">rcases</span> <span class="n">yz</span> <span class="k">with</span> <span class="o">(</span><span class="n">rfl</span> <span class="bp">|</span> <span class="n">_</span><span class="o">),</span> <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">apply</span> <span class="n">xy</span> <span class="o">},</span>
    <span class="n">right</span><span class="o">,</span>
    <span class="n">linarith</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="225200240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225200240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225200240">(Feb 04 2021 at 18:18)</a>:</h4>
<p>I can post a full gist if that's convenient, but it's not particularly interesting; that's the semiring structure and the partial order structure, the counterexample is a = 1, b = 1.5</p>



<a name="225200298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225200298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225200298">(Feb 04 2021 at 18:19)</a>:</h4>
<p>In particular this is cancellative</p>



<a name="225205386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225205386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225205386">(Feb 04 2021 at 18:57)</a>:</h4>
<p>I've upgraded it to a <code>canonically_ordered_comm_semiring</code> now, (thanks Kevin!)</p>



<a name="225205810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225205810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225205810">(Feb 04 2021 at 19:00)</a>:</h4>
<p>I wonder whether mathlib should at some point also start collecting such counterexamples.</p>



<a name="225206114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225206114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225206114">(Feb 04 2021 at 19:02)</a>:</h4>
<p>The example I like best right now is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">{</mo><mi>x</mi><mo>∈</mo><mi mathvariant="double-struck">R</mi><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mi>x</mi><mo>=</mo><mn>0</mn><mo>∨</mo><mi>x</mi><mo>≥</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">A=\{x\in\mathbb{R}\,|\,x=0\lor x\geq1\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">R</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span> with the rather bizarre <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span> defined by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\leq b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> iff <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a=b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mn>1</mn><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a+1\leq b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span>.</p>



<a name="225206195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225206195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225206195">(Feb 04 2021 at 19:02)</a>:</h4>
<p>So again <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mn>1.5</mn></mrow><annotation encoding="application/x-tex">1\leq 1.5</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span></span></span></span> is false, but doubling it it's true</p>



<a name="225206451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225206451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225206451">(Feb 04 2021 at 19:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/canonically_ordered.20pathology/near/225206114">said</a>:</p>
<blockquote>
<p>The example I like best right now is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">{</mo><mi>x</mi><mo>∈</mo><mi mathvariant="double-struck">R</mi><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mi>x</mi><mo>=</mo><mn>0</mn><mo>∨</mo><mi>x</mi><mo>≥</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">A=\{x\in\mathbb{R}\,|\,x=0\lor x\geq1\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">R</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span> with the rather bizarre <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span> defined by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\leq b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> iff <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a=b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mn>1</mn><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a+1\leq b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span>.</p>
</blockquote>
<p>Yeah, this was my upgraded example</p>



<a name="225206667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225206667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225206667">(Feb 04 2021 at 19:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="317890">Julian Külshammer</span> <a href="#narrow/stream/113489-new-members/topic/canonically_ordered.20pathology/near/225205810">said</a>:</p>
<blockquote>
<p>I wonder whether mathlib should at some point also start collecting such counterexamples.</p>
</blockquote>
<p>I think it should. But I don't yet know what the best way is to organize this. They shouldn't be scattered all over the place, I guess.</p>



<a name="225206769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225206769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225206769">(Feb 04 2021 at 19:06)</a>:</h4>
<p>And ideally they would be tagged in some way, so that automation such as <code>slim_check</code> (or similar stuff, I don't know) can take advantage of them.</p>



<a name="225207560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225207560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225207560">(Feb 04 2021 at 19:12)</a>:</h4>
<p>These remarks deserve definitely to be mentioned at least in the doc string... especially for not so well known notions</p>



<a name="225207570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225207570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225207570">(Feb 04 2021 at 19:12)</a>:</h4>
<p>Yes, I think mathlib should contain counter-examples. They also act as sanity checks for the definitions.</p>



<a name="225208942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225208942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225208942">(Feb 04 2021 at 19:23)</a>:</h4>
<p>For me this naively sounds like a version of <code>inhabited</code> where instead of supplying one example one should supply a non-example which is an example of the things it extends.</p>



<a name="225210810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225210810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225210810">(Feb 04 2021 at 19:35)</a>:</h4>
<p>I meant something more general, not only when extending structures.</p>



<a name="225212104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225212104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225212104">(Feb 04 2021 at 19:45)</a>:</h4>
<p>Late to the party, but my general sense is that a typeclass like <code>ordered_semiring</code> shouldn't have anything "cancellative" about it. <code>ordered_cancel_add_comm_monoid</code> seems named well enough, but it shouldn't be an ancestor of <code>ordered_semiring</code>, which should admit <code>fin n</code> with saturating add as an example</p>



<a name="225212361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225212361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225212361">(Feb 04 2021 at 19:47)</a>:</h4>
<p>I don't think the counter examples need to be formally stated or proved, though</p>



<a name="225212472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225212472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225212472">(Feb 04 2021 at 19:48)</a>:</h4>
<p>For me the main thing I learn from counterexamples is to not attempt a certain theorem, and for that formality in the counterexample is not needed</p>



<a name="225212534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225212534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225212534">(Feb 04 2021 at 19:48)</a>:</h4>
<p>They could be in the docstrings, though of what exactly I'm not sure</p>



<a name="225215054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225215054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225215054">(Feb 04 2021 at 20:06)</a>:</h4>
<p>Slim_check seems like a particularly good motivation for this type of pathological typeclass instance to be in mathlib somewhere</p>



<a name="225215259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225215259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225215259">(Feb 04 2021 at 20:08)</a>:</h4>
<p>Having a collection of examples that satisfy a typeclass A but not a derived typeclass B would allow a slim-check-like tactic to say "this is false for A but if you strengthen your requirement to B it might not be</p>



<a name="225218462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225218462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225218462">(Feb 04 2021 at 20:33)</a>:</h4>
<p>I really like these examples: thank you all who contributed them!</p>
<p>I also think that counterexamples are fundamental to maths and therefore should find their way into mathlib.  However, I am not sure what the best approach is.</p>



<a name="225219768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225219768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225219768">(Feb 04 2021 at 20:44)</a>:</h4>
<p>By the way, I think it is safe to assume that class A implies class B iff there is an instance that says so; if there is no instance then most likely it's false, because mathlib tries to be complete about such things</p>



<a name="225223308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225223308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225223308">(Feb 04 2021 at 21:13)</a>:</h4>
<p>Just to make sure that I understand correctly: <code>\N + zmod 2</code> <em>without</em> (0,1) and comparing elements just based on their <code>\N</code> coordinate, provided they are at least 1 away is another version of the same example as above, right?  It is canonically ordered and an ordered semiring, where (1,0) and (1,1) are not comparable, but their doubles are actually equal.</p>
<p>Am I missing some further assumption?</p>



<a name="225223671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225223671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225223671">(Feb 04 2021 at 21:16)</a>:</h4>
<p>This looks like it should work to me, but it's always safest to formalise the argument ;-)</p>



<a name="225333528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225333528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225333528">(Feb 05 2021 at 17:58)</a>:</h4>
<p>In case people find it useful, I pushed a <code>counterexamples</code> branch to mathlib.  I am trying to formalize the example that I mentioned above, but if someone wants to add other (counter)examples, feel free to do so!</p>



<a name="225428368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225428368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225428368">(Feb 06 2021 at 20:16)</a>:</h4>
<p>Note that I think we don't have a counterexample to the original 2 &lt;= a -&gt; 2 &lt;= b -&gt; a + b &lt;= a * b question (I think) for ordered-semirings. As far as I can tell, amongst the semirings we've found which fail 2a &lt;= 2b -&gt; a &lt;= b, I don't think any of them contradict the original problem</p>



<a name="225431577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225431577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225431577">(Feb 06 2021 at 21:42)</a>:</h4>
<p>I agree with you: so far, I do not know if <code>2 ≤ a v 2 ≤ b</code> implies <code>a + b ≤ a * b</code> in an ordered (commutative) semiring.</p>



<a name="225431594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225431594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225431594">(Feb 06 2021 at 21:43)</a>:</h4>
<p>I thought that we didn't know if 2&lt;=a  and 2 &lt;=b implied a+b&lt;=a*b in the pathological structure which is an <code>ordered_semiring</code>, but we did know it wasn't true in what the literature calls an ordered semiring.</p>



<a name="225431626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225431626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225431626">(Feb 06 2021 at 21:44)</a>:</h4>
<p>oh maybe we never finished the proof</p>



<a name="225431670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225431670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225431670">(Feb 06 2021 at 21:45)</a>:</h4>
<p>Today's idea: let the semiring be {0,1,2,3,4,a,b,a+b,ab,a+1,a+2,b+1,b+2,2a, 2b, a^2, b^2, BIG}</p>



<a name="225431733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225431733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225431733">(Feb 06 2021 at 21:46)</a>:</h4>
<p>where I'm thinking of a=2+epsilon and b=2+delta and BIG means "5 or more" (so e.g 3+a=BIG etc)</p>



<a name="225431752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225431752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225431752">(Feb 06 2021 at 21:47)</a>:</h4>
<p>Now look at the ordering generated by 0&lt;1&lt;2&lt;3&lt;4, everything &lt;= BIG and 2&lt;=a, 2&lt;=b</p>



<a name="225431794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225431794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225431794">(Feb 06 2021 at 21:48)</a>:</h4>
<p>close under ordered semiring axioms and it will either turn into a counterexample or a proof</p>



<a name="225431816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225431816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225431816">(Feb 06 2021 at 21:49)</a>:</h4>
<p>but I am not talking about mathlib ordered semirings here, note that 3+4&lt;=2+4 is true but 3&lt;=2 is false.</p>



<a name="225431820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225431820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225431820">(Feb 06 2021 at 21:49)</a>:</h4>
<p>I think that I agree with you, but, to be honest, the axioms of ordered semirings are so strange that I really need to write them down to understand what the implications of "close under the axioms" are.</p>



<a name="225431859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225431859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225431859">(Feb 06 2021 at 21:50)</a>:</h4>
<p>I'm talking about literature ordered semirings. I think the axiom should be removed. I suspect Leo just added it randomly</p>



<a name="225431876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225431876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225431876">(Feb 06 2021 at 21:51)</a>:</h4>
<p>Damiano I think the definition of ordered semiring in Lean 3 is <em>wrong</em> and there is no point investing any time investigating it. It's like deleting additive associativity from the axioms of a ring and then asking questions about the resulting pathological structure -- it's not worth investing time in it.</p>



<a name="225431885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225431885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225431885">(Feb 06 2021 at 21:51)</a>:</h4>
<p>Ok, fair enough!</p>



<a name="225431887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225431887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225431887">(Feb 06 2021 at 21:51)</a>:</h4>
<p>Nowhere in the literature is this cancellation axiom, it is an embarrassment that our definition of ordered semiring has this axiom in.</p>



<a name="225431930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225431930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225431930">(Feb 06 2021 at 21:52)</a>:</h4>
<p>With the axiom removed I think my sketch above will get to the bottom of it and I strongly suspect that the boring answer will be that the ring above is a counterexample.</p>



<a name="225431945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225431945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225431945">(Feb 06 2021 at 21:53)</a>:</h4>
<p>A more interesting question would be to see what happens if the lemma is removed from the definition of ordered semiring. I doubt anything will break, and furthermore you'll be able to prove that a canonically ordered comm semiring is an ordered semiring</p>



<a name="225431998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225431998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225431998">(Feb 06 2021 at 21:54)</a>:</h4>
<p>This could be a fun experiment, I agree!</p>



<a name="225432015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225432015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225432015">(Feb 06 2021 at 21:56)</a>:</h4>
<p>Somehow, I suspect that <em>something</em> will break down, but maybe not much.</p>



<a name="225432052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225432052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225432052">(Feb 06 2021 at 21:56)</a>:</h4>
<p>Note that for linear_ordered semirings the axiom can be proved</p>



<a name="225432063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225432063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225432063">(Feb 06 2021 at 21:56)</a>:</h4>
<p>And in that case, Johan proved add_le_mul.  Maybe that one is the important axiom?  Ahaha</p>



<a name="225432070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225432070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225432070">(Feb 06 2021 at 21:57)</a>:</h4>
<p>It would be funny to mix add and mul like that...</p>



<a name="225432125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225432125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225432125">(Feb 06 2021 at 21:58)</a>:</h4>
<p>Anyway, if I get a chance, I will try to remove the axiom and see what happens.. but not tonight!</p>



<a name="225445398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225445398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225445398">(Feb 07 2021 at 04:58)</a>:</h4>
<p>Kevin, I think that your idea does indeed construct a counterexample.  Here is an attempt at an explanation: actually formalizing it seems very long for me!</p>
<p>Make <code>zmod 2 × zmod 2</code> intro an ordered ring by defining the three non-zero elements to be all incomparable and all greater than <code>(0, 0)</code>.  Intuitively, we have three rays, all starting at zero, but incomparable with one another.</p>
<p>The actual ring is <code>ℕ × zmod 2 × zmod 2</code> with its normal (component-wise) addition and multiplication.  For the order, let <code>m, n : ℕ</code> and <code>a, b : zmod 2 × zmod 2</code>.  We set <code>(m, a) ≤ (n, b)</code> if and only if</p>
<ul>
<li><code>m &lt; n</code>, or</li>
<li><code>m = n</code> and <code>a ≤ b</code>.</li>
</ul>
<p>This is the "lexicographic preorder".  From each natural number, sprout out 3 incomparable directions.</p>
<p>Now, <code>(2, (1, 0))</code> and <code>(2, (0, 1))</code> are both at least <code>2 * (1, (1, 1)) = (2, (0, 0))</code>.  However,</p>
<ul>
<li>their sum <code>(2, (1, 0)) + (2, (0, 1)) = (4, (1, 1)) </code> and</li>
<li>their product <code>(2, (1, 0)) * (2, (0, 1)) = (4, (0, 0)) </code></li>
</ul>
<p><em>are</em> comparable, but the inequality is the wrong one!</p>



<a name="225445688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225445688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225445688">(Feb 07 2021 at 05:08)</a>:</h4>
<p>I don't think that's an ordered ring. <code>(0, 0) &lt;= (0, 1)</code> but if you add <code>(1, 0)</code> on both sides you get <code>(1, 0) &lt;= (1, 1)</code> which fails</p>



<a name="225445945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225445945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225445945">(Feb 07 2021 at 05:18)</a>:</h4>
<p>Ah, your example is taking place in <code>zmod 2 × zmod 2</code>, right?  Hmm, I need to think more about this!</p>



<a name="225450468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225450468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225450468">(Feb 07 2021 at 07:32)</a>:</h4>
<p>If a=2+e and b=2+f with e,f&gt;=0 then a+b+(e+f+ef)=ab so you have to avoid this</p>



<a name="225450620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225450620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225450620">(Feb 07 2021 at 07:36)</a>:</h4>
<p>My impression with Bhavik's {0} union {x&gt;=1} example where a&lt;=b in the ring if a=b or a+1&lt;=b in the reals is that you can, if you're lucky, drop various &lt;=s and preserve ordered ring axioms, this is why maybe building up a weird finite counterexample might work</p>



<a name="225471937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225471937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225471937">(Feb 07 2021 at 16:33)</a>:</h4>
<p>I've been playing with the semiring</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[derive [comm_semiring]</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">mv_polynomial</span> <span class="n">bool</span> <span class="n">ℕ</span>

<span class="kd">inductive</span> <span class="n">K_le</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">→</span> <span class="n">K</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">zero_le_one</span> <span class="o">:</span> <span class="n">K_le</span> <span class="mi">0</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">K_le</span> <span class="n">x</span> <span class="n">x</span>
<span class="bp">|</span> <span class="n">trans</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">K_le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">K_le</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">K_le</span> <span class="n">x</span> <span class="n">z</span>
<span class="bp">|</span> <span class="n">add_le_add_left</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">K_le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">K_le</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">mul_le_mul_left</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">K_le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">K_le</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">le_of_add_le_add_left</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">K_le</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">→</span> <span class="n">K_le</span> <span class="n">x</span> <span class="n">y</span>
<span class="bp">|</span> <span class="n">two_le_tt</span> <span class="o">:</span> <span class="n">K_le</span> <span class="mi">2</span> <span class="o">(</span><span class="n">X</span> <span class="n">tt</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">two_le_ff</span> <span class="o">:</span> <span class="n">K_le</span> <span class="mi">2</span> <span class="o">(</span><span class="n">X</span> <span class="n">ff</span><span class="o">)</span>
</code></pre></div>
<p>based off your finite example (though I'm trying to make it into a mathlib ordered semiring mostly because I think it's a fun puzzle), I think the difficulty here is in showing that the ordering generated by the ordered semiring axioms isn't obviously antisymmetric - curiously enough including <code>le_of_add_le_add_left</code> in there makes it a little easier - but I still can't complete the antisymmetry proof. Perhaps in the finite case you mention it's easier though, since you could probably just case bash.</p>



<a name="225472140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225472140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225472140">(Feb 07 2021 at 16:39)</a>:</h4>
<p>I was thinking that it might just be easier to do the finite example with Andrej Bauer's tool.</p>



<a name="225481024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225481024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225481024">(Feb 07 2021 at 20:04)</a>:</h4>
<p>I tried this now and it doesn't seem any finite models exist for the canonically ordered comm semiring. I could be encoding it incorrectly still, I can't quite get alg to recognize the canonically ordered property well, I don't see the reason why it should be infinite from the axioms.</p>



<a name="225481570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225481570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225481570">(Feb 07 2021 at 20:19)</a>:</h4>
<p>well that's false</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">canonically_ordered_comm_semiring</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">refine</span> <span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="o">(),</span>
  <span class="n">zero</span> <span class="o">:=</span> <span class="o">(),</span>
  <span class="n">le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span>
  <span class="n">lt</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span>
  <span class="n">lt_iff_le_not_le</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">bot</span> <span class="o">:=</span> <span class="o">(),</span>
  <span class="n">mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="o">(),</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="o">(),</span>
  <span class="bp">..</span> <span class="o">}</span><span class="bp">;</span> <span class="n">dec_trivial</span>
</code></pre></div>



<a name="225483880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225483880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225483880">(Feb 07 2021 at 21:08)</a>:</h4>
<p>Well <em>obviously</em> the trivial ring works, Alex is a mathematician so he is <em>obviously</em> excluding all trivial counterexamples to any statement he makes.</p>



<a name="225483909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225483909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225483909">(Feb 07 2021 at 21:09)</a>:</h4>
<p>Is this not in <code>punit_instances</code> btw?</p>



<a name="225484317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225484317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225484317">(Feb 07 2021 at 21:18)</a>:</h4>
<p>Is 0&lt;=1 an axiom in these wretched things? If not then any ring with &lt;= := = works right (finite or not). If so then either 0=1 giving the example too trivial for us mathematicians to care about, or 0&lt;1&lt;2&lt;3&lt;...</p>



<a name="225489274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225489274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225489274">(Feb 07 2021 at 23:07)</a>:</h4>
<p>I don't think you can set <code>&lt;=</code> to <code>=</code> in a canonically ordered whatever because the canonical order thing characterizes exactly what <code>&lt;=</code> is</p>



<a name="225489343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225489343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225489343">(Feb 07 2021 at 23:09)</a>:</h4>
<p>(unless it's the trivial ring, of course)</p>



<a name="225489400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225489400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225489400">(Feb 07 2021 at 23:10)</a>:</h4>
<p><code>0 &lt;= x</code> is a theorem in canonically ordered monoids</p>



<a name="225489442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225489442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225489442">(Feb 07 2021 at 23:12)</a>:</h4>
<p>You don't know that <code>x |-&gt; a + x</code> is injective, so you can't deduce <code>x &lt; y -&gt; a + x &lt; a + y</code> so the infinite chain <code>0&lt;1&lt;2&lt;...</code> doesn't work</p>



<a name="225489483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225489483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225489483">(Feb 07 2021 at 23:12)</a>:</h4>
<p>it seems like fin n should be an instance</p>



<a name="225489568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225489568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225489568">(Feb 07 2021 at 23:14)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">canonically_ordered_comm_semiring</span> <span class="n">bool</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">refine</span> <span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="n">bor</span><span class="o">,</span>
  <span class="n">zero</span> <span class="o">:=</span> <span class="n">ff</span><span class="o">,</span>
  <span class="n">le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">bot</span> <span class="o">:=</span> <span class="n">ff</span><span class="o">,</span>
  <span class="n">mul</span> <span class="o">:=</span> <span class="n">band</span><span class="o">,</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">,</span>
  <span class="bp">..</span> <span class="o">}</span><span class="bp">;</span> <span class="n">dec_trivial</span>
</code></pre></div>



<a name="225494039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225494039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225494039">(Feb 08 2021 at 00:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/canonically_ordered.20pathology/near/225481024">said</a>:</p>
<blockquote>
<p>I tried this now and it doesn't seem any finite models exist for the canonically ordered comm semiring. I could be encoding it incorrectly still, I can't quite get alg to recognize the canonically ordered property well, I don't see the reason why it should be infinite from the axioms.</p>
</blockquote>
<p>I might be missing something, but I thought a+b &lt;= a*b always holds in canonically ordered comm semirings for 2 &lt;= a and 2 &lt;= b - don't we always have 0 &lt;= x, and then Damiano's original proof basically works</p>



<a name="225494211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225494211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225494211">(Feb 08 2021 at 01:02)</a>:</h4>
<p>I haven't been following this thread at all, but isn't <code>nnreal</code> such an object?</p>



<a name="225494222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225494222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225494222">(Feb 08 2021 at 01:02)</a>:</h4>
<p>Oh, nevermind, I missed the inequalities with <code>2</code></p>



<a name="225496765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225496765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225496765">(Feb 08 2021 at 02:08)</a>:</h4>
<p>Cool, there must be a problem with the translation to alg then</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Constant</span> <span class="mi">0</span> <span class="mi">1</span> <span class="n">_.</span>
<span class="n">Binary</span> <span class="bp">+</span> <span class="bp">*.</span>
<span class="n">Relation</span> <span class="bp">&lt;=.</span>
<span class="n">Relation</span> <span class="bp">&lt;.</span>

<span class="n">Axiom</span> <span class="n">plus_commutative</span><span class="o">:</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">x.</span>
<span class="n">Axiom</span> <span class="n">plus_associative</span><span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">+</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span>
<span class="n">Axiom</span> <span class="n">zero_neutral_left</span><span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x.</span>
<span class="n">Axiom</span> <span class="n">mult_associative</span><span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span>
<span class="n">Axiom</span> <span class="n">mult_comm</span><span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">x.</span>
<span class="n">Axiom</span> <span class="n">one_unit_left</span><span class="o">:</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x.</span>
<span class="n">Axiom</span> <span class="n">one_unit_right</span><span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">x.</span>
<span class="n">Axiom</span> <span class="n">distrutivity_right</span><span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">z.</span>
<span class="n">Axiom</span> <span class="n">distributivity_left</span><span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">z.</span>

<span class="bp">#</span> <span class="n">Consequences</span> <span class="n">of</span> <span class="kd">axioms</span> <span class="n">that</span> <span class="n">make</span> <span class="n">alg</span> <span class="n">run</span> <span class="n">faster</span><span class="o">:</span>

<span class="n">Axiom</span> <span class="n">zero_neutral_right</span><span class="o">:</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">x.</span>
<span class="n">Axiom</span> <span class="n">mult_zero_left</span><span class="o">:</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="bp">.</span>
<span class="n">Axiom</span> <span class="n">mult_zero_right</span><span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="bp">.</span>


<span class="bp">#</span> <span class="n">order</span> <span class="kd">axioms</span>
<span class="n">Axiom</span> <span class="n">reflexivity</span><span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;=</span> <span class="n">x.</span>
<span class="n">Axiom</span> <span class="n">transitivity</span><span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;=</span> <span class="n">y</span> <span class="bp">/\</span> <span class="n">y</span> <span class="bp">&lt;=</span> <span class="n">z</span> <span class="bp">-&gt;</span> <span class="n">x</span> <span class="bp">&lt;=</span> <span class="n">z.</span>
<span class="n">Axiom</span> <span class="n">antisymmetry</span><span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;=</span> <span class="n">y</span> <span class="bp">/\</span> <span class="n">y</span> <span class="bp">&lt;=</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y.</span>
<span class="n">Axiom</span> <span class="n">canon</span><span class="o">:</span> <span class="k">forall</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">exists</span> <span class="n">z</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">-&gt;</span> <span class="n">x</span> <span class="bp">&lt;=</span> <span class="n">y.</span>
<span class="n">Axiom</span> <span class="n">canon</span><span class="o">:</span> <span class="k">forall</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;=</span> <span class="n">y</span> <span class="bp">-&gt;</span> <span class="n">exists</span> <span class="n">z</span><span class="o">,</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">g.</span>
<span class="n">Axiom</span> <span class="n">totality</span><span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;=</span> <span class="n">y</span> <span class="bp">\/</span> <span class="n">y</span> <span class="bp">&lt;=</span> <span class="n">x.</span>

<span class="n">Axiom</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;=</span> <span class="n">y</span> <span class="bp">-&gt;</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">z</span> <span class="bp">&lt;=</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">z.</span>
<span class="n">Axiom</span> <span class="n">eq_zero_or_eq_zero_of_mul_eq_zero</span><span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">-&gt;</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">\/</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">0</span><span class="bp">.</span>
<span class="n">Axiom</span> <span class="n">lt_iff_le_not_le</span><span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">y</span> <span class="bp">&lt;-&gt;</span> <span class="n">x</span> <span class="bp">&lt;=</span> <span class="n">y</span> <span class="bp">/\</span> <span class="n">not</span> <span class="n">y</span> <span class="bp">&lt;=</span> <span class="n">x.</span>
<span class="n">Axiom</span> <span class="n">bot_le</span><span class="o">:</span> <span class="n">_</span> <span class="bp">&lt;=</span> <span class="n">x.</span>
</code></pre></div>



<a name="225496777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225496777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225496777">(Feb 08 2021 at 02:09)</a>:</h4>
<p>I think the issue must be what the exists is quantifying over in the <code>canon</code> axioms</p>



<a name="225496783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225496783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225496783">(Feb 08 2021 at 02:09)</a>:</h4>
<p>But if I try to bracket it I get an error message when parsing.</p>



<a name="225496848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225496848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225496848">(Feb 08 2021 at 02:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/canonically_ordered.20pathology/near/225483880">said</a>:</p>
<blockquote>
<p>Well <em>obviously</em> the trivial ring works, Alex is a mathematician so he is <em>obviously</em> excluding all trivial counterexamples to any statement he makes.</p>
</blockquote>
<p>I wish this was what happened <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>, once again my mental model has 0, 1 separate so I didn't even consider  a 1-element example</p>



<a name="225497211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225497211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225497211">(Feb 08 2021 at 02:19)</a>:</h4>
<p>"Axiom canon: forall x y, x &lt;= y -&gt; exists z, y = x + g." looks dubious to me - surely you want <code>y = x + z</code> on the rhs</p>



<a name="225497277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225497277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225497277">(Feb 08 2021 at 02:21)</a>:</h4>
<p>oops thats a copy paste error!</p>



<a name="225497442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225497442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225497442">(Feb 08 2021 at 02:24)</a>:</h4>
<p>Oh also you have totality - you don't want to assume totality for these, an ordered semiring only needs a partial order structure</p>



<a name="225497582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225497582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225497582">(Feb 08 2021 at 02:27)</a>:</h4>
<p>I also wonder if it runs faster if you don't include <code>&lt;</code> in the definition, since it can be inferred just from the definition of <code>&lt;=</code></p>



<a name="225502740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225502740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225502740">(Feb 08 2021 at 04:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/canonically_ordered.20pathology/near/225152002">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.char_zero</span>

<span class="kd">lemma</span> <span class="n">char_zero_ordered_semiring</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">char_zero</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">cast_injective</span> <span class="o">:=</span> <span class="n">nat.strict_mono_cast.injective</span> <span class="o">}</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Alex, I am not sure whether this will answer your question, but <code>nontrivial</code> <code>ordered_semiring</code>s have characteristic zero, so they are never finite.</p>



<a name="225503288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225503288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225503288">(Feb 08 2021 at 04:43)</a>:</h4>
<p>Yeah I got that (slowly during the discussion the other day) I'm thinking of the canonical ordered version now, and wondering why I can't convince alg to find finite ones (which as mario observed certainly exist).</p>



<a name="225503299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225503299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225503299">(Feb 08 2021 at 04:43)</a>:</h4>
<p>Or maybe I don't get it, Mario's one is trivial after all!</p>



<a name="225503344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225503344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225503344">(Feb 08 2021 at 04:44)</a>:</h4>
<p>Nevertheless my alg code is wrong as it doesn't even find the trivial one</p>



<a name="225503700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225503700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225503700">(Feb 08 2021 at 04:55)</a>:</h4>
<p>Ah, ok!  I thought that the question was about <code>ordered_semiring</code>s that were <em>also</em> canonically ordered!  I find the names really confusing!  I never remember whether a <code>canonically_ordered_semiring</code> is also an <code>ordered_semiring</code>...</p>



<a name="225503759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225503759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225503759">(Feb 08 2021 at 04:56)</a>:</h4>
<p>I need to think more about Mario's <code>bool</code> example of a canonically ordered semiring of non-zero characteristic.</p>



<a name="225633956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225633956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225633956">(Feb 09 2021 at 01:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/canonically_ordered.20pathology/near/225431670">said</a>:</p>
<blockquote>
<p>Today's idea: let the semiring be {0,1,2,3,4,a,b,a+b,ab,a+1,a+2,b+1,b+2,2a, 2b, a^2, b^2, BIG}</p>
</blockquote>
<p>I've shown that this semiring is a semiring, and that it has a partial order structure satisfying x &lt;= y -&gt; x+z &lt;= y+z and x &lt;= y -&gt; x<em>z &lt;= y</em>z, is there anything else left to check for this to be an example of the literature definition of an ordered semiring which doesn't have a+b &lt;= a*b?</p>



<a name="225654191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225654191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225654191">(Feb 09 2021 at 07:48)</a>:</h4>
<p>I guess commutativity of * (or else you're missing x&lt;= y implies zx&lt;=zy) but this looks good to me. Does the cancellation axiom fall?</p>



<a name="225688770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/canonically_ordered%20pathology/near/225688770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/canonically_ordered.20pathology.html#225688770">(Feb 09 2021 at 13:28)</a>:</h4>
<p>Oops yeah I should have said comm semiring. Cancellation fails for exactly the reason you suggested it should, 3+2 &gt;= 4+2 but 3 &lt; 4</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Working.20with.20order.20duals.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html">Working with order duals</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="243363696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243363696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243363696">(Jun 21 2021 at 10:32)</a>:</h4>
<p>Sorry, I'm afraid I'm stuck again. I have a class of normed lattices for which I can prove that the inf and sup operations are continuous. As these proofs are long and similar, I want to prove one and then infer the other from the equivalent property for the dual:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.normed_space.ordered</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">class</span> <span class="n">normed_lattice_add_comm_group</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
  <span class="kd">extends</span> <span class="n">normed_group</span> <span class="n">α</span><span class="o">,</span> <span class="n">lattice</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_le_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="kd">notation</span> <span class="bp">`|`</span><span class="n">a</span><span class="bp">`|`</span> <span class="o">:=</span> <span class="n">a</span><span class="bp">⊔-</span><span class="n">a</span><span class="o">)</span> <span class="c1">-- temporary notation within this definition</span>
<span class="o">(</span><span class="n">solid'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">≤</span> <span class="bp">|</span><span class="n">b</span><span class="bp">|</span> <span class="bp">→</span> <span class="bp">∥</span><span class="n">a</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="n">b</span><span class="bp">∥</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">has_continuous_inf</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">has_inf</span> <span class="n">L</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">continuous_inf</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">×</span> <span class="n">L</span><span class="o">,</span> <span class="n">p.1</span> <span class="bp">⊓</span> <span class="n">p.2</span><span class="o">))</span>

<span class="kd">class</span> <span class="n">has_continuous_sup</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">has_sup</span> <span class="n">L</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">continuous_sup</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">×</span> <span class="n">L</span><span class="o">,</span> <span class="n">p.1</span> <span class="bp">⊔</span> <span class="n">p.2</span><span class="o">))</span>

<span class="c1">-- If α is a normed lattice ordered group, so is order_dual α</span>
<span class="kd">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">[</span><span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">],</span> <span class="n">normed_lattice_add_comm_group</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">id</span>

<span class="c1">-- Proof omitted for brevity</span>
<span class="kd">instance</span> <span class="n">normed_lattice_add_comm_group_has_continuous_inf</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_continuous_inf</span> <span class="n">α</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- If the inf is continuous in the order dual then the sup is continuous</span>
<span class="kd">instance</span> <span class="n">has_continuous_inf_dual_has_continuous_sup</span>
<span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">has_sup</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">h</span><span class="o">:</span> <span class="n">has_continuous_inf</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">L</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">has_continuous_sup</span>  <span class="n">L</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">continuous_sup</span> <span class="o">:=</span>
    <span class="bp">@</span><span class="n">has_continuous_inf.continuous_inf</span>  <span class="o">(</span><span class="n">order_dual</span> <span class="n">L</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span>
<span class="o">}</span>

<span class="c1">-- If the order dual is a normed lattice ordered group, it has continuous inf</span>
<span class="kd">lemma</span> <span class="n">dual_normed_lattice_add_comm_group_has_continuous_inf</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">}</span> <span class="o">[</span><span class="n">h</span><span class="o">:</span> <span class="n">normed_lattice_add_comm_group</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">α</span><span class="o">)]</span> <span class="o">:</span> <span class="n">has_continuous_inf</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">normed_lattice_add_comm_group_has_continuous_inf</span><span class="o">,</span>
<span class="kd">end</span>

<span class="k">#check</span> <span class="n">has_continuous_inf_dual_has_continuous_sup</span>

<span class="kd">set_option</span> <span class="n">pp.all</span> <span class="n">true</span>
<span class="kd">lemma</span> <span class="n">normed_lattice_add_comm_group_dual_has_continuous_inf</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">}</span> <span class="o">[</span><span class="n">h</span><span class="o">:</span> <span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_continuous_inf</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="bp">@</span><span class="n">dual_normed_lattice_add_comm_group_has_continuous_inf</span> <span class="n">α</span> <span class="n">h</span><span class="o">,</span>
  <span class="c1">-- ⊢ order_dual.has_inf α = semilattice_inf.to_has_inf (order_dual α)</span>

  <span class="c1">-- ⊢ @eq.{u+1}</span>
  <span class="c1">-- (has_inf.{u} (order_dual.{u} α))</span>
  <span class="c1">-- (@order_dual.has_inf.{u} α (@semilattice_sup.to_has_sup.{u} α (@lattice.to_semilattice_sup.{u} α (@normed_lattice_add_comm_group.to_lattice.{u} α h))))</span>
  <span class="c1">-- (@semilattice_inf.to_has_inf.{u} (order_dual.{u} α) (@lattice.to_semilattice_inf.{u} (order_dual.{u} α) (@normed_lattice_add_comm_group.to_lattice.{u} (order_dual.{u} α) h)))</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>I've tried various permutations, but I always end up being asked to prove</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">order_dual.has_inf</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">semilattice_inf.to_has_inf</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span>
</code></pre></div>
<p>and at this point I get stuck.</p>
<p>Thanks,</p>
<p>Christopher</p>



<a name="243364222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243364222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243364222">(Jun 21 2021 at 10:38)</a>:</h4>
<p>This looks wrong:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">[</span><span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">],</span> <span class="n">normed_lattice_add_comm_group</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">id</span>
</code></pre></div>
<p>this says <code>order_dual α</code> has the same lattice structure as <code>α</code>, not the dual structure</p>



<a name="243371914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243371914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243371914">(Jun 21 2021 at 12:02)</a>:</h4>
<p>I adapted that line from <a href="https://github.com/leanprover-community/mathlib/blob/c7d094da6d3ced93ab034ba9d77519b4f9147124/src/topology/algebra/ordered/basic.lean#L109">this line</a> in Mathlib</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">],</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">id</span>
</code></pre></div>
<p>I think that line says that the dual of a topological space is also a topological space, so I assume my line says that the dual of a normed lattice ordered group is a normed lattice ordered group?</p>



<a name="243372015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243372015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243372015">(Jun 21 2021 at 12:03)</a>:</h4>
<p>Yes, but the difference is a topological space has nothing to take the dual of</p>



<a name="243372019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243372019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243372019">(Jun 21 2021 at 12:03)</a>:</h4>
<p>"Instance" is like "definition", not "theorem". This line in mathlib says "we <em>define</em> the topology on the dual space to be the same as the topology on the original space".</p>



<a name="243372161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243372161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243372161">(Jun 21 2021 at 12:04)</a>:</h4>
<p>What you want to do here is copy the topology unmodified, and fill in the remaining fields using the existing instance for <code>lattice (order_dual α)</code></p>



<a name="243375202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243375202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243375202">(Jun 21 2021 at 12:34)</a>:</h4>
<p>Thank you. So, something more like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">h</span><span class="o">:</span> <span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">normed_lattice_add_comm_group</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">add_le_add_left</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">solid'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">h</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>
<p>where the sorry remain to be proved?</p>



<a name="243375386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243375386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243375386">(Jun 21 2021 at 12:36)</a>:</h4>
<p><code>..h</code> is no good, that will give you the wrong lattice structure.</p>



<a name="243375393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243375393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243375393">(Jun 21 2021 at 12:36)</a>:</h4>
<p>I think this also copies the definition of <code>le</code> from <code>h</code> to the order dual</p>



<a name="243375427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243375427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243375427">(Jun 21 2021 at 12:37)</a>:</h4>
<p>You want <code>.. order_dual.lattice h</code>, or something like that.</p>



<a name="243376661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243376661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243376661">(Jun 21 2021 at 12:49)</a>:</h4>
<p>Presumably</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">α</span><span class="o">],</span> <span class="n">normed_group</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">id</span>
</code></pre></div>
<p>is okay, as, like <code>topological_space</code>, the definition of <code>normed_group</code> is independent of order?</p>



<a name="243376895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243376895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243376895">(Jun 21 2021 at 12:51)</a>:</h4>
<p>Yes, this part looks fine.</p>



<a name="243399107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243399107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243399107">(Jun 21 2021 at 15:25)</a>:</h4>
<p>Okay, I think I have the proof that the order dual of a <code>normed_lattice_add_comm_group</code> is also a <code>normed_lattice_add_comm_group</code> correct now?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.normed_space.ordered</span>
<span class="kn">import</span> <span class="n">algebra.ordered_group</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">class</span> <span class="n">normed_lattice_add_comm_group</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
  <span class="kd">extends</span> <span class="n">normed_group</span> <span class="n">α</span><span class="o">,</span> <span class="n">lattice</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_le_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="kd">notation</span> <span class="bp">`|`</span><span class="n">a</span><span class="bp">`|`</span> <span class="o">:=</span> <span class="n">a</span><span class="bp">⊔-</span><span class="n">a</span><span class="o">)</span> <span class="c1">-- temporary notation within this definition</span>
<span class="o">(</span><span class="n">solid'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">≤</span> <span class="bp">|</span><span class="n">b</span><span class="bp">|</span> <span class="bp">→</span> <span class="bp">∥</span><span class="n">a</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="n">b</span><span class="bp">∥</span><span class="o">)</span>

<span class="c1">-- Every (normed) lattice additive commutative group is also an ordered additive commutative group</span>
<span class="c1">-- @[priority 100] -- see Note [lower instance priority]</span>
<span class="kd">instance</span> <span class="n">normed_lattice_add_comm_group.to_ordered_add_comm_group</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
  <span class="o">[</span><span class="n">s</span> <span class="o">:</span> <span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">ordered_add_comm_group</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="n">s.add</span><span class="o">,</span> <span class="bp">..</span><span class="n">s</span> <span class="o">}</span>

<span class="kd">class</span> <span class="n">has_continuous_inf</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">has_inf</span> <span class="n">L</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">continuous_inf</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">×</span> <span class="n">L</span><span class="o">,</span> <span class="n">p.1</span> <span class="bp">⊓</span> <span class="n">p.2</span><span class="o">))</span>

<span class="kd">class</span> <span class="n">has_continuous_sup</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">has_sup</span> <span class="n">L</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">continuous_sup</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">×</span> <span class="n">L</span><span class="o">,</span> <span class="n">p.1</span> <span class="bp">⊔</span> <span class="n">p.2</span><span class="o">))</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">α</span><span class="o">],</span> <span class="n">normed_group</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">id</span>

<span class="c1">-- Special case of Bourbaki A.VI.9 (2)</span>
<span class="c1">-- (Actually this is true for a lattice_add_comm_group, but omit that for simplicity)</span>
<span class="kd">lemma</span> <span class="n">neg_join_eq_neg_meet_neg</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">-</span><span class="o">(</span><span class="n">a</span><span class="bp">⊔</span><span class="n">b</span><span class="o">)</span><span class="bp">=</span><span class="o">(</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span><span class="bp">⊓</span><span class="o">(</span><span class="bp">-</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">le_antisymm_iff</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">le_inf_iff</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">neg_le_neg_iff</span><span class="o">,</span> <span class="n">apply</span> <span class="n">le_sup_left</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">neg_le_neg_iff</span><span class="o">,</span> <span class="n">apply</span> <span class="n">le_sup_right</span><span class="o">,</span> <span class="o">}</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">neg_le_neg_iff</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">neg_le_neg_iff</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">neg_le_neg_iff</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="o">}</span>
  <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">join_neg_eq_neg_meet</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">-</span><span class="n">a</span><span class="bp">⊔-</span><span class="n">b</span> <span class="bp">=</span> <span class="bp">-</span><span class="o">(</span><span class="n">a</span><span class="bp">⊓</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">neg_neg</span> <span class="o">(</span><span class="bp">-</span><span class="n">a</span><span class="bp">⊔-</span><span class="n">b</span><span class="o">),</span> <span class="n">neg_join_eq_neg_meet_neg</span> <span class="o">(</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="bp">-</span><span class="n">b</span><span class="o">),</span> <span class="n">neg_neg</span><span class="o">,</span> <span class="n">neg_neg</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">opsolid</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">h</span><span class="o">:</span> <span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span><span class="bp">⊓-</span><span class="n">a</span> <span class="bp">≥</span> <span class="n">b</span><span class="bp">⊓-</span><span class="n">b</span> <span class="bp">→</span> <span class="bp">∥</span><span class="n">a</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="n">b</span><span class="bp">∥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h.solid'</span><span class="o">,</span>
  <span class="n">nth_rewrite</span> <span class="mi">0</span> <span class="bp">←</span> <span class="n">neg_neg</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">join_neg_eq_neg_meet</span><span class="o">,</span>
  <span class="n">nth_rewrite</span> <span class="mi">0</span> <span class="bp">←</span> <span class="n">neg_neg</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">join_neg_eq_neg_meet</span><span class="o">,</span>
  <span class="n">finish</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- If α is a normed lattice ordered group, so is order_dual α</span>
<span class="kd">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">h</span><span class="o">:</span> <span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">normed_lattice_add_comm_group</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">add_le_add_left</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h₁</span> <span class="n">c</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">order_dual.dual_le</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">order_dual.dual_le</span> <span class="n">at</span> <span class="n">h₁</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">h.add_le_add_left</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">solid'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">opsolid</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">order_dual.dual_le</span> <span class="n">at</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="n">finish</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>
<p>However, I still get asked to prove <code>order_dual.has_inf α = semilattice_inf.to_has_inf (order_dual α)</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- Proof omitted for brevity</span>
<span class="kd">instance</span> <span class="n">normed_lattice_add_comm_group_has_continuous_inf</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_continuous_inf</span> <span class="n">α</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- If the inf is continuous in the order dual then the sup is continuous</span>
<span class="kd">instance</span> <span class="n">has_continuous_inf_dual_has_continuous_sup</span>
<span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">has_sup</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">h</span><span class="o">:</span> <span class="n">has_continuous_inf</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">L</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">has_continuous_sup</span>  <span class="n">L</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">continuous_sup</span> <span class="o">:=</span>
    <span class="bp">@</span><span class="n">has_continuous_inf.continuous_inf</span>  <span class="o">(</span><span class="n">order_dual</span> <span class="n">L</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span>
<span class="o">}</span>

<span class="c1">-- If the order dual is a normed lattice ordered group, it has continuous inf</span>
<span class="kd">lemma</span> <span class="n">dual_normed_lattice_add_comm_group_has_continuous_inf</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">}</span> <span class="o">[</span><span class="n">h</span><span class="o">:</span> <span class="n">normed_lattice_add_comm_group</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">α</span><span class="o">)]</span> <span class="o">:</span> <span class="n">has_continuous_inf</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">normed_lattice_add_comm_group_has_continuous_inf</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">normed_lattice_add_comm_group_dual_has_continuous_inf</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">}</span> <span class="o">[</span><span class="n">h</span><span class="o">:</span> <span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_continuous_inf</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="bp">@</span><span class="n">dual_normed_lattice_add_comm_group_has_continuous_inf</span> <span class="n">α</span> <span class="n">h</span><span class="o">,</span>
  <span class="c1">-- ⊢ order_dual.has_inf α = semilattice_inf.to_has_inf (order_dual α)</span>

  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>Thanks very much for all your help!</p>



<a name="243539583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243539583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243539583">(Jun 22 2021 at 16:09)</a>:</h4>
<p>Do I need:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>
</code></pre></div>
<p>in order to make this work? In Mathlib <code>order/bounded_lattices.lean</code>, <code>bounded_lattice</code> extends <code>lattice</code> and some other classes, and I notice it uses <code>set_option old_structure_cmd true</code>.</p>



<a name="243541608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243541608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243541608">(Jun 22 2021 at 16:24)</a>:</h4>
<p>That option is for when you extend two typeclasses which have overlapping fields. I suspect <code>normed_group</code> and <code>lattice</code> don't have any overlapping fields so I don't think it will help.</p>



<a name="243542127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243542127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243542127">(Jun 22 2021 at 16:29)</a>:</h4>
<p>I should add that I'm quite surprised this proof isn't <code>refl</code> (but it isn't)</p>



<a name="243542763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243542763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243542763">(Jun 22 2021 at 16:33)</a>:</h4>
<p>In fact this goal seems to be false :-(</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">normed_lattice_add_comm_group_dual_has_continuous_inf</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">}</span> <span class="o">[</span><span class="n">h</span><span class="o">:</span> <span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_continuous_inf</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="bp">@</span><span class="n">dual_normed_lattice_add_comm_group_has_continuous_inf</span> <span class="n">α</span> <span class="n">h</span><span class="o">,</span>
  <span class="c1">-- ⊢ order_dual.has_inf α = semilattice_inf.to_has_inf (order_dual α)</span>
  <span class="n">unfold</span> <span class="n">order_dual.has_inf</span><span class="o">,</span>
  <span class="n">delta</span> <span class="n">semilattice_inf.to_has_inf</span><span class="o">,</span>
  <span class="n">congr'</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">⊔</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">⊓</span> <span class="n">b</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span> <span class="c1">-- cheat by assuming false thing</span>
  <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span> <span class="c1">-- unfortunately this now works</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">lattice</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="k">show</span> <span class="n">order_dual</span> <span class="n">α</span><span class="o">,</span> <span class="k">from</span> <span class="n">a</span><span class="o">)</span> <span class="bp">⊓</span> <span class="n">b</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">⊔</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- fails</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">lattice</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="k">show</span> <span class="n">order_dual</span> <span class="n">α</span><span class="o">,</span> <span class="k">from</span> <span class="n">a</span><span class="o">)</span> <span class="bp">⊔</span> <span class="n">b</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">⊔</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- works :-(</span>
</code></pre></div>



<a name="243545531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243545531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243545531">(Jun 22 2021 at 16:53)</a>:</h4>
<p>Actually your proof looks wrong to me, maybe this is expected behaviour. You've proved that NLACGs have a continuous_inf. Your <code>convert</code> line is claiming that what you're trying to prove (dual has continuous inf) follows from <code>dual_normed_lattice_add_comm_group_has_continuous_inf</code> but you're giving it the wrong <code>h</code>, if you give it <code>h</code> then it will identify alpha with its dual and now you're in trouble.</p>



<a name="243545908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243545908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243545908">(Jun 22 2021 at 16:55)</a>:</h4>
<p>If you put <code>attribute [irreducible] order_dual</code> before <code>normed_lattice_add_comm_group_dual_has_continuous_inf</code> you'll see an error on the convert line, because now Lean cannot unify <code>alpha</code> and <code>order_dual alpha</code>, which is not what you want it to do anyway.</p>



<a name="243547707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243547707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243547707">(Jun 22 2021 at 17:08)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">lattice</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="k">show</span> <span class="n">order_dual</span> <span class="n">α</span><span class="o">,</span> <span class="k">from</span> <span class="n">a</span><span class="o">)</span> <span class="bp">⊓</span> <span class="n">b</span> <span class="bp">=</span> <span class="o">((</span><span class="n">a</span> <span class="bp">⊔</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- works</span>
</code></pre></div>
<p>OK I see where I was going wrong with my examples. It looks to me like we're back on track.</p>



<a name="243551020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243551020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243551020">(Jun 22 2021 at 17:30)</a>:</h4>
<p>So, now I have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">attribute</span> <span class="o">[</span><span class="n">irreducible</span><span class="o">]</span> <span class="n">order_dual</span>

<span class="kd">lemma</span> <span class="n">normed_lattice_add_comm_group_dual_has_continuous_inf</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">}</span> <span class="o">[</span><span class="n">h</span><span class="o">:</span> <span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_continuous_inf</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h₁</span> <span class="o">:</span> <span class="n">normed_lattice_add_comm_group</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">exact</span> <span class="n">order_dual.normed_lattice_add_comm_group</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">convert</span> <span class="bp">@</span><span class="n">dual_normed_lattice_add_comm_group_has_continuous_inf</span> <span class="n">α</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="c1">-- ⊢ order_dual.topological_space = uniform_space.to_topological_space</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="c1">-- ⊢ order_dual.has_inf α = semilattice_inf.to_has_inf (order_dual α)</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>?</p>



<a name="243551398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243551398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243551398">(Jun 22 2021 at 17:32)</a>:</h4>
<p>Better:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">normed_lattice_add_comm_group_dual_has_continuous_inf</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">}</span> <span class="o">[</span><span class="n">h</span><span class="o">:</span> <span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_continuous_inf</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="bp">@</span><span class="n">dual_normed_lattice_add_comm_group_has_continuous_inf</span> <span class="n">α</span> <span class="n">order_dual.normed_lattice_add_comm_group</span><span class="o">,</span>
  <span class="c1">-- ⊢ order_dual.topological_space = uniform_space.to_topological_space</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="243582163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243582163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243582163">(Jun 22 2021 at 21:36)</a>:</h4>
<p>That goal looks true!</p>



<a name="243582381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243582381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243582381">(Jun 22 2021 at 21:39)</a>:</h4>
<p>Your <code>convert</code> closes the goal for me. Don't put the irreducibility attribute on order_dual, that was just to show you where your abuse of definitional equality was not what you wanted. Abuse of defeq gives you <code>alpha = order_dual alpha</code> which is bad because then an inf or a sup might slip over that equality and become hard to work with.</p>



<a name="243582551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243582551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243582551">(Jun 22 2021 at 21:41)</a>:</h4>
<p>The way which I would argue was the "correct" way to do this would be to make <code>order_dual</code> irreducible, define a map <code>to_dual : alpha -&gt; order_dual alpha</code> which was <code>id</code> but defined before <code>order_dual</code> was made irreducible, and then prove a ton of lemmas about to_dual being an order-reversing isomorphism. But the CS people are too lazy to use this principled approach because they are more used to defeq abuse and it makes for shorter code. It's quite a knack to get it right though.</p>



<a name="243582643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20order%20duals/near/243582643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20order.20duals.html#243582643">(Jun 22 2021 at 21:42)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">normed_lattice_add_comm_group_dual_has_continuous_inf</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">}</span>
  <span class="o">[</span><span class="n">h</span><span class="o">:</span> <span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_continuous_inf</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">infer_instance</span>
</code></pre></div>
<p>It just follows from the two other instances you've made.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
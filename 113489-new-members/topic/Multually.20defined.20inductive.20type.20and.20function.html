---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html">Multually defined inductive type and function</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="202086075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202086075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202086075">(Jun 26 2020 at 12:59)</a>:</h4>
<p>Is it possible to use <code>mutual inductive</code> where one branch is a type and the other is a <code>def</code>? Or does that question not make sense?</p>



<a name="202086368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202086368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202086368">(Jun 26 2020 at 13:02)</a>:</h4>
<p>More the latter, but can you post an example of what you'd like to do?</p>



<a name="202086406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202086406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Olson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202086406">(Jun 26 2020 at 13:02)</a>:</h4>
<p>I know for sure this is possible in Agda, but Lean's <code>mutual</code> syntax seems less flexible in these examples: <a href="https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html#mutual-recursion">https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html#mutual-recursion</a></p>



<a name="202086516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202086516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Olson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202086516">(Jun 26 2020 at 13:03)</a>:</h4>
<p>The Agda docs have a TypeCode/Interpretation example: <a href="https://agda.readthedocs.io/en/v2.6.1/language/mutual-recursion.html#mutual-recursion">https://agda.readthedocs.io/en/v2.6.1/language/mutual-recursion.html#mutual-recursion</a></p>



<a name="202086857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202086857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202086857">(Jun 26 2020 at 13:06)</a>:</h4>
<p>Here's my best attempt:</p>
<div class="codehilite"><pre><span></span><code><span class="n">mutual</span> <span class="kn">inductive</span> <span class="n">blade_new</span><span class="o">,</span> <span class="n">blade_is_perp</span>
<span class="k">with</span> <span class="n">blade</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">scalar</span> <span class="o">:</span> <span class="n">G₀</span> <span class="bp">→</span> <span class="n">blade_new</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">vector</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">→</span> <span class="n">blade</span> <span class="mi">1</span>
<span class="c1">-- takes a vector, n+1 blade, and a proof that the vector and n+1 blade are perpendicular</span>
<span class="bp">|</span> <span class="n">graded</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">blade_new</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)),</span> <span class="o">(</span><span class="n">blade_is_perp</span> <span class="n">v</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">blade_new</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span>

<span class="c1">-- a proof of perpendicularity is either</span>
<span class="k">with</span> <span class="n">blade_is_perp</span> <span class="o">:</span> <span class="bp">Π</span>  <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">},</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">G₁</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">blade_new</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)),</span> <span class="n">sorry</span> <span class="o">:</span> <span class="n">sorry</span>
<span class="c1">-- a proof that `v` is perpendicular to the sole element of `blade_new.vector`</span>
<span class="c1">-- a proof that both:</span>
<span class="c1">--   `v` is perpendicular to the v argument of `blade_new.graded`</span>
<span class="c1">--   `v` is perpendicular to the b argument of `blade_new.graded`</span>
</code></pre></div>



<a name="202087023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202087023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202087023">(Jun 26 2020 at 13:08)</a>:</h4>
<p>I'm not really sure how to write the type of <code>blade_is_perp</code></p>



<a name="202087037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202087037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202087037">(Jun 26 2020 at 13:08)</a>:</h4>
<p>This makes sense (it's called induction-recursion) but Lean doesn't support it.</p>



<a name="202087270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202087270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202087270">(Jun 26 2020 at 13:11)</a>:</h4>
<p>(are <code>blade</code> and <code>blade_new</code> supposed to be the same thing?)</p>



<a name="202087272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202087272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202087272">(Jun 26 2020 at 13:11)</a>:</h4>
<p>I suppose a perhaps simpler example of my problem is constructing a list along with a proof that a relation is satisfied between every pair of elements</p>



<a name="202087337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202087337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202087337">(Jun 26 2020 at 13:12)</a>:</h4>
<p>You can emulate induction-recursion in Lean in various ways, but the easiest to work with in a case like this will just be to build it directly as <code>{l : list A // l.pairwise r}</code> -- or whatever the actual name is.</p>



<a name="202088163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202088163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202088163">(Jun 26 2020 at 13:19)</a>:</h4>
<p>Kind of a reiteration of what he said, but often you can state the definition you want in a more general way than you actually plan to use it, then declare the inductive such that it uses the specialized form of the definition. Mario Carneiro helped me with similar solution a little while back, where <code>IFunc</code> gets declared with a type parameter (A) that then gets filled in as the inductive : <a href="#narrow/stream/113488-general/topic/Lea%28r%29n.20you.20a.20scheme/near/190326502">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lea%28r%29n.20you.20a.20scheme/near/190326502</a></p>



<a name="202089530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202089530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202089530">(Jun 26 2020 at 13:30)</a>:</h4>
<p>To be honest, I've always had the impression that people interested in those things should play with Agda instead of Lean. This part part of Lean seems broken and completely orthogonal to what works great in Lean.</p>



<a name="202090259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202090259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202090259">(Jun 26 2020 at 13:36)</a>:</h4>
<p>In this case the "workaround" of using a list + separately defined property is also more convenient in practice anyways.</p>



<a name="202092750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202092750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202092750">(Jun 26 2020 at 13:53)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>, is it generally better to reuse existing inductive types like list instead of defining my own?</p>



<a name="202092905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202092905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202092905">(Jun 26 2020 at 13:54)</a>:</h4>
<p>Depends on what you want to do. If you reuse stuff, you can also reuse a lot of lemmas.</p>



<a name="202092931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202092931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202092931">(Jun 26 2020 at 13:54)</a>:</h4>
<p>And sometimes "a lot" means &gt; 4000 lines of code.</p>



<a name="202093034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202093034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202093034">(Jun 26 2020 at 13:55)</a>:</h4>
<p>And can I use <code>pairwise</code> on <code>vector</code> instead of <code>list</code>?</p>



<a name="202093324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202093324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202093324">(Jun 26 2020 at 13:57)</a>:</h4>
<p>Well, a <code>vector</code> is defined in terms of lists, so "yes".</p>



<a name="202093413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202093413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202093413">(Jun 26 2020 at 13:58)</a>:</h4>
<p>you could easily make vector.pairwise</p>



<a name="202093422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202093422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202093422">(Jun 26 2020 at 13:58)</a>:</h4>
<p>But you might need to extract the listy part out of the vector</p>



<a name="202093912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202093912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202093912">(Jun 26 2020 at 14:01)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>: I don't fully understand the syntax you have, mind giving me a really simple <code>#check</code> command that I can put that into?</p>



<a name="202094078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202094078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202094078">(Jun 26 2020 at 14:02)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">parameters</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span> <span class="bp">//</span> <span class="n">l</span><span class="bp">.</span><span class="n">pairwise</span> <span class="n">eq</span><span class="o">)</span>
</code></pre></div>


<p>is giving me "invalid expression"</p>



<a name="202094145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202094145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202094145">(Jun 26 2020 at 14:03)</a>:</h4>
<p>you have two l's?</p>



<a name="202094191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202094191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202094191">(Jun 26 2020 at 14:03)</a>:</h4>
<p><code>{}</code>, not <code>()</code></p>



<a name="202094238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202094238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202094238">(Jun 26 2020 at 14:03)</a>:</h4>
<p><code>#check {l : list ℕ // l.pairwise eq}</code></p>



<a name="202094320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202094320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202094320">(Jun 26 2020 at 14:04)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> Can we rip <code>parameter</code> out of core? [/joking]</p>



<a name="202094386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202094386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202094386">(Jun 26 2020 at 14:04)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> (Note that parameters will be gone in lean 4.)</p>



<a name="202094425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202094425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202094425">(Jun 26 2020 at 14:05)</a>:</h4>
<p>In general, it's advised to use <code>variables</code> instead.</p>



<a name="202095142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202095142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202095142">(Jun 26 2020 at 14:10)</a>:</h4>
<p>Oh, I assumed the <code>{}</code> was an argument declaration like <code>()</code></p>



<a name="202095190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202095190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202095190">(Jun 26 2020 at 14:10)</a>:</h4>
<p>But here it's part of the type itself. I haven't seen this type of <code>Type</code> before - is there somewhere in the docs I can read about the syntax?</p>



<a name="202095240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202095240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202095240">(Jun 26 2020 at 14:11)</a>:</h4>
<p>It's notation for <code>subtype</code></p>



<a name="202095303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202095303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202095303">(Jun 26 2020 at 14:11)</a>:</h4>
<p>You could also just make a custom structure.</p>



<a name="202095412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202095412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202095412">(Jun 26 2020 at 14:12)</a>:</h4>
<p>Reuse of list lemmas is one advantage, but this style is also just easier to work with than a fancy inductive-recursive definition, at least when the inductive-recursive definition isn't buying you any additional expressive power.</p>



<a name="202095461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202095461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202095461">(Jun 26 2020 at 14:12)</a>:</h4>
<p>I'm not sure it's easy to see the <code>{x : X // p x}</code> notation for <code>@subtype X p</code> defined in Lean, it might be baked in somehow?</p>



<a name="202095543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202095543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202095543">(Jun 26 2020 at 14:13)</a>:</h4>
<p>For example, you can replace the list by a propositionally equal one and then transport the proof of the property without having to rebuild the entire inductive structure.</p>



<a name="202095556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202095556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202095556">(Jun 26 2020 at 14:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function/near/202093422">said</a>:</p>
<blockquote>
<p>But you might need to extract the listy part out of the vector</p>
</blockquote>
<p>How do I do that?</p>



<a name="202095633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202095633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202095633">(Jun 26 2020 at 14:14)</a>:</h4>
<p><code>(v : list ℕ)</code> didn't work, so I guess there's no <code>coe</code> defined?</p>



<a name="202095773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202095773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202095773">(Jun 26 2020 at 14:15)</a>:</h4>
<p>There is for <code>subtype</code> itself, but if you introduced a <code>def</code> for it then there isn't for your <code>def</code>.</p>



<a name="202095800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202095800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202095800">(Jun 26 2020 at 14:15)</a>:</h4>
<p><code>v.val</code> or <code>v.1</code> or add a <code>has_coe</code> instance defined to be one of these.</p>



<a name="202095892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202095892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202095892">(Jun 26 2020 at 14:16)</a>:</h4>
<p>Is there any way to get autocomplete to help me there?</p>



<a name="202095912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202095912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202095912">(Jun 26 2020 at 14:16)</a>:</h4>
<p>Hitting tab after the dot gave me a massive list</p>



<a name="202095933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202095933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202095933">(Jun 26 2020 at 14:16)</a>:</h4>
<p>Yes, define your own structure instead of reusing <code>subtype</code> <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="202095966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202095966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202095966">(Jun 26 2020 at 14:16)</a>:</h4>
<p>Otherwise, there is nothing for autocomplete to know (it isn't smart enough to unfold definitions).</p>



<a name="202096027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202096027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202096027">(Jun 26 2020 at 14:17)</a>:</h4>
<p>What is the structure equivalent to <code>{x : X // p x}</code>?</p>



<a name="202096061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202096061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202096061">(Jun 26 2020 at 14:17)</a>:</h4>
<p>subtype p</p>



<a name="202096138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202096138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202096138">(Jun 26 2020 at 14:18)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">foo</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">l</span><span class="bp">.</span><span class="n">pairwise</span> <span class="n">eq</span><span class="o">)</span>
</code></pre></div>



<a name="202096152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202096152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202096152">(Jun 26 2020 at 14:18)</a>:</h4>
<p>(modulo typos)</p>



<a name="202096176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202096176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202096176">(Jun 26 2020 at 14:18)</a>:</h4>
<p>Thanks, that now seems obvious</p>



<a name="202096231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202096231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202096231">(Jun 26 2020 at 14:18)</a>:</h4>
<p>I was trying to work out how I could constrain the <code>l</code> field</p>



<a name="202096275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202096275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202096275">(Jun 26 2020 at 14:19)</a>:</h4>
<p>oh you mean rolling your own?</p>



<a name="202096283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202096283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202096283">(Jun 26 2020 at 14:19)</a>:</h4>
<p>the joys of dependent types</p>



<a name="202096288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202096288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202096288">(Jun 26 2020 at 14:19)</a>:</h4>
<p>But obviously that's not necessary, if you pass an l that doesn't satisfy the pairwise requirement, then you just get stuck producing a <code>p</code></p>



<a name="202096304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202096304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Olson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202096304">(Jun 26 2020 at 14:19)</a>:</h4>
<p>This is the actual definition of <code>subtype</code> in Lean for reference: <a href="https://github.com/leanprover-community/lean/blob/de6c873a57fda86c20dc93f4660ab257ef8e8995/library/init/core.lean#L270-L271">https://github.com/leanprover-community/lean/blob/de6c873a57fda86c20dc93f4660ab257ef8e8995/library/init/core.lean#L270-L271</a></p>



<a name="202100368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202100368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202100368">(Jun 26 2020 at 14:52)</a>:</h4>
<p>By the way, note that <code>vector</code> is defined in the Lean core library as a subtype and not an inductive family indexed on <code>nat</code>, even though Lean supports those just fine, for the same reason: it's easier to use.</p>



<a name="202101981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202101981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202101981">(Jun 26 2020 at 15:04)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> Why are you actually interested in lists of which all elements are pairwise equal? They don't seem very interesting to me...</p>



<a name="202177559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202177559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202177559">(Jun 27 2020 at 09:44)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>: That was a contrived example, what I actually care about is list where elements have a pairwise dot product of zero</p>



<a name="202177655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multually%20defined%20inductive%20type%20and%20function/near/202177655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multually.20defined.20inductive.20type.20and.20function.html#202177655">(Jun 27 2020 at 09:47)</a>:</h4>
<p>Ok, that sounds a lot more interesting <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
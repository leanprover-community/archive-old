---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html">More documentation on the syntax of quantifiers?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="301507785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301507785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301507785">(Sep 29 2022 at 18:40)</a>:</h4>
<p>I'm working through TPIL4 (I don't believe the issues are any different in Lean3) and I find the documentation in TPIL to be under-explanatory for the syntax of quantifiers. For example, I don't understand why this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">h1</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">p</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=&gt;</span>
      <span class="k">fun</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">p</span> <span class="n">y</span><span class="o">))</span> <span class="bp">=&gt;</span>
          <span class="k">fun</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">h1</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>
<p>and why this does not...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=&gt;</span>
      <span class="k">fun</span> <span class="o">{</span><span class="n">y</span><span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hpy</span><span class="o">:</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">h</span> <span class="n">y</span><span class="o">)</span> <span class="n">hpy</span>
</code></pre></div>
<p>or this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">y</span> <span class="bp">=&gt;</span>
      <span class="k">fun</span> <span class="o">{</span><span class="n">y</span><span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hpy</span><span class="o">:</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">h</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">hpy</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>
<p>and there doesn't seem to be anything in TPIL that explains <em>why</em> one works and one does not, or why lean4 gets very particular about constraining <code>y : α</code> in some contexts but is quite happy to understand <code>y</code> in others. I feel like I'm just trying things at random as opposed to having a deep theory about how Lean models the syntax of quantifiers...</p>



<a name="301509112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301509112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301509112">(Sep 29 2022 at 18:48)</a>:</h4>
<p>The type <code>(∀ x, p x → q x) → (∀ x, p x) → (∀ x, q x)</code> is for a function that takes three arguments in the following order: a <code>∀ x, p x → q x</code>, a <code>∀ x, p x</code>, and an <code>α</code> (I'm guessing based on context; it depends on what <code>q</code> is)</p>



<a name="301509380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301509380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301509380">(Sep 29 2022 at 18:50)</a>:</h4>
<p>Your <code>fun (h: ∀ x, p x → q x) =&gt; fun {y: α} (hpy: p y) =&gt; (h y) hpy</code> (or, equivalently, <code>fun (h: ∀ x, p x → q x) {y: α} (hpy: p y) =&gt; (h y) hpy</code>) has the wrong type for the second argument.</p>



<a name="301509500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301509500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301509500">(Sep 29 2022 at 18:50)</a>:</h4>
<p>It looks like you're mistaking <code>(∀ x, p x → q x) → (∀ x, p x) → (∀ x, q x)</code> for <code>(∀ x, p x → q x) → (∀ x, p x → (∀ x, q x))</code></p>



<a name="301509904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301509904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301509904">(Sep 29 2022 at 18:52)</a>:</h4>
<p>Fair. So if I fix the quantifier</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">y</span> <span class="bp">=&gt;</span>
      <span class="k">fun</span> <span class="o">{</span><span class="n">y</span><span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hpy</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">h</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">hpy</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>
<p>I get</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span>
  <span class="k">fun</span> <span class="o">{</span><span class="n">y</span><span class="o">}</span> <span class="n">hpy</span> <span class="bp">=&gt;</span> <span class="n">h</span> <span class="n">y</span> <span class="o">(</span><span class="n">hpy</span> <span class="n">y</span><span class="o">)</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">y</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">Prop</span>
</code></pre></div>
<p>which seems to say that there's a quantifier problem in the result?</p>



<a name="301510023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301510023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301510023">(Sep 29 2022 at 18:53)</a>:</h4>
<p>Why are your <code>fun</code>s taking two <code>y</code> arguments?</p>



<a name="301510038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301510038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301510038">(Sep 29 2022 at 18:53)</a>:</h4>
<p>But in the function that works, we don't specify quantifiers....</p>



<a name="301510419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301510419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301510419">(Sep 29 2022 at 18:55)</a>:</h4>
<p>The error is telling you that <code>fun {y} hpy =&gt; h y (hpy y)</code> has type <code>∀ {y : α}, (∀ (y : α), p y) → q y</code>. It's something that takes an <code>α</code> called <code>y</code> and a <code>∀ (y : α), p y</code> (with a differently scoped <code>y</code>) and returns a <code>q y</code></p>



<a name="301510499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301510499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301510499">(Sep 29 2022 at 18:56)</a>:</h4>
<p>That's not the type signature that you're aiming for with your <code>example</code>, right?</p>



<a name="301510743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301510743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301510743">(Sep 29 2022 at 18:57)</a>:</h4>
<p>OK, if I take the indirection out, I get the same result</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=&gt;</span>
      <span class="k">fun</span> <span class="o">{</span><span class="n">y</span><span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hpy</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">h</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">hpy</span><span class="o">)</span>
</code></pre></div>
<p>which gives me the opposite error. Again, not disputing that one works and one doesn't -- I just don't read TPIL or any other documentation and having a theory as to the case of why I've quantified correctly in the first example up top, but incorrectly in the second.</p>



<a name="301511167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301511167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301511167">(Sep 29 2022 at 18:59)</a>:</h4>
<p>Just keep in mind that <code>∀ (x : α), p x</code> is how you write the type of a function that takes something of <code>α</code> (called <code>x</code>) and returns something of type <code>p x</code> (which depends on the input value, so it's a <em>dependent</em> type). And, if the result is independent of the input value, it uses the arrow notation, so for example <code>p x → q x</code> is the type of a function whose output type does not depend on the input value.</p>



<a name="301511190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301511190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301511190">(Sep 29 2022 at 18:59)</a>:</h4>
<p>I've only used Lean3 so I'm not that sure, but I think the problem is that the order of <code>y</code> and <code>hpy</code> in the quantifier is reversed?</p>



<a name="301511341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301511341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301511341">(Sep 29 2022 at 19:00)</a>:</h4>
<p>So implication/arrow is a special case of the forall notation, which we use because it looks nicer.</p>



<a name="301511412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301511412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301511412">(Sep 29 2022 at 19:00)</a>:</h4>
<p>You use <code>fun</code> to create functions/foralls/implications</p>



<a name="301511608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301511608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301511608">(Sep 29 2022 at 19:01)</a>:</h4>
<p>So, just using the type, you know that your <code>fun</code> has to look like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="o">(</span><span class="n">hpq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">...</span> <span class="n">something</span> <span class="n">of</span> <span class="n">type</span> <span class="n">q</span> <span class="n">x</span> <span class="bp">...</span>
</code></pre></div>



<a name="301511718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301511718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301511718">(Sep 29 2022 at 19:02)</a>:</h4>
<p>You're allowed to drop the type from the forall syntax if it can be inferred.</p>



<a name="301511776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301511776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301511776">(Sep 29 2022 at 19:02)</a>:</h4>
<p><code>∀ x, p x</code> and <code>∀ (x : α), p x</code> are exactly the same in this context.</p>



<a name="301511858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301511858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301511858">(Sep 29 2022 at 19:02)</a>:</h4>
<p>The <code>α</code> itself is not being quantified, and the inference might be why you're feeling like you want to include <code>α</code> as an extra argument to your functions.</p>



<a name="301512589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301512589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301512589">(Sep 29 2022 at 19:06)</a>:</h4>
<p>Just to give one more example: if <code>p q : Prop</code>, then <code>∀ (h : p), q</code> and <code>p → q</code> are exactly the same, since <code>q</code> does not syntactically depend on <code>h</code>.</p>



<a name="301513893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301513893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301513893">(Sep 29 2022 at 19:15)</a>:</h4>
<p>Anyway, I hope this helps. I believe you mentioned you were familiar with Ocaml and Haskell, so the angle I'm going for is "<code>fun</code> is an anonymous lambda, forall/implication are fancy function types, and you just need to get the correct number of arguments with the right types."</p>



<a name="301514598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301514598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301514598">(Sep 29 2022 at 19:19)</a>:</h4>
<p>(A hint: be sure to take a look at the goal view in your editor to see what the actual types are after they've been elaborated. Here, using Lean 3, I see that the example's goal is <code>(∀ (x : α), p x → q x) → (∀ (x : α), p x) → ∀ (x : α), q x</code> when pretty printed. This can be useful in other situations when Lean inserts additional arguments for you, for example in the <code>∀ x ∈ s, p x</code> construct.)</p>



<a name="301519138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301519138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301519138">(Sep 29 2022 at 19:47)</a>:</h4>
<p>If I drop the <code>{y: α}</code> I get </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">application</span> <span class="n">type</span> <span class="n">mismatch</span>
  <span class="n">p</span> <span class="n">y</span>
<span class="n">argument</span>
  <span class="n">y</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span>
</code></pre></div>



<a name="301521586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301521586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301521586">(Sep 29 2022 at 20:01)</a>:</h4>
<p>Since we've defined <code>variable (α : Type) (p q : α → Prop)</code>, the general flow of going from "for all x, IsHuman x implies IsMortal x" implies "for all x IsHuman x" implies "for all x Is Mortal X" which is what the types want.</p>
<p>But as I follow the goals, unless I get the invocation just so, the quantifiers are all messed up,  As an example,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=&gt;</span>
      <span class="k">fun</span> <span class="o">{</span><span class="n">y</span><span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hpy</span><span class="o">:</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">h</span> <span class="n">y</span><span class="o">)</span> <span class="n">hpy</span>
</code></pre></div>
<p>leads to this error, which doesn't make any sense to me</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span>
  <span class="n">h</span> <span class="n">y</span> <span class="n">hpy</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">q</span> <span class="n">y</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">q</span> <span class="n">hpy</span> <span class="o">:</span> <span class="kt">Prop</span>
</code></pre></div>



<a name="301522178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301522178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301522178">(Sep 29 2022 at 20:05)</a>:</h4>
<p>Does this not work?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=&gt;</span>
      <span class="k">fun</span> <span class="o">(</span><span class="n">hpy</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span><span class="n">y</span><span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">h</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">hpy</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>



<a name="301522803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301522803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301522803">(Sep 29 2022 at 20:08)</a>:</h4>
<p><span class="user-mention" data-user-id="542196">@Arien Malec</span> Given that the second argument is supposed to be of type <code>∀ x, p x</code>, why are you writing that second <code>fun</code> with its first argument having type <code>α</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=&gt;</span>
      <span class="k">fun</span> <span class="o">{</span><span class="n">y</span><span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hpy</span><span class="o">:</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">h</span> <span class="n">y</span><span class="o">)</span> <span class="n">hpy</span>
</code></pre></div>
<p>Please let me know what about what I wrote doesn't make sense.</p>



<a name="301523001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301523001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301523001">(Sep 29 2022 at 20:09)</a>:</h4>
<p><span class="user-mention" data-user-id="439483">@Andrew Yang</span> Just note that the <code>{y: α}</code> "should" be <code>(y: α)</code> since the expected type has an explicit argument rather than an implicit one. It doesn't matter in this case.</p>



<a name="301523243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301523243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301523243">(Sep 29 2022 at 20:11)</a>:</h4>
<p><span class="user-mention" data-user-id="542196">@Arien Malec</span> Just to check, are you familiar with how <code>fun {y: α} (hpy: p y) =&gt; (h y) hpy</code> is equivalent to <code>fun {y: α} =&gt; fun (hpy: p y) =&gt; (h y) hpy</code>?</p>



<a name="301523461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301523461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301523461">(Sep 29 2022 at 20:12)</a>:</h4>
<p>yep, that's not the issue here, it's how quantifiers interact.</p>
<p>And in particular why we have to have a <code>(y: α)</code> in the last place here.</p>



<a name="301523535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301523535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301523535">(Sep 29 2022 at 20:13)</a>:</h4>
<p>It's because it corresponds to the argument for <code>∀ x, q x</code></p>



<a name="301523711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301523711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301523711">(Sep 29 2022 at 20:14)</a>:</h4>
<p>I'm curious what you're seeing as "interacting" quantifiers</p>



<a name="301523906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301523906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301523906">(Sep 29 2022 at 20:15)</a>:</h4>
<p>Here's another hint. The following types are completely equivalent:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">hpq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span>
</code></pre></div>



<a name="301524517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301524517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301524517">(Sep 29 2022 at 20:19)</a>:</h4>
<p>So what's perhaps misleading me is that in the previous chapter of TPIL, I get to do things like </p>
<p><code>theorem and_dist_right {p q r: Prop} : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := sorry</code> and my types there are implicit parameters, but now I have a very explicit <code>x</code> that appears in the argument list that appears to be the key to making all the types work.</p>
<p>Again, not confused by the currying here, but probably by the way <code>p</code> is defined here as opposed to the way <code>p</code> is defined in the previous chapter.</p>



<a name="301524584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301524584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301524584">(Sep 29 2022 at 20:19)</a>:</h4>
<p>Tactics are also useful for poking around and seeing what's what. The <code>intros</code> tactic is for automatically creating <code>fun</code>s:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span>
  <span class="n">intros</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  α : Type</span>
<span class="cm">  p q : α → Prop</span>
<span class="cm">   : ∀ (x : α), p x → q x    -- the first argument</span>
<span class="cm">   : ∀ (x : α), p x          -- the second argument</span>
<span class="cm">  x✝ : α                     -- the third argument</span>
<span class="cm">  ⊢ q x✝                     -- the goal (q x)</span>
<span class="cm">  -/</span>
</code></pre></div>



<a name="301524688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301524688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301524688">(Sep 29 2022 at 20:20)</a>:</h4>
<p>From NNG, this would be very grokable in tactics land.</p>



<a name="301524789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301524789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301524789">(Sep 29 2022 at 20:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="542196">Arien Malec</span> <a href="#narrow/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F/near/301524517">said</a>:</p>
<blockquote>
<p><code>theorem and_dist_right {p q r: Prop} : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := sorry</code> </p>
</blockquote>
<p>With this example, <code>p</code>, <code>q</code>, and <code>r</code> are automatically introduces (no need for <code>fun</code>) since they come "before the colon".</p>



<a name="301524839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301524839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301524839">(Sep 29 2022 at 20:21)</a>:</h4>
<p>It's not about implicit/explicit arguments, just to clarify</p>



<a name="301524897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301524897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301524897">(Sep 29 2022 at 20:21)</a>:</h4>
<p>since <code>p</code> is now defined as <code>α → Prop</code> rather than <code>Prop</code> there's an extra argument hidden here it seems?</p>



<a name="301525174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301525174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301525174">(Sep 29 2022 at 20:23)</a>:</h4>
<p>Also, by the way, if those <code>p</code>, <code>q</code>, and <code>r</code> came "after the colon" you'd start like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">and_dist_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="n">p</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="bp">∨</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">fun</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="bp">∨</span> <span class="n">r</span><span class="o">))</span> <span class="bp">=&gt;</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="301525368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301525368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301525368">(Sep 29 2022 at 20:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="542196">Arien Malec</span> <a href="#narrow/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F/near/301524897">said</a>:</p>
<blockquote>
<p>since <code>p</code> is now defined as <code>α → Prop</code> rather than <code>Prop</code> there's an extra argument hidden here it seems?</p>
</blockquote>
<p>No, there's nothing special about <code>α → Prop</code>. That just means <code>p</code> needs to take an argument.</p>



<a name="301525447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301525447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301525447">(Sep 29 2022 at 20:25)</a>:</h4>
<p>If you want this new example to look analogous to <code>and_dist_right</code>, it could easily be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="301525599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301525599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301525599">(Sep 29 2022 at 20:26)</a>:</h4>
<p>You could even write this as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hpq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="n">x</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>
<p>if you want to avoid needing to write the <code>fun</code>s yourself.</p>



<a name="301525759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301525759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301525759">(Sep 29 2022 at 20:27)</a>:</h4>
<p>Notice it's <code>hp : ∀ x, p x</code>. This <code>hp</code> is a function that takes any arbitrary <code>x : α</code> and returns a proof of <code>p x</code> for that <code>x</code>.</p>



<a name="301525902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301525902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301525902">(Sep 29 2022 at 20:28)</a>:</h4>
<p>This is different from taking arguments <code>{y: α} (hpy: p y)</code>, which is saying "here is some specific <code>y : α</code> for which <code>p y</code> is true"</p>



<a name="301526161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301526161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301526161">(Sep 29 2022 at 20:29)</a>:</h4>
<p>Right, again that's the lightbulb moment here -- since we've defined <code>p</code> as <code>α → Prop</code> I need to give it something of type <code>α</code>, which is why I need a <code>(y : α)</code> in the last parameter.</p>



<a name="301526403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301526403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301526403">(Sep 29 2022 at 20:31)</a>:</h4>
<p>No, it's so much simpler than that, it's because the end of the type is <code>∀ (x : α), q x</code>, so the last argument is this <code>x : α</code> from the quantifier</p>



<a name="301526458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301526458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301526458">(Sep 29 2022 at 20:31)</a>:</h4>
<p>Lean doesn't care about the fact that there's a <code>p</code> that's <code>α → Prop</code></p>



<a name="301526708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301526708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301526708">(Sep 29 2022 at 20:33)</a>:</h4>
<p>Just so we're on the same page, you're reading these forall quantifications as being the same sort of thing as an implication, right?</p>



<a name="301526761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301526761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301526761">(Sep 29 2022 at 20:33)</a>:</h4>
<p>(they're both "pi types" under the hood, just pretty printed differently)</p>



<a name="301526779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301526779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301526779">(Sep 29 2022 at 20:33)</a>:</h4>
<p><code>q</code> is defined the same way, which is why <code>q x</code> even makes sense, right? <code>q x</code> is a <code>Prop</code> because <code>q</code> is <code>α → Prop</code></p>
<p>I thought all along that my problem was with the quantifiers, but it was with not having anything of type <code>α </code> to apply this to.</p>
<p>Now I *still don't understand why Lean was telling me</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span>
  <span class="n">h</span> <span class="n">y</span> <span class="n">hpy</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">q</span> <span class="n">y</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">q</span> <span class="n">hpy</span> <span class="o">:</span> <span class="kt">Prop</span>
</code></pre></div>



<a name="301526973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301526973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301526973">(Sep 29 2022 at 20:34)</a>:</h4>
<p>To repeat back, <code>∀ (x : α), q x</code> already is an implication, or only works when <code>q</code> is <code>Type -&gt; Prop</code>?</p>



<a name="301527164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301527164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301527164">(Sep 29 2022 at 20:36)</a>:</h4>
<p>It is already the same sort of thing as an implication. A function that takes something of type alpha (call it <code>x</code>) and returns something of type <code>q x</code>.</p>



<a name="301527187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301527187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301527187">(Sep 29 2022 at 20:36)</a>:</h4>
<p>Here's an exercise for you:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">q</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="301527194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301527194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301527194">(Sep 29 2022 at 20:36)</a>:</h4>
<p>Or quoting from the book, in language I didn't understand "If <code>p</code> is any expression, <code>∀ x : α, p</code> is nothing more than alternative notation for <code>(x : α) → p</code>, with the idea that the former is more natural than the latter in cases where p is a proposition. "</p>



<a name="301527412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301527412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301527412">(Sep 29 2022 at 20:37)</a>:</h4>
<p>The <code>(x : α) → foo</code> notation is equivalent to <code>∀ x : α, foo</code>, where <code>foo</code> can be any expression involving (or not involving) <code>x</code>. If <code>foo</code> does not involve <code>x</code>, then the notation is also equivalent to <code>α → foo</code>.</p>



<a name="301527967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301527967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301527967">(Sep 29 2022 at 20:40)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">q</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="o">(</span><span class="n">h₁</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="o">(</span><span class="n">h₂</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">h₁</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>



<a name="301528127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301528127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301528127">(Sep 29 2022 at 20:41)</a>:</h4>
<p>The point of this exercise is that there is absolutely no difference between it and your other one for how you prove it.</p>



<a name="301528380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301528380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301528380">(Sep 29 2022 at 20:42)</a>:</h4>
<p>For that last error message you were getting, I'm pretty sure it's telling you something irrelevant because you didn't have the <code>fun</code>s structured correctly</p>



<a name="301528420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/More%20documentation%20on%20the%20syntax%20of%20quantifiers%3F/near/301528420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/More.20documentation.20on.20the.20syntax.20of.20quantifiers.3F.html#301528420">(Sep 29 2022 at 20:43)</a>:</h4>
<p>yep, sartori achieved. Thanks!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
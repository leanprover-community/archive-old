---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/a.20concrete.20group.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html">a concrete group</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="183718581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183718581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183718581">(Dec 18 2019 at 04:08)</a>:</h4>
<p>I'd like to define a group via its presentation, prove that it's finite, and then compute its character table. I read some of the files in mathlib/algebra/group but still don't really know where to start. Could anyone point me to an example that might be instructive?</p>



<a name="183718815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183718815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183718815">(Dec 18 2019 at 04:15)</a>:</h4>
<p>what's the group?</p>



<a name="183718817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183718817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183718817">(Dec 18 2019 at 04:15)</a>:</h4>
<p>I don't really think it's best to define a group via its presentation</p>



<a name="183718820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183718820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183718820">(Dec 18 2019 at 04:15)</a>:</h4>
<p>rather than going from large to small, we go from small to large</p>



<a name="183721066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183721066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183721066">(Dec 18 2019 at 05:08)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> But we'll need to be able to deal with this, right? Presentations are pervasive in maths</p>



<a name="183721087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183721087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183721087">(Dec 18 2019 at 05:09)</a>:</h4>
<p><span class="user-mention" data-user-id="252300">@Jalex Stark</span> In mathlib, you can find free groups. And subgroups. And quotients. That should allow you to build your group. And didn't a student of Scott even do finitely presented groups?</p>



<a name="183721088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183721088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183721088">(Dec 18 2019 at 05:09)</a>:</h4>
<p>I guess groupprops would be a good source for proofs using presentations</p>



<a name="183721089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183721089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183721089">(Dec 18 2019 at 05:09)</a>:</h4>
<p>It might be in mathlib already</p>



<a name="183721134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183721134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183721134">(Dec 18 2019 at 05:10)</a>:</h4>
<p>do we have normal closure?</p>



<a name="183721138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183721138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183721138">(Dec 18 2019 at 05:10)</a>:</h4>
<p>Yep</p>



<a name="183721148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183721148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183721148">(Dec 18 2019 at 05:10)</a>:</h4>
<p><span class="user-mention" data-user-id="252300">@Jalex Stark</span> You probably want to look at <a href="https://github.com/leanprover-community/mathlib/blob/0eea0d9fc53bd037da13abdf5d95a711cbd0c288/src/group_theory/presented_group.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/0eea0d9fc53bd037da13abdf5d95a711cbd0c288/src/group_theory/presented_group.lean">https://github.com/leanprover-community/mathlib/blob/0eea0d9fc53bd037da13abdf5d95a711cbd0c288/src/group_theory/presented_group.lean</a></p>



<a name="183721161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183721161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183721161">(Dec 18 2019 at 05:11)</a>:</h4>
<p>However, be warned that proving that this thing is finite is probably going to be quite awkard</p>



<a name="183721204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183721204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183721204">(Dec 18 2019 at 05:12)</a>:</h4>
<p><a href="https://groupprops.subwiki.org/wiki/Equivalence_of_presentations_of_dicyclic_group" target="_blank" title="https://groupprops.subwiki.org/wiki/Equivalence_of_presentations_of_dicyclic_group">https://groupprops.subwiki.org/wiki/Equivalence_of_presentations_of_dicyclic_group</a></p>



<a name="183721206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183721206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183721206">(Dec 18 2019 at 05:12)</a>:</h4>
<p>maybe we would want to be able to do something like this</p>



<a name="183721374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183721374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183721374">(Dec 18 2019 at 05:17)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Certainly. It would be great to have all sorts of stuff like that.</p>



<a name="183727207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183727207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183727207">(Dec 18 2019 at 07:52)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> You probably want to look at <a href="https://github.com/leanprover-community/mathlib/blob/0eea0d9fc53bd037da13abdf5d95a711cbd0c288/src/group_theory/presented_group.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/0eea0d9fc53bd037da13abdf5d95a711cbd0c288/src/group_theory/presented_group.lean">https://github.com/leanprover-community/mathlib/blob/0eea0d9fc53bd037da13abdf5d95a711cbd0c288/src/group_theory/presented_group.lean</a></p>
</blockquote>
<p>I'll work on understanding this file (on my first pass, I have a mathematical understanding but I don't yet have a good guess of how to translate a group presentation like &lt; a , b | a^2 = 1, abab\inv = 1&gt; into code)</p>



<a name="183727283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183727283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183727283">(Dec 18 2019 at 07:53)</a>:</h4>
<blockquote>
<p>what's the group?</p>
</blockquote>
<p>The groups I'm interested are described here <a href="https://en.wikipedia.org/wiki/Extra_special_group" target="_blank" title="https://en.wikipedia.org/wiki/Extra_special_group">https://en.wikipedia.org/wiki/Extra_special_group</a><br>
quantum information people call them the pauli group on n qudits</p>



<a name="183727434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183727434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183727434">(Dec 18 2019 at 07:56)</a>:</h4>
<blockquote>
<p>However, be warned that proving that this thing is finite is probably going to be quite awkard</p>
</blockquote>
<p>The proof I have in mind is to define a canonical form, that is a list of words in the group together with a proof that any word in the group is equal to one of the canonical ones<br>
Do you mean awkward like, I will have to understand details about how lean represents finite lists?</p>



<a name="183728055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183728055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183728055">(Dec 18 2019 at 08:08)</a>:</h4>
<p><span class="user-mention" data-user-id="252300">@Jalex Stark</span> Cool, I think it's really good if people work on examples. But usually it's not something that Lean excels at. Let's break down a bit what you have to do. We've got the following definition:</p>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm">- Given a set of relations, rels, over a type α, presented_group constructs the group with</span>
<span class="cm">generators α and relations rels as a quotient of free_group α.-/</span>
<span class="n">def</span> <span class="n">presented_group</span> <span class="o">(</span><span class="n">rels</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="n">quotient_group</span><span class="bp">.</span><span class="n">quotient</span> <span class="err">$</span> <span class="n">group</span><span class="bp">.</span><span class="n">normal_closure</span> <span class="n">rels</span>
</pre></div>



<a name="183728144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183728144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183728144">(Dec 18 2019 at 08:10)</a>:</h4>
<p>You gave as example, a group generated by two elements <code>a</code> and <code>b</code>. So you need a type with two elements. You could choose <code>bool</code> or <code>fin 2</code>, or roll your own type:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">pauli_two_gens</span> <span class="bp">|</span> <span class="n">a</span> <span class="bp">|</span> <span class="n">b</span>
</pre></div>



<a name="183728245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183728245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183728245">(Dec 18 2019 at 08:12)</a>:</h4>
<p>After that, you need the relations. So you do something like</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">pauli_two_gens</span>

<span class="n">def</span> <span class="n">pauli_two_rels</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="n">pauli_two_gens</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">x</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">a</span><span class="err">^</span><span class="mi">2</span> <span class="err">\</span><span class="n">or</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="err">\</span><span class="bp">-</span><span class="mi">1</span> <span class="o">}</span>
</pre></div>



<a name="183728255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183728255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183728255">(Dec 18 2019 at 08:12)</a>:</h4>
<p>Once you have those, you should be able to write</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">pauli_two</span> <span class="o">:=</span> <span class="n">presented_group</span> <span class="n">pauli_two_rels</span>
</pre></div>



<a name="183728295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183728295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183728295">(Dec 18 2019 at 08:13)</a>:</h4>
<p>Wow, thanks! I will play with your definitions when I get home from work.</p>



<a name="183728369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183728369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183728369">(Dec 18 2019 at 08:15)</a>:</h4>
<p>Note that I didn't test any of these in Lean. So they might be full of hidden mistakes</p>



<a name="183728950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183728950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183728950">(Dec 18 2019 at 08:24)</a>:</h4>
<p>I did a little testing earlier and the following works</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">presented_group</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span>

<span class="n">def</span> <span class="n">r</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">free_group</span><span class="bp">.</span><span class="n">of</span> <span class="mi">0</span>
<span class="n">def</span> <span class="n">s</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">free_group</span><span class="bp">.</span><span class="n">of</span> <span class="mi">1</span>

<span class="c1">--check everything makes sense so far</span>
<span class="bp">#</span><span class="kn">eval</span> <span class="n">to_bool</span> <span class="o">(</span><span class="n">r</span> <span class="bp">*</span> <span class="o">(</span><span class="n">s</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">-- if you use pauli_two_gens like Johan you need to tell lean that this is decidable</span>
<span class="bp">#</span><span class="kn">eval</span> <span class="n">to_bool</span> <span class="o">(</span><span class="n">r</span> <span class="bp">*</span> <span class="o">(</span><span class="n">r</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>

<span class="c1">-- either one of the following ways works, but lean does not automatically work out what 0 or 1 are inside the free group so we use r and s</span>
<span class="n">def</span> <span class="n">my_rels</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">x</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">r</span><span class="err">^</span><span class="mi">2</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">s</span> <span class="bp">*</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">s</span><span class="bp">⁻¹</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">my_rels2</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">r</span><span class="err">^</span><span class="mi">2</span><span class="o">,</span> <span class="n">r</span><span class="bp">*</span><span class="n">s</span><span class="bp">*</span><span class="n">r</span><span class="bp">*</span><span class="n">s</span><span class="bp">⁻¹</span><span class="o">}</span>

<span class="n">def</span> <span class="n">pauli_two</span> <span class="o">:=</span> <span class="n">presented_group</span> <span class="n">my_rels2</span> <span class="c1">-- or my_rels</span>
</pre></div>



<a name="183728958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183728958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183728958">(Dec 18 2019 at 08:24)</a>:</h4>
<p>I would try defining your "canonical forms" as a type in its own right, then construct the group operation and prove that it is generated the way you expect</p>



<a name="183728995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183728995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183728995">(Dec 18 2019 at 08:25)</a>:</h4>
<p>You will have to do essentially all this work anyway in order to prove that the free group modulo relations is in fact finite</p>



<a name="183729217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183729217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183729217">(Dec 18 2019 at 08:29)</a>:</h4>
<p>Whut? How does this work:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">my_rels2</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">r</span><span class="err">^</span><span class="mi">2</span><span class="o">,</span> <span class="n">r</span><span class="bp">*</span><span class="n">s</span><span class="bp">*</span><span class="n">r</span><span class="bp">*</span><span class="n">s</span><span class="bp">⁻¹</span><span class="o">}</span>
</pre></div>


<p>Has this syntax always been available in lean?</p>



<a name="183729305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183729305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183729305">(Dec 18 2019 at 08:30)</a>:</h4>
<p>I guess it is, but I just never really realized...</p>



<a name="183729327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183729327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183729327">(Dec 18 2019 at 08:30)</a>:</h4>
<p>Always used the <code>{x | x = _ \or _ \or _}</code> stuff</p>



<a name="183729543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183729543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183729543">(Dec 18 2019 at 08:34)</a>:</h4>
<p>I believe it unfolds to something worse than your option ;-)</p>



<a name="183729769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183729769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183729769">(Dec 18 2019 at 08:38)</a>:</h4>
<p><code>example  (x : ℕ) : x ∈ ({4,6} : set ℕ) ↔ x = 6 ∨ x = 4 ∨ false := iff.rfl</code></p>



<a name="183729799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183729799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183729799">(Dec 18 2019 at 08:39)</a>:</h4>
<blockquote>
<p>I would try defining your "canonical forms" as a type in its own right, then construct the group operation and prove that it is generated the way you expect</p>
</blockquote>
<p>Proving associativity will be a nightmare like this.</p>



<a name="183729887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/183729887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#183729887">(Dec 18 2019 at 08:40)</a>:</h4>
<p>I don't see why, provided you set up the operation right</p>



<a name="184010176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010176">(Dec 21 2019 at 13:06)</a>:</h4>
<p>Using the definitions that Alex J Best gave, it seems like the type system has less of an understanding of the claim "pauli_two is a group" than the claim "free_group (fin 2)" is a group. </p>
<p>Lean knows how to deal with <br>
theorem order_not_two : ∀ x : (free_group (fin 3)), x≠ 1 → x * x ≠ 1</p>
<p>but not<br>
theorem order_two : ∀ x : pauli_two, x * x = 1<br>
in which case it says it can't find has_mul or has_one for pauli_two</p>



<a name="184010370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010370">(Dec 21 2019 at 13:12)</a>:</h4>
<p>the presented_group file has this line<br>
instance (rels : set (free_group α)) : group (presented_group (rels)) :=<br>
quotient_group.group _</p>
<p>and I guess I expected it to have something like<br>
instance group : (presented_group rels)</p>



<a name="184010375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010375">(Dec 21 2019 at 13:12)</a>:</h4>
<p>Can you post the current working version of your code? The errors just mean that there is no term of tyoe <code>group G</code> for your group <code>G</code></p>



<a name="184010383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010383">(Dec 21 2019 at 13:13)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">presented_group</span>

<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span>

<span class="c1">-- open presented_group</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">def</span> <span class="n">J</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="n">free_group</span><span class="bp">.</span><span class="n">of</span> <span class="mi">0</span>
<span class="n">def</span> <span class="n">x</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="n">free_group</span><span class="bp">.</span><span class="n">of</span> <span class="mi">1</span>
<span class="n">def</span> <span class="n">z</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="n">free_group</span><span class="bp">.</span><span class="n">of</span> <span class="mi">2</span>

<span class="c1">--check everything makes sense so far</span>
<span class="bp">#</span><span class="kn">eval</span> <span class="n">to_bool</span> <span class="o">(</span><span class="n">z</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">-- if you use pauli_two_gens like Johan you need to tell lean that this is decidable</span>
<span class="bp">#</span><span class="kn">eval</span> <span class="n">to_bool</span> <span class="o">(</span><span class="n">J</span> <span class="bp">*</span> <span class="o">(</span><span class="n">J</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">def</span> <span class="n">my_rels2</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">J</span><span class="err">^</span><span class="mi">2</span><span class="o">,</span> <span class="n">x</span><span class="err">^</span><span class="mi">2</span><span class="o">,</span> <span class="n">z</span><span class="err">^</span><span class="mi">2</span><span class="o">,</span> <span class="n">J</span><span class="bp">*</span><span class="n">x</span><span class="bp">*</span><span class="n">z</span><span class="bp">*</span><span class="n">x</span><span class="bp">⁻¹*</span><span class="n">z</span><span class="bp">⁻¹</span><span class="o">}</span>

<span class="n">def</span> <span class="n">pauli_two</span> <span class="o">:=</span> <span class="n">presented_group</span> <span class="n">my_rels2</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">my_rels2</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">pauli_two</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">group</span> <span class="n">pauli_two</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">has_pow</span> <span class="o">(</span><span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">))</span> <span class="bp">ℕ</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">has_pow</span> <span class="o">(</span><span class="n">pauli_two</span><span class="o">)</span> <span class="bp">ℕ</span>

<span class="kn">open</span> <span class="n">free_group</span>

<span class="kn">theorem</span> <span class="n">order_not_two</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)),</span> <span class="n">x</span><span class="bp">≠</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">≠</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rintros</span>  <span class="bp">⟨</span> <span class="n">L</span><span class="bp">⟩</span> <span class="o">,</span>
<span class="n">induction</span> <span class="n">L</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">h</span><span class="o">,</span>
<span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">order_two</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">pauli_two</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">sorry</span>
</pre></div>



<a name="184010432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010432">(Dec 21 2019 at 13:14)</a>:</h4>
<p>Can you put it all in quotes so it displays properly?</p>



<a name="184010441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010441">(Dec 21 2019 at 13:15)</a>:</h4>
<p><code> ```lean </code> at the top</p>



<a name="184010444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010444">(Dec 21 2019 at 13:15)</a>:</h4>
<p>And <code> ``` </code> at the end</p>



<a name="184010604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010604">(Dec 21 2019 at 13:20)</a>:</h4>
<blockquote>
<p>there is no term of type group G for your group G</p>
</blockquote>
<p>If I construct such a term manually, how do I get the compiler to notice it when I'm writing statements about G?</p>



<a name="184010615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010615">(Dec 21 2019 at 13:21)</a>:</h4>
<p>which version of lean/mathlib are you using? Your proof of <code>order_not_two</code> doesn't compile for me</p>



<a name="184010660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010660">(Dec 21 2019 at 13:22)</a>:</h4>
<p>oh, sorry, it doesn't compile for me either</p>



<a name="184010663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010663">(Dec 21 2019 at 13:22)</a>:</h4>
<p>it had been a sorry and I  had been trying to prove it and forgot to revert it before posting</p>



<a name="184010666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010666">(Dec 21 2019 at 13:22)</a>:</h4>
<p><code>instance : group pauli_two := by unfold pauli_two; apply_instance</code></p>



<a name="184010667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010667">(Dec 21 2019 at 13:22)</a>:</h4>
<p>is what you're missing.</p>



<a name="184010674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010674">(Dec 21 2019 at 13:23)</a>:</h4>
<p>or alternatively</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">group</span><span class="o">]</span>
<span class="n">def</span> <span class="n">pauli_two</span> <span class="o">:=</span> <span class="n">presented_group</span> <span class="n">my_rels2</span>
</pre></div>



<a name="184010721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010721">(Dec 21 2019 at 13:25)</a>:</h4>
<p>The type class inference system handles the job of coming up with e.g. what notation means for a given type. Your definition of <code>pauli_two</code> is just a definition of a new type -- if you hover over <code>presented_group</code> then you'll see that it just returns something of type <code>Type</code>.</p>



<a name="184010731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010731">(Dec 21 2019 at 13:25)</a>:</h4>
<p>that @derive clause makes a lot of sense to me coming from programming in ocaml</p>



<a name="184010735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010735">(Dec 21 2019 at 13:25)</a>:</h4>
<p>OK great, it's brand spanking new in Lean.</p>



<a name="184010778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010778">(Dec 21 2019 at 13:26)</a>:</h4>
<p>would it make sense for presented_group to return a type decorated with a group instance?</p>



<a name="184010785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010785">(Dec 21 2019 at 13:26)</a>:</h4>
<p>I am not a computer scientist, all I can say is that because groups are "partially bundled" this is what we have to do.</p>



<a name="184010797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010797">(Dec 21 2019 at 13:27)</a>:</h4>
<p>Another alternative is that <code>presented_group</code> returns a term of type <code>Group</code> where <code>Group</code> is the category of groups.</p>



<a name="184010800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010800">(Dec 21 2019 at 13:27)</a>:</h4>
<p>ok, I think I can accept this as a fact of life.</p>



<a name="184010802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010802">(Dec 21 2019 at 13:27)</a>:</h4>
<p>If you do it that way then all your maps between groups will be morphisms in the category and you'll lose some of the cool advantages of functional programming because they won't be functions any more. Or something.</p>



<a name="184010842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010842">(Dec 21 2019 at 13:28)</a>:</h4>
<p>In short, this is a design decision</p>



<a name="184010847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010847">(Dec 21 2019 at 13:28)</a>:</h4>
<p>and the less I say about it the better ;-) because I know nothing about the pros and cons. There is a section about this in the mathlib paper.</p>



<a name="184010861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010861">(Dec 21 2019 at 13:29)</a>:</h4>
<p>Note that <code>theorem order_two : ∀ x : presented_group my_rels2, x * x = 1 := by sorry</code> works fine, because the typeclass system knows that <code>presented_group R</code> is a group.</p>



<a name="184010922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184010922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184010922">(Dec 21 2019 at 13:31)</a>:</h4>
<p>section 4.1.1 of <a href="https://leanprover-community.github.io/papers/mathlib-paper.pdf" target="_blank" title="https://leanprover-community.github.io/papers/mathlib-paper.pdf">the mathlib paper</a> talks about the design decisions.</p>



<a name="184011026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184011026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184011026">(Dec 21 2019 at 13:34)</a>:</h4>
<p>i guess the term <code>lean ∀ x : presented_group my_rels2, x * x = 1</code> can be turned into the term<code>lean ∀ x:pauli_two, x * x = 1</code> by one application of definitional equality, but you can't make that substitution before the compiler has made up its mind about whether the second term makes sense</p>



<a name="184012753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184012753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184012753">(Dec 21 2019 at 14:32)</a>:</h4>
<p>I don't know how to access a statment like "if w \in rels, then w = 1 in presented_group rels". I also don't know how to access the quotient map from my free group to my presented group. There is a lemma in the presented_groups file that looks awfully relevant but I can't figure out how to make any interesting terms with it. </p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">to_group_eq_one_of_mem_closure</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">group</span><span class="bp">.</span><span class="n">normal_closure</span> <span class="n">rels</span><span class="o">,</span> <span class="n">F</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span> <span class="n">w</span><span class="o">,</span> <span class="o">(</span><span class="n">is_group_hom</span><span class="bp">.</span><span class="n">mem_ker</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>  <span class="o">((</span><span class="n">closure_rels_subset_ker</span> <span class="n">h</span><span class="o">)</span> <span class="n">w</span><span class="o">)</span>
</pre></div>


<p>(I would love if the answer to my question was "read X tutorial or Y book chapter more closely to understand Z fundamental concept that you clearly lack understanding of")</p>
<div class="codehilite"><pre><span></span><span class="c1">-- goal: define the two qubit pauli group</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">presented_group</span>

<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span>

<span class="kn">open</span> <span class="n">presented_group</span>

<span class="n">def</span> <span class="n">gen_J</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="n">free_group</span><span class="bp">.</span><span class="n">of</span> <span class="mi">0</span>
<span class="n">def</span> <span class="n">gen_x</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="n">free_group</span><span class="bp">.</span><span class="n">of</span> <span class="mi">1</span>
<span class="n">def</span> <span class="n">gen_z</span> <span class="o">:</span> <span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="n">free_group</span><span class="bp">.</span><span class="n">of</span> <span class="mi">2</span>

<span class="n">def</span> <span class="n">my_rels</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">gen_J</span><span class="err">^</span><span class="mi">2</span><span class="o">,</span> <span class="n">gen_x</span><span class="err">^</span><span class="mi">2</span><span class="o">,</span> <span class="n">gen_z</span><span class="err">^</span><span class="mi">2</span><span class="o">,</span> <span class="n">gen_J</span><span class="bp">*</span><span class="n">gen_x</span><span class="bp">*</span><span class="n">gen_z</span><span class="bp">*</span><span class="n">gen_x</span><span class="bp">⁻¹*</span><span class="n">gen_z</span><span class="bp">⁻¹</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">group</span><span class="o">]</span>
<span class="n">def</span> <span class="n">pauli_two</span> <span class="o">:=</span> <span class="n">presented_group</span> <span class="n">my_rels</span>

<span class="n">def</span> <span class="n">J</span> <span class="o">:=</span> <span class="o">((</span><span class="n">presented_group</span><span class="bp">.</span><span class="n">of</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">pauli_two</span><span class="o">)</span>
<span class="n">def</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">((</span><span class="n">presented_group</span><span class="bp">.</span><span class="n">of</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">pauli_two</span><span class="o">)</span>
<span class="n">def</span> <span class="n">z</span> <span class="o">:=</span> <span class="o">((</span><span class="n">presented_group</span><span class="bp">.</span><span class="n">of</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">pauli_two</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">rel1</span> <span class="o">:</span> <span class="n">J</span><span class="err">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>



<a name="184013732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184013732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184013732">(Dec 21 2019 at 15:02)</a>:</h4>
<p>Its possible a lot of the lemmas you are interested in are actually just lemmas about group quotients, and so in <code>group_theory/quotient_group.lean</code> rather than this file. In particular the one you mentioned <code>to_group_eq_one_of_mem_closure</code> is a bit more complex, it has the additional assumptions defined above in that file</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">rels</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="n">α</span><span class="o">)}</span>

<span class="n">local</span> <span class="kn">notation</span> <span class="bp">`</span><span class="n">F</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">free_group</span><span class="bp">.</span><span class="n">to_group</span> <span class="n">f</span>

<span class="kn">variable</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="err">∈</span> <span class="n">rels</span><span class="o">,</span> <span class="n">F</span> <span class="n">r</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>


<p>so its to do with when you have a map from your generating letters into some other group such that rels end up in the kernel then the universal property of a presented group gives you a map to the other group etcetc..</p>



<a name="184014211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184014211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184014211">(Dec 21 2019 at 15:16)</a>:</h4>
<p>Thanks, Alex! I'm currently convinced that if I read the quotient_group file closely enough, I will learn how to access the quotient map</p>



<a name="184015083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184015083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184015083">(Dec 21 2019 at 15:44)</a>:</h4>
<p>Yeah I think this area (presented_group) needs many more helper lemmas and things, I did it one way, there may be an easier one but I couldn't find it yet:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">rel1</span> <span class="o">:</span> <span class="n">J</span><span class="err">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">rw</span> <span class="n">J</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">presented_group</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span> <span class="n">gen_J</span><span class="o">,</span>
    <span class="n">change</span> <span class="o">((</span><span class="n">quotient_group</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">gen_J</span> <span class="err">^</span><span class="mi">2</span><span class="o">))</span> <span class="o">:</span> <span class="n">quotient_group</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">(</span><span class="n">group</span><span class="bp">.</span><span class="n">normal_closure</span> <span class="n">my_rels</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span> <span class="n">is_group_hom</span><span class="bp">.</span><span class="n">mem_ker</span> <span class="o">(</span><span class="n">quotient_group</span><span class="bp">.</span><span class="n">mk</span><span class="o">),</span>
    <span class="n">rw</span> <span class="n">quotient_group</span><span class="bp">.</span><span class="n">ker_mk</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_of_subset_of_mem</span> <span class="o">(</span><span class="n">group</span><span class="bp">.</span><span class="n">subset_normal_closure</span><span class="o">),</span>
    <span class="n">rw</span> <span class="n">my_rels</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>



<a name="184018270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/a%20concrete%20group/near/184018270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/a.20concrete.20group.html#184018270">(Dec 21 2019 at 17:21)</a>:</h4>
<p>Probably a nicer refactor is</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">mk</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">rels</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="n">α</span><span class="o">)}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">presented_group</span> <span class="n">rels</span> <span class="o">:=</span>
<span class="n">quotient_group</span><span class="bp">.</span><span class="n">mk</span> <span class="n">x</span>

<span class="kn">lemma</span> <span class="n">mk_eq_one_of_mem_rels</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">rels</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_group</span> <span class="n">α</span><span class="o">)}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">rels</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">mk</span> <span class="n">x</span> <span class="o">:</span> <span class="n">presented_group</span> <span class="n">rels</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">refine</span> <span class="o">(</span><span class="n">is_group_hom</span><span class="bp">.</span><span class="n">mem_ker</span> <span class="o">(</span><span class="n">quotient_group</span><span class="bp">.</span><span class="n">mk</span><span class="o">))</span><span class="bp">.</span><span class="n">mp</span> <span class="bp">_</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">quotient_group</span><span class="bp">.</span><span class="n">ker_mk</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_of_subset_of_mem</span> <span class="o">(</span><span class="n">group</span><span class="bp">.</span><span class="n">subset_normal_closure</span><span class="o">)</span> <span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">rel1</span> <span class="o">:</span> <span class="n">J</span><span class="err">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">change</span> <span class="n">mk</span> <span class="o">(</span><span class="n">gen_J</span> <span class="err">^</span><span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">mk_eq_one_of_mem_rels</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">my_rels</span><span class="o">],</span>
<span class="kn">end</span>
</pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
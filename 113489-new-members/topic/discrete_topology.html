---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/discrete_topology.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html">discrete_topology</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="218922522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218922522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218922522">(Dec 05 2020 at 07:00)</a>:</h4>
<p>Dear All,</p>
<p>while playing around with <a href="https://github.com/leanprover-community/mathlib/issues/4301">#4301</a>, following the thread, I decided to learn some topology in Lean.  Below is my attempt to prove that the roots of a polynomial with real coefficients are a discrete topological space.</p>
<p>I am somewhat puzzled that I was not asked by Lean to assume that the polynomial is non-zero, though.  Therefore, I learned that <code>0.roots</code> is defined to be <code>∅</code>.  Should this have been <code>univ</code> instead?</p>
<p>Anyway, any suggestions on how to streamline the proofs below would be more than welcome!  I particularly struggled with <code>discrete_of_finite</code>.  I suspect that the largest issue is that I do not understand well all the coercions and I had the impression that I had forced myself in a co[e]rner...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.calculus.mean_value</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">open</span> <span class="n">polynomial</span> <span class="n">set</span>

<span class="kd">lemma</span> <span class="n">discrete_of_forall_open</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">,</span> <span class="n">is_open</span> <span class="n">s</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">discrete_topology</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">sep</span><span class="o">,</span> <span class="o">⟨</span><span class="n">topological_space_eq</span> <span class="o">(</span><span class="n">funext</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">eq_iff_iff.mpr</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="o">⟨⟩,</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">sep</span> <span class="n">x</span><span class="o">⟩))⟩,</span> <span class="bp">λ</span> <span class="n">d</span> <span class="n">s</span><span class="o">,</span>
  <span class="bp">@</span><span class="n">is_open_discrete</span> <span class="n">X</span> <span class="n">_</span> <span class="n">d</span> <span class="n">s</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">discrete_of_singletons_open</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="bp">@</span><span class="n">is_open</span> <span class="n">X</span> <span class="n">_</span> <span class="o">(</span><span class="n">singleton</span> <span class="n">a</span><span class="o">))</span> <span class="bp">→</span> <span class="n">discrete_topology</span> <span class="n">X</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">discrete_of_forall_open.mp</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">bUnion_of_singleton</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">is_open_Union</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">is_open_Union</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="n">s</span> <span class="n">i</span><span class="o">)),</span>
<span class="kd">end</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">open_of_open_inter</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">U</span> <span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">is_open</span> <span class="n">X</span> <span class="n">_</span> <span class="n">U</span> <span class="bp">→</span> <span class="bp">@</span><span class="n">is_open</span> <span class="n">S</span> <span class="n">_</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">|</span> <span class="bp">↑</span><span class="n">s</span> <span class="bp">∈</span> <span class="n">U</span><span class="o">}</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">oU</span><span class="o">,</span> <span class="o">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">oU</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">discrete_subspace_of_open_int_singletons</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span>
  <span class="o">(</span><span class="n">sep</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">,</span> <span class="n">is_open</span> <span class="n">U</span> <span class="bp">∧</span> <span class="n">U</span> <span class="bp">∩</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">singleton</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="n">S</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">discrete_of_singletons_open</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="o">⟩,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">oU</span><span class="o">,</span> <span class="n">j</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">sep</span> <span class="n">t</span> <span class="n">ht</span><span class="o">),</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">oU</span><span class="o">,</span> <span class="n">ext</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">)⟩,</span>
  <span class="n">cases</span> <span class="n">x</span> <span class="k">with</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="n">F</span> <span class="o">:=</span> <span class="o">(</span><span class="n">mem_inter_iff</span> <span class="n">x</span> <span class="n">U</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">j</span><span class="o">,</span> <span class="n">mem_singleton_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">F</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">id</span> <span class="o">(</span><span class="n">subtype.mk.inj_eq</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">t</span> <span class="n">ht</span><span class="o">))</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">F</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mem_singleton_iff</span><span class="o">,</span> <span class="n">subtype.mk.inj_eq</span><span class="o">]</span> <span class="n">at</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">change</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">U</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">mem_of_subset_of_mem</span> <span class="n">_</span> <span class="o">(</span><span class="n">mem_singleton</span> <span class="n">x</span><span class="o">),</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">a</span> <span class="n">at</span> <span class="n">j</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">j</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">inter_subset_left</span> <span class="n">U</span> <span class="n">S</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">discrete_of_lt_dist</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span>
  <span class="o">(</span><span class="n">sep</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">e</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">dist</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">e</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">discrete_subspace_of_open_int_singletons</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">xs</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="o">(</span><span class="n">sep</span> <span class="n">x</span> <span class="n">xs</span><span class="o">)</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">e0</span><span class="o">,</span> <span class="n">disj</span><span class="o">⟩,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">metric.ball</span> <span class="n">x</span> <span class="n">e</span><span class="o">,</span> <span class="n">metric.is_open_ball</span><span class="o">,</span> <span class="n">ext</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">mem_singleton_iff.mpr</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩)⟩,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">eq.symm</span> <span class="o">(</span><span class="n">disj</span> <span class="n">y</span> <span class="n">h.2</span> <span class="o">(</span><span class="n">metric.mem_ball'.mp</span> <span class="n">h.1</span><span class="o">))</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">metric.mem_ball_self</span> <span class="n">e0</span><span class="o">,</span> <span class="n">xs</span><span class="o">⟩</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">discrete_of_lt_dist_uniform</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">e</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">dist</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">e</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">))</span> <span class="bp">→</span> <span class="n">discrete_topology</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">e0</span><span class="o">,</span> <span class="n">F</span><span class="o">⟩,</span>
  <span class="n">apply</span> <span class="n">discrete_of_lt_dist</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">xs</span><span class="o">,</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">e0</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">b</span> <span class="n">bs</span><span class="o">,</span> <span class="n">F</span> <span class="n">x</span> <span class="n">b</span> <span class="n">xs</span> <span class="n">bs</span><span class="o">⟩),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">min'_image_le</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">S</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">)</span>
  <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.min'</span> <span class="o">(</span><span class="n">finset.image</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">finset.nonempty.image</span> <span class="n">hs</span> <span class="n">f</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">f</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">finset.min'_le</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">$</span> <span class="n">finset.mem_image.mpr</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">‹</span><span class="n">_</span><span class="o">›,</span> <span class="n">rfl</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">lt_min'</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">S</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">S</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">finset.min'</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">s</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">al</span> <span class="n">as</span><span class="o">,</span> <span class="n">imp_false.mpr</span> <span class="o">(</span><span class="n">not_lt.mpr</span> <span class="o">(</span><span class="n">finset.min'_le</span> <span class="n">s</span> <span class="n">a</span> <span class="n">as</span><span class="o">))</span> <span class="n">al</span>

<span class="kd">lemma</span> <span class="n">lt_min'_image</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">S</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">)</span>
  <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">finset.min'</span> <span class="o">(</span><span class="n">finset.image</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">finset.nonempty.image</span> <span class="n">hs</span> <span class="n">f</span><span class="o">)</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">s</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">al</span> <span class="n">as</span><span class="o">,</span> <span class="n">not_le.mpr</span> <span class="n">al</span> <span class="o">(</span><span class="n">min'_image_le</span> <span class="n">hs</span> <span class="n">a</span> <span class="n">as</span> <span class="n">f</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">discrete_of_finite</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">discrete_topology</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">//</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">discrete_of_lt_dist</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">am</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">d0</span> <span class="o">:</span> <span class="o">(</span><span class="n">finset.erase</span> <span class="n">s</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a0</span><span class="o">,</span> <span class="n">ha0</span><span class="o">,</span> <span class="n">da0</span><span class="o">⟩</span> <span class="o">:=</span>
      <span class="n">finset.mem_image.mp</span> <span class="o">(</span><span class="n">finset.min'_mem</span> <span class="o">((</span><span class="n">finset.erase</span> <span class="n">s</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">image</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">dist</span> <span class="n">x</span> <span class="n">a</span><span class="o">))</span>
      <span class="o">(</span><span class="n">finset.nonempty.image</span> <span class="n">d0</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">dist</span> <span class="n">x</span> <span class="n">a</span><span class="o">))),</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">finset.min'</span> <span class="o">((</span><span class="n">finset.erase</span> <span class="n">s</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">image</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">dist</span> <span class="n">x</span> <span class="n">a</span><span class="o">))</span>
      <span class="o">(</span><span class="n">finset.nonempty.image</span> <span class="n">d0</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">dist</span> <span class="n">x</span> <span class="n">a</span><span class="o">)),</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">b</span> <span class="n">hb</span> <span class="n">dab</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">lt_of_le_of_ne</span> <span class="o">(</span><span class="n">finset.le_min'</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">_</span><span class="o">))</span> <span class="n">_</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">rcases</span> <span class="n">finset.mem_image.mp</span> <span class="n">hy</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">aa</span><span class="o">,</span> <span class="n">bb</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
        <span class="n">exact</span> <span class="n">dist_nonneg</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">intros</span> <span class="n">ma</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">ma</span><span class="o">,</span> <span class="n">dist_eq_zero</span><span class="o">]</span> <span class="n">at</span> <span class="n">da0</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">da0</span> <span class="n">at</span> <span class="n">ha0</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">finset.not_mem_erase</span> <span class="n">a</span> <span class="n">s</span> <span class="n">ha0</span> <span class="o">}</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">dist_comm</span> <span class="n">a</span> <span class="n">b</span> <span class="n">at</span> <span class="n">dab</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">dist</span> <span class="n">x</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="bp">@</span><span class="n">finset.image</span> <span class="n">X</span> <span class="n">ℝ</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">classical.prop_decidable</span> <span class="o">(</span><span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">))</span>
        <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">dist</span> <span class="n">x</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">s.erase</span> <span class="n">a</span><span class="o">))</span><span class="bp">.</span><span class="n">min'</span> <span class="n">_</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">convert</span> <span class="n">dab</span><span class="o">,</span>
        <span class="n">convert</span> <span class="n">finset.nonempty.image</span> <span class="n">d0</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">dist</span> <span class="n">x</span> <span class="n">a</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">obtain</span> <span class="n">F</span> <span class="o">:=</span> <span class="n">lt_min'_image</span> <span class="n">d0</span> <span class="n">b</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">dist</span> <span class="n">x</span> <span class="n">a</span><span class="o">)</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">symmetry</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">finset.eq_of_mem_of_not_mem_erase</span> <span class="n">hb</span> <span class="n">F</span><span class="o">,</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">zero_lt_one</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">b</span> <span class="n">hb</span> <span class="n">dab</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">finset.sdiff_singleton_eq_erase</span> <span class="n">a</span> <span class="n">at</span> <span class="n">d0</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">finset.mem_singleton.mp</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">am</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="n">sa</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">singleton</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">le_antisymm</span> <span class="n">_</span> <span class="o">(</span><span class="n">finset.singleton_subset_iff.mpr</span> <span class="n">am</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">subst</span> <span class="n">sa</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">hb</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">hb</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">hb</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">by_contradiction</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">d0</span> <span class="o">(</span><span class="n">finset.nonempty_of_ne_empty</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">h</span> <span class="o">(</span><span class="n">finset.sdiff_eq_empty_iff_subset.mp</span> <span class="n">e</span><span class="o">)))</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">roots_discrete</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">//</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">f.roots.to_finset</span><span class="o">}</span> <span class="o">:=</span>
<span class="n">discrete_of_finite</span>
</code></pre></div>



<a name="218922877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218922877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218922877">(Dec 05 2020 at 07:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/discrete_topology/near/218922522">said</a>:</p>
<blockquote>
<p>I am somewhat puzzled that I was not asked by Lean to assume that the polynomial is non-zero, though.  Therefore, I learned that <code>0.roots</code> is defined to be <code>∅</code>.  Should this have been <code>univ</code> instead?</p>
</blockquote>
<p>Unfortunately, <code>univ</code> is not a finset.</p>



<a name="218922896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218922896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218922896">(Dec 05 2020 at 07:14)</a>:</h4>
<p>Ok, I guess this is one of the things that I will constantly have in the back of my mind, like the fact that <code>1-2=0</code>!</p>



<a name="218923078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218923078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218923078">(Dec 05 2020 at 07:18)</a>:</h4>
<p>It might make sense to add the hypothesis <code>f ≠ 0</code> to the final lemma (<code>roots_discrete</code>), even though the lemma is correct also in its more general form, right?</p>



<a name="218923092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218923092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218923092">(Dec 05 2020 at 07:19)</a>:</h4>
<p>Yes.</p>



<a name="218923153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218923153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218923153">(Dec 05 2020 at 07:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/discrete_topology/near/218923078">said</a>:</p>
<blockquote>
<p>It might make sense to add the hypothesis <code>f ≠ 0</code> to the final lemma (<code>roots_discrete</code>), even though the lemma is correct also in its more general form, right?</p>
</blockquote>
<p>Why? It just means people will have to prove their polynomials are zero every time they want to use your lemma?</p>



<a name="218923168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218923168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218923168">(Dec 05 2020 at 07:21)</a>:</h4>
<p>Yeah, if it's true in general, then state it in general.</p>



<a name="218923318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218923318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218923318">(Dec 05 2020 at 07:25)</a>:</h4>
<p><span class="user-mention" data-user-id="127136">@Alex J. Best</span> <span class="user-mention" data-user-id="110064">@Kenny Lau</span> I am not so comfortable with the idea that the zero set of the polynomial <code>0</code> should be considered as a discrete topological space.  I realize that the definitions in Lean allow this, since the zero set of the zero polynomial is empty.  However, this might lead to the (human) conclusion that the topology on ℝ is discrete.</p>
<p>Am I the only one who thinks this?</p>



<a name="218923344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218923344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218923344">(Dec 05 2020 at 07:25)</a>:</h4>
<p>I understand that a person coming from a mathematical background might not be very comfortable with this idea of stating a junk theorem in general, but that's just how we do it in Lean, so that other people can use it more easily.</p>



<a name="218923517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218923517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218923517">(Dec 05 2020 at 07:30)</a>:</h4>
<p>In that case I might write a big warning message in the docstring before the theorem so that nobody reading the theorem makes a mistake.</p>



<a name="218923547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218923547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218923547">(Dec 05 2020 at 07:30)</a>:</h4>
<p>Ok, I removed the hypothesis.  I do like the idea of flagging this in a comment somewhere, though!</p>



<a name="218923619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218923619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218923619">(Dec 05 2020 at 07:33)</a>:</h4>
<p>If you use the</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- comment here -/</span>
<span class="kd">theorem</span> <span class="n">blah</span>
</code></pre></div>
<p>syntax it will show up prominently in the docs and if people hover their mouse over the theorem</p>



<a name="218923976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218923976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218923976">(Dec 05 2020 at 07:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/discrete_topology/near/218923619">said</a>:</p>
<blockquote>
<p>If you use the</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- comment here -/</span>
<span class="kd">theorem</span> <span class="n">blah</span>
</code></pre></div>
<p>syntax it will show up prominently in the docs and if people hover their mouse over the theorem</p>
</blockquote>
<p>Comment added!  Thanks for the suggestion!</p>



<a name="218928882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218928882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218928882">(Dec 05 2020 at 10:18)</a>:</h4>
<p>If you think that this might be a useful addition to mathlib, let me know and I might ask a couple of specific questions, to clean up the parts of the proofs that feel clunky!</p>
<p>As usual, thank you all for making this chat so helpful and supportive!<br>
<span aria-label="pray" class="emoji emoji-1f64f" role="img" title="pray">:pray:</span></p>



<a name="218929592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218929592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218929592">(Dec 05 2020 at 10:42)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span>  here's a parable. When I was formalising my first year course example sheets in 2017, mathlib had the reals as a complete ordered field but didn't have a square root function. In my course I proved that sqrt(x) could be defined to be the sup of the real numbers whose square was &lt;= x, if x was nonnegative. So I defined a square root function myself for x nonnegative as this sup and posted on the chat (this was back in the gitter days so it's lost in time). Mario laughed at the definition because he said he said it was a function which asked for an input (a proof that x&gt;=0) and then never used it. I was surprised it didn't use it but what was happening was that real.sup didn't ask for a proof that the set was nonempty and bounded either, it just returned 37 if the set didn't actually have a sup and then there was a lemma saying that the value of real.sup was a least upper bound if the set was nonempty and bounded. From a computer science point of view I could understand that it was ridiculous to ask for an input to my function which was never used when calculating the output but from a mathematical point of view I was deeply concerned about the square root of every negative real being 37 so I left the assumption in there anyway and went on to formalise the example sheet.</p>
<p>And it was a nightmare. Because the first question on is was "prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mn>2</mn></msqrt><mo>+</mo><msqrt><mn>3</mn></msqrt><mo>&lt;</mo><msqrt><mn>10</mn></msqrt></mrow><annotation encoding="application/x-tex">\sqrt2+\sqrt3&lt;\sqrt{10}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;">2</span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg height="1.08em" preserveAspectRatio="xMinYMin slice" viewBox="0 0 400000 1080" width="400em"><path d="M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;">3</span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg height="1.08em" preserveAspectRatio="xMinYMin slice" viewBox="0 0 400000 1080" width="400em"><path d="M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">1</span><span class="mord">0</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg height="1.08em" preserveAspectRatio="xMinYMin slice" viewBox="0 0 400000 1080" width="400em"><path d="M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span></span>" (and this was before the days that proving <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">0\leq2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> was easy) and in every single line of the proof I had to keep inserting these stupid proofs that everything was nonnegative, even if I was just doing something like squaring both sides which mathematically would work fine if the square root of every negative number was 37, and this was all in the knowledge that the system was asking me for a proof which I was finding annoying to construct and then simply ignoring it. I soon learnt that the idea of "garbage in, garbage out" was a convenient one in dependent type theory.</p>
<p>In this situation one could imagine two polynomial roots functions, one returning a set which functioned correctly, and one which returned a finset which returned junk at zero. In fact we'll have a similar situation with DVRs soon. I defined the additive valuation on a DVR but it's nat-valued and sends 0 to 37 instead of +infinity, for the simple reason that this function is much easier to work with in practice than the function taking values in <code>with_top nat</code>. The advantage of <code>with_top nat</code> is that things like v(a+b)&gt;=min(v(a),v(b)) are true unconditionally, but when you look at the proofs of these things they always treat 0 as a special case anyway, we claim it's a unified approach but actually this is an illusion. There's an art to all this but basically the best definitions in dependent type theory are the ones most convenient to work with in dependent type theory and if this differs from mathematical conventions then maybe that's the fault of dependent type theory but we're doing dependent type theory and goodness knows we have enough other problems, we may as well use the definition style best suited to the theory.</p>



<a name="218929593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218929593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218929593">(Dec 05 2020 at 10:42)</a>:</h4>
<p>Damiano, I think you're making this a lot more complicated that it needs to be, because you are too focused on the intended application.</p>



<a name="218930608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218930608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218930608">(Dec 05 2020 at 11:14)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> your issue is that you're too focused on sets inside metric spaces. In Lean this is costly. You need to think as much as possible about abstract spaces and then apply things to sets endowed with the induced topology. I claim your file should begin with:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">open</span> <span class="n">polynomial</span> <span class="n">set</span>

<span class="kd">lemma</span> <span class="n">forall_open_iff_discrete</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">,</span> <span class="n">is_open</span> <span class="n">s</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">discrete_topology</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">U</span> <span class="bp">;</span> <span class="k">show</span> <span class="n">is_open</span> <span class="n">U</span> <span class="bp">↔</span> <span class="n">true</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span> <span class="n">U</span><span class="o">]</span> <span class="o">}⟩,</span>
 <span class="kd">by</span> <span class="n">introsI</span> <span class="bp">;</span> <span class="n">exact</span> <span class="n">is_open_discrete</span> <span class="n">_</span><span class="o">⟩</span>


<span class="kd">lemma</span> <span class="n">singletons_open_iff_discrete</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">is_open</span> <span class="o">({</span><span class="n">a</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">))</span> <span class="bp">↔</span> <span class="n">discrete_topology</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">eq_bot_of_singletons_open</span> <span class="n">h</span><span class="o">⟩,</span> <span class="kd">by</span> <span class="n">introsI</span> <span class="bp">;</span> <span class="n">exact</span> <span class="n">is_open_discrete</span> <span class="n">_</span><span class="o">⟩</span>


<span class="kd">lemma</span> <span class="n">subset_singleton_iff</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">mem_singleton_iff.mp</span> <span class="o">(</span><span class="n">h</span> <span class="n">hy</span><span class="o">),</span>
 <span class="bp">λ</span> <span class="n">h</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">mem_singleton_iff.mpr</span> <span class="o">(</span><span class="n">h</span> <span class="n">y</span> <span class="n">hy</span><span class="o">)⟩</span>

<span class="kn">open</span> <span class="n">metric</span>

<span class="kd">lemma</span> <span class="n">metric.is_open_singleton_iff</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">is_open</span> <span class="o">({</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">dist</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">is_open_iff</span><span class="o">,</span> <span class="n">subset_singleton_iff</span><span class="o">,</span> <span class="n">mem_ball</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">metric.discrete_of_finite</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="n">X</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">singletons_open_iff_discrete</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">metric.is_open_singleton_iff</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">discrete_of_finite</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">discrete_topology</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">//</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}</span> <span class="o">:=</span>
<span class="n">metric.discrete_of_finite</span>
</code></pre></div>
<p>And the <code>sorry</code> should be filled using some version of your <code>finset.min'</code> stuff (that I didn't look at closely), but my point is this is a completely separate issue from the induced topology stuff.</p>



<a name="218930963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218930963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218930963">(Dec 05 2020 at 11:24)</a>:</h4>
<p>For the final statement <code>roots_discrete</code> I think a more natural formulation is <code>discrete_topology {a : ℝ // f.eval a = 0}</code>, which now does need the nonzero hypothesis you expected.</p>



<a name="218932160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218932160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218932160">(Dec 05 2020 at 11:59)</a>:</h4>
<p>My shower says this has nothing to do with metric spaces, some kind of separation condition should be enough and get us rid of <code>finset.min</code>. Hold on.</p>



<a name="218932564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218932564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218932564">(Dec 05 2020 at 12:10)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.metric_space.basic</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="kd">lemma</span> <span class="n">forall_open_iff_discrete</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">,</span> <span class="n">is_open</span> <span class="n">s</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">discrete_topology</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">U</span> <span class="bp">;</span> <span class="k">show</span> <span class="n">is_open</span> <span class="n">U</span> <span class="bp">↔</span> <span class="n">true</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span> <span class="n">U</span><span class="o">]</span> <span class="o">}⟩,</span>
 <span class="kd">by</span> <span class="n">introsI</span> <span class="bp">;</span> <span class="n">exact</span> <span class="n">is_open_discrete</span> <span class="n">_</span><span class="o">⟩</span>


<span class="kd">lemma</span> <span class="n">singletons_open_iff_discrete</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">is_open</span> <span class="o">({</span><span class="n">a</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">))</span> <span class="bp">↔</span> <span class="n">discrete_topology</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">eq_bot_of_singletons_open</span> <span class="n">h</span><span class="o">⟩,</span> <span class="kd">by</span> <span class="n">introsI</span> <span class="bp">;</span> <span class="n">exact</span> <span class="n">is_open_discrete</span> <span class="n">_</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">subset_singleton_iff</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">mem_singleton_iff.mp</span> <span class="o">(</span><span class="n">h</span> <span class="n">hy</span><span class="o">),</span>
 <span class="bp">λ</span> <span class="n">h</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">mem_singleton_iff.mpr</span> <span class="o">(</span><span class="n">h</span> <span class="n">y</span> <span class="n">hy</span><span class="o">)⟩</span>

<span class="kn">open</span> <span class="n">metric</span>

<span class="kd">lemma</span> <span class="n">metric.is_open_singleton_iff</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">is_open</span> <span class="o">({</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">dist</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">is_open_iff</span><span class="o">,</span> <span class="n">subset_singleton_iff</span><span class="o">,</span> <span class="n">mem_ball</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">compl_singleton_eq_bUnion_singleton</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">({</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">ᶜ</span> <span class="bp">=</span> <span class="bp">⋃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">≠</span> <span class="n">x</span><span class="o">),</span> <span class="o">{</span><span class="n">y</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">compl_singleton_eq</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">simp</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">discrete_of_t1_of_finite</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">t1_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">discrete_topology</span> <span class="n">X</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">singletons_open_iff_discrete</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">is_closed_compl_iff</span><span class="o">,</span> <span class="n">compl_singleton_eq_bUnion_singleton</span> <span class="n">x</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">is_closed_bUnion</span> <span class="o">(</span><span class="n">finite.of_fintype</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="n">_</span><span class="o">,</span> <span class="n">is_closed_singleton</span><span class="o">)</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">metric.discrete_of_finite</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="n">X</span> <span class="o">:=</span>
<span class="n">discrete_of_t1_of_finite</span>

<span class="kd">lemma</span> <span class="n">discrete_of_finite</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">discrete_topology</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">//</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}</span> <span class="o">:=</span>
<span class="n">metric.discrete_of_finite</span>
</code></pre></div>



<a name="218932579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218932579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218932579">(Dec 05 2020 at 12:11)</a>:</h4>
<p>No cheating involved, I started searching wikipedia for separation axioms after I posted the preceding message.</p>



<a name="218932626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218932626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218932626">(Dec 05 2020 at 12:12)</a>:</h4>
<p>Notice how the last two lemmas aren't doing anything, only specializing <code>discrete_of_t1_of_finite</code> using type class instances magic.</p>



<a name="218932636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218932636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218932636">(Dec 05 2020 at 12:12)</a>:</h4>
<p>I claim <em>this</em> is formalization. If you're suffering then you need to get clearer, more abstract, ideas.</p>



<a name="218933964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218933964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218933964">(Dec 05 2020 at 12:50)</a>:</h4>
<p>I remember when I was at Damiano's stage, and this idea which Patrick refers to as "suffering", presumably referring to Damiano's original 34 line proof of <code>discrete_of_finite</code>, is something which I always thought of as "fun" (as I was beginning to realise that I had found a computer program which thought about mathematics in the same way that I did). However, whatever your take on writing 34 line proofs, Patrick certainly has a point that it's better to find the right generality in which to prove a theorem. The introduction of <code>t1</code> and the abstraction of using topological spaces instead of metric spaces turns a 34 line proof that a finite subset of a metric space is discrete (using fiddly mins of sets of distances) into a 4 line proof that a finite subset of a T1 space is discrete, and this is an important lesson, regardless of how much fun we're having.</p>



<a name="218938851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218938851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218938851">(Dec 05 2020 at 15:10)</a>:</h4>
<p>Dear All,</p>
<p>thank you so much for your suggestions!  I had no idea that the T_i axioms were in Lean!  I will now look at how you managed to avoid all the coercion suffering that I was going through!</p>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I understand your parable and I had read your post about division by zero.  However, I am still trying to get my head around stuff in Lean.  My (I realize incorrect) reasoning is.  If you are trying to talk about 1/0, then you already did something wrong, so getting garbage results is ok.  If you are asking Lean to compute the roots of a polynomial, though, it is reasonable that you argument also applies to the zero polynomial.  In this case, the Lean theorem makes me think that the topology on ℝ is discrete, not that the vanishing set of the zero polynomial is empty!  I can see that Lean is working consistently, but I since I am familiar with the mathematical conventions and not the Lean ones, I still need adjusting!</p>
<p>Anyway, I will now dive into learning the "correct" proof of these results.  Sadly, once the proof is done, it becomes <em>irrelevant</em>, right?<br>
<span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="218938980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218938980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218938980">(Dec 05 2020 at 15:14)</a>:</h4>
<p>the issue is the type of the function. If you're looking for the roots of a polynomial, the roots of 0 will be everything. But if the question is to find the finite set of roots of a polynomial, which apparently it is if it's returning a finset, then because it's a <em>definition</em> and not a theorem, it's best to have this "garbage in, garbage out" principle. I think that the most extreme example of it is <code>real.sup</code>, which takes any set of reals, bounded or unbounded, and produces a real number anyway. All the correct hypotheses are there but they're in the theorems, not the definitions. Definitions are special and different.</p>



<a name="218939277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218939277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218939277">(Dec 05 2020 at 15:22)</a>:</h4>
<p>Ok, I can agree with this.  But then, the result <code>roots_discrete</code> should contain the hypothesis, no?  Or am I still misunderstanding something?  This is a result, not a definition, or at least this is how I view it!</p>



<a name="218939302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218939302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218939302">(Dec 05 2020 at 15:23)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span>  If you want to have infinitely many roots for the zero polynomial you can use directly <code>is_root</code> instead of <code>p.roots</code>.</p>



<a name="218939367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218939367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218939367">(Dec 05 2020 at 15:24)</a>:</h4>
<p>I think that the current state of things is really the optimal one, I have used this stuff a little bit in the last weeks and it's quite natural to work with them.</p>



<a name="218939380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218939380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218939380">(Dec 05 2020 at 15:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> Thank you very much for taking the time to generalize and consequently cleaning up my clunky proofs!  I feel that I have learned a lot!</p>
<p>To be honest, even if I had known about the existence of T_i spaces, first, I might have used T_2, just to be safe, and second, I would have probably had long proofs anyway!</p>



<a name="218939450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218939450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218939450">(Dec 05 2020 at 15:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/113489-new-members/topic/discrete_topology/near/218939302">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span>  If you want to have infinitely many roots for the zero polynomial you can use directly <code>is_root</code> instead of <code>p.roots</code>.</p>
</blockquote>
<p>Ok, I learned about the <code>roots</code>command from the Liouville PR, but I will keep an eye out for <code>is_root</code>: thanks for the pointer!</p>



<a name="218939452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218939452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218939452">(Dec 05 2020 at 15:26)</a>:</h4>
<p>The most extreme example I've seen of long proofs going to short proofs is trying to prove any theorem about basic topology using open sets the way it was taught to us as undergraduates. You prove e.g. compact subspace of Hausdorff space is closed by chasing open sets around, and then you look at the mathlib proof and it's usually about 4 lines with filters. This is especially true for Tychonoff.</p>



<a name="218939658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218939658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218939658">(Dec 05 2020 at 15:32)</a>:</h4>
<p>Moreover <code>p.roots</code> is a multiset (and we happy to have multiplicity of the roots!), I don't see any reasonable convention for the multiplicity of the roots of <code>0</code>...</p>



<a name="218939872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218939872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218939872">(Dec 05 2020 at 15:37)</a>:</h4>
<p>Just to spell out something that is likely clear to everyone else, but I feel that I should air out.  I will take this example at hand: in mathematics, I would say that the roots of a polynomials are a finite set, except in the case of the zero polynomial.  Thus, in my mind, I construct a "function" with inputs polynomials and targets "finite sets" or "everything", depending on the input.  This appeared to me to work well with <em>dependent</em> type theory: the type of the image of the function depends on the input.  The fault in this is that the <em>Type</em> of the target is allowed to depend <em>only on the Type</em> of the source, not on the given term.  Is this correct?</p>
<p>Now that I am writing this, I realize that it should be a tautology, but I had not internalized this until now...</p>



<a name="218940017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940017">(Dec 05 2020 at 15:41)</a>:</h4>
<p>The paradox here is that writing dependent types in dependent type theory is inadvisable</p>



<a name="218940067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940067">(Dec 05 2020 at 15:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/discrete_topology/near/218930963">said</a>:</p>
<blockquote>
<p>For the final statement <code>roots_discrete</code> I think a more natural formulation is <code>discrete_topology {a : ℝ // f.eval a = 0}</code>, which now does need the nonzero hypothesis you expected.</p>
</blockquote>
<p>Thank you for this comment!  It makes me feel better about omitting the hypothesis in the initial formulation.  I am thinking that it might be useful to have both statements...</p>



<a name="218940071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940071">(Dec 05 2020 at 15:42)</a>:</h4>
<p>DTT makes it <em>possible</em> but it makes every use harder so it should be used sparingly and well encapsulated</p>



<a name="218940076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940076">(Dec 05 2020 at 15:43)</a>:</h4>
<p>I don't know the answer to your question, but my feeling is that in any case the real difference is that in normal mathematics nobody proves that <code>X ^ 2 - 3</code> is different from <code>0</code>, so we can speak about the finite set of its roots without any trouble. In lean you would be forced to prove this over and over, essentially anytime you want to speak about <code>p.roots</code>. I realized this working with <code>p.degree</code> and <code>p.nat_degree</code>: there is really no alternative to have the two definitions, but sometimes it's really annoying.</p>



<a name="218940128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940128">(Dec 05 2020 at 15:44)</a>:</h4>
<p>Ah, ok!  While my skills had not made working with <em>dependent</em> types especially accessible, I had not realized that it was actually hard.  And coming from you, <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> , adds an unfathomable weight to the assertion!</p>



<a name="218940164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940164">(Dec 05 2020 at 15:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/113489-new-members/topic/discrete_topology/near/218940076">said</a>:</p>
<blockquote>
<p>I don't know the answer to your question, but my feeling is that in any case the real difference is that in normal mathematics nobody proves that <code>X ^ 2 - 3</code> is different from <code>0</code>, so we can speak about the finite set of its roots without any trouble. In lean you would be forced to prove this over and over, essentially anytime you want to speak about <code>p.roots</code>. I realized this working with <code>p.degree</code> and <code>p.nat_degree</code>: there is really no alternative to have the two definitions, but sometimes it's really annoying.</p>
</blockquote>
<p>I had a similar experience with <code>nat_degree</code> and <code>degree</code>, however, I think that the <code>min'</code> always requiring the assumption <code>nonempty</code> is what really annoys me most.  Why is there such an assumption all the time in this case?</p>



<a name="218940215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940215">(Dec 05 2020 at 15:46)</a>:</h4>
<p>I'm not sure exactly which <code>min'</code> you mean but I would guess that the codomain is not necessarily inhabited, so it's impossible to avoid the assumption in that case</p>



<a name="218940230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940230">(Dec 05 2020 at 15:47)</a>:</h4>
<p>I am thinking of <code>finset.min'</code>.</p>



<a name="218940274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940274">(Dec 05 2020 at 15:48)</a>:</h4>
<p>there are actually several variations on min and max for finsets depending on your constraints</p>



<a name="218940277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940277">(Dec 05 2020 at 15:48)</a>:</h4>
<p>I see, I have likely only used <code>min'</code> for subsets of nat and (today) of \R!</p>



<a name="218940291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940291">(Dec 05 2020 at 15:49)</a>:</h4>
<p>you can have it return an <code>option A</code>, or if <code>A</code> is a inf-top semilattice you can return an <code>A</code> using <code>finset.sup</code>, or if it's known to be nonempty but A isn't then you can use <code>finset.min'</code></p>



<a name="218940343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940343">(Dec 05 2020 at 15:50)</a>:</h4>
<p>I guess we don't have a version that assumes <code>[nonempty A]</code> instead of <code>s.nonempty</code></p>



<a name="218940349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940349">(Dec 05 2020 at 15:50)</a>:</h4>
<p>I have bad memories of getting stuck on <code>option</code>s, so I am wary of choosing this "option".  Especially in the context of degrees of polynomials, I found that I would have liked it to be defined as the <code>min' insert f.support 0</code>...</p>



<a name="218940360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940360">(Dec 05 2020 at 15:51)</a>:</h4>
<p>that's <code>nat_degree</code>, right?</p>



<a name="218940376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940376">(Dec 05 2020 at 15:51)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> I had to choose between <code>v : R -&gt; nat</code> and <code>v : R -&gt; with_top nat</code> for the valuation on a DVR and I went for nat and gave v(0) a junk value, and this was simply because I know from experience that nat is much easier to deal with than with_top nat. Probably I will make <code>v' : R -&gt; with_top nat</code> at some point, but I know that I can make the norm <code>n : R -&gt; real</code> easily from <code>v</code> so now I am not even sure why I need <code>v'</code> at all. To get n from v I just say "(1/p)^v(x) if x isn't 0, and 0 if x=0". To get n from v' you might think it's easier but I still need to split into cases because (1/p)^n isn't defined if n is in <code>with_top nat</code>. I think it's swings and roundabouts.</p>



<a name="218940423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940423">(Dec 05 2020 at 15:52)</a>:</h4>
<p>I think that <code>nat_degree</code>  is defined using <code>option.get_or_else</code>.  Due to my limitations, I did not understand how to use <code>option</code>...</p>



<a name="218940496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940496">(Dec 05 2020 at 15:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/discrete_topology/near/218940376">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> I had to choose between <code>v : R -&gt; nat</code> and <code>v : R -&gt; with_top nat</code> for the valuation on a DVR and I went for nat and gave v(0) a junk value, and this was simply because I know from experience that nat is much easier to deal with than with_top nat. Probably I will make <code>v' : R -&gt; with_top nat</code> at some point, but I know that I can make the norm <code>n : R -&gt; real</code> easily from <code>v</code> so now I am not even sure why I need <code>v'</code> at all. To get n from v I just say "(1/p)^v(x) if x isn't 0, and 0 if x=0". To get n from v' you might think it's easier but I still need to split into cases because (1/p)^n isn't defined if n is in <code>with_top nat</code>. I think it's swings and roundabouts.</p>
</blockquote>
<p>I am becoming more familiar with Lean, so I start to "feel inside" what you mean by this!  I still need to go through a bit of the learning process, though, to fully automate it and stop worrying about it!</p>



<a name="218940510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940510">(Dec 05 2020 at 15:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/discrete_topology/near/218940423">said</a>:</p>
<blockquote>
<p>I think that <code>nat_degree</code>  is defined using <code>option.get_or_else</code>.  Due to my limitations, I did not understand how to use <code>option</code>...</p>
</blockquote>
<p>It shouldn't matter what the definition is, as long as it is extensionally equal to whatever you want it to be</p>



<a name="218940522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940522">(Dec 05 2020 at 15:55)</a>:</h4>
<p>because you can simply prove a theorem that gives the desired unfolding</p>



<a name="218940572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940572">(Dec 05 2020 at 15:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/discrete_topology/near/218940522">said</a>:</p>
<blockquote>
<p>because you can simply prove a theorem that gives the desired unfolding</p>
</blockquote>
<p>True, although <em>you</em> was not <em>me</em> in this specific case: Johan proved what I had tried and failed to achieve!</p>



<a name="218940593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940593">(Dec 05 2020 at 15:57)</a>:</h4>
<p>Once I had a lemma showing that <code>nat_degree</code> equals <code>min' (exponents with 0 added)</code>, I would start all my proofs with first applying this lemma, and then proceeding from there!</p>



<a name="218940635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940635">(Dec 05 2020 at 15:58)</a>:</h4>
<p>In the case of <code>nat_degree</code>, I would expect the api theorem to say that <code>nat_degree 0 = 0</code> and <code>nat_degree p = &lt;degree of p&gt;</code></p>



<a name="218940639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940639">(Dec 05 2020 at 15:58)</a>:</h4>
<p>so you don't have to worry about any <code>option</code>s here</p>



<a name="218940643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940643">(Dec 05 2020 at 15:58)</a>:</h4>
<p>(I know that this is due to my inability to use Lean propertly: if I looked back at these issues now, I may not feel so strongly about it...)</p>



<a name="218940645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940645">(Dec 05 2020 at 15:58)</a>:</h4>
<p>Right. If you're having to translate to <code>min'</code> them it might mean that you either don't know the API for <code>nat_degree</code> or it wasn't made.</p>



<a name="218940738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940738">(Dec 05 2020 at 16:00)</a>:</h4>
<p>I think that the API might even have been there, except that I was trying to introduce <code>trailing_degrees</code> and wanted to mimick the lemmas for <code>degree</code> and found out that I failed a fairly high proportion of the times</p>



<a name="218940760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218940760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218940760">(Dec 05 2020 at 16:01)</a>:</h4>
<p>In the specific case of converting a <code>nat_degree</code> to a <code>min'</code> I am not sure that that was available, though <strong>a lot</strong> was available!</p>



<a name="218941319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941319">(Dec 05 2020 at 16:13)</a>:</h4>
<p>Thank's to this discussion I just realized that <code>with_bot ℕ</code> is by definition <code>option ℕ</code>! This is weird because in my mind <code>option ℕ</code> is used to produce partial functions, and, still in my mind, <code>degree</code> is not partial, <code>0.degree</code> is something like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">-\infty</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">∞</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">-\infty</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">∞</span></span></span></span> is an element of <code>with_bot ℕ</code> (like in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="bold">N</mi><mo>ˉ</mo></mover><mo>=</mo><mi mathvariant="bold">N</mi><mo>∪</mo><mo stretchy="false">{</mo><mo>−</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\bar \mathbf{N} = \mathbf{N} \cup \{-\infty\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8228899999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8228899999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">N</span></span></span><span style="top:-3.25511em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">N</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">−</span><span class="mord">∞</span><span class="mclose">}</span></span></span></span>). I find this approach very clever <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="218941380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941380">(Dec 05 2020 at 16:14)</a>:</h4>
<p>And this also explains why in the definition of <code>nat_degree</code> there is no proof that the degree of a nonzero polynomial is the coercion of a natural number.</p>



<a name="218941450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941450">(Dec 05 2020 at 16:16)</a>:</h4>
<p>You should think of <code>option</code> as the + 1 operator on types</p>



<a name="218941454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941454">(Dec 05 2020 at 16:16)</a>:</h4>
<p>it's useful whenever you want to add a single new element disjoint from everything else</p>



<a name="218941538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941538">(Dec 05 2020 at 16:18)</a>:</h4>
<p>It can also be used to represent fallible operations, but this is used less in mathlib than in other programming languages, because we also have a couple other alternative representations. I usually use the term "partial function" to refer to a function with a propositional argument, like <code>min'</code></p>



<a name="218941557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941557">(Dec 05 2020 at 16:19)</a>:</h4>
<p>I kind of got the hang of what <code>option</code> does, but I felt that the API was too much oriented to be parsed by a computer scientist, than by a mathematician.  This is why I realize that it was my fault for "not getting it"...</p>



<a name="218941558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941558">(Dec 05 2020 at 16:19)</a>:</h4>
<p><code>A -&gt; option B</code> means that the function is fallible but it can also tell you when it failed</p>



<a name="218941624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941624">(Dec 05 2020 at 16:20)</a>:</h4>
<p><code>A -&gt; roption B</code> means that the function is fallible but it can't determine the success condition</p>



<a name="218941646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941646">(Dec 05 2020 at 16:21)</a>:</h4>
<p><code>\all x : A, p x -&gt; B</code> means that the function always returns a proper result but it has a precondition <code>p x</code> so it is partial in the mathematical sense</p>



<a name="218941651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941651">(Dec 05 2020 at 16:21)</a>:</h4>
<p>(I have been reading a book suggested by Kevin, Learn you a Haskell, which clarified a lot of basic Lean for me.  I understood the idea behind <code>option</code> it just always felt like a dead-end when I had that some hypothesis was an <code>option.get_or_else ...</code>, since I knew none of the API to convert it to something else.</p>



<a name="218941704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941704">(Dec 05 2020 at 16:22)</a>:</h4>
<p>it is a pretty programmer friendly side of things, but it's definitely useful for pure maths as well</p>



<a name="218941709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941709">(Dec 05 2020 at 16:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/discrete_topology/near/218941624">said</a>:</p>
<blockquote>
<p><code>A -&gt; roption B</code> means that the function is fallible but it can't determine the success condition</p>
</blockquote>
<p>I don't think that I ever encountered a <code>roption</code>, or, if I did, I skimmed it so quickly, that I pretended it was an <code>option</code>!</p>



<a name="218941712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941712">(Dec 05 2020 at 16:22)</a>:</h4>
<p><code>enat</code> is defined in terms of <code>roption</code></p>



<a name="218941728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941728">(Dec 05 2020 at 16:23)</a>:</h4>
<p>...and that's exactly the reason we didn't have valuations on a DVR for several months :-)</p>



<a name="218941731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941731">(Dec 05 2020 at 16:23)</a>:</h4>
<p>It is classically equivalent to <code>option</code></p>



<a name="218941737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941737">(Dec 05 2020 at 16:23)</a>:</h4>
<p>you probably want to prefer <code>option</code> for most things</p>



<a name="218941741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941741">(Dec 05 2020 at 16:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/discrete_topology/near/218941704">said</a>:</p>
<blockquote>
<p>it is a pretty programmer friendly side of things, but it's definitely useful for pure maths as well</p>
</blockquote>
<p>Undoubtedly!  For instance, the notion of <code>monoid_with_zero</code> is something that is probably lurking in the back of every mathematician, but I had never really formalized it in my head and seeing it written down really added depth to my understanding of mathematics!</p>



<a name="218941810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941810">(Dec 05 2020 at 16:24)</a>:</h4>
<p>Yeah, <code>monoid_with_zero</code> makes me really happy. Stuff like units of a ring and UFDs and IDs are all defined using only <code>*</code> and not <code>+</code>, but because we only use them for rings we don't ever really think about the <code>*</code>-only side of the story.</p>



<a name="218941819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941819">(Dec 05 2020 at 16:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/discrete_topology/near/218941731">said</a>:</p>
<blockquote>
<p>It is classically equivalent to <code>option</code></p>
</blockquote>
<p>Ok, this makes sense!  To be honest, even though I consider myself as a mathematician, I am not so much against constructive mathematics as other mathematicians are..</p>



<a name="218941828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941828">(Dec 05 2020 at 16:25)</a>:</h4>
<p>you wait until you start trying to use <code>roption</code>.</p>



<a name="218941839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941839">(Dec 05 2020 at 16:26)</a>:</h4>
<p>Although Mario's comment above just taught me a useful way of thinking about it!</p>



<a name="218941876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941876">(Dec 05 2020 at 16:26)</a>:</h4>
<p>The idea is that it represents "unending computations", for example the return value of a turing machine or other enumerable search procedure</p>



<a name="218941893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941893">(Dec 05 2020 at 16:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/discrete_topology/near/218941646">said</a>:</p>
<blockquote>
<p><code>\all x : A, p x -&gt; B</code> means that the function always returns a proper result but it has a precondition <code>p x</code> so it is partial in the mathematical sense</p>
</blockquote>
<p>This simple observation actually clears up some of the confusion in my mind!!</p>



<a name="218941907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941907">(Dec 05 2020 at 16:27)</a>:</h4>
<p>Because I'm so used to just saying "if it terminates then x, else y" and not really caring about whether there's an algorithm, this is why I've had option and roption conflated in my head forever.</p>



<a name="218941915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941915">(Dec 05 2020 at 16:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/discrete_topology/near/218941728">said</a>:</p>
<blockquote>
<p>...and that's exactly the reason we didn't have valuations on a DVR for several months :-)</p>
</blockquote>
<p>I feel your pain!  And probably, I feel it much less than you did!</p>



<a name="218941921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941921">(Dec 05 2020 at 16:27)</a>:</h4>
<p>computationally, you can't shoehorn this into <code>option</code> even though logically it is, because an <code>option</code> would require you to determine if the value is <code>some</code>  or <code>none</code>, which is basically the halting problem</p>



<a name="218941978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941978">(Dec 05 2020 at 16:28)</a>:</h4>
<p>Right, but for someone who opens their files with <code>open_locale classical</code> and then says "if this happens then do that, else do something else", you quickly lose track of what is easy to decide in practice.</p>



<a name="218941982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941982">(Dec 05 2020 at 16:28)</a>:</h4>
<p>Also, <code>roption</code> has an interesting topology different from <code>option</code></p>



<a name="218941987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941987">(Dec 05 2020 at 16:28)</a>:</h4>
<p>yeah that's pretty insane</p>



<a name="218941998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218941998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218941998">(Dec 05 2020 at 16:29)</a>:</h4>
<p><code>option</code> adds the point discretely separate from everything else, while <code>roption</code> is the one point compactification</p>



<a name="218942014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218942014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218942014">(Dec 05 2020 at 16:29)</a>:</h4>
<p>and the continuous map is the constructive one, right?</p>



<a name="218942019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218942019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218942019">(Dec 05 2020 at 16:29)</a>:</h4>
<p>right</p>



<a name="218942097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218942097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218942097">(Dec 05 2020 at 16:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/discrete_topology/near/218941876">said</a>:</p>
<blockquote>
<p>The idea is that it represents "unending computations", for example the return value of a turing machine or other enumerable search procedure</p>
</blockquote>
<p>In a module that I taught, I presented part of Hilbert's 10th problem and developed a soft spot for the circle of ideas around termination of algorithms.  Also, since I started doing mathematics as an algebraic geometer over an algebraically closed field, it was difficult to come across natural concepts that do not have a decidable first order theory.  Seeing number theory really opened to door for the possibility of knowing something, but not being able to compute it!</p>



<a name="218942269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218942269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218942269">(Dec 05 2020 at 16:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/discrete_topology/near/218941982">said</a>:</p>
<blockquote>
<p>Also, <code>roption</code> has an interesting topology different from <code>option</code></p>
</blockquote>
<p>I am only beginning to see glimpses of this "topological side" to type theory right now, but this observation (and the one about the disjoint point or the one point compactification) are really helpful!  Thanks for these insights!</p>



<a name="218942428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218942428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218942428">(Dec 05 2020 at 16:38)</a>:</h4>
<p>There are two interpretations of "every constructible function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi><mo>→</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}\to\mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> is continuous" -- one is "hey that's a really cool property of constructibility" and the other is "constructive maths is crazy". I veer from one to the other!</p>



<a name="218942536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218942536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218942536">(Dec 05 2020 at 16:40)</a>:</h4>
<p>Wait, really every constructible function is continuous?  What about the characteristic function of 0? Is this not constructible?  Is it continuous at 0?</p>



<a name="218942545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218942545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218942545">(Dec 05 2020 at 16:40)</a>:</h4>
<p>You can't determine if a real number is zero computably</p>



<a name="218942558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218942558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218942558">(Dec 05 2020 at 16:41)</a>:</h4>
<p>Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> be an explicit elliptic curve over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi></mrow><annotation encoding="application/x-tex">\mathbb{Q}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.85556em;vertical-align:-0.16667em;"></span><span class="mord"><span class="mord mathbb">Q</span></span></span></span></span> with rank 4. Is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo stretchy="false">(</mo><mi>E</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">L''(E,1)=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>?</p>



<a name="218942563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218942563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218942563">(Dec 05 2020 at 16:41)</a>:</h4>
<p>There is no elliptic curve of rank 4 for which the value of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo stretchy="false">(</mo><mi>E</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L''(E,1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> is known!</p>



<a name="218942565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218942565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218942565">(Dec 05 2020 at 16:41)</a>:</h4>
<p>or the sum of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><msup><mi>i</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">1/i^2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> over all odd perfect numbers <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span></p>



<a name="218942639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218942639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218942639">(Dec 05 2020 at 16:43)</a>:</h4>
<p>With these comments, I am tempted to strengthen the above statement to  "every constructible function \mathbb{R}\to\mathbb{R}R→R is constant", or even  "there are no constructible functions \mathbb{R}\to\mathbb{R}"!</p>



<a name="218942647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218942647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218942647">(Dec 05 2020 at 16:43)</a>:</h4>
<p>the identity function is computable</p>



<a name="218942662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218942662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218942662">(Dec 05 2020 at 16:44)</a>:</h4>
<p>... but maybe it is constructibly constant... hahaha</p>



<a name="218942701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218942701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218942701">(Dec 05 2020 at 16:44)</a>:</h4>
<p>(In case this was not clear, I am joking! <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> )</p>



<a name="218942705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218942705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218942705">(Dec 05 2020 at 16:45)</a>:</h4>
<p>more generally, most explicitly given continuous functions are computable, like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>sin</mi><mo>⁡</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\sin x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>x</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="padding-left:0.833em;">x</span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg height="1.08em" preserveAspectRatio="xMinYMin slice" viewBox="0 0 400000 1080" width="400em"><path d="M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span> (with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x\ge 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> as precondition)</p>



<a name="218942721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218942721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218942721">(Dec 05 2020 at 16:45)</a>:</h4>
<p>here computable just means that you can calculate the value out to n decimal places in finite time</p>



<a name="218942791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218942791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218942791">(Dec 05 2020 at 16:47)</a>:</h4>
<p>I see, so the issue with continuity is that, for instance, at a point of a jump discontinuity you would not know on which of the two branches you would be with enough precision to know which value to choose?</p>



<a name="218943093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218943093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218943093">(Dec 05 2020 at 16:55)</a>:</h4>
<p>right</p>



<a name="218943141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218943141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218943141">(Dec 05 2020 at 16:56)</a>:</h4>
<p>there will be some finite <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> where no amount of precision <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span></span> on the input is good enough to resolve the answer</p>



<a name="218943211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218943211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218943211">(Dec 05 2020 at 16:58)</a>:</h4>
<p>Thanks for the explanation!</p>



<a name="218981141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218981141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218981141">(Dec 06 2020 at 10:54)</a>:</h4>
<p>I really like the new version: thank you again <span class="user-mention" data-user-id="110031">@Patrick Massot</span> !</p>
<p>In the process of cleaning up, I decided to add the lemma the Reid Barton suggested as well and something strange happened: I end up with having to prove the same goal twice, after applying <code>convert</code>.  Why is that?  Below I repeat all the code above, but the question is really about the last proof.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.metric_space.basic</span>
<span class="kn">import</span> <span class="n">data.polynomial.ring_division</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="kn">namespace</span> <span class="n">topological_space</span>

<span class="kd">lemma</span> <span class="n">forall_open_iff_discrete</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">,</span> <span class="n">is_open</span> <span class="n">s</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">discrete_topology</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">U</span> <span class="bp">;</span> <span class="k">show</span> <span class="n">is_open</span> <span class="n">U</span> <span class="bp">↔</span> <span class="n">true</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span> <span class="n">U</span><span class="o">]</span> <span class="o">}⟩,</span>
 <span class="kd">by</span> <span class="n">introsI</span> <span class="bp">;</span> <span class="n">exact</span> <span class="n">is_open_discrete</span> <span class="n">_</span><span class="o">⟩</span>


<span class="kd">lemma</span> <span class="n">singletons_open_iff_discrete</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">is_open</span> <span class="o">({</span><span class="n">a</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">))</span> <span class="bp">↔</span> <span class="n">discrete_topology</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">eq_bot_of_singletons_open</span> <span class="n">h</span><span class="o">⟩,</span> <span class="kd">by</span> <span class="n">introsI</span> <span class="bp">;</span> <span class="n">exact</span> <span class="n">is_open_discrete</span> <span class="n">_</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">subset_singleton_iff</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">mem_singleton_iff.mp</span> <span class="o">(</span><span class="n">h</span> <span class="n">hy</span><span class="o">),</span>
 <span class="bp">λ</span> <span class="n">h</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">mem_singleton_iff.mpr</span> <span class="o">(</span><span class="n">h</span> <span class="n">y</span> <span class="n">hy</span><span class="o">)⟩</span>

<span class="kn">open</span> <span class="n">metric</span>

<span class="kd">lemma</span> <span class="n">metric.is_open_singleton_iff</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">is_open</span> <span class="o">({</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">dist</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">is_open_iff</span><span class="o">,</span> <span class="n">subset_singleton_iff</span><span class="o">,</span> <span class="n">mem_ball</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">compl_singleton_eq_bUnion_singleton</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">({</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">ᶜ</span> <span class="bp">=</span> <span class="bp">⋃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">≠</span> <span class="n">x</span><span class="o">),</span> <span class="o">{</span><span class="n">y</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">y</span><span class="o">,</span>  <span class="n">simp</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">discrete_of_t1_of_finite</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">t1_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">discrete_topology</span> <span class="n">X</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">singletons_open_iff_discrete</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">is_closed_compl_iff</span><span class="o">,</span> <span class="n">compl_singleton_eq_bUnion_singleton</span> <span class="n">x</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">is_closed_bUnion</span> <span class="o">(</span><span class="n">finite.of_fintype</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="n">_</span><span class="o">,</span> <span class="n">is_closed_singleton</span><span class="o">)</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">metric.discrete_of_finite</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="n">X</span> <span class="o">:=</span>
<span class="n">discrete_of_t1_of_finite</span>

<span class="kd">lemma</span> <span class="n">discrete_of_finite</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">discrete_topology</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">//</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}</span> <span class="o">:=</span>
<span class="n">discrete_of_t1_of_finite</span>

<span class="kd">end</span> <span class="n">topological_space</span>

<span class="kd">lemma</span> <span class="n">roots_discrete</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">//</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">f.roots.to_finset</span><span class="o">}</span> <span class="o">:=</span>
<span class="n">topological_space.discrete_of_t1_of_finite</span>

<span class="kd">lemma</span> <span class="n">polynomial_eval_zero_discrete</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">discrete_topology</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">//</span> <span class="n">f.eval</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="n">roots_discrete</span> <span class="n">f</span><span class="bp">;</span>  <span class="c1">--creates two identical goals, each of which is solved by the commands below</span>
  <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">multiset.mem_to_finset</span><span class="o">,</span> <span class="o">(</span><span class="n">polynomial.mem_roots</span> <span class="n">hf</span><span class="o">),</span> <span class="n">polynomial.is_root.def</span><span class="o">]</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218984466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218984466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218984466">(Dec 06 2020 at 12:21)</a>:</h4>
<p>I'm happy that you like it. It's good to remember that formalizating is not only playing a computer game where you fight a weird programming language. There is actual mathematical content that can be very satisfying.</p>



<a name="218984571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218984571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218984571">(Dec 06 2020 at 12:24)</a>:</h4>
<p>Your new question is definitely more on the weird computer game side. In the type of <code>roots_discrete f</code>, the set (or finset) that is not quite the announced one appear twice: one appearance is clear, the second one is hidden in the topological space structure that <code>discrete_topology</code> needs. So <code>convert</code> bumps into both and is somehow not smart enough to clean up afterwards. This is definitely a technological issue, there should be a better version of convert.</p>



<a name="218989045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218989045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218989045">(Dec 06 2020 at 14:27)</a>:</h4>
<p>Ok, thanks for the explanation!  I agree that the double appearance of an identical goal is not too important.  Still, I am happy with the explanation!</p>
<p>Should I make a pull request with your arguments?  :). Or is it too trivial for mathlib?</p>



<a name="218990541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218990541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218990541">(Dec 06 2020 at 15:02)</a>:</h4>
<p>I don't think this is likely to change, as <code>congr</code> is the responsible party and it has no maintainer atm</p>



<a name="218992162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218992162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218992162">(Dec 06 2020 at 15:46)</a>:</h4>
<p>Ok, although I meant to have the stuff about discrete topological spaces PR'ed</p>



<a name="218996612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218996612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218996612">(Dec 06 2020 at 17:49)</a>:</h4>
<p>There are two interleaved discussion here. Mario, I think <code>convert</code> (and <code>congr'</code>) could do a post-processing pass getting rid of duplicate goals, probably testing only for syntactic equality of goals to keep performance under control. Obviously this isn't very high priority. Damiano, please PR all that, it clearly deserves to get in.</p>



<a name="218996750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218996750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218996750">(Dec 06 2020 at 17:54)</a>:</h4>
<p>Actually, that should probably be a tactic on its own</p>



<a name="218996789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218996789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218996789">(Dec 06 2020 at 17:54)</a>:</h4>
<p>which perhaps is used as a post processing step in <code>convert</code></p>



<a name="218996810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/218996810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#218996810">(Dec 06 2020 at 17:55)</a>:</h4>
<p>We could even run it only if convert is given some flag, this would keep performance in existing cases.</p>



<a name="219003640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/219003640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#219003640">(Dec 06 2020 at 19:48)</a>:</h4>
<p>Ok, I will do the PR, either tomorrow or on Monday!</p>
<p>Regardless of the issue with the duplicate goal, I might introduce the conversion of the "finset" as a separate lemma, and then <code>rw</code> instead of <code>convert</code>.</p>



<a name="219006110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/219006110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#219006110">(Dec 06 2020 at 20:01)</a>:</h4>
<p>Yes, I also wanted to write this and then I forgot.</p>



<a name="219041675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/219041675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#219041675">(Dec 07 2020 at 04:44)</a>:</h4>
<p>Hopefully, this is one of the last details in this thread.  I tried to find a good home for the lemmas and below is what I came up with.  I am missing a good fit for the last two results.  Any suggestions?</p>
<p>Thanks!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.metric_space.basic</span>
<span class="kn">import</span> <span class="n">data.polynomial.ring_division</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="sd">/-- to data.set.basic -/</span>
<span class="kd">lemma</span> <span class="n">subset_singleton_iff</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">mem_singleton_iff.mp</span> <span class="o">(</span><span class="n">h</span> <span class="n">hy</span><span class="o">),</span>
 <span class="bp">λ</span> <span class="n">h</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">mem_singleton_iff.mpr</span> <span class="o">(</span><span class="n">h</span> <span class="n">y</span> <span class="n">hy</span><span class="o">)⟩</span>

<span class="sd">/-- to data.set.basic -/</span>
<span class="kd">lemma</span> <span class="n">compl_singleton_eq_bUnion_singleton</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">({</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">ᶜ</span> <span class="bp">=</span> <span class="bp">⋃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">≠</span> <span class="n">x</span><span class="o">),</span> <span class="o">{</span><span class="n">y</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">y</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">exists_prop</span><span class="o">,</span> <span class="n">mem_Union</span><span class="o">,</span> <span class="n">mem_singleton_iff</span><span class="o">,</span> <span class="n">exists_eq_right'</span><span class="o">,</span> <span class="n">mem_compl_eq</span><span class="o">]}</span>

<span class="sd">/-- to topology.order -/</span>
<span class="kd">lemma</span> <span class="n">forall_open_iff_discrete</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">,</span> <span class="n">is_open</span> <span class="n">s</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">discrete_topology</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">U</span> <span class="o">,</span> <span class="k">show</span> <span class="n">is_open</span> <span class="n">U</span> <span class="bp">↔</span> <span class="n">true</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span> <span class="n">U</span><span class="o">]</span> <span class="o">}⟩,</span>
 <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">@</span><span class="n">is_open_discrete</span> <span class="n">_</span> <span class="n">_</span> <span class="n">a</span><span class="o">⟩</span>

<span class="sd">/-- to topology.order -/</span>
<span class="kd">lemma</span> <span class="n">singletons_open_iff_discrete</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">is_open</span> <span class="o">({</span><span class="n">a</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">))</span> <span class="bp">↔</span> <span class="n">discrete_topology</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">eq_bot_of_singletons_open</span> <span class="n">h</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">_</span><span class="o">,</span> <span class="bp">@</span><span class="n">is_open_discrete</span> <span class="n">_</span> <span class="n">_</span> <span class="n">a</span> <span class="n">_</span><span class="o">⟩</span>

<span class="sd">/-- to topology.separation -/</span>
<span class="kd">lemma</span> <span class="n">discrete_of_t1_of_finite</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">t1_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">discrete_topology</span> <span class="n">X</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">singletons_open_iff_discrete.mp</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">is_closed_compl_iff</span><span class="o">,</span> <span class="n">compl_singleton_eq_bUnion_singleton</span> <span class="n">x</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">is_closed_bUnion</span> <span class="o">(</span><span class="n">finite.of_fintype</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="n">_</span><span class="o">,</span> <span class="n">is_closed_singleton</span><span class="o">)</span>
<span class="kd">end</span>

<span class="kn">open</span> <span class="n">metric</span>

<span class="sd">/-- to topology.metric_space.basic -/</span>
<span class="kd">lemma</span> <span class="n">metric.is_open_singleton_iff</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">is_open</span> <span class="o">({</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">dist</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">is_open_iff</span><span class="o">,</span> <span class="n">subset_singleton_iff</span><span class="o">,</span> <span class="n">mem_ball</span><span class="o">]</span>

<span class="sd">/-- to topology.metric_space.basic -/</span>
<span class="kd">lemma</span> <span class="n">metric.discrete_of_fintype</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="n">X</span> <span class="o">:=</span>
<span class="n">discrete_of_t1_of_finite</span>

<span class="sd">/-- to topology.metric_space.basic -/</span>
<span class="kd">lemma</span> <span class="n">metric.discrete_of_finite</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">discrete_topology</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">//</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}</span> <span class="o">:=</span>
<span class="n">discrete_of_t1_of_finite</span>

<span class="sd">/-- to data.polynomial.ring_division -/</span>
<span class="kd">lemma</span> <span class="n">polynomial.eval_zero_eq_roots</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">polynomial.eval</span> <span class="n">a</span> <span class="n">f</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">f.roots.to_finset</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">multiset.mem_to_finset</span><span class="o">,</span> <span class="o">(</span><span class="n">polynomial.mem_roots</span> <span class="n">hf</span><span class="o">),</span> <span class="n">polynomial.is_root.def</span><span class="o">]</span> <span class="o">}</span>

<span class="sd">/-- I could not find a good home for these last two results</span>
<span class="sd">The following result does not require the assumption that `f` be non-zero, as</span>
<span class="sd">`0.roots` is defined to be `∅`.</span>
<span class="sd">-/</span>
<span class="kd">lemma</span> <span class="n">roots_discrete</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">//</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">f.roots.to_finset</span><span class="o">}</span> <span class="o">:=</span>
<span class="n">discrete_of_t1_of_finite</span>

<span class="kd">lemma</span> <span class="n">polynomial_eval_zero_discrete</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">discrete_topology</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">//</span> <span class="n">f.eval</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">polynomial.eval_zero_eq_roots</span> <span class="n">hf</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">roots_discrete</span> <span class="n">f</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="219428359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/219428359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#219428359">(Dec 10 2020 at 03:28)</a>:</h4>
<p>Dear All,</p>
<p>I just created <a href="https://github.com/leanprover-community/mathlib/issues/5298">#5298</a> adding almost all these lemmas in their appropriate places!</p>
<p>Lean is now building it and we'll see what it does not like!</p>



<a name="219433275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/219433275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#219433275">(Dec 10 2020 at 05:20)</a>:</h4>
<p>I left some comments.</p>



<a name="219440115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/219440115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#219440115">(Dec 10 2020 at 07:49)</a>:</h4>
<p>Thank you very much for your comments!  I have implemented all of them, except the very last one.  I left a more expanded comment in the PR.</p>
<p>Thanks again!<br>
<span aria-label="pray" class="emoji emoji-1f64f" role="img" title="pray">:pray:</span></p>



<a name="219440403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/219440403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#219440403">(Dec 10 2020 at 07:54)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> thanks a lot for doing this <span aria-label="thumbs up" class="emoji emoji-1f44d" role="img" title="thumbs up">:thumbs_up:</span></p>



<a name="219566396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/discrete_topology/near/219566396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/discrete_topology.html#219566396">(Dec 11 2020 at 05:06)</a>:</h4>
<p>Thank you all to those who contributed to cleaning up and polishing the PR: this is now in mathlib!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
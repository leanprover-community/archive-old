---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html">Transporting across an isomorphism</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="203309826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203309826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Devon Tuma <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203309826">(Jul 08 2020 at 19:14)</a>:</h4>
<p>I've been trying to start learning Lean by formalizing Jacobson rings, and one theorem I wanted to use was along the lines of  <code>is_jacobson_iff_iso (e : S ≃+* R) : is_jacobson S ↔ is_jacobson R</code> where S and R are two commutative rings. I ended up just writing out a a direct proof using the definitions with maps and comaps of ideals, but I was wondering if there was a nicer way to do a proof like this in Lean? Or is a ring equivalence not "strong" enough for this?</p>



<a name="203311507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203311507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203311507">(Jul 08 2020 at 19:29)</a>:</h4>
<p>I wonder if this is because this <em>is</em> the statement that being a Jacobson ring is an invariant of rings up to isomorphism, and that needs proof.  It would be cool if there were a tactic to automatically construct a proof for you if you only used the ring axioms in the statement of some property.</p>



<a name="203312424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203312424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203312424">(Jul 08 2020 at 19:37)</a>:</h4>
<p>This is a big open problem in lean really, there are some tactics like <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#equiv_rw">tactic#equiv_rw</a> and <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#transport">tactic#transport</a> but they aren't at the stage where they can handle these goals with no input from the user as far as I can tell.<br>
You can't just rewrite along an equiv so in that sense an equiv is not strong enough in lean (compared to equality), but as the proof steps should all be somewhat automatic a lot of us hope that there does exist a tactic to finish these goals easily, just nobody has written a bulletproof one yet!</p>



<a name="203313082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203313082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203313082">(Jul 08 2020 at 19:42)</a>:</h4>
<p>This should be solvable by a tactic yes, and we'll get there in the end :-)</p>



<a name="203313333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203313333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203313333">(Jul 08 2020 at 19:45)</a>:</h4>
<p>In this particular case, Mario's law applies I think. A homomorphic image of a Jacobson ring is a Jacobson ring I guess, and probably this needs a proof. The isomorphism statement follows from this.</p>



<a name="203313484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203313484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203313484">(Jul 08 2020 at 19:46)</a>:</h4>
<p>Mario argues that many cases of this rewriting along equivalence principle follow from stronger results which aren't tautological to a mathematician and need to be proved anyway. This breaks down for various 1-dimensional properties such as PID though</p>



<a name="203313550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203313550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203313550">(Jul 08 2020 at 19:47)</a>:</h4>
<p>Aah but not for PIR, interestingly enough</p>



<a name="203314279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203314279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Devon Tuma <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203314279">(Jul 08 2020 at 19:53)</a>:</h4>
<p>Yes in this case the actual proof isn't too bad to just write so its not a huge issue, but thanks for this info on the general state of things like this. Using tactics for proofs like this is new to me coming from a background in just Agda, and I hadn't considered they could prove bigger things like this.</p>
<p>I hadn't thought about proving this for the homomorphic image first and then specializing that to the isomorphic case, that seems like a nice way to make the proof cleaner.</p>



<a name="203314806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203314806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203314806">(Jul 08 2020 at 19:57)</a>:</h4>
<p>My rough understanding of an underlying issue is that you need some sort of coherence law to be able to do rewrites.  For example, you might have some loop of equivalences whose composition is some nontrivial automorphism, and if you rewrite only portions of a term using an equivalence, you're liable to obtain absurd conclusions.  Equality in lean has the property that any such loop gives the trivial automorphism, due to proof irrelevance in <code>Prop</code>.</p>
<p>There's a nonconstructive way to rewrite across isomorphisms, I think.  You can choose (probably by the axiom of choice somehow) a canonical isomorphism between every pair of objects in an isomorphism class in such a way that any loop of compositions is the identity, and then you should be able to do rewrites with respect to these specific isomorphisms for terms involving only the axioms of the objects under question.  I have no intuition about whether you can actually do anything useful with this, though.  But, at least for the <code>is_jacobson</code> example, all the terms are in the theory of rings so the isomorphism implies there is a canonical isomorphism, and so you would be able to rewrite <code>is_jacobson S</code> to <code>is_jacobson R</code> to get a tautology.</p>



<a name="203315042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203315042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203315042">(Jul 08 2020 at 19:59)</a>:</h4>
<p>What if R=S and e isn't the identity?</p>



<a name="203315842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203315842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203315842">(Jul 08 2020 at 20:04)</a>:</h4>
<p>You wouldn't rewrite using e itself.  You'd use the fact it exists to nonconstructively obtain the canonical isomorphism R to S (and these isomorphisms are chosen so that any loop of compositions is the identity).  If R = S, then this canonical automorphism is the identity.</p>



<a name="203315865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203315865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Devon Tuma <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203315865">(Jul 08 2020 at 20:05)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>  Ah, I assume that means Lean does not have any sort of UIP axiom or axiom K for types? So outside of Prop there can be multiple different equivalences between two types, which gives these "nontrivial automorphisms" between types?</p>



<a name="203316133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203316133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203316133">(Jul 08 2020 at 20:07)</a>:</h4>
<p>There certainly can be multiple different equivs between two types.</p>



<a name="203316142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203316142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203316142">(Jul 08 2020 at 20:07)</a>:</h4>
<p>I don't know these axioms, but at least the way <code>equiv</code> is defined in Lean, which is a pair of maps that are left and right inverses to each other, there can certainly be many equivalences between non-<code>Prop</code> types.</p>



<a name="203316215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203316215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203316215">(Jul 08 2020 at 20:07)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> I have no idea what you would mean with choosing a <code>canonical</code> isomorphism...</p>



<a name="203316235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203316235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203316235">(Jul 08 2020 at 20:07)</a>:</h4>
<p>Is it just whatever <code>classical.choice</code> spits out?</p>



<a name="203316299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203316299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203316299">(Jul 08 2020 at 20:08)</a>:</h4>
<p>I don't think you can prove that it is the identity in the case of <code>R = S</code>.</p>



<a name="203316369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203316369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203316369">(Jul 08 2020 at 20:08)</a>:</h4>
<p>Equality of types is an extremely awkard notion to prove things about.</p>



<a name="203316424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203316424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203316424">(Jul 08 2020 at 20:09)</a>:</h4>
<p>You'd have to set up your statement carefully, which I'm not sure how to do right now.  It's "canonical" in the same sense that every module has a "canonical" projective resolution.</p>



<a name="203316670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203316670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203316670">(Jul 08 2020 at 20:11)</a>:</h4>
<p>I'm only more confused now...</p>



<a name="203316780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203316780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203316780">(Jul 08 2020 at 20:12)</a>:</h4>
<p>If I have two isomorphic rings <code>R</code> and <code>S</code>, I don't have any idea what could be meant be the "canonical" isomorphism between <code>R</code> and <code>S</code>...</p>



<a name="203316818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203316818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203316818">(Jul 08 2020 at 20:12)</a>:</h4>
<p>Informally, I was imagining taking a representative object from each isomorphism class, and for every other object choose some isomorphism to the representative object.  Then, every pair of objects in the isomorphism class would have a "canonical" isomorphism between them by the unique composition of chosen isomorphisms.</p>



<a name="203317017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203317017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203317017">(Jul 08 2020 at 20:14)</a>:</h4>
<p>It's a similar sort of solution to the problem of defining derived functors, with a solution being to fix specific projective resolutions for every module.  Sorry, I'm severely misusing the word "canonical."</p>



<a name="203317040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203317040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Devon Tuma <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203317040">(Jul 08 2020 at 20:14)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I can see that there are certainly multiple equivalences between types, but in Lean can you apply univalence to them to also get distinct equalities between types? Or do all type equalities get squashed down to being equal in Lean (or is univalence not even a thing in Lean)?</p>



<a name="203317138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203317138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203317138">(Jul 08 2020 at 20:15)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> But, since you're saying proving things about equalities of types is extremely awkward, this might be completely unworkable.</p>



<a name="203317157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203317157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203317157">(Jul 08 2020 at 20:15)</a>:</h4>
<p>univalence is not a thing in lean</p>



<a name="203317246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203317246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203317246">(Jul 08 2020 at 20:16)</a>:</h4>
<p>UIP and axiom K everywhere</p>



<a name="203318191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203318191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203318191">(Jul 08 2020 at 20:25)</a>:</h4>
<p><span class="user-mention" data-user-id="319772">@Devon Tuma</span> Oh, it looks like "equivalence" has meant two things in this conversation.  Sorry to mislead you that Lean had nontrivial homotopy equivalences between types.</p>



<a name="203318742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203318742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Devon Tuma <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203318742">(Jul 08 2020 at 20:30)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> No worries, I think that was part of what was tripping me up in the first place with a ring equivalence being very different than a homotopy style equivalence between the actual types</p>



<a name="203319922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203319922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203319922">(Jul 08 2020 at 20:39)</a>:</h4>
<p>I believe that what lean calls <code>R ≃+* S</code> is equivalent to what a HoTT system would call an equivalence (or via univalence, equality) of elements of the type <code>Ring</code></p>



<a name="203319991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Transporting%20across%20an%20isomorphism/near/203319991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Transporting.20across.20an.20isomorphism.html#203319991">(Jul 08 2020 at 20:39)</a>:</h4>
<p>so calling them "ring equivalences" is not a misrepresentation</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
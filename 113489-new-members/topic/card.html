---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/card.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html">card</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="246206166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246206166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246206166">(Jul 16 2021 at 10:19)</a>:</h4>
<p>Is there any built-in lemma that picks distinct elements of a given type such as picking three as follows? </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.card</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">I</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">I</span><span class="o">]</span>
<span class="kn">open</span> <span class="n">fintype</span>
<span class="kd">lemma</span> <span class="n">Hadamard_matrix.order_aux1</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">card</span> <span class="n">I</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">card</span> <span class="n">I</span> <span class="bp">≠</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">∃</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span> <span class="bp">∧</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">k</span> <span class="bp">∧</span> <span class="n">j</span> <span class="bp">≠</span> <span class="n">k</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>
<p>My formulation might be bad btw.</p>



<a name="246208397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246208397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246208397">(Jul 16 2021 at 10:48)</a>:</h4>
<p>I would first prove card &gt;= 3 and then dig into the definition of fintype</p>



<a name="246212395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246212395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246212395">(Jul 16 2021 at 11:42)</a>:</h4>
<p>An easier one is perhaps</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.card</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">I</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">I</span><span class="o">]</span>
<span class="kn">open</span> <span class="n">fintype</span>
<span class="kd">lemma</span> <span class="n">ex2</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">card</span> <span class="n">I</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">∃</span> <span class="n">i</span> <span class="n">j</span><span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span><span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">i</span><span class="o">:=</span> <span class="n">classical.arbitrary</span> <span class="n">I</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">I</span><span class="o">,</span>
 <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="246212716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246212716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246212716">(Jul 16 2021 at 11:46)</a>:</h4>
<p>A generalized one</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ex</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">card</span> <span class="n">I</span> <span class="bp">≥</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">I</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">a</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">a</span> <span class="n">j</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="246212778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246212778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246212778">(Jul 16 2021 at 11:47)</a>:</h4>
<p>Are there any relevant or equivalent built-in lemmas to the above ones?</p>



<a name="246213320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246213320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246213320">(Jul 16 2021 at 11:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="408694">Alex Zhang</span> <a href="#narrow/stream/113489-new-members/topic/card/near/246212395">said</a>:</p>
<blockquote>
<p>An easier one is perhaps</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.card</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">I</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">I</span><span class="o">]</span>
<span class="kn">open</span> <span class="n">fintype</span>
<span class="kd">lemma</span> <span class="n">ex2</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">card</span> <span class="n">I</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">∃</span> <span class="n">i</span> <span class="n">j</span><span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span><span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">i</span><span class="o">:=</span> <span class="n">classical.arbitrary</span> <span class="n">I</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">I</span><span class="o">,</span>
 <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I think the case where the size isn't 1 is probably quite a bit easier than the general case</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.card</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">I</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">I</span><span class="o">]</span>
<span class="kn">open</span> <span class="n">fintype</span>
<span class="kd">lemma</span> <span class="n">ex2</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">card</span> <span class="n">I</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">∃</span> <span class="n">i</span> <span class="n">j</span><span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span><span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_contra</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">fintype.card</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">i</span> <span class="o">:</span> <span class="n">I</span> <span class="o">:=</span> <span class="n">classical.arbitrary</span> <span class="n">I</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="bp">=</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">I</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">finset.eq_univ_iff_forall</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">finset.mem_singleton</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">h</span> <span class="o">},</span>
  <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span><span class="n">h2</span><span class="o">]</span>
<span class="kd">end</span>
</code></pre></div>



<a name="246213381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246213381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246213381">(Jul 16 2021 at 11:55)</a>:</h4>
<p><span class="user-mention" data-user-id="266440">@Shing Tak Lam</span>  Do you have any idea about <code>ex3</code> and <code>ex</code>?</p>



<a name="246213598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246213598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246213598">(Jul 16 2021 at 11:58)</a>:</h4>
<p>I will read your proof in detail after a nap.</p>



<a name="246217173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246217173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246217173">(Jul 16 2021 at 12:38)</a>:</h4>
<p>This is quite straightforward:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.card</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">I</span><span class="o">]</span>

<span class="kn">open</span> <span class="n">fintype</span>

<span class="kd">lemma</span> <span class="n">ex1</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">card</span> <span class="n">I</span> <span class="bp">=</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span> <span class="bp">∧</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">k</span> <span class="bp">∧</span> <span class="n">j</span> <span class="bp">≠</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">equiv_fin_of_card_eq</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">f.symm</span> <span class="mi">0</span><span class="o">,</span> <span class="n">f.symm</span> <span class="mi">1</span><span class="o">,</span> <span class="n">f.symm</span> <span class="mi">2</span><span class="o">,</span>
    <span class="n">and.imp</span> <span class="n">f.symm.injective.ne</span> <span class="o">(</span><span class="n">and.imp</span> <span class="n">f.symm.injective.ne</span> <span class="n">f.symm.injective.ne</span><span class="o">)</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="gr">sorry</span> <span class="c1">-- `0 ≠ 1 ∧ 0 ≠ 2 ∧ 1 ≠ 2`, all in `fin 3`</span>
<span class="kd">end</span>
</code></pre></div>
<p>I don't know how to close those fin goals, but they're at least "very obviously true" rather than "handwavingly true"</p>



<a name="246217516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246217516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246217516">(Jul 16 2021 at 12:42)</a>:</h4>
<p><code>dec_trivial</code> works for the <code>sorry</code> there</p>



<a name="246218915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246218915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246218915">(Jul 16 2021 at 12:57)</a>:</h4>
<p><code>equiv_fin_of_card_eq</code> is the lemma I am looking for!!</p>



<a name="246219463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246219463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246219463">(Jul 16 2021 at 13:02)</a>:</h4>
<p>A <code>fin_embedding_of_lt_card</code> would be convenient for your use case</p>



<a name="246219977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246219977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246219977">(Jul 16 2021 at 13:07)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/fin.cast_le_order_iso">docs#fin.cast_le_order_iso</a> would help</p>



<a name="246220130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246220130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246220130">(Jul 16 2021 at 13:08)</a>:</h4>
<p>Maybe something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">trunc_fin_embedding_of_card_eq</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">fintype.card</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">trunc</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">↪</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">trunc_equiv_fin</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="o">(</span><span class="n">fin.cast_le</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">to_embedding.trans</span> <span class="n">e.symm.to_embedding</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">trunc_embedding_fin_of_card_le</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="n">α</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">trunc</span> <span class="o">(</span><span class="n">α</span> <span class="bp">↪</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">trunc_equiv_fin</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">e.to_embedding.trans</span> <span class="o">(</span><span class="n">fin.cast_le</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">to_embedding</span><span class="o">)</span>
</code></pre></div>



<a name="246220288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246220288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246220288">(Jul 16 2021 at 13:10)</a>:</h4>
<p>This is all pretty <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a>. It's easier to just postulate the existence of such elements, then show the cardinality of their finset is le than the cardinality of the fintype.</p>



<a name="246430058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246430058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246430058">(Jul 19 2021 at 08:46)</a>:</h4>
<p>Is there any version of coded lemma stating that the <code>card</code> of the unit group of a finite field <code>F</code> is exactly <code>F.card - 1</code>?<br>
Also not exactly sure what the definition of "the unit group of finite field"  in mathlib will be handy and is supposed to be used. Perhaps <code>units F</code>?</p>



<a name="246430144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246430144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246430144">(Jul 19 2021 at 08:47)</a>:</h4>
<p>You should think about how you want to prove this and write down a step-by-step proof and then formalise it. My advice: stop using natural number subtraction, it just makes your life worse. Rewrite everything as addition.</p>



<a name="246430242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246430242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246430242">(Jul 19 2021 at 08:48)</a>:</h4>
<p>Why not explicitly write an <code>equiv</code> between <code>F</code> and <code>option (units F)</code> and then deduce the addition version from results about card of option?</p>



<a name="246430292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246430292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246430292">(Jul 19 2021 at 08:49)</a>:</h4>
<p><span class="user-mention" data-user-id="408694">@Alex Zhang</span> Did you look at <code>src/field_theory/finite/basic.lean</code>?</p>



<a name="246430633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246430633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246430633">(Jul 19 2021 at 08:53)</a>:</h4>
<p>Ah, I found it! <code>finite_field.card_units</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">finite_field.card_units</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">K</span><span class="o">]</span> <span class="o">:</span>
<span class="n">fintype.card</span> <span class="o">(</span><span class="n">units</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">K</span> <span class="bp">-</span> <span class="mi">1</span>
</code></pre></div>



<a name="246482876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246482876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246482876">(Jul 19 2021 at 17:07)</a>:</h4>
<p>I defined the set of quadratic residues in a finite field F, then I want to prove the card of it is half of the unit group of F, as formalised in the code.<br>
I gave three definitions in the <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> (not quite sure which one is the most convenient for proving this). Could anyone please point me a direction for proving this equality? The way I currently think of is to use some version of <br>
<code>card (im f) * card (kernel f) = card units F</code> as f is a group hom (not sure if it is the correct or a convenient way).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.fintype.card</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kn">import</span> <span class="n">field_theory.finite.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">F</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">char_p</span> <span class="n">F</span> <span class="n">p</span><span class="o">]</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">F</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">f</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">quad_residues</span> <span class="o">:</span> <span class="n">set</span> <span class="n">F</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="bp">''</span> <span class="o">((</span><span class="bp">@</span><span class="n">set.univ</span> <span class="n">F</span><span class="o">)</span> <span class="bp">\</span> <span class="o">{</span><span class="mi">0</span><span class="o">})</span>

<span class="c1">-- alternative defns</span>
<span class="kd">def</span> <span class="n">quad_residues'</span> <span class="o">:=</span> <span class="o">{</span><span class="n">b</span> <span class="bp">//</span> <span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">}</span>
<span class="kd">def</span> <span class="n">quad_residues''</span> <span class="o">:=</span> <span class="o">{</span><span class="n">b</span> <span class="bp">//</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">units</span> <span class="n">F</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">quad_residues</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">p</span> <span class="bp">≠</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">quad_residues</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset.card</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">F</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="246484050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246484050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246484050">(Jul 19 2021 at 17:16)</a>:</h4>
<p>Is it possible to construct an explicit isomorphism, even if it is noncomputable?</p>



<a name="246484309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246484309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246484309">(Jul 19 2021 at 17:18)</a>:</h4>
<p>You could define <code>is_quad_residue</code> as a Prop, and use that in a <code>finset.filter</code> instead.</p>



<a name="246484529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246484529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246484529">(Jul 19 2021 at 17:20)</a>:</h4>
<p>Would this def be helpful for proving the equality?</p>



<a name="246486095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246486095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246486095">(Jul 19 2021 at 17:32)</a>:</h4>
<p>Ah, I found the defn of "kernel".  <a href="https://leanprover-community.github.io/mathlib_docs/group_theory/subgroup.html#monoid_hom.ker">https://leanprover-community.github.io/mathlib_docs/group_theory/subgroup.html#monoid_hom.ker</a><br>
and I will leave for dinner for now.</p>



<a name="246494203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246494203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246494203">(Jul 19 2021 at 18:33)</a>:</h4>
<p>How about this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.fintype.card</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kn">import</span> <span class="n">field_theory.finite.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">is_quad_res</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">),</span> <span class="n">y</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">F</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">char_p</span> <span class="n">F</span> <span class="n">p</span><span class="o">]</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">p</span> <span class="bp">≠</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="n">is_quad_res</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">F</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="kd">end</span>
</code></pre></div>



<a name="246494315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246494315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246494315">(Jul 19 2021 at 18:34)</a>:</h4>
<p>Is this correct?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">(</span><span class="n">F</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">sq_hom</span> <span class="o">:</span> <span class="n">units</span> <span class="n">F</span> <span class="bp">→*</span> <span class="n">units</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="n">mul_left_comm</span><span class="o">]⟩</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">F</span><span class="o">}</span>
<span class="kd">lemma</span> <span class="n">sq_hom_res_iff</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">char_p</span> <span class="n">F</span> <span class="n">p</span><span class="o">]</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">units</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">sq_hom</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">ker</span> <span class="bp">↔</span> <span class="n">is_quad_res</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="246497381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246497381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246497381">(Jul 19 2021 at 18:57)</a>:</h4>
<p><code>example (h: p ≠ 2) : ((finset.univ : finset F).filter is_quad_res).card = fintype.card F - 1 :=</code><br>
should be <br>
<code>example (h: p ≠ 2) : ((finset.univ : finset F).filter is_quad_res).card  * 2 = fintype.card F - 1 :=</code></p>



<a name="246497396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246497396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246497396">(Jul 19 2021 at 18:57)</a>:</h4>
<p>No. The squaring function has a kernel and an image. The quadratic residues are the stuff in the <em>image</em>. If p&gt;2 then the kernel is +-1 which has size 2. Hence the first isomorphism theorem says that twice the size of the image equals the size of the units (Alex' version correctly adds this factor of 2)</p>



<a name="246497642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246497642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246497642">(Jul 19 2021 at 18:59)</a>:</h4>
<p>The units of a finite field are cyclic, although this is not obvious. The quadratic residues are a subgroup, so they must hence be the kernel of the map raising a unit to the power (c-1)/2 where c is the size of the field</p>



<a name="246498087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246498087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246498087">(Jul 19 2021 at 19:02)</a>:</h4>
<p>Yes, Kevin. I am still looking for the first iso thm in mathlib. Do you have any suggestion for proving the card equality? <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span></p>



<a name="246498364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246498364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246498364">(Jul 19 2021 at 19:04)</a>:</h4>
<p>Yes, use the first isomorphism theorem!</p>



<a name="246498983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246498983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246498983">(Jul 19 2021 at 19:08)</a>:</h4>
<p>Yes, sorry for the missing <code>* 2</code> typo. Thanks Kevin for the clarification, I was going through the proof using powers of <code>(p - 1)  / 2</code> and realized that I must have meant image and not kernel.</p>



<a name="246499308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246499308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246499308">(Jul 19 2021 at 19:11)</a>:</h4>
<p>I found the first iso thm: <a href="https://leanprover-community.github.io/mathlib_docs/group_theory/quotient_group.html#quotient_group.quotient_ker_equiv_range">https://leanprover-community.github.io/mathlib_docs/group_theory/quotient_group.html#quotient_group.quotient_ker_equiv_range</a></p>



<a name="246500122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246500122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246500122">(Jul 19 2021 at 19:14)</a>:</h4>
<p>But there are still some gaps to <code>card</code>.</p>



<a name="246501179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246501179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246501179">(Jul 19 2021 at 19:24)</a>:</h4>
<p>Ah, <a href="https://leanprover-community.github.io/mathlib_docs/group_theory/coset.html#subgroup.card_eq_card_quotient_mul_card_subgroup">https://leanprover-community.github.io/mathlib_docs/group_theory/coset.html#subgroup.card_eq_card_quotient_mul_card_subgroup</a><br>
seems to be useful</p>



<a name="246503140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246503140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246503140">(Jul 19 2021 at 19:37)</a>:</h4>
<p>It is weird. Why can't <code>ring</code> close </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.fintype.card</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kn">import</span> <span class="n">field_theory.finite.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">F</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">char_p</span> <span class="n">F</span> <span class="n">p</span><span class="o">]</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">F</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">units</span> <span class="n">F</span><span class="o">)</span> <span class="bp">→*</span> <span class="o">(</span><span class="n">units</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span><span class="n">ring</span><span class="o">})⟩</span>
</code></pre></div>



<a name="246503809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246503809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246503809">(Jul 19 2021 at 19:42)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">sq_hom</span> <span class="o">:</span> <span class="n">units</span> <span class="n">F</span> <span class="bp">→*</span> <span class="n">units</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="n">mul_left_comm</span><span class="o">]⟩</span>
</code></pre></div>



<a name="246503881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246503881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246503881">(Jul 19 2021 at 19:43)</a>:</h4>
<p><code>units F</code> is not a <code>ring</code>.</p>



<a name="246503939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246503939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246503939">(Jul 19 2021 at 19:43)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">sq_hom</span> <span class="o">:</span> <span class="n">units</span> <span class="n">F</span> <span class="bp">→*</span> <span class="n">units</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">units.ext_iff</span><span class="o">]</span><span class="bp">;</span> <span class="n">ring</span><span class="o">⟩</span>
</code></pre></div>



<a name="246507824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246507824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246507824">(Jul 19 2021 at 20:13)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.fintype.card</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kn">import</span> <span class="n">field_theory.finite.basic</span>
<span class="kn">import</span> <span class="n">group_theory.quotient_group</span>


<span class="kd">variables</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">is_quad_res</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">),</span> <span class="n">y</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span>

<span class="kd">lemma</span> <span class="n">is_quad_res.ne_zero</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_quad_res</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">mul_ne_zero</span> <span class="n">hy</span> <span class="n">hy</span>
<span class="kd">end</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">F</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">char_p</span> <span class="n">F</span> <span class="n">p</span><span class="o">]</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">F</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">sq_hom</span> <span class="o">:</span> <span class="n">units</span> <span class="n">F</span> <span class="bp">→*</span> <span class="n">units</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="n">mul_left_comm</span><span class="o">]⟩</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">F</span><span class="o">}</span>
<span class="kd">lemma</span> <span class="n">sq_hom_res_iff</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">units</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">sq_hom</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">range</span> <span class="bp">↔</span> <span class="n">is_quad_res</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">sq_hom</span><span class="o">,</span> <span class="n">is_quad_res</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">monoid_hom.mem_range</span><span class="o">,</span> <span class="n">monoid_hom.coe_mk</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="o">⟨(</span><span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">),</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">units.ne_zero</span><span class="o">,</span> <span class="n">not_false_iff</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span><span class="n">hy</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hn</span><span class="o">,</span> <span class="n">hy</span><span class="o">⟩,</span>
    <span class="k">have</span> <span class="n">key</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">is_unit.mk0</span> <span class="n">y</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">key.unit</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">units.ext_iff</span><span class="o">,</span> <span class="n">key.unit_spec</span><span class="o">,</span> <span class="n">hy</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">@</span><span class="n">is_quad_res</span> <span class="n">F</span> <span class="n">_</span><span class="o">)]</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">p</span> <span class="bp">≠</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="n">is_quad_res</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">F</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">finite_field.card_units</span><span class="o">,</span>
  <span class="c1">-- probably some neater way of constructing this, but who cares</span>
  <span class="k">let</span> <span class="n">iso</span> <span class="o">:</span> <span class="o">((</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="n">is_quad_res</span> <span class="bp">≃</span> <span class="o">(</span><span class="n">sq_hom</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">range</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">equiv.trans</span> <span class="n">_</span> <span class="o">(</span><span class="n">equiv.subtype_equiv_right</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">sq_hom_res_iff</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)),</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">y</span><span class="o">,</span>
      <span class="n">refine</span> <span class="o">⟨(</span><span class="n">is_unit.mk0</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">is_quad_res.ne_zero</span> <span class="n">_</span><span class="o">))</span><span class="bp">.</span><span class="n">unit</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
      <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">y.prop</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">is_unit.unit_spec</span><span class="o">]</span> <span class="n">using</span> <span class="n">y.prop</span> <span class="o">}</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="n">y</span><span class="o">,</span>
      <span class="n">refine</span> <span class="o">⟨((</span><span class="n">y</span> <span class="o">:</span> <span class="n">units</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span><span class="o">),</span> <span class="n">_</span><span class="o">⟩,</span>
      <span class="n">simpa</span> <span class="n">using</span> <span class="n">y.prop</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">is_unit.unit_spec</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">units.ext_iff</span><span class="o">,</span> <span class="n">is_unit.unit_spec</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">((</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="n">is_quad_res</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">sq_hom</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">range</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">fintype.card_coe</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">fintype.card_congr</span> <span class="n">iso</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">eq_comm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">subgroup.card_eq_card_quotient_mul_card_subgroup</span> <span class="o">((</span><span class="n">sq_hom</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">ker</span><span class="o">),</span>
  <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">fintype.card_congr</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">quotient_group.quotient_ker_equiv_range</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">to_equiv</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- The kernel is {1, -1}, prove that elsewhere</span>
    <span class="c1">-- this is actually where the `(h : p ≠ 2)` hypothesis needs to be used</span>
    <span class="gr">sorry</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="246509128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246509128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246509128">(Jul 19 2021 at 20:24)</a>:</h4>
<p>Cool, Yakov! I am also getting to the final part to prove that the <code>card</code> of the kernel is 2. Do you have any idea of proving that? <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span></p>



<a name="246509634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246509634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246509634">(Jul 19 2021 at 20:29)</a>:</h4>
<p>factor the quadratic?</p>



<a name="246509804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246509804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246509804">(Jul 19 2021 at 20:30)</a>:</h4>
<p>Relatedly, a simpler puzzle:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">sq_hom_ker_eq_char_2</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">sq_hom</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">ker</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfreezingI</span> <span class="o">{</span> <span class="n">subst</span> <span class="n">h</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="n">bot_le</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">monoid_hom.mem_ker</span><span class="o">,</span> <span class="n">sq_hom</span><span class="o">,</span> <span class="n">monoid_hom.coe_mk</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subgroup.mem_bot</span><span class="o">],</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="246510099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246510099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246510099">(Jul 19 2021 at 20:33)</a>:</h4>
<p>Thanks a lot for the proof!!</p>



<a name="246512186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246512186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246512186">(Jul 19 2021 at 20:51)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">sq_hom_ker_eq_char_2</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">sq_hom</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">ker</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfreezingI</span> <span class="o">{</span> <span class="n">subst</span> <span class="n">h</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="n">bot_le</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">monoid_hom.mem_ker</span><span class="o">,</span> <span class="n">sq_hom</span><span class="o">,</span> <span class="n">monoid_hom.coe_mk</span><span class="o">,</span> <span class="n">units.ext_iff</span><span class="o">,</span> <span class="n">units.coe_one</span><span class="o">,</span>
             <span class="n">units.coe_mul</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">pow_two</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">fact</span> <span class="o">(</span><span class="n">nat.prime</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">nat.prime_two</span><span class="o">⟩,</span>
  <span class="k">let</span> <span class="n">iso</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">≃+*</span> <span class="n">zmod</span> <span class="mi">2</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">(</span><span class="n">zmod.ring_equiv</span> <span class="n">F</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
    <span class="gr">sorry</span>
  <span class="o">},</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subgroup.mem_bot</span><span class="o">,</span> <span class="n">units.ext_iff</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">iso.injective</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">iso</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">iso.to_monoid_hom</span> <span class="n">z</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span><span class="o">,</span>
    <span class="n">refl</span> <span class="o">},</span>
  <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span><span class="n">hx</span><span class="o">,</span> <span class="n">this</span><span class="o">]</span>
<span class="kd">end</span>
</code></pre></div>



<a name="246512924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246512924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246512924">(Jul 19 2021 at 20:56)</a>:</h4>
<p>Why is the goal at <code>sorry</code> <code>fintype.card F = 2</code>?</p>



<a name="246512929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246512929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246512929">(Jul 19 2021 at 20:56)</a>:</h4>
<p>Are you claiming that every finite field of characteristic 2 has two elements? This is not true.</p>



<a name="246513025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246513025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246513025">(Jul 19 2021 at 20:57)</a>:</h4>
<p>There's a field with elements 0,1,a,b with a^2=a+1=b and b^2=b+1=a. It has characteristic 2 and order 4.</p>



<a name="246513044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246513044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246513044">(Jul 19 2021 at 20:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/card/near/246512929">said</a>:</p>
<blockquote>
<p>Are you claiming that every finite field of characteristic 2 has two elements? This is not true.</p>
</blockquote>
<p>I feel I got back to my third year (or second year) algebra course although I have got very sleepy :)</p>



<a name="246513430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246513430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246513430">(Jul 19 2021 at 21:00)</a>:</h4>
<p>I have not set about proving <code>card ker</code> is 2 myself as I am too sleepy now.</p>



<a name="246513434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246513434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246513434">(Jul 19 2021 at 21:00)</a>:</h4>
<p>I see, apologies for the wrong statement! I have never actually taken algebra at that level, and have been trying to learn it myself.</p>



<a name="246513720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246513720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246513720">(Jul 19 2021 at 21:01)</a>:</h4>
<p>You have already given many helpful answers, Yakov. Many thanks! <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span></p>



<a name="246514009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246514009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246514009">(Jul 19 2021 at 21:02)</a>:</h4>
<p>I was not sure how to get Fermat's Little Theorem to work on arbitrary finite fields, but we have it for <code>zmod p</code>. So I faked it =/</p>



<a name="246514052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246514052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246514052">(Jul 19 2021 at 21:02)</a>:</h4>
<p>Just like you can make the complexes by starting with the reals and throwing in a root of a real quadratic which doesn't have a real root, you can do the same with the field with two elements, throwing in a root of X^2=X+1. This polynomial mod 2 doesn't have 0 or 1 as a root, so throw a root in and you get something 2-dimensional over {0,1}.</p>



<a name="246514250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246514250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246514250">(Jul 19 2021 at 21:03)</a>:</h4>
<p>Fermat's little theorem follows from the theorem in group theory that the order of the element divides the order of the group, applied to the unit group. This does not need the deeper fact that this group is cyclic</p>



<a name="246514434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246514434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246514434">(Jul 19 2021 at 21:04)</a>:</h4>
<p>Ah, of course! I was just formalizing notes from Gross's class about this.</p>



<a name="246574364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246574364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246574364">(Jul 20 2021 at 11:58)</a>:</h4>
<p>I have proved<code> the card of the ker is 2</code>, but have not sorted things out.</p>



<a name="246579977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246579977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246579977">(Jul 20 2021 at 12:58)</a>:</h4>
<p>Did you prove it by explicitly showing that the ker is 1 and -1 for the appropriate p?</p>



<a name="246584221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246584221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246584221">(Jul 20 2021 at 13:33)</a>:</h4>
<p>Yes, doing something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">f_0</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">ker.carrier</span> <span class="bp">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="bp">-</span><span class="mi">1</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">ker</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">f_ker</span><span class="o">,</span> <span class="n">subgroup.comap</span><span class="o">,</span> <span class="n">set.preimage</span><span class="o">,</span> <span class="n">f</span><span class="o">],</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">any_goals</span> <span class="o">{</span><span class="n">intro</span> <span class="n">h</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">units.ext_iff</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h'</span> <span class="o">:</span> <span class="o">((</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">{</span><span class="n">simp</span> <span class="o">[</span><span class="n">add_mul</span><span class="o">,</span> <span class="n">mul_sub</span><span class="o">,</span> <span class="n">h</span><span class="o">],</span> <span class="n">ring</span><span class="o">},</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="n">h'</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h'</span><span class="o">,</span>
    <span class="o">{</span><span class="n">right</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">units.ext_iff</span><span class="o">,</span> <span class="n">eq_neg_of_add_eq_zero</span> <span class="n">h'</span><span class="o">],},</span>
    <span class="o">{</span><span class="n">left</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">units.ext_iff</span><span class="o">,</span> <span class="n">sub_eq_zero.mp</span> <span class="n">h'</span><span class="o">]}</span>
  <span class="o">},</span>
  <span class="n">cases</span> <span class="n">h</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span>
<span class="kd">end</span>
</code></pre></div>



<a name="246592453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246592453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246592453">(Jul 20 2021 at 14:21)</a>:</h4>
<p>Golfed:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">sq_hom_ker_eq</span> <span class="o">:</span> <span class="o">(</span><span class="n">sq_hom</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">ker.carrier</span> <span class="bp">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="bp">-</span><span class="mi">1</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">monoid_hom.mem_ker</span><span class="o">,</span> <span class="n">set.mem_insert_iff</span><span class="o">,</span> <span class="n">subgroup.mem_carrier</span><span class="o">,</span> <span class="n">set.mem_singleton_iff</span><span class="o">,</span>
             <span class="n">sq_hom</span><span class="o">,</span> <span class="n">monoid_hom.coe_mk</span><span class="o">,</span> <span class="n">units.ext_iff</span><span class="o">,</span> <span class="n">units.coe_mul</span><span class="o">,</span> <span class="n">units.coe_one</span><span class="o">,</span> <span class="n">units.coe_neg</span><span class="o">],</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="n">h'</span> <span class="o">:</span> <span class="o">((</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_mul</span><span class="o">,</span> <span class="n">mul_sub</span><span class="o">,</span> <span class="n">h</span><span class="o">],</span> <span class="n">ring</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="n">mul_eq_zero</span> <span class="n">at</span> <span class="n">h'</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h'.symm.imp</span> <span class="n">eq_of_sub_eq_zero</span> <span class="n">eq_neg_of_add_eq_zero</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">h</span><span class="bp">;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="246603392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246603392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246603392">(Jul 20 2021 at 15:03)</a>:</h4>
<p>Is there a way to recycle <code>mul_self_eq_one_iff</code> more efficiently?  I feel that the proof of <code>units.sq_one</code> should be much shorter...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">monoid_hom.ker_mul_self</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">units</span> <span class="n">F</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">monoid_hom.ker</span> <span class="o">(</span><span class="n">sq_hom</span> <span class="n">F</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">lemma</span> <span class="n">units.sq_one</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">F</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">units</span> <span class="n">F</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="bp">@</span><span class="n">mul_self_eq_one_iff</span> <span class="n">F</span> <span class="n">_</span> <span class="n">x</span> <span class="n">using</span> <span class="mi">1</span><span class="bp">;</span> <span class="n">refine</span> <span class="n">eq_iff_iff.mpr</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">congr_arg</span> <span class="n">coe</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">units.eq_iff.mp</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span><span class="bp">;</span> <span class="n">rintros</span> <span class="o">(</span><span class="n">h</span> <span class="bp">|</span> <span class="n">h</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">or.inl</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">])</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">or.inr</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">])</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">or.inl</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">or.inr</span> <span class="o">(</span><span class="n">units.ext</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span><span class="o">))</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">f_0</span> <span class="o">:</span> <span class="o">(</span><span class="n">sq_hom</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">ker.carrier</span> <span class="bp">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="bp">-</span><span class="mi">1</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">monoid_hom.ker_mul_self</span><span class="o">,</span> <span class="n">units.sq_one</span><span class="o">]</span>
</code></pre></div>



<a name="246689348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246689348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246689348">(Jul 21 2021 at 07:52)</a>:</h4>
<p>Also, note that it might make sense to develop some API for the slightly more general version of <code>sq_hom</code> below.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">mul_self_hom</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">F</span><span class="o">]</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→*</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span><span class="o">,</span> <span class="n">mul_one</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">mul_mul_mul_comm</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩</span>
</code></pre></div>
<p>Your version, would be the above applied to <code>units F</code>.</p>
<p>Possibly, even for the more general <code>nat</code>-power map</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">pow_self_hom</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">F</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→*</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">^</span> <span class="n">n</span><span class="o">,</span> <span class="n">one_pow</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">mul_pow</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩</span>
</code></pre></div>



<a name="246690256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246690256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246690256">(Jul 21 2021 at 08:04)</a>:</h4>
<p>IIRC this map is already in mathlib</p>



<a name="246690300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246690300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246690300">(Jul 21 2021 at 08:04)</a>:</h4>
<p>Or perhaps there's an old skool <code>is_monoid_hom</code> instance on the power map</p>



<a name="246690344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/card/near/246690344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/card.html#246690344">(Jul 21 2021 at 08:05)</a>:</h4>
<p>Ah, in either case, it might make sense to generalize some of the lemmas above to work for this more general setting.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
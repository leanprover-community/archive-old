---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html">Multinomial coefficients definition</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="292812185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/292812185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#292812185">(Aug 10 2022 at 18:48)</a>:</h4>
<p>Below a definition for <a href="https://en.wikipedia.org/wiki/Multinomial_theorem#Multinomial_coefficients">multinomial coefficients</a> with the multiplicative defintion (rather than the recursive one)</p>
<p>A general question of "Does this look okay?" as well as the more specific:</p>
<p>Is the convention to use a finsupp because any function from \alpha would be finsupp, or is the convention to use something else (function, fun_like?), because it would automatically be finsupp?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finsupp.basic</span>

<span class="kn">open</span> <span class="n">nat</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">noncomputable theory</span>

<span class="kd">def</span> <span class="n">multinomial</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span>  <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">factorial</span> <span class="n">n</span><span class="o">)</span><span class="bp">*∏</span> <span class="n">i</span><span class="o">,</span> <span class="n">choose</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">j</span> <span class="k">in</span> <span class="o">{</span><span class="n">j'</span> <span class="bp">∈</span> <span class="n">fintype.elems</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">j'</span> <span class="bp">≤</span> <span class="n">i</span><span class="o">},</span> <span class="o">(</span><span class="n">k</span> <span class="n">j</span><span class="o">))</span> <span class="o">(</span><span class="n">k</span> <span class="n">i</span><span class="o">))</span>
</code></pre></div>



<a name="292824976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/292824976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#292824976">(Aug 10 2022 at 20:09)</a>:</h4>
<p>I actually switched to function since I managed to make that work first with the defintion of the multinomial theorem I was trying to formulate. </p>
<p>Does the following look okay? The main thing I'm kind of doubting are the explicit coercions.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finsupp.basic</span>

<span class="kn">open</span> <span class="n">nat</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">noncomputable theory</span>

<span class="kd">def</span> <span class="n">multinomial</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span>  <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">factorial</span> <span class="n">n</span><span class="o">)</span><span class="bp">*∏</span> <span class="n">i</span><span class="o">,</span> <span class="n">choose</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">j</span> <span class="k">in</span> <span class="o">{</span><span class="n">j'</span> <span class="bp">∈</span> <span class="n">fintype.elems</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">j'</span> <span class="bp">≤</span> <span class="n">i</span><span class="o">},</span> <span class="o">(</span><span class="n">k</span> <span class="n">j</span><span class="o">))</span> <span class="o">(</span><span class="n">k</span> <span class="n">i</span><span class="o">))</span>


<span class="kd">def</span> <span class="n">multinomial_theorem</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span>  <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">α</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="n">x</span> <span class="n">i</span><span class="o">)</span><span class="bp">^</span><span class="n">n</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">k</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)),</span> <span class="n">ite</span> <span class="o">((</span><span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="n">k</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">comm_ring.nat_cast</span> <span class="o">(</span><span class="n">multinomial</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">fin.coe_embedding</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="n">i</span><span class="o">)))</span><span class="bp">*</span><span class="o">(</span><span class="bp">∏</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span><span class="bp">^</span><span class="o">(</span><span class="n">fin.coe_embedding</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="n">i</span><span class="o">))))</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="293418203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293418203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293418203">(Aug 14 2022 at 16:26)</a>:</h4>
<p>There are several problems with this definition:</p>
<ol>
<li>I think <code>factorial n</code> shouldn't be there, and the argument <code>n</code> is not necessary.</li>
<li>This definition of <code>multinomial</code> only works with <code>[linear_order α]</code>; <code>has_le</code> is insufficient. You may take <code>α</code> to be <code>fin m</code> for <code>m := fintype.card α</code>, but that's less flexible. Since the multinomial coefficient doesn't really depend on the choice of an order, I suggest you use an order-independent definition. Your definition could become a lemma and serves as a nice formula to calculate it when there's a linear order.</li>
<li><code>fintype.elems α</code> is usually written <code>finset.univ</code>.</li>
</ol>



<a name="293420597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293420597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293420597">(Aug 14 2022 at 16:48)</a>:</h4>
<p>Here are three definitions I came up with, and I like the last one because it's the shortest and doesn't have the <code>fintype</code> restriction, and could be used to state a multinomial theorem in e.g. a <a href="https://leanprover-community.github.io/mathlib_docs/find/mv_power_series">docs#mv_power_series</a> ring; I'm not sure what the statement should be, but at least this definition realizes the coefficients of (X1+X2+X3+...)^n as multinomial coefficients. However, we have to use <code>multiset α ≃ (α →₀ ℕ)</code> to connect it to mv_power_series and to your <code>choose</code> formula; the third definition uses finsupp instead of multiset, so it's more directly connected to mv_power_series, but <code>(finsupp.sum f $ λ _, id)</code> is slightly awkward.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finsupp.basic</span>
<span class="kn">import</span> <span class="n">data.finite.card</span>
<span class="n">open_locale</span> <span class="n">big_operators</span>
<span class="kd">noncomputable theory</span>

<span class="kd">def</span> <span class="n">multinomial</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">finset.univ.filter</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">nat.card</span> <span class="o">(</span><span class="n">k</span><span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">a</span><span class="o">})</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span>
<span class="c1">-- This will be zero if `n ≠ ∑ a, f a`.</span>

<span class="kd">def</span> <span class="n">multinomial'</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">finset.univ.filter</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">nat.card</span> <span class="o">(</span><span class="n">k</span><span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">a</span><span class="o">})</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span>

<span class="kd">def</span> <span class="n">multinomial''</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">nat.card</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">finsupp.sum</span> <span class="n">f</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">id</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">nat.card</span> <span class="o">(</span><span class="n">k</span><span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">a</span><span class="o">})</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">multinomial'''</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">nat.card</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">s.card</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">nat.card</span> <span class="o">(</span><span class="n">k</span><span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">a</span><span class="o">})</span> <span class="bp">=</span> <span class="n">s.count</span> <span class="n">a</span><span class="o">}</span>
<span class="c1">-- notice that `multiset α ≃ (α →₀ ℕ)`; could also use `multiset.has_coe_to_sort`.</span>
</code></pre></div>



<a name="293421188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293421188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293421188">(Aug 14 2022 at 16:54)</a>:</h4>
<p>Thanks so much, this is extremely helpful! I'm not quite familiar with the "//" operator, what's it called/is there some documentation on it?</p>



<a name="293421249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293421249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293421249">(Aug 14 2022 at 16:54)</a>:</h4>
<p><code>//</code> is <a href="https://leanprover-community.github.io/mathlib_docs/find/subtype">docs#subtype</a>.</p>



<a name="293421415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293421415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293421415">(Aug 14 2022 at 16:56)</a>:</h4>
<p>Just came up to me, this def may be nicer:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">multinomial''''</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">nat.card</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">nat.card</span> <span class="o">(</span><span class="n">k</span><span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">a</span><span class="o">})</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span><span class="o">}</span>
<span class="c1">-- This will be zero if `n ≠ finsupp.sum f $ λ _, id`, so you don't need the `ite ((∑ i, k i) = n)` to state the multinomial theorem.</span>
</code></pre></div>



<a name="293435866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293435866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293435866">(Aug 14 2022 at 19:38)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> is <code>{α}</code> equivalent to <code>{α : Type*}</code>? I wasn't aware of that shorthand, seems useful</p>



<a name="293440485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293440485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293440485">(Aug 14 2022 at 20:37)</a>:</h4>
<p><span class="user-mention" data-user-id="380294">@Matt Diamond</span> Not writing the type means the type will get inferred as usual. In this case yes α will have type <code>Type*</code> since <code>finsupp (α : Type u_13) (M : Type u_14) [has_zero M] :</code>, but sometimes it might be <code>Sort*</code>, for example if α appears in the expression <code>psum α α</code>, because <a href="https://leanprover-community.github.io/mathlib_docs/find/psum">docs#psum</a> takes arguments <code>(α : Sort u) (β : Sort v)</code>.</p>



<a name="293440577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293440577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293440577">(Aug 14 2022 at 20:38)</a>:</h4>
<p>gotcha</p>



<a name="293608777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293608777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293608777">(Aug 15 2022 at 19:37)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span>  I've made an attempt to formulate the multinomial theorem, but I'm a little stuck on how to get the required fintype instance. (My attempts are the commented lines. The problem with the first line is that I'm not even sure restrict_support_equiv gets what I need, and if it does, I don't know how to get the fintype for the subtype introduced in that lemma. The second one doesn't work because it requires a fintype on alpha, which I don't think should be necessary.)</p>
<p>I'm also aware of some problems: 1. It's a little messy. I played with s/k.support/casts until all the types worked out, and though I think it's semantically correct, it's kind of whacky still. 2. I didn't use the mv_power_series approach. I don't strictly need it for the result I want to prove, but I do recognize it would be nicer to formulate for that, since it is more general. I wouldn't know how to get the sum on the right though, since then the "domain" of the sum would no longer be finite, right? I guess you could formulate the theorem in terms of coeff (\sum x_i)^n, but that seems kind of hacky too.</p>
<p>If you have any pointers, it would be greatly appreciated:)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finsupp.basic</span>
<span class="kn">import</span> <span class="n">data.finite.card</span>
<span class="n">open_locale</span> <span class="n">big_operators</span>
<span class="kd">noncomputable theory</span>


<span class="kd">def</span> <span class="n">multinomial</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">nat.card</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">nat.card</span> <span class="o">(</span><span class="n">k</span><span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">a</span><span class="o">})</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">fintype.finsupp_on_finset</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>  <span class="n">fintype</span> <span class="o">(</span><span class="n">coe_sort</span> <span class="n">s</span> <span class="bp">→₀</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span> <span class="o">:=</span> <span class="gr">sorry</span>
   <span class="c1">-- fintype.of_equiv _ ((finsupp.restrict_support_equiv (s : set α) (fin (n+1))))</span>
   <span class="c1">-- fintype.of_equiv (coe_sort s → fin (n+1)) (equiv.symm (finsupp.equiv_fun_on_fintype))</span>

<span class="kd">def</span> <span class="n">multinomial_theorem</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">α</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
   <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span> <span class="n">i</span><span class="o">)</span><span class="bp">^</span><span class="n">n</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">k</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→₀</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)),</span> <span class="o">(</span><span class="bp">@</span><span class="n">multinomial</span> <span class="n">s</span> <span class="n">n</span> <span class="o">(</span><span class="n">finsupp.map_range</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">))),</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">))</span> <span class="o">(</span><span class="n">rfl</span><span class="o">)</span> <span class="n">k</span><span class="o">))</span><span class="bp">*</span><span class="o">(</span><span class="bp">∏</span> <span class="n">i</span> <span class="k">in</span> <span class="n">k.support</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span><span class="bp">^</span><span class="o">(((</span><span class="n">k</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)))</span>  <span class="o">:=</span>
<span class="kd">begin</span>
   <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="293630101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293630101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293630101">(Aug 15 2022 at 22:24)</a>:</h4>
<p><span class="user-mention" data-user-id="519269">@Pim Otte</span> I've also found the question about the indexing type for the summation tricky, but I think I just found the preferred choice: <code>sym s n</code> (<a href="https://leanprover-community.github.io/mathlib_docs/find/sym">docs#sym</a>), which has a fintype instance <a href="https://leanprover-community.github.io/mathlib_docs/find/sym.fintype">docs#sym.fintype</a>, albeit a very inefficient one if you want to use it for computation, because the time complexity is like #s^n; a generalized <a href="https://leanprover-community.github.io/mathlib_docs/find/list.nat.antidiagonal">docs#list.nat.antidiagonal</a> (which is the special case #s=2) would have time complexity <code>(n+#s-1).choose n</code> and be much more friendly for computation for large <code>n</code>. This would be an issue if you want to do explicit computation and have Lean enumerate all the monomials in the sum expansion for you, but it doesn't matter if you just want to prove things.</p>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/sym">docs#sym</a> gives you <code>multiset s</code>, and you can use <a href="https://leanprover-community.github.io/mathlib_docs/find/multiset.map">docs#multiset.map</a> subtype.val to get <code>multiset α</code> and then <a href="https://leanprover-community.github.io/mathlib_docs/find/multiset.to_finsupp">docs#multiset.to_finsupp</a> to get to <code>α →₀ ℕ</code>. You may also simply use <code>multiset α</code> in the definition of <code>multinomial</code> to make this conversion unnecessary. (And note that finsupp is also notoriously known to be unamenable to computation.)</p>



<a name="293634795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293634795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293634795">(Aug 15 2022 at 23:10)</a>:</h4>
<p>Notice that there is <a href="https://leanprover-community.github.io/mathlib_docs/find/sym.sym'">docs#sym.sym'</a> is a quotient of <code>vector α n</code> and has an equiv <a href="https://leanprover-community.github.io/mathlib_docs/find/sym.sym_equiv_sym'">docs#sym.sym_equiv_sym'</a>  with <a href="https://leanprover-community.github.io/mathlib_docs/find/sym">docs#sym</a>, so you may define the multinomial coefficients as cardinalities of the fibers of the map <code>vector α n → sym α n</code> as well.</p>



<a name="293635325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293635325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293635325">(Aug 15 2022 at 23:14)</a>:</h4>
<p>Of course if you don't care about computability at all you can prove your indexing set is finite and then use the noncomputable <a href="https://leanprover-community.github.io/mathlib_docs/find/set.finite.to_finset">docs#set.finite.to_finset</a> to get a indexing finset.</p>



<a name="293635819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293635819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293635819">(Aug 15 2022 at 23:18)</a>:</h4>
<p>Also mind <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sym">docs#finset.sym</a> as a way to avoid fintype computation. I introduced it a while back precisely for multinomial coefficients.</p>



<a name="293639686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293639686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293639686">(Aug 15 2022 at 23:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="519269">Pim Otte</span> <a href="#narrow/stream/113489-new-members/topic/Multinomial.20coefficients.20definition/near/293608777">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span>  I've made an attempt to formulate the multinomial theorem, but I'm a little stuck on how to get the required fintype instance. (My attempts are the commented lines. The problem with the first line is that I'm not even sure restrict_support_equiv gets what I need, and if it does, I don't know how to get the fintype for the subtype introduced in that lemma. The second one doesn't work because it requires a fintype on alpha, which I don't think should be necessary.)</p>
<p>I'm also aware of some problems: 1. It's a little messy. I played with s/k.support/casts until all the types worked out, and though I think it's semantically correct, it's kind of whacky still. 2. I didn't use the mv_power_series approach. I don't strictly need it for the result I want to prove, but I do recognize it would be nicer to formulate for that, since it is more general. I wouldn't know how to get the sum on the right though, since then the "domain" of the sum would no longer be finite, right? I guess you could formulate the theorem in terms of coeff (\sum x_i)^n, but that seems kind of hacky too.</p>
<p>If you have any pointers, it would be greatly appreciated:)</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finsupp.basic</span>
<span class="kn">import</span> <span class="n">data.finite.card</span>
<span class="n">open_locale</span> <span class="n">big_operators</span>
<span class="kd">noncomputable theory</span>


<span class="kd">def</span> <span class="n">multinomial</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">nat.card</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">nat.card</span> <span class="o">(</span><span class="n">k</span><span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">a</span><span class="o">})</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">fintype.finsupp_on_finset</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>  <span class="n">fintype</span> <span class="o">(</span><span class="n">coe_sort</span> <span class="n">s</span> <span class="bp">→₀</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span> <span class="o">:=</span> <span class="gr">sorry</span>
   <span class="c1">-- fintype.of_equiv _ ((finsupp.restrict_support_equiv (s : set α) (fin (n+1))))</span>
   <span class="c1">-- fintype.of_equiv (coe_sort s → fin (n+1)) (equiv.symm (finsupp.equiv_fun_on_fintype))</span>

<span class="kd">def</span> <span class="n">multinomial_theorem</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">α</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
   <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span> <span class="n">i</span><span class="o">)</span><span class="bp">^</span><span class="n">n</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">k</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→₀</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)),</span> <span class="o">(</span><span class="bp">@</span><span class="n">multinomial</span> <span class="n">s</span> <span class="n">n</span> <span class="o">(</span><span class="n">finsupp.map_range</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">))),</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">))</span> <span class="o">(</span><span class="n">rfl</span><span class="o">)</span> <span class="n">k</span><span class="o">))</span><span class="bp">*</span><span class="o">(</span><span class="bp">∏</span> <span class="n">i</span> <span class="k">in</span> <span class="n">k.support</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span><span class="bp">^</span><span class="o">(((</span><span class="n">k</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)))</span>  <span class="o">:=</span>
<span class="kd">begin</span>
   <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Hmm, is there a reason you aren't assuming <code>[decidable_eq α]</code>? With that, your second attempt works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">fintype.finsupp_on_finset</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
   <span class="n">fintype</span> <span class="o">(</span><span class="n">coe_sort</span> <span class="n">s</span> <span class="bp">→₀</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span> <span class="o">:=</span>
   <span class="n">fintype.of_equiv</span> <span class="n">_</span> <span class="o">(</span><span class="n">equiv.symm</span> <span class="o">(</span><span class="n">finsupp.equiv_fun_on_fintype</span><span class="o">))</span>
</code></pre></div>



<a name="293665443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293665443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293665443">(Aug 16 2022 at 07:12)</a>:</h4>
<p>Thanks a lot, all of you! I'm going to experiment a little bit and see if I want to switch to <a href="https://leanprover-community.github.io/mathlib_docs/find/sym">docs#sym</a> or stay with the current approach.</p>
<p><span class="user-mention" data-user-id="391579">@Jake Levinson</span> I'm guessing this works because there's some fintype floating around that applies when you add the <code>[decidable_eq α]</code>, but how did you get to this? Is it just intuition or is there a systematic approach you took that I could apply in the future?</p>



<a name="293752277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293752277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293752277">(Aug 16 2022 at 16:25)</a>:</h4>
<p>The saga continues! </p>
<p>I managed to formulate the theorem using <code>sym</code>, which looks kind of nice. I also managed to do it for arbitrary finsets, not just univ of a fintype. However, I used coe_sort to coerce the type s to a structure to iterate over it, which I think is correct, but in the proof I'm stuck going the other way, identifying an emptyset that's coerced to sort with an emptyset. Any pointers for this, or should I have gone another way in the definition?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finsupp.basic</span>
<span class="kn">import</span> <span class="n">data.finite.card</span>
<span class="kn">import</span> <span class="n">data.finset.sym</span>
<span class="kn">import</span> <span class="n">data.finsupp.multiset</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>
<span class="kd">noncomputable theory</span>


<span class="kd">def</span> <span class="n">multinomial</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">nat.card</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">nat.card</span> <span class="o">(</span><span class="n">k</span><span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">a</span><span class="o">})</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">multinomial_theorem</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">s</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hn</span><span class="o">:</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">):</span>
   <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">coe_sort</span> <span class="n">s</span><span class="o">),</span> <span class="n">x</span> <span class="n">i</span><span class="o">)</span><span class="bp">^</span><span class="n">n</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">k</span> <span class="o">:</span> <span class="o">(</span><span class="n">sym</span> <span class="n">s</span> <span class="n">n</span><span class="o">),</span> <span class="o">((</span><span class="n">multinomial</span> <span class="n">n</span> <span class="o">(</span><span class="n">k.val.to_finsupp</span><span class="o">))</span><span class="bp">*</span><span class="o">(</span><span class="bp">∏</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">coe_sort</span> <span class="n">s</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span><span class="bp">^</span><span class="o">(</span><span class="n">k.val.count</span> <span class="n">i</span><span class="o">)))</span>  <span class="o">:=</span>
<span class="kd">begin</span>
   <span class="n">induction</span> <span class="n">s</span> <span class="n">using</span> <span class="n">finset.cons_induction</span> <span class="k">with</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">h₃</span> <span class="n">h₄</span><span class="o">,</span>
   <span class="o">{</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">zero_pow</span> <span class="n">hn</span><span class="o">,</span> <span class="n">finset.univ_eq_attach</span><span class="o">,</span> <span class="n">finset.attach_empty</span><span class="o">,</span> <span class="n">finset.sum_empty</span><span class="o">,</span> <span class="n">subtype.val_eq_coe</span><span class="o">,</span> <span class="n">finset.prod_empty</span><span class="o">,</span>
  <span class="n">mul_one</span><span class="o">],</span>
      <span class="k">have</span> <span class="n">fact</span><span class="o">:</span> <span class="n">sym</span> <span class="o">(</span><span class="n">coe_sort</span> <span class="o">(</span><span class="n">finset.empty</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">))</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">finset.empty</span><span class="o">,</span>
      <span class="o">{</span>
         <span class="n">unfold</span> <span class="n">finset.empty</span><span class="o">,</span>
         <span class="n">rw</span> <span class="n">finset.mk_zero</span><span class="o">,</span>

         <span class="n">exact</span> <span class="n">finset.sym_eq_empty.mpr</span> <span class="o">⟨</span><span class="n">ne_of_gt</span> <span class="n">hn</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
      <span class="o">},</span>
   <span class="o">},</span>
   <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="293767579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293767579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293767579">(Aug 16 2022 at 17:37)</a>:</h4>
<p>I'll take a look later if no one does; now I'd just point out that you can simply write <code>i : s</code> and Lean will parse it as <code>i : coe_sort s</code>, displayed as <code>i : ↥s</code>.</p>



<a name="293767854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293767854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293767854">(Aug 16 2022 at 17:39)</a>:</h4>
<p>I think what you want are <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.is_empty_coe_sort">docs#finset.is_empty_coe_sort</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/sym.is_empty">docs#sym.is_empty</a></p>



<a name="293768044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293768044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293768044">(Aug 16 2022 at 17:40)</a>:</h4>
<p>similarly there's no need to write <code>coe_sort</code> in <code>sym (coe_sort (finset.empty : finset α)) n</code>. Since Lean expects a type/sort as the first argument of <code>sym</code>, it will automatically insert a coe_sort.<br>
And you can write <code>∅ : finset α</code></p>



<a name="293768326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293768326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293768326">(Aug 16 2022 at 17:42)</a>:</h4>
<p>The right way to sum over a finset is Sum i in s, also</p>



<a name="293771880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293771880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293771880">(Aug 16 2022 at 18:05)</a>:</h4>
<p>Yes, <code>∑ i in s</code> instead of <code>∑ (i : coe_sort s)</code><br>
<code>∑ k : sym s n</code> is correct because <code>sym s n</code> is a (finite) type.</p>



<a name="293773437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293773437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293773437">(Aug 16 2022 at 18:14)</a>:</h4>
<p>I'm still working on the other stuff, but <code>∑ i in s</code> leads to <code>i : α</code>, whereas <code>∑ i</code> leads to <code>i : ↥s</code>, which works a little better with the definition of <code>x</code>, so I'm currently rolling <code>∑ i</code>which does look a lot nicer:D</p>



<a name="293773812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293773812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293773812">(Aug 16 2022 at 18:16)</a>:</h4>
<p>Oh I see <code>x: s →₀ R</code> is also problematic. Since <code>s</code> is finite there's no need of the <code>₀</code>. Moreover, finset big operator lemmas are usually stated with <code>x : α → R</code> instead.</p>



<a name="293774130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293774130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293774130">(Aug 16 2022 at 18:18)</a>:</h4>
<p>Some other comments:<br>
<code>[comm_semiring R]</code> should work.<br>
mathlib prefers <code>0 &lt; n</code> over <code>n &gt; 0</code>. The convention is to always use le/lt not ge/gt (except for epsilon in anlysis).</p>



<a name="293775181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293775181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293775181">(Aug 16 2022 at 18:24)</a>:</h4>
<p>Attempt to reformulate with <code>x : α →₀ R</code>. Two issues: It gives  a type mismatch with the finsupp derived from the sym element.   Also, I kept the finsupp, because I have no idea how to make the sums in the infinite context (I guess that has something to do with the power_series approach you mentioned earlier?)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finsupp.basic</span>
<span class="kn">import</span> <span class="n">data.finite.card</span>
<span class="kn">import</span> <span class="n">data.finset.sym</span>
<span class="kn">import</span> <span class="n">data.finsupp.multiset</span>

<span class="kn">import</span> <span class="n">data.nat.basic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>
<span class="kd">noncomputable theory</span>


<span class="kd">def</span> <span class="n">multinomial</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">nat.card</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">nat.card</span> <span class="o">(</span><span class="n">k</span><span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">a</span><span class="o">})</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">multinomial_theorem</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">α</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hn</span><span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">):</span>
   <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">x.support</span><span class="o">,</span> <span class="n">x</span> <span class="n">i</span><span class="o">)</span><span class="bp">^</span><span class="n">n</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">k</span> <span class="o">:</span> <span class="o">(</span><span class="n">sym</span> <span class="n">x.support</span> <span class="n">n</span><span class="o">),</span> <span class="o">((</span><span class="n">multinomial</span> <span class="n">n</span> <span class="o">(</span><span class="n">k.val.to_finsupp</span><span class="o">))</span><span class="bp">*</span><span class="o">(</span><span class="bp">∏</span> <span class="n">i</span> <span class="k">in</span> <span class="n">x.support</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span><span class="bp">^</span><span class="o">(</span><span class="n">k.val.count</span> <span class="n">i</span><span class="o">)))</span>  <span class="o">:=</span>
<span class="kd">begin</span>
<span class="kd">end</span>
</code></pre></div>



<a name="293776906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293776906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293776906">(Aug 16 2022 at 18:34)</a>:</h4>
<p>Sorry, this is what I mean; we still need the finset, and <code>x</code> need only be a function not finsupp:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">multinomial_theorem</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">=</span> <span class="c">/-</span><span class="cm"> or simply `s.sum x` -/</span>
  <span class="bp">∑</span> <span class="n">k</span> <span class="o">:</span> <span class="n">sym</span> <span class="n">s</span> <span class="n">n</span><span class="o">,</span> <span class="n">multinomial</span> <span class="n">n</span> <span class="n">k.val.to_finsupp</span> <span class="bp">*</span> <span class="o">(</span><span class="n">k.val.map</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∘</span> <span class="n">subtype.val</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="o">:=</span>
  <span class="c">/-</span><span class="cm"> changed the product to use `multiset.map`and `multiset.prod` -/</span>
</code></pre></div>



<a name="293779752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293779752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293779752">(Aug 16 2022 at 18:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="519269">Pim Otte</span> <a href="#narrow/stream/113489-new-members/topic/Multinomial.20coefficients.20definition/near/293665443">said</a>:</p>
<blockquote>
<p>Thanks a lot, all of you! I'm going to experiment a little bit and see if I want to switch to <a href="https://leanprover-community.github.io/mathlib_docs/find/sym">docs#sym</a> or stay with the current approach.</p>
<p><span class="user-mention silent" data-user-id="391579">Jake Levinson</span> I'm guessing this works because there's some fintype floating around that applies when you add the <code>[decidable_eq α]</code>, but how did you get to this? Is it just intuition or is there a systematic approach you took that I could apply in the future?</p>
</blockquote>
<p>In this case I had previously looked for the <code>fintype</code> instance for maps <code>α → β</code> when both are fintypes, and I eventually found <code>pi.fintype</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">pi.fintype</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span><span class="o">)]</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>This is actually slightly more general since it allows dependent functions. I don't have much intuition for decidability, but I think the idea is that to enumerate all the functions <code>α → β</code>, we would enumerate through the elements <code>a : α</code> and then through the choices of where to map them. But then, to map an arbitrary term <code>a' : α</code> through a function constructed "by cases" this way, we have to match <code>a'</code> with one of the <code>a : α</code>'s, and that requires <code>decidable_eq α</code>.</p>



<a name="293783237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293783237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293783237">(Aug 16 2022 at 19:13)</a>:</h4>
<p>Yeah, I think the decidable_eq originates from the <code>ite</code>s in the recursive definition of the (dependent) functions in <a href="https://leanprover-community.github.io/mathlib_docs/find/multiset.pi.cons">docs#multiset.pi.cons</a>.</p>



<a name="293788145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293788145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293788145">(Aug 16 2022 at 19:45)</a>:</h4>
<p>I've made some more steps, but I'm missing the final bit.</p>
<p>I think finset.sum_of_empty should apply, and I have the is_empty on the type, but it doesn't seem to apply. What am I missing?:)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finsupp.basic</span>
<span class="kn">import</span> <span class="n">data.finite.card</span>
<span class="kn">import</span> <span class="n">data.finset.sym</span>
<span class="kn">import</span> <span class="n">data.finsupp.multiset</span>


<span class="n">open_locale</span> <span class="n">big_operators</span>
<span class="kd">noncomputable theory</span>


<span class="kd">def</span> <span class="n">multinomial</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">nat.card</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">nat.card</span> <span class="o">(</span><span class="n">k</span><span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">a</span><span class="o">})</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">multinomial_theorem</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">s.sum</span> <span class="n">x</span><span class="o">)</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">k</span> <span class="o">:</span> <span class="n">sym</span> <span class="n">s</span> <span class="n">n</span><span class="o">,</span> <span class="n">multinomial</span> <span class="n">n</span> <span class="n">k.val.to_finsupp</span> <span class="bp">*</span> <span class="o">(</span><span class="n">k.val.map</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∘</span> <span class="n">subtype.val</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="o">:=</span>
<span class="kd">begin</span>
      <span class="n">induction</span> <span class="n">s</span> <span class="n">using</span> <span class="n">finset.cons_induction</span> <span class="k">with</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">h₃</span> <span class="n">h₄</span><span class="o">,</span>
   <span class="o">{</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">zero_pow</span> <span class="n">hn</span><span class="o">,</span> <span class="n">finset.univ_eq_attach</span><span class="o">,</span> <span class="n">finset.attach_empty</span><span class="o">,</span> <span class="n">finset.sum_empty</span><span class="o">,</span> <span class="n">subtype.val_eq_coe</span><span class="o">,</span> <span class="n">finset.prod_empty</span><span class="o">,</span>
  <span class="n">mul_one</span><span class="o">],</span>
      <span class="k">have</span> <span class="n">fact</span> <span class="o">:</span> <span class="n">is_empty</span> <span class="o">(</span><span class="n">sym</span> <span class="o">(</span><span class="bp">∅</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="n">n</span><span class="o">),</span>
      <span class="o">{</span>
         <span class="n">rw</span> <span class="bp">←</span> <span class="n">nat.pred_inj</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span><span class="bp">.</span><span class="n">succ_pos</span> <span class="n">hn</span> <span class="n">rfl</span><span class="o">,</span>
         <span class="n">apply</span> <span class="n">sym.is_empty</span> <span class="n">_</span><span class="o">,</span>
         <span class="n">rw</span> <span class="n">finset.is_empty_coe_sort</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="n">rw</span> <span class="n">eq_comm</span><span class="o">,</span>

      <span class="n">apply</span> <span class="n">finset.sum_of_empty</span><span class="o">,</span>
      <span class="c1">-- apply (@finset.sum_of_empty R (sym (∅ : finset α) n) (λ k, multinomial n k.val.to_finsupp * (k.val.map (x ∘ subtype.val)).prod) _ fact),</span>
      <span class="gr">sorry</span><span class="o">,</span>
   <span class="o">},</span>
   <span class="o">{</span>
   <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="293788618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293788618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293788618">(Aug 16 2022 at 19:48)</a>:</h4>
<p>haveI instead of have. is_empty is used as a typeclass constraint, and haveI populates it into the typeclass instance cache</p>



<a name="293788935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293788935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293788935">(Aug 16 2022 at 19:51)</a>:</h4>
<p>Thanks! I've corrected this, but it still fails to unify, I'm afraid</p>



<a name="293789800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293789800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293789800">(Aug 16 2022 at 19:57)</a>:</h4>
<p>Yeah Lean seems to have trouble figuring out the function <code>sym ↥∅ n → R</code> in <code>finset.sum_of_empty</code> when doing <code>apply</code> or <code>exact</code>, but this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>      <span class="n">convert</span> <span class="n">finset.sum_of_empty</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">fact</span><span class="o">,</span>
</code></pre></div>



<a name="293789845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293789845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293789845">(Aug 16 2022 at 19:57)</a>:</h4>
<p>By the way the theorem should hold for n=0 right? Just the proof would be different.</p>



<a name="293790351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293790351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293790351">(Aug 16 2022 at 20:00)</a>:</h4>
<p>Curiously, if you do <code>haveI</code>, then <code>convert</code> creates the goal <code>sym ↥∅ n → R</code>. I've seen this bug elsewhere ...</p>



<a name="293790641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293790641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293790641">(Aug 16 2022 at 20:02)</a>:</h4>
<p>Awesome, new tactic time:)</p>
<p>With respect to <code>n=0</code>: the part that I was kind of fuzzy about is the 0^0 issue for <code>s = ∅</code>and <code>n=0</code>. I don't really know how I'd work around that.</p>



<a name="293791429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293791429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293791429">(Aug 16 2022 at 20:07)</a>:</h4>
<p><code>0^0 = 1</code> in Lean (at least with the zeroes you're dealing with now <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span>)</p>



<a name="293797016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293797016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293797016">(Aug 16 2022 at 20:42)</a>:</h4>
<p>Thanks for all the help everyone! </p>
<p>Current roadblock for me: How to handle <code>multiset.map</code> and <code>coe default</code> (which I think represents an emptyset in the current context, but I don't really grasp what it is). It's probably a bit explicit/long too, so if people have golfing suggestions, I'm open to those:)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finsupp.basic</span>
<span class="kn">import</span> <span class="n">data.finite.card</span>
<span class="kn">import</span> <span class="n">data.finset.sym</span>
<span class="kn">import</span> <span class="n">data.finsupp.multiset</span>


<span class="n">open_locale</span> <span class="n">big_operators</span>
<span class="kd">noncomputable theory</span>


<span class="kd">def</span> <span class="n">multinomial</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">nat.card</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">nat.card</span> <span class="o">(</span><span class="n">k</span><span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">a</span><span class="o">})</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">multinomial_theorem</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">s.sum</span> <span class="n">x</span><span class="o">)</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">k</span> <span class="o">:</span> <span class="n">sym</span> <span class="n">s</span> <span class="n">n</span><span class="o">,</span> <span class="n">multinomial</span> <span class="n">n</span> <span class="n">k.val.to_finsupp</span> <span class="bp">*</span> <span class="o">(</span><span class="n">k.val.map</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∘</span> <span class="n">subtype.val</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="o">:=</span>
<span class="kd">begin</span>
      <span class="n">induction</span> <span class="n">s</span> <span class="n">using</span> <span class="n">finset.cons_induction</span> <span class="k">with</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">h₃</span> <span class="n">h₄</span><span class="o">,</span>
   <span class="o">{</span>
      <span class="n">by_cases</span> <span class="n">hn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span>
      <span class="o">{</span>
         <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">zero_pow</span> <span class="n">hn</span><span class="o">,</span> <span class="n">finset.univ_eq_attach</span><span class="o">,</span> <span class="n">finset.attach_empty</span><span class="o">,</span> <span class="n">finset.sum_empty</span><span class="o">,</span> <span class="n">subtype.val_eq_coe</span><span class="o">,</span> <span class="n">finset.prod_empty</span><span class="o">,</span>
  <span class="n">mul_one</span><span class="o">],</span>
         <span class="n">convert</span> <span class="n">eq_comm.mp</span> <span class="n">finset.sum_of_empty</span><span class="o">,</span>
         <span class="n">rw</span> <span class="bp">←</span> <span class="n">nat.pred_inj</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span><span class="bp">.</span><span class="n">succ_pos</span> <span class="n">hn</span> <span class="n">rfl</span><span class="o">,</span>
         <span class="n">apply</span> <span class="n">sym.is_empty</span> <span class="n">_</span><span class="o">,</span>
         <span class="n">rw</span> <span class="n">finset.is_empty_coe_sort</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="o">{</span>
         <span class="k">have</span> <span class="n">fact</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
         <span class="o">{</span>
            <span class="n">push_neg</span> <span class="n">at</span> <span class="n">hn</span><span class="o">,</span>
            <span class="n">exact</span> <span class="n">nat.le_zero_iff.mp</span> <span class="n">hn</span><span class="o">,</span>
         <span class="o">},</span>
         <span class="n">rw</span> <span class="n">fact</span><span class="o">,</span>
         <span class="n">rw</span> <span class="n">finset.sum_empty</span><span class="o">,</span>
         <span class="n">simp</span><span class="o">,</span>
         <span class="k">have</span> <span class="n">fact'</span><span class="o">:</span> <span class="n">is_empty</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="bp">∅</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)},</span>
         <span class="o">{</span>
            <span class="n">exact</span> <span class="n">set.is_empty_coe_sort.mpr</span> <span class="n">rfl</span><span class="o">,</span>
         <span class="o">},</span>
         <span class="gr">sorry</span><span class="o">,</span>
      <span class="o">}</span>

   <span class="o">},</span>
   <span class="o">{</span>
      <span class="gr">sorry</span><span class="o">,</span>
   <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="293800089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293800089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293800089">(Aug 16 2022 at 21:02)</a>:</h4>
<p>↑default is <a href="https://leanprover-community.github.io/mathlib_docs/find/multiset.nil">docs#multiset.nil</a> (denoted <code>0</code>) but this is missing as a simp lemma. You can <code>unfold default</code> to get <code>↑sym.nil</code> but we don't even have sym.coe_nil ...<br>
I think you don't need induction for n = 0, i.e. you can do <code>by_cases</code> before <code>induction</code>.<br>
I'm not even sure induction is the correct approach to prove the multinomial theorem as formulated, because <code>multinomial</code> isn't defined recursively. I think the we should rather use something like <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.prod_univ_sum">docs#finset.prod_univ_sum</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum_sigma">docs#finset.sum_sigma</a>, and <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.sum_equiv">docs#fintype.sum_equiv</a>.</p>



<a name="293800692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293800692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293800692">(Aug 16 2022 at 21:06)</a>:</h4>
<p>By the way I just remembered that replacing <code>x ∘ subtype.val</code> with <code>x ∘ coe</code> would be nicer. <code>coe</code> (or ↑) is the "simp normal form" of <code>subtype.val</code>.</p>



<a name="293802106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293802106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293802106">(Aug 16 2022 at 21:15)</a>:</h4>
<p>For this specific goal: if you do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>         <span class="n">convert</span> <span class="o">(</span><span class="n">mul_one</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
         <span class="n">erw</span> <span class="n">multiset.to_finsupp_zero</span><span class="o">,</span>
</code></pre></div>
<p>then the goal becomes <code>↑(multinomial 0 0) = 1</code>.</p>



<a name="293859833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293859833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293859833">(Aug 17 2022 at 09:06)</a>:</h4>
<blockquote>
<p>a generalized <a href="https://leanprover-community.github.io/mathlib_docs/find/list.nat.antidiagonal">docs#list.nat.antidiagonal</a> (which is the special case #s=2) would have time complexity <code>(n+#s-1).choose n</code> and be much more friendly for computation for large <code>n</code>.</p>
</blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/list.nat.antidiagonal_tuple">docs#list.nat.antidiagonal_tuple</a></p>



<a name="293905158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293905158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293905158">(Aug 17 2022 at 14:15)</a>:</h4>
<p>Thanks for pointing it out! There are also the multiset/finset versions and <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.nat.sigma_antidiagonal_tuple_equiv_tuple">docs#finset.nat.sigma_antidiagonal_tuple_equiv_tuple</a> seems to be made exactly for the purpose of multinomial theorem. I guess we should construct an <code>equiv</code> between the finset version and <code>sym</code> so that we can translate freely between sums over both.</p>



<a name="293920915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293920915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293920915">(Aug 17 2022 at 15:34)</a>:</h4>
<p>I think there is some code on a branch somewhere that does that; <span class="user-mention" data-user-id="306601">@Kyle Miller</span> might remember</p>



<a name="293924672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293924672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293924672">(Aug 17 2022 at 15:53)</a>:</h4>
<p>I'm not sure what "that" is here, but I'm remembering one multinomial-related piece of code: <a href="https://github.com/leanprover-community/mathlib/blob/binomial/src/data/nat/choose/multinomial.lean">https://github.com/leanprover-community/mathlib/blob/binomial/src/data/nat/choose/multinomial.lean</a></p>
<p>It's the multinomial coefficient is using a list, so for example <code>multinomial [a, b, c]</code>. I've thought this was nice because it gives a reasonable notation for it.</p>



<a name="293932639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293932639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293932639">(Aug 17 2022 at 16:34)</a>:</h4>
<p>I didn't get very far, but this seems like a nice interface for the multinomial coefficient. I suggest proving the combinatorial version as a lemma (and to do this, you probably want a good number of supporting lemmas, giving equivalences for the type that parallel a recursive definition for <code>multinomial</code>)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">open_locale</span> <span class="n">big_operators</span> <span class="n">nat</span>

<span class="kd">def</span> <span class="n">multinomial</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span><span class="bp">!</span> <span class="bp">/</span> <span class="bp">∏</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span><span class="bp">!</span>

<span class="k">#eval</span> <span class="n">multinomial</span> <span class="bp">!</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="c1">-- 60</span>

<span class="kd">lemma</span> <span class="n">multinomial_eq</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">multinomial</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">nat.card</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">nat.card</span> <span class="o">(</span><span class="n">k</span> <span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">a</span><span class="o">})</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span><span class="o">}</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="293933036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293933036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293933036">(Aug 17 2022 at 16:36)</a>:</h4>
<p>"that" refers to the equivalence between the n-ary antidiagonal, and <code>sym</code>, I think</p>



<a name="293933692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293933692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293933692">(Aug 17 2022 at 16:39)</a>:</h4>
<p>A fun application:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="o">((</span><span class="n">list.nat.antidiagonal_tuple</span> <span class="mi">5</span> <span class="mi">20</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">multinomial</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span>
<span class="c1">-- 95367431640625</span>
<span class="k">#eval</span> <span class="mi">5</span><span class="bp">^</span><span class="mi">20</span>
<span class="c1">-- 95367431640625</span>
</code></pre></div>
<p>It evaluates relatively quickly for Lean, just a second or two.</p>



<a name="293933926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293933926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293933926">(Aug 17 2022 at 16:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Multinomial.20coefficients.20definition/near/293932639">said</a>:</p>
<blockquote>
<p>I didn't get very far, but this seems like a nice interface for the multinomial coefficient. I suggest proving the combinatorial version as a lemma (and to do this, you probably want a good number of supporting lemmas, giving equivalences for the type that parallel a recursive definition for <code>multinomial</code>)</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">open_locale</span> <span class="n">big_operators</span> <span class="n">nat</span>

<span class="kd">def</span> <span class="n">multinomial</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span><span class="bp">!</span> <span class="bp">/</span> <span class="bp">∏</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span><span class="bp">!</span>

<span class="k">#eval</span> <span class="n">multinomial</span> <span class="bp">!</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="c1">-- 60</span>

<span class="kd">lemma</span> <span class="n">multinomial_eq</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">multinomial</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">nat.card</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">nat.card</span> <span class="o">(</span><span class="n">k</span> <span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">a</span><span class="o">})</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span><span class="o">}</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div><br>
</p>
</blockquote>
<p>The combinatorialist in me thinks that the underlying combinatorial object<br>
<code>{k : fin (∑ i, f i) → α // ∀ a, nat.card (k ⁻¹' {a}) = f a}</code> should also be given a name, and then the various recursions can be proven bijectively instead of just by counting.</p>



<a name="293934072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/293934072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#293934072">(Aug 17 2022 at 16:41)</a>:</h4>
<p>(Though, that particular lemma should probably be proven using something like the orbit-stabilizer lemma.)</p>



<a name="294109706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294109706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294109706">(Aug 18 2022 at 15:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Multinomial.20coefficients.20definition/near/293924672">said</a>:</p>
<blockquote>
<p>I'm not sure what "that" is here, but I'm remembering one multinomial-related piece of code: <a href="https://github.com/leanprover-community/mathlib/blob/binomial/src/data/nat/choose/multinomial.lean">https://github.com/leanprover-community/mathlib/blob/binomial/src/data/nat/choose/multinomial.lean</a></p>
<p>It's the multinomial coefficient is using a list, so for example <code>multinomial [a, b, c]</code>. I've thought this was nice because it gives a reasonable notation for it.</p>
</blockquote>
<p>This looks pretty useful and besides the duplication between bionomial.lean/multinomial.lean, my untrained eye doesn't really spot any reason not to PR this as-is. Of course it could be extended with more lemma's and the combinatorial definition and such, but this seems like plenty  already. What would you say would need to be done before starting a PR? Would you mind if I tried my hand at bringing this branch to mathlib?</p>



<a name="294128109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294128109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294128109">(Aug 18 2022 at 16:58)</a>:</h4>
<p><span class="user-mention" data-user-id="519269">@Pim Otte</span> I'm not sure why it hasn't been PR'd. I think this branch was an experiment by <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> with some additional experimentation of my own.</p>
<p>If you wanted to take it on, I'd suggest getting things from <code>multinomial.lean</code> together for a PR, and I'd also suggest switching to the following definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">multinomial</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span><span class="bp">!</span> <span class="bp">/</span> <span class="bp">∏</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span><span class="bp">!</span>
</code></pre></div>
<p>That seems to be more versatile than using lists.</p>



<a name="294129708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294129708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294129708">(Aug 18 2022 at 17:06)</a>:</h4>
<p>Sounds good:) In a comparable situation <span class="user-mention" data-user-id="224323">@Junyan Xu</span> recommended to base a definition on a finset instead of just univ of a fintype. I don't know if that still holds in this context, any thoughts on that?</p>



<a name="294130346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294130346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294130346">(Aug 18 2022 at 17:09)</a>:</h4>
<p>I agree with you. It still applies.</p>



<a name="294130368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294130368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294130368">(Aug 18 2022 at 17:09)</a>:</h4>
<p>I like this one because you can write <code>multinomial ![a, b, c]</code>, which is some nice notation for free, but I haven't given it too much thought.</p>



<a name="294130407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294130407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294130407">(Aug 18 2022 at 17:10)</a>:</h4>
<p>What is the reason? I missed this discussion.</p>



<a name="294130526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294130526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294130526">(Aug 18 2022 at 17:10)</a>:</h4>
<p>It's much easier to add/remove an element to a finset than to a fintype.</p>



<a name="294130641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294130641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294130641">(Aug 18 2022 at 17:11)</a>:</h4>
<p>If we add a finset, your example becomes <code>multinomial univ ![a, b, c]</code>, which I think is still quite nice?</p>



<a name="294130867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294130867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294130867">(Aug 18 2022 at 17:12)</a>:</h4>
<p>I suppose that's reasonable, and that's a fine enough interface.</p>



<a name="294132036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294132036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294132036">(Aug 18 2022 at 17:19)</a>:</h4>
<p><span class="user-mention" data-user-id="519269">@Pim Otte</span> Then here's an amended suggestion:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- The multinomial coefficient. Gives the number of strings</span>
<span class="sd">consisting of symbols from `s`, where `c ∈ s`</span>
<span class="sd">appears with multiplicity `f c`.</span>

<span class="sd">Example: `multinomial finset.univ ![2,2,3]` gives the number of strings</span>
<span class="sd">from the set `{0, 1, 2}` with two `0`'s, two `1`'s, and three `2`'s. -/</span>
<span class="kd">def</span> <span class="n">multinomial</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="o">(</span><span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span><span class="bp">!</span> <span class="bp">/</span> <span class="bp">∏</span> <span class="n">i</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span><span class="bp">!</span>
</code></pre></div>



<a name="294132726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294132726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294132726">(Aug 18 2022 at 17:23)</a>:</h4>
<p>I'm forgetting -- what's the mathlib interface to update the value of a function at a particular input? It shows up in the API for summations/products.</p>



<a name="294134733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294134733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294134733">(Aug 18 2022 at 17:32)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/function.update">docs#function.update</a></p>



<a name="294136743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294136743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294136743">(Aug 18 2022 at 17:42)</a>:</h4>
<p>We can do finsupp as well:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">open_locale</span> <span class="n">nat</span>
<span class="kd">def</span> <span class="n">multinomial</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f.sum</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">id</span><span class="o">)</span><span class="bp">!</span> <span class="bp">/</span> <span class="n">f.prod</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span><span class="bp">!</span><span class="o">)</span>
</code></pre></div>



<a name="294137617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294137617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294137617">(Aug 18 2022 at 17:47)</a>:</h4>
<p>One weakness with <code>finsupp</code> is that you can't tell the difference between having zero of a symbol in the string and not including the symbol at all. They give the same values, but I worried that it might make some things more awkward.</p>



<a name="294137869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294137869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294137869">(Aug 18 2022 at 17:49)</a>:</h4>
<p>Maybe that's not a bug, but a feature?</p>



<a name="294137990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294137990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294137990">(Aug 18 2022 at 17:49)</a>:</h4>
<p>Using the principle that it tends to be better to break apart product types into separate arguments unless the function is specifically about a particular object, maybe it's better writing <code>multinomial f.support f</code>?</p>



<a name="294139018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294139018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294139018">(Aug 18 2022 at 17:53)</a>:</h4>
<p>A <code>finsupp</code> is not a product of a finset and a function, however.</p>



<a name="294139615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294139615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294139615">(Aug 18 2022 at 17:56)</a>:</h4>
<p>Sure, it's a finset, a function, and a proof the finset is a support of the function</p>



<a name="294139666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294139666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294139666">(Aug 18 2022 at 17:57)</a>:</h4>
<p>and <code>multinomial</code> doesn't make use of the third one</p>



<a name="294139764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294139764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294139764">(Aug 18 2022 at 17:57)</a>:</h4>
<p>to be more precise, I mean "sigma type" (i.e., a dependent product)</p>



<a name="294140011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294140011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294140011">(Aug 18 2022 at 17:58)</a>:</h4>
<p>crazy idea: <code>M x ∈ s, f x</code></p>



<a name="294141152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294141152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294141152">(Aug 18 2022 at 18:04)</a>:</h4>
<p>Oh, does that make <code>M x y, f x y</code> mean the right thing?</p>



<a name="294141829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294141829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294141829">(Aug 18 2022 at 18:08)</a>:</h4>
<p>that sounds unlikely: it works out to <code>(∑ x, (∑ y, f x y)! / ∏ y, (f x y)!)! / ∏ x, ((∑ y, f x y)! / ∏ y, (f x y)!)!</code> which doesn't look like it would be equal to <code>(∑ x y, f x y)! / ∏ x y, (f x y)!</code></p>



<a name="294142685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294142685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294142685">(Aug 18 2022 at 18:13)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">multinomial</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span><span class="bp">!</span> <span class="bp">/</span> <span class="bp">∏</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span><span class="bp">!</span>

<span class="k">#eval</span> <span class="n">multinomial</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">bool</span><span class="o">,</span> <span class="n">multinomial</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="o">:</span> <span class="n">bool</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span> <span class="c1">-- 6</span>
<span class="k">#eval</span> <span class="n">multinomial</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">×</span> <span class="n">bool</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">-- 24</span>
</code></pre></div>



<a name="294156119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294156119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294156119">(Aug 18 2022 at 19:34)</a>:</h4>
<p>Hmm, that makes me wonder whether it might be useful to have "universal big operators":</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">multinomial</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span><span class="bp">!</span> <span class="bp">/</span> <span class="bp">∏</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span><span class="bp">!</span>

<span class="kd">notation</span> <span class="bp">`&lt;|</span> <span class="bp">`</span> <span class="n">g</span> <span class="bp">`</span> <span class="bp">|&gt;λ</span> <span class="bp">`</span> <span class="n">binders</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="n">r</span><span class="o">:(</span><span class="n">scoped</span><span class="o">:</span><span class="mi">67</span> <span class="n">f</span><span class="o">,</span> <span class="n">g</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">r</span>

<span class="k">#eval</span> <span class="bp">&lt;|</span><span class="n">multinomial</span><span class="bp">|&gt;λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">bool</span><span class="o">),</span> <span class="mi">1</span>
</code></pre></div>
<p>(I'm just using <code>multinomial</code> as an example; I'm not sure it's useful here.)</p>



<a name="294458187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/294458187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#294458187">(Aug 20 2022 at 16:01)</a>:</h4>
<p>I collected some of the basic results and <a href="https://github.com/leanprover-community/mathlib/pull/16170">PR'd them</a> :D</p>



<a name="295085937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/295085937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#295085937">(Aug 24 2022 at 16:51)</a>:</h4>
<p>I've picked up trying the multinomial theorem. Below my progress (I have a separate case for n=0, if necessary)</p>
<p>My guess is that the way forward from this point would be to prove that the term in the first sum is stable under permutation of p, rewrite the sum per "orbit" under permutation (don't know if orbit is the technically correct term here). However, I have no clue how to approach that formally, and I'm not even sure it's the right approach. Proving the other term stable under permutation and "reversing" the quotient on permutation that happens in the definition of multiset would work too, but seems harder.</p>
<p>Any pointers?:)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.big_operators.fin</span>
<span class="kn">import</span> <span class="n">algebra.big_operators.order</span>
<span class="kn">import</span> <span class="n">data.nat.choose.basic</span>
<span class="kn">import</span> <span class="n">data.finset.sym</span>
<span class="kn">import</span> <span class="n">data.finsupp.multiset</span>
<span class="kn">import</span> <span class="n">data.fin.vec_notation</span>


<span class="n">open_locale</span> <span class="n">nat</span>
<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">multinomial</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span><span class="bp">!</span> <span class="bp">/</span> <span class="bp">∏</span> <span class="n">i</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span><span class="bp">!</span>

<span class="kd">def</span> <span class="n">nil_coe</span> <span class="o">:</span> <span class="o">(</span><span class="n">coe</span> <span class="o">(</span><span class="bp">@</span><span class="n">sym.nil</span> <span class="n">α</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">sym.nil</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sym.mk_coe</span> <span class="mi">0</span> <span class="n">multiset.card_zero</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">multinomial_theorem</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">s.sum</span> <span class="n">x</span><span class="o">)</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">k</span> <span class="o">:</span> <span class="n">sym</span> <span class="n">s</span> <span class="n">n</span><span class="o">,</span> <span class="n">multinomial</span> <span class="n">k.val.to_finsupp.support</span> <span class="n">k.val.to_finsupp</span> <span class="bp">*</span> <span class="o">(</span><span class="n">k.val.map</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∘</span> <span class="n">coe</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subtype.val_eq_coe</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">],</span>
  <span class="n">rw</span> <span class="n">finset.pow_eq_prod_const</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">fin.prod_univ_eq_prod_range</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset.prod_univ_sum</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="295569593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/295569593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#295569593">(Aug 27 2022 at 09:38)</a>:</h4>
<p>I'm late to the party but I would proceed by using <code>finset.induction_on</code>. You'll instantly run into a bunch of easier facts about <code>multinomial</code> which you should then factor out and prove first. I don't know if this is the best approach for multinomial coefficients (I'm not implying that is isn't, I just don't know). What do they do in Isabelle/HOL?</p>



<a name="295633355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/295633355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#295633355">(Aug 27 2022 at 19:25)</a>:</h4>
<p><span class="user-mention" data-user-id="519269">@Pim Otte</span>  Here is a continuation of the non-inductive approach, where the sorry should be filled in by considering the action of <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.perm">docs#equiv.perm</a> on <code>fin n → α</code>(acting on the domain) which preserves the range multiset. Then we can use <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_action.card_orbit_mul_card_stabilizer_eq_card_group">docs#mul_action.card_orbit_mul_card_stabilizer_eq_card_group</a> (but mathlib doesn't even know the cardinality of <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.perm">docs#equiv.perm</a> is <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.factorial">docs#nat.factorial</a>, it seems).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.big_operators.fin</span>
<span class="kn">import</span> <span class="n">algebra.big_operators.order</span>
<span class="kn">import</span> <span class="n">data.nat.choose.basic</span>
<span class="kn">import</span> <span class="n">data.finset.sym</span>
<span class="kn">import</span> <span class="n">data.finsupp.multiset</span>
<span class="kn">import</span> <span class="n">data.fin.vec_notation</span>

<span class="n">open_locale</span> <span class="n">nat</span> <span class="n">big_operators</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">multinomial</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span><span class="bp">!</span> <span class="bp">/</span> <span class="bp">∏</span> <span class="n">i</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span><span class="bp">!</span>

<span class="kd">def</span> <span class="n">nil_coe</span> <span class="o">:</span> <span class="o">(</span><span class="n">coe</span> <span class="o">(</span><span class="bp">@</span><span class="n">sym.nil</span> <span class="n">α</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">sym.nil</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sym.mk_coe</span> <span class="mi">0</span> <span class="n">multiset.card_zero</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">finsupp.multinomial</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f.sum</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">id</span><span class="o">)</span><span class="bp">!</span> <span class="bp">/</span> <span class="n">f.prod</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span><span class="bp">!</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">finsupp.multinomial_eq</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f.multinomial</span> <span class="bp">=</span> <span class="n">multinomial</span> <span class="n">f.support</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">multiset.multinomial</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">m.to_finsupp.multinomial</span>

<span class="kd">lemma</span> <span class="n">multiset.to_finsupp_map</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">m.map</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finsupp</span> <span class="bp">=</span> <span class="n">m.to_finsupp.map_domain</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">conv_lhs</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">m.to_finsupp_to_multiset</span><span class="o">,</span> <span class="n">finsupp.to_multiset_map</span><span class="o">,</span> <span class="n">finsupp.to_multiset_to_finsupp</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">multiset.map_multinomial</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">↪</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">m.map</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">multinomial</span> <span class="bp">=</span> <span class="n">m.multinomial</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">multiset.multinomial</span><span class="o">,</span> <span class="n">finsupp.multinomial</span><span class="o">,</span> <span class="n">m.to_finsupp_map</span> <span class="n">f</span><span class="o">],</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">exacts</span> <span class="o">[</span><span class="n">finsupp.sum_map_domain_index_inj</span> <span class="n">f.inj'</span><span class="o">,</span> <span class="n">finsupp.prod_map_domain_index_inj</span> <span class="n">f.inj'</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">@[simps]</span> <span class="kd">def</span> <span class="n">sym_finset_to_multiset</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">sym</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">↪</span> <span class="n">multiset</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.1.map</span> <span class="n">coe</span><span class="o">,</span>
  <span class="n">inj'</span> <span class="o">:=</span> <span class="o">(</span><span class="n">multiset.map_injective</span> <span class="n">subtype.coe_injective</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">subtype.val_injective</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">multiset.trunc_enum_of_fin_card</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">trunc</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">s.card</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">finset.univ.val.map</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">s</span><span class="o">}</span> <span class="o">:=</span>
<span class="n">quotient.rec_on</span> <span class="n">s</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">trunc.mk</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">l.nth_le</span> <span class="n">i</span> <span class="n">i.2</span><span class="o">,</span> <span class="n">congr_arg</span> <span class="n">coe</span> <span class="n">l.map_nth_le</span><span class="o">⟩)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">subsingleton.elim</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">multinomial_theorem</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">s.sum</span> <span class="n">x</span><span class="o">)</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">k</span> <span class="o">:</span> <span class="n">sym</span> <span class="n">s</span> <span class="n">n</span><span class="o">,</span> <span class="n">k.val.multinomial</span> <span class="bp">*</span> <span class="o">(</span><span class="n">k.val.map</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∘</span> <span class="n">coe</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subtype.val_eq_coe</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">finset.pow_eq_prod_const</span><span class="o">,</span> <span class="bp">←</span> <span class="n">fin.prod_univ_eq_prod_range</span><span class="o">,</span> <span class="n">finset.prod_univ_sum</span><span class="o">],</span>
  <span class="n">simp_rw</span> <span class="n">finset.prod</span><span class="o">,</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">finset.sum_comp</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="n">m.map</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">,</span> <span class="n">finset.univ.val.map</span> <span class="n">f</span><span class="o">)</span> <span class="n">using</span> <span class="mi">1</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp_rw</span> <span class="n">multiset.map_map</span> <span class="o">},</span>
  <span class="n">convert</span> <span class="o">(</span><span class="n">finset.sum_map</span> <span class="n">_</span> <span class="o">(</span><span class="n">sym_finset_to_multiset</span> <span class="n">s</span> <span class="n">n</span><span class="o">)</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">nsmul_eq_mul</span><span class="o">,</span> <span class="n">congr'</span> <span class="mi">2</span><span class="o">,</span>
    <span class="gr">sorry</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">sym_finset_to_multiset_apply</span><span class="o">,</span> <span class="n">multiset.map_map</span><span class="o">],</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">ext1</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finset.mem_image</span><span class="o">,</span> <span class="n">finset.mem_map</span><span class="o">],</span> <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">hf</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="o">⟨⟨</span><span class="n">finset.univ.1.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">f</span> <span class="n">i</span><span class="o">,</span> <span class="n">fintype.mem_pi_finset.1</span> <span class="n">hf</span> <span class="n">i</span><span class="o">⟩),</span>
      <span class="o">(</span><span class="n">multiset.card_map</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="bp">$</span> <span class="n">finset.card_fin</span> <span class="n">n</span><span class="o">⟩,</span> <span class="n">finset.mem_univ</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">sym_finset_to_multiset_apply</span><span class="o">,</span> <span class="n">multiset.map_map</span><span class="o">],</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">hm</span><span class="o">⟩,</span> <span class="bp">-</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">hf</span><span class="o">⟩⟩</span> <span class="o">:=</span> <span class="n">m.trunc_enum_of_fin_card</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">coe</span> <span class="bp">∘</span> <span class="n">f</span> <span class="bp">∘</span> <span class="n">fin_congr</span> <span class="n">hm.symm</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">fintype.mem_pi_finset</span><span class="o">,</span>
    <span class="n">use</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">finset.coe_mem</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">multiset.map_map</span><span class="o">,</span> <span class="bp">←</span> <span class="n">multiset.map_map</span> <span class="n">f</span><span class="o">],</span>
    <span class="n">congr</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">hf</span> <span class="n">using</span> <span class="mi">1</span><span class="o">,</span>
    <span class="n">congr</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">congr_arg</span> <span class="n">finset.val</span> <span class="o">(</span><span class="n">finset.map_univ_equiv</span> <span class="bp">$</span> <span class="n">fin_congr</span> <span class="n">hm.symm</span><span class="o">)</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">α: Type</span>
<span class="cm">_inst_1: decidable_eq α</span>
<span class="cm">R: Type ?</span>
<span class="cm">_inst_2: comm_semiring R</span>
<span class="cm">x: α → R</span>
<span class="cm">s: finset α</span>
<span class="cm">n: ℕ</span>
<span class="cm">x_1: sym ↥s n</span>
<span class="cm">⊢ ↑x_1.multinomial =</span>
<span class="cm">  (finset.filter</span>
<span class="cm">    (λ (a : fin n → α), multiset.map a finset.univ.val = ⇑(sym_finset_to_multiset s n) x_1)</span>
<span class="cm">    (fintype.pi_finset (λ (a : fin n), s))).card</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="295634237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/295634237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#295634237">(Aug 27 2022 at 19:35)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> Thanks a lot! I had made one more step in my original proof, but that sort of fell flat. I'm going to take a good look at it all and see if I get it and then try and fill in the sorry:)</p>



<a name="295669847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/295669847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#295669847">(Aug 28 2022 at 05:41)</a>:</h4>
<p><span class="user-mention" data-user-id="519269">@Pim Otte</span>  I just discovered <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sym">docs#finset.sym</a> which can make the statement of the multinomial theorem simpler (removes the coercion), and probably the proof as well.<br>
I made some progress in the direction of the inductive approach suggested by <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, and it looks like it's gonna yield a shorter proof. Here's my progress so far:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">sym_insert_of_sigma_sym_sub</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">sym</span> <span class="n">s</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">i</span><span class="o">))</span> <span class="o">:</span> <span class="n">sym</span> <span class="bp">↥</span><span class="o">(</span><span class="n">insert</span> <span class="n">a</span> <span class="n">s</span><span class="o">)</span> <span class="n">n</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">m.2.1.map</span> <span class="o">(</span><span class="n">set.inclusion</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">finset.mem_insert_of_mem</span><span class="o">)</span> <span class="bp">+</span> <span class="n">m.1.1</span> <span class="bp">•</span> <span class="o">{⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">s.mem_insert_self</span> <span class="n">a</span><span class="o">⟩},</span>
  <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">multiset.card_add</span><span class="o">,</span> <span class="n">multiset.card_map</span><span class="o">,</span> <span class="n">m.2.2</span><span class="o">,</span> <span class="n">multiset.card_nsmul</span><span class="o">,</span>
    <span class="n">multiset.card_singleton</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">],</span> <span class="n">exact</span> <span class="n">nat.sub_add_cancel</span> <span class="o">(</span><span class="n">nat.lt_succ_iff.1</span> <span class="n">m.1.2</span><span class="o">)</span> <span class="o">}⟩</span>

<span class="kd">@[simps]</span> <span class="kd">def</span> <span class="n">sym_insert_equiv_sigma_sym_sub</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sym</span> <span class="bp">↥</span><span class="o">(</span><span class="n">insert</span> <span class="n">a</span> <span class="n">s</span><span class="o">)</span> <span class="n">n</span> <span class="bp">≃</span> <span class="bp">Σ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">sym</span> <span class="n">s</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="o">⟨⟨(</span><span class="n">m.1.map</span> <span class="n">coe</span><span class="o">)</span><span class="bp">.</span><span class="n">count</span> <span class="n">a</span><span class="o">,</span>
    <span class="o">(</span><span class="n">multiset.count_le_card</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans_lt</span> <span class="bp">$</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">multiset.card_map</span><span class="o">,</span> <span class="n">m.2</span><span class="o">,</span> <span class="n">nat.lt_succ_iff</span><span class="o">]⟩,</span>
    <span class="o">(</span><span class="n">m.1.filter</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">insert</span> <span class="n">a</span> <span class="n">s</span><span class="o">,</span> <span class="n">x.1</span> <span class="bp">≠</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">attach.map</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">finset.mem_of_mem_insert_of_ne</span> <span class="n">x.1.2</span> <span class="o">(</span><span class="n">multiset.mem_filter.1</span> <span class="n">x.2</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">⟩),</span>
    <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">multiset.card_map</span><span class="o">,</span> <span class="n">multiset.card_attach</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">,</span> <span class="n">multiset.count_map</span><span class="o">],</span>
      <span class="n">convert</span> <span class="bp">←</span> <span class="o">(</span><span class="n">tsub_eq_of_eq_add</span> <span class="bp">$</span> <span class="n">multiset.card_eq_countp_add_countp</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">apply</span> <span class="n">multiset.countp_eq_card_filter</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">m.2</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">simp_rw</span> <span class="o">[</span><span class="n">not_ne_iff</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">],</span> <span class="n">apply</span> <span class="n">multiset.countp_eq_card_filter</span> <span class="o">}</span> <span class="o">}⟩,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">sym_insert_of_sigma_sym_sub</span> <span class="n">s</span> <span class="n">a</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>

<span class="kd">theorem</span> <span class="n">multinomial_theorem</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">s.sum</span> <span class="n">x</span><span class="o">)</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">k</span> <span class="o">:</span> <span class="n">sym</span> <span class="n">s</span> <span class="n">n</span><span class="o">,</span> <span class="n">k.val.multinomial</span> <span class="bp">*</span> <span class="o">(</span><span class="n">k.val.map</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∘</span> <span class="n">coe</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">s</span> <span class="n">using</span> <span class="n">finset.induction</span> <span class="k">with</span> <span class="n">a</span> <span class="n">s</span> <span class="n">ha</span> <span class="n">ih</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">finset.sum_empty</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="o">(</span><span class="n">_</span> <span class="bp">|</span> <span class="n">n</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">pow_zero</span><span class="o">,</span> <span class="n">finset.sum_unique_nonempty</span><span class="o">],</span>
      <span class="o">{</span> <span class="n">convert</span> <span class="o">(</span><span class="n">one_mul</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="n">apply</span> <span class="n">nat.cast_one</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">apply</span> <span class="n">finset.univ_nonempty</span> <span class="o">}</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">pow_succ</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">],</span>
      <span class="n">convert</span> <span class="n">finset.sum_of_empty.symm</span><span class="o">,</span>
      <span class="n">convert</span> <span class="n">sym.is_empty</span> <span class="n">n</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">finset.is_empty_coe_sort</span><span class="o">,</span>
      <span class="c">/-</span><span class="cm"> extract instance: finset version of set.has_emptyc.emptyc.is_empty -/</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">finset.sum_insert</span> <span class="n">ha</span><span class="o">,</span> <span class="n">add_pow</span><span class="o">,</span> <span class="n">finset.sum_range</span><span class="o">],</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">ih</span><span class="o">,</span> <span class="n">finset.mul_sum</span><span class="o">,</span> <span class="n">finset.sum_mul</span><span class="o">,</span> <span class="n">finset.sum_sigma'</span><span class="o">],</span>
  <span class="c">/-</span><span class="cm"> now apply fintype.sum_equiv with `sym_insert_equiv_sigma_sym_sub` and</span>
<span class="cm">    rewrite by `multinomial_insert` in #16170;</span>
<span class="cm">    however if we switch to `finset.sym` in the statement</span>
<span class="cm">    then we would have to use `finset.sum_bij` or `sum_bij'`. -/</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="295672923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/295672923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#295672923">(Aug 28 2022 at 06:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/Multinomial.20coefficients.20definition/near/293635819">said</a>:</p>
<blockquote>
<p>Also mind <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sym">docs#finset.sym</a> as a way to avoid fintype computation. I introduced it a while back precisely for multinomial coefficients.</p>
</blockquote>
<p><span aria-label="point up" class="emoji emoji-1f446" role="img" title="point up">:point_up:</span> <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="295714595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/295714595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#295714595">(Aug 28 2022 at 14:08)</a>:</h4>
<p>Small rewrite to use finset.sym (which actually does seem to simplify the first part) and to bring the <code>(n : ℕ)</code> to the theorem statement, which I think is preferred?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">multinomial_theorem</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">):</span>
 <span class="o">(</span><span class="n">s.sum</span> <span class="n">x</span><span class="o">)</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">k</span> <span class="k">in</span> <span class="n">finset.sym</span> <span class="n">s</span> <span class="n">n</span><span class="o">,</span> <span class="n">k.val.multinomial</span> <span class="bp">*</span> <span class="o">(</span><span class="n">k.val.map</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span> <span class="o">:=</span>
<span class="kd">begin</span>
 <span class="n">revert</span> <span class="n">n</span><span class="o">,</span>
 <span class="n">induction</span> <span class="n">s</span> <span class="n">using</span> <span class="n">finset.induction</span> <span class="k">with</span> <span class="n">a</span> <span class="n">s</span> <span class="n">ha</span> <span class="n">ih</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">finset.sum_empty</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="o">(</span><span class="n">_</span> <span class="bp">|</span> <span class="n">n</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">pow_zero</span><span class="o">,</span> <span class="n">finset.sum_unique_nonempty</span><span class="o">],</span>
      <span class="o">{</span> <span class="n">convert</span> <span class="o">(</span><span class="n">one_mul</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="n">apply</span> <span class="n">nat.cast_one</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">apply</span> <span class="n">finset.univ_nonempty</span> <span class="o">}</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">pow_succ</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">,</span> <span class="n">finset.sym_empty</span><span class="o">,</span> <span class="n">finset.sum_empty</span><span class="o">],</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">finset.sum_insert</span> <span class="n">ha</span><span class="o">,</span> <span class="n">add_pow</span><span class="o">,</span> <span class="n">finset.sum_range</span><span class="o">],</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">ih</span><span class="o">,</span> <span class="n">finset.mul_sum</span><span class="o">,</span> <span class="n">finset.sum_mul</span><span class="o">,</span> <span class="n">finset.sum_sigma'</span><span class="o">],</span>
  <span class="c">/-</span><span class="cm"> TODO: use `finset.sum_bij(')`and rewrite by `multinomial_insert` in #16170; -/</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="295720249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/295720249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#295720249">(Aug 28 2022 at 15:04)</a>:</h4>
<blockquote>
<p>bring the (n : ℕ) to the theorem statement, which I think is preferred?</p>
</blockquote>
<p>All arguments before the colon is the general conventnion, but you occasionally see arguments after the colon because it makes the proof shorter, as is the case here.</p>



<a name="295723798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/295723798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#295723798">(Aug 28 2022 at 15:37)</a>:</h4>
<p>I think the only "guideline" is make the proof shortest - <code>revert/intros</code> at the very start is always unnecessary. Still, I often see <code>revert</code> at the start, and this is also often OK, especially when the terms being reverted are part of a <code>variables</code> statement</p>



<a name="295729082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/295729082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#295729082">(Aug 28 2022 at 16:25)</a>:</h4>
<p><code>intros</code> at the beginning is not always a bad sign. For example if you want to prove that some function is injective, you will <code>intros a b hab</code></p>



<a name="295756871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/295756871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#295756871">(Aug 28 2022 at 20:58)</a>:</h4>
<p><span class="user-mention" data-user-id="519269">@Pim Otte</span> I now have a complete proof using the inductive approach at <a href="https://gist.github.com/alreadydone/f9d4444bde854a77e9771db3c9011cb1">https://gist.github.com/alreadydone/f9d4444bde854a77e9771db3c9011cb1</a> . Indeed using <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sym">docs#finset.sym</a> makes things smoother. Have you been working on the orbit-stabilizer approach? I would be curious to know about any progress.</p>
<p>I'm not sure if it's worth providing the original statement using <code>sym s n</code> as a version of the theorem, but I think it's definitely worth making a <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.nat.antidiagonal_tuple">docs#finset.nat.antidiagonal_tuple</a> version when <code>s</code> is <code>finset.univ</code> in <code>fin k</code>. For general <code>s</code> with a bijection to <code>fin k</code>, I think it's also worth providing the antidiagonal_tuple version, as it allows more efficient computation.</p>



<a name="295787890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/295787890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#295787890">(Aug 29 2022 at 06:33)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> Awesome! I had not made any progress on the orbit-stabilizer approach. I don't really have an opinion one way or the other on alternative proofs, but I think for what I was working on this would be sufficient.</p>
<p>If we move this into mathlib, would stuff like <code>finsupp.multinomial</code> go in the <code>data.nat.choose.multinomial</code> (edited), but with a <code>finsupp</code> namespace? </p>
<p>Is it okay if I PR this with you as co-author, in a new PR, dependent  on <a href="https://github.com/leanprover-community/mathlib/pull/16170">#16170</a>?</p>



<a name="295789094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/295789094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#295789094">(Aug 29 2022 at 06:44)</a>:</h4>
<p>Feel free to PR! I think it's most natural to include the various versions of multinomial coefficients in the multinomial file. data.nat.choose seems a weird place. For example, we can't state finsuop.multinomial_eq without the finset version. (And I think the finset version should probably be renamed finset.multinomial.)</p>



<a name="295905561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/295905561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#295905561">(Aug 29 2022 at 15:20)</a>:</h4>
<p>Interestingly there is another thing that could be called <code>multiset.multinomial</code>, which comes from showing the original <code>list.multinomial</code> (which takes a list of multiplicities as input) is independent of the order of the multiplicities. (And we could also define docs$nat.partition .multinomial.) Do we want both multiset versions, and if so how should we disambiguate the names?</p>



<a name="295930010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/295930010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pim Otte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#295930010">(Aug 29 2022 at 15:33)</a>:</h4>
<p>I don't really have the overview to see if we need the alternative version and the naming conventions. Since you can always convert the list to a finsupp easily and use that for the multinomial, I think it's fine using the current version as <code>multiset.mutinomial</code>, and worrying about an alternative name for the other version later?</p>



<a name="295941582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/295941582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Luis Castillo <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#295941582">(Aug 29 2022 at 15:49)</a>:</h4>
<p>(deleted)</p>



<a name="296016960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Multinomial%20coefficients%20definition/near/296016960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Multinomial.20coefficients.20definition.html#296016960">(Aug 29 2022 at 23:49)</a>:</h4>
<p>I think <code>multiset.multinomial</code> is good for the current version; the other version could be called <code>multiset.nat_multinomial</code> or <code>multiset.nat.multinomial</code>. The latter dot notation needs a special ^ trick to work and I don't know where it's documented (I only discovered it in the last month) or if anything changed in Lean 4, but it's used for <a href="https://leanprover-community.github.io/mathlib_docs/find/ideal.quotient.mk">docs#ideal.quotient.mk</a> <a href="https://github.com/leanprover-community/mathlib/blob/b490ab4ac99873a41a6fc5731cb548728d6df9d5/src/ring_theory/ideal/quotient.lean#L116">here</a> for example.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
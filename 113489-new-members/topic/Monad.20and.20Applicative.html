---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Monad.20and.20Applicative.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html">Monad and Applicative</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="300480031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300480031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300480031">(Sep 24 2022 at 03:32)</a>:</h4>
<p>Hi, I am reading <a href="https://leanprover.github.io/lean4/doc/monads/monads.lean.html#what-separates-monads-from-applicatives">https://leanprover.github.io/lean4/doc/monads/monads.lean.html#what-separates-monads-from-applicatives</a> but I don't quite understand that paragraph. It says "You cannot really determine the structure of "future" operations" but we do. For example, a Maybe monad can only produce another Maybe monad in the future. Is that not right?</p>



<a name="300480218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300480218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300480218">(Sep 24 2022 at 03:36)</a>:</h4>
<p>There seem to be some missing words in that sentence. It's talking about applicatives there</p>



<a name="300480240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300480240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300480240">(Sep 24 2022 at 03:37)</a>:</h4>
<p>A monad allows you to determine the structure of future computations based on the results of past computations</p>



<a name="300480251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300480251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300480251">(Sep 24 2022 at 03:37)</a>:</h4>
<p>In an applicative, you determine the structure in advance of getting any of the results</p>



<a name="300480351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300480351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300480351">(Sep 24 2022 at 03:38)</a>:</h4>
<p>Here by "structure of computations" we mean things like which functions get called</p>



<a name="300484078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300484078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300484078">(Sep 24 2022 at 04:50)</a>:</h4>
<p>Thank you. I think I've got it now. That sentence might have been a general statement, applicable to both Applicative and Monad.</p>



<a name="300484190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300484190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300484190">(Sep 24 2022 at 04:52)</a>:</h4>
<p>the first sentence sets up the premise that context is what separates the two. the second sentence states that general observation. the third says that with applicative you can't get final value (i guess you can with monad, e.g. Nothing), but you can determine the call tree.</p>



<a name="300484323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300484323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300484323">(Sep 24 2022 at 04:54)</a>:</h4>
<p>does that sound about right?</p>



<a name="300484951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300484951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300484951">(Sep 24 2022 at 05:05)</a>:</h4>
<p>I'm not sure what you mean by "you can't get the final value"</p>



<a name="300485087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300485087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300485087">(Sep 24 2022 at 05:07)</a>:</h4>
<p>you can always get the value if you know what type it is; it's just that the monad / applicative operations don't give you a way to exit the monad generically</p>



<a name="300485144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300485144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300485144">(Sep 24 2022 at 05:08)</a>:</h4>
<p>most monads will have a <code>run</code> function which extracts the data from the monad. It's just that the type signature of this function varies a lot depending on the monad</p>



<a name="300485177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300485177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300485177">(Sep 24 2022 at 05:09)</a>:</h4>
<p>by "final value" i mean the same as "final function result" in that paragraph</p>



<a name="300485199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300485199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300485199">(Sep 24 2022 at 05:09)</a>:</h4>
<p>"""With applicatives, you can't get the final function result without evaluating everything,"""</p>



<a name="300487218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300487218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300487218">(Sep 24 2022 at 05:43)</a>:</h4>
<p>Stated that way, it's true for monads too</p>



<a name="300487264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300487264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300487264">(Sep 24 2022 at 05:44)</a>:</h4>
<p>or functions in general</p>



<a name="300487275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300487275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300487275">(Sep 24 2022 at 05:44)</a>:</h4>
<p>you don't get the result until everything is evaluated</p>



<a name="300549870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300549870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300549870">(Sep 24 2022 at 15:10)</a>:</h4>
<p>damn. then i don't know what that paragraph means.</p>



<a name="300555779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300555779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300555779">(Sep 24 2022 at 16:03)</a>:</h4>
<p><span class="user-mention" data-user-id="284601">@Nam</span> I think that paragraph is getting at the fact that applicatives have more restrictive control flow than monads. Roughly speaking, with applicatives you can figure out what the control flow is going to be even without evaluating anything, but with monads the control flow can depend on the specific values involved. (<span class="user-mention" data-user-id="434989">@Chris Lovett</span> The sentence in the monad docs might be clearer as "With applicatives, you can determine the structure of how the operation will take place even before you evaluate everything.")</p>



<a name="300565098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300565098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300565098">(Sep 24 2022 at 17:32)</a>:</h4>
<p>ah, yes, thank you Kyle. that's roughly what i understand too.</p>



<a name="300566930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300566930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300566930">(Sep 24 2022 at 17:52)</a>:</h4>
<p>I've another question. the <code>bind</code> operation is defined as <code>bind : {α β : Type u} → f α → (α → f β) → f β</code>. it uses the same type constructor <code>f</code>, which is the monad itself. that means the chain of operations must return the same type of monad. why can't it return a different type of monad?</p>



<a name="300567412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300567412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300567412">(Sep 24 2022 at 17:58)</a>:</h4>
<p><span class="user-mention" data-user-id="284601">@Nam</span> Because then it wouldn't be a monad <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span> That's just the definition.</p>



<a name="300567503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300567503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300567503">(Sep 24 2022 at 17:59)</a>:</h4>
<p>lol fair enough</p>



<a name="300567919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Monad%20and%20Applicative/near/300567919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Monad.20and.20Applicative.html#300567919">(Sep 24 2022 at 18:03)</a>:</h4>
<p>One example of something that's monad-like but not a monad is indexed monads. One version I've seen has a bind operation of type <code>bind : {α β : Type u} → f i j α → (α → f j k β) → f i k β</code> where for each <code>i</code> you have that <code>f i i</code> is a monad.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
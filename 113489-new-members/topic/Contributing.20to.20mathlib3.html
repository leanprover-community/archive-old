---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Contributing.20to.20mathlib3.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html">Contributing to mathlib3</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="253328014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/253328014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#253328014">(Sep 14 2021 at 21:36)</a>:</h4>
<p>I want to try contributing an undergraduate topic into mathlib. So far I have been learning with Lean 4 and I've found that I prefer it a lot more than Lean 3. Is it still worth contributing to mathlib3 if everything is getting moved over into mathlib4?</p>



<a name="253331391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/253331391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#253331391">(Sep 14 2021 at 22:07)</a>:</h4>
<p>mathlib3 a.k.a. mathlib is being moved over into lean 4, so sure it's worth contributing to that. mathlib4 is just some fun experimentation and the current plan is that this is not going to be Lean4 maths library.</p>



<a name="253332231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/253332231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#253332231">(Sep 14 2021 at 22:14)</a>:</h4>
<p>Ok, thanks. I noticed everything in mathlib is proved in the highest level of abstraction possible. Can I still contribute if I don't know enough abstract math to do that? Areas I was thinking of are matrices and complex analysis</p>



<a name="253334336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/253334336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#253334336">(Sep 14 2021 at 22:34)</a>:</h4>
<p>Unfortunately complex analysis is being formalised in mathlib in quite a complicated way; there is a plan which is slowly being executed, and it involves a lot of abstract maths. Matrices on the other hand are in mathlib already.</p>



<a name="253335165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/253335165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#253335165">(Sep 14 2021 at 22:42)</a>:</h4>
<p>I've looked at the matrix files just a little bit. What about any of these topics that are listed on the undergrad todo page?<br>
 change of basis, rank of a matrix, elementary row operations, elementary column operations, Gaussian elimination, row-reduced matrices.</p>



<a name="253335247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/253335247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Pilotti <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#253335247">(Sep 14 2021 at 22:43)</a>:</h4>
<p>Out of curiosity, how is complex analysis being formalized? Which math does it involve?</p>



<a name="253335260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/253335260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#253335260">(Sep 14 2021 at 22:43)</a>:</h4>
<p>Matrices: Oh if these are not done then they're definitely fair game! But I would definitely discuss any specific plans you have for this with experts before you launch into anything.</p>



<a name="253335367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/253335367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#253335367">(Sep 14 2021 at 22:44)</a>:</h4>
<p>complex analysis: the theory of integration and Cauchy's integral formula are being deduced from more general results involving  some n-dimensional version of Stokes' theorem in real analysis.</p>



<a name="253342371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/253342371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#253342371">(Sep 14 2021 at 23:59)</a>:</h4>
<p>Elementary operations and a form of Gaussian elimination were recently added in <a href="https://github.com/leanprover-community/mathlib/issues/8898">#8898</a></p>



<a name="272075792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272075792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272075792">(Feb 16 2022 at 05:40)</a>:</h4>
<p>Hi, I'd like to contribute some things to mathlib here's what I'd like to add:</p>
<ul>
<li>
<p>Generalized binomial coefficients: <br>
<a href="/user_uploads/3121/s3R4fQrqIiIkErDnHF_jhpMO/image.png">image.png</a> </p>
<div class="message_inline_image"><a href="/user_uploads/3121/s3R4fQrqIiIkErDnHF_jhpMO/image.png" title="image.png"><img src="/user_uploads/3121/s3R4fQrqIiIkErDnHF_jhpMO/image.png"></a></div></li>
<li>
<p>Multinomial coefficients<br>
<a href="/user_uploads/3121/UCgLQfqqVmBWGA-tlE32j5Mp/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/UCgLQfqqVmBWGA-tlE32j5Mp/image.png" title="image.png"><img src="/user_uploads/3121/UCgLQfqqVmBWGA-tlE32j5Mp/image.png"></a></div></li>
</ul>
<p>Based on this conversation I have a good idea of what arguments the multinomial coefficient could take in:</p>
<p><a href="/user_uploads/3121/jiwJH1otEL7FQLV9j8j2nQZb/image.png">image.png</a> </p>
<div class="message_inline_image"><a href="/user_uploads/3121/jiwJH1otEL7FQLV9j8j2nQZb/image.png" title="image.png"><img src="/user_uploads/3121/jiwJH1otEL7FQLV9j8j2nQZb/image.png"></a></div><p>Once we have these new types of coefficients I could possibly extend this to add in the multinomial theorem  as well as newtons binomial theorem which extends the usual binomial theorem to work for real numbers as well.</p>
<p>I have a few questions:</p>
<p>I'm aware that we already have <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.choose">docs#nat.choose</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/add_pow">docs#add_pow</a>. Where would these new definitions go?</p>
<p>I was trying to get an idea of how to define the new coefficients, so I took a look at the current definition we have for <code>nat.choose</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">choose</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">_</span>             <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="o">(</span><span class="n">k</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">choose</span> <span class="n">n</span> <span class="n">k</span> <span class="bp">+</span> <span class="n">choose</span> <span class="n">n</span> <span class="o">(</span><span class="n">k</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>Am I right that this is trying to pattern match in the following way?</p>
<p>Anything choose 0 is 1, <br>
0 choose some number is 0<br>
finally (n + 1 ) choose (k + 1) = n choose k + n choose (k + 1)  (recursive definition)</p>



<a name="272076202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272076202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272076202">(Feb 16 2022 at 05:49)</a>:</h4>
<p>What's your goal? Are you wanting to prove Newton's binomial series expansion or something like that?</p>



<a name="272077023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272077023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272077023">(Feb 16 2022 at 06:05)</a>:</h4>
<p>That’s the right way to read the definition, yes</p>



<a name="272077278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272077278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272077278">(Feb 16 2022 at 06:10)</a>:</h4>
<p>Here's a branch containing the multinomial coefficient, using a <code>list</code> for <code>[k1, k2, ..., kn]</code>. <a href="https://github.com/leanprover-community/mathlib/blob/binomial/src/data/nat/choose/multinomial.lean#L12">https://github.com/leanprover-community/mathlib/blob/binomial/src/data/nat/choose/multinomial.lean#L12</a></p>



<a name="272077305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272077305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ccn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272077305">(Feb 16 2022 at 06:11)</a>:</h4>
<p>Well right now I have questions I'm working with that use multinomial coefficients and the generalized binomial coefficients, once we have them then I could try to prove newtons expansion yes.</p>



<a name="272078379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272078379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272078379">(Feb 16 2022 at 06:35)</a>:</h4>
<p>Ideally the generalized binomial coefficient could take as input anything that has multiplication, subtraction by naturals, and division by naturals. That way you could both plug in real numbers directly or get a polynomial out of it.</p>
<p>I'm not sure how to go about setting that up in that generality. Maybe it's not necessary, but I was trying to get it so that it could still take in natural numbers.</p>



<a name="272078585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272078585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272078585">(Feb 16 2022 at 06:39)</a>:</h4>
<p>One thing I was experimenting with (but it doesn't help with division by naturals) is add-cancellative commutative semirings. They have a unique subtraction operation -- but giving a default instance for this seems problematic diamond-wise...</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>code</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="kd">@[protect_proj, ancestor comm_semiring add_left_cancel_monoid]</span>
<span class="kd">class</span> <span class="n">add_cancel_comm_semiring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">comm_semiring</span> <span class="n">α</span><span class="o">,</span> <span class="n">add_left_cancel_monoid</span> <span class="n">α</span>

<span class="kd">@[priority 0]</span>
<span class="kd">noncomputable</span>
<span class="kd">instance</span> <span class="n">comm_semiring.has_sub</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_cancel_comm_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_sub</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">classical</span><span class="bp">;</span> <span class="n">exactI</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">c</span><span class="o">,</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="k">then</span> <span class="n">h.some</span> <span class="k">else</span> <span class="mi">0</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">comm_semiring.sub_unique</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_cancel_comm_semiring</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">-</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">has_sub.sub</span><span class="o">],</span>
  <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">h'</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">subst</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h''</span> <span class="o">:=</span> <span class="n">h'.some_spec</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">add_left_cancel</span> <span class="n">h''</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">h'</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">add_cancel_comm_semiring</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add_left_cancel</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">apply</span> <span class="n">add_left_cancel</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">infer_instance</span> <span class="o">:</span> <span class="n">comm_semiring</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>
</div></div>



<a name="272079191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272079191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272079191">(Feb 16 2022 at 06:52)</a>:</h4>
<p>Oh right, to avoid problems the subtraction can be required as additional data.</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>code</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="kd">@[protect_proj, ancestor comm_semiring add_left_cancel_monoid]</span>
<span class="kd">class</span> <span class="n">add_cancel_comm_semiring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="kd">extends</span> <span class="n">comm_semiring</span> <span class="n">α</span><span class="o">,</span> <span class="n">add_left_cancel_monoid</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_sub</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">sub_eq_of_eq_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">-</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">add_cancel_comm_semiring</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">sub_eq_of_eq_add</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintro</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">add_comm</span><span class="o">,</span> <span class="n">nat.add_sub_cancel</span><span class="o">],</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">add_left_cancel</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">add_left_cancel</span><span class="o">,</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">infer_instance</span> <span class="o">:</span> <span class="n">comm_semiring</span> <span class="n">ℕ</span><span class="o">),</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">infer_instance</span> <span class="o">:</span> <span class="n">has_sub</span> <span class="n">ℕ</span><span class="o">)}</span>

<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">comm_semiring.has_sub</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_sub</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">classical</span><span class="bp">;</span> <span class="n">exactI</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">c</span><span class="o">,</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="k">then</span> <span class="n">h.some</span> <span class="k">else</span> <span class="mi">0</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">comm_semiring.sub_unique</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">has_sub.sub</span> <span class="n">_</span> <span class="n">comm_semiring.has_sub</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">change</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">dite</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">h'</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">subst</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h''</span> <span class="o">:=</span> <span class="n">h'.some_spec</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span> <span class="n">h''</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">h'</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="272086093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272086093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272086093">(Feb 16 2022 at 08:32)</a>:</h4>
<p>Why not just stick to ℚ-algebras? All the important examples like the reals and complexes and p-adics (hypergeometric functions etc) are ℚ-algebras.</p>



<a name="272261400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272261400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272261400">(Feb 17 2022 at 13:51)</a>:</h4>
<p>Is "Q-algebra" and "char-zero division_ring" synonymous?</p>



<a name="272263970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272263970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272263970">(Feb 17 2022 at 14:08)</a>:</h4>
<p>No reasons for a <code>Q</code>-algebra to be a division ring.</p>



<a name="272284212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272284212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272284212">(Feb 17 2022 at 16:25)</a>:</h4>
<p>If anyone wants to work on this, here's a possible definition of the generalized binomial coefficient for ℚ-algebras. There's part of a proof that it coincides with <code>nat.choose</code> for natural numbers, though maybe it can be generalized to ℚ-algebras in general.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ring.basic</span>
<span class="kn">import</span> <span class="n">algebra.algebra.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">def</span> <span class="n">binomial</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">ℚ</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">x</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">x</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">((</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">•</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">binomial</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">•</span> <span class="mi">1</span><span class="o">)</span> <span class="n">n</span>

<span class="kd">lemma</span> <span class="n">binomial_eq</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">binomial</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">nat.choose</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span> <span class="n">generalizing</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">binomial</span><span class="o">],</span>
  <span class="n">cases</span> <span class="n">m</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">binomial</span><span class="o">],</span>
    <span class="c1">-- (↑n + 1)⁻¹ • 0 = 0</span>
    <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">binomial</span><span class="o">,</span> <span class="n">ih</span><span class="o">],</span>
    <span class="n">norm_cast</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">nat.succ_mul_choose_eq</span><span class="o">],</span>
    <span class="c1">-- (↑(n + 1))⁻¹ • ↑(m.succ.choose n.succ * n.succ) = ↑(m.succ.choose n.succ)</span>
    <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="c1">-- maybe?</span>
<span class="kd">lemma</span> <span class="n">binomial_eq'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">ℚ</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">binomial</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">nat.choose</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="272555572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272555572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272555572">(Feb 20 2022 at 01:17)</a>:</h4>
<p>Ok,  I think that definition looks good,  ( I can start with that) and then try to complete those lemmas. Since I'm still pretty new to contributing to mathlib, could you outline how I would get it in there?</p>
<p>So far what I know is that I would fork the project make a branch, but then would this content go into it's own file?</p>



<a name="272555648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272555648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272555648">(Feb 20 2022 at 01:18)</a>:</h4>
<p>What would I call that file?</p>



<a name="272555743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272555743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272555743">(Feb 20 2022 at 01:20)</a>:</h4>
<p>What about <code>data.nat.choose.multi</code>, <code>data.nat.choose.multinomial</code>?</p>



<a name="272555770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272555770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272555770">(Feb 20 2022 at 01:21)</a>:</h4>
<p>And for the generalized coefficients?</p>



<a name="272555831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272555831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272555831">(Feb 20 2022 at 01:22)</a>:</h4>
<p>And for the q-analog, I guess <code>data.nat.choose.q_analog</code> or <code>data.nat.choose.q_binomial</code> (to avoid confusion with other q-analogs) is fair.</p>



<a name="272555847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272555847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272555847">(Feb 20 2022 at 01:23)</a>:</h4>
<p>Ok, as for the different ways of approaching the multinomial which do you think is better, passing in a list or passing in a function?</p>



<a name="272555855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272555855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272555855">(Feb 20 2022 at 01:23)</a>:</h4>
<p>If we pass in a list we can do <code>(m.map nat.factorial).prod</code> to dividie it</p>



<a name="272555910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272555910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272555910">(Feb 20 2022 at 01:24)</a>:</h4>
<p>and if we pass in a function we can use <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.prod">docs#finset.prod</a></p>



<a name="272555921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272555921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272555921">(Feb 20 2022 at 01:24)</a>:</h4>
<p>Ok, so they both seem good</p>



<a name="272555929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272555929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272555929">(Feb 20 2022 at 01:24)</a>:</h4>
<p>It looks like some work was already done on it: <a href="https://github.com/leanprover-community/mathlib/blob/binomial/src/data/nat/choose/multinomial.lean">https://github.com/leanprover-community/mathlib/blob/binomial/src/data/nat/choose/multinomial.lean</a></p>



<a name="272555952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272555952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272555952">(Feb 20 2022 at 01:25)</a>:</h4>
<p>In this situation is there a way to "revive" the branch and then I can get it to work? I don't even know what's wrong with that branch anyways...</p>



<a name="272555957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272555957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272555957">(Feb 20 2022 at 01:25)</a>:</h4>
<p>I personally prefer the function version, because it emphasizes that there is no preferred order. And also it seems pretty convenient to prove the multinomial formula.</p>



<a name="272555968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272555968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272555968">(Feb 20 2022 at 01:26)</a>:</h4>
<p>Ok, so in this case should I just make a new branch and work on it from there?</p>



<a name="272555970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272555970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272555970">(Feb 20 2022 at 01:26)</a>:</h4>
<p>Yes of course, just ask Kyle and merge master.</p>



<a name="272556018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272556018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272556018">(Feb 20 2022 at 01:26)</a>:</h4>
<p>(to your previous question)</p>



<a name="272556030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272556030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272556030">(Feb 20 2022 at 01:26)</a>:</h4>
<p>Do you think it would be worth it to convert it to be working for the function version?</p>



<a name="272556034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272556034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272556034">(Feb 20 2022 at 01:26)</a>:</h4>
<p>I'm open to trying that</p>



<a name="272556048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272556048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272556048">(Feb 20 2022 at 01:27)</a>:</h4>
<p>I think you could try both.</p>



<a name="272556060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272556060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272556060">(Feb 20 2022 at 01:27)</a>:</h4>
<p>Arguably, Kyle already did half the job.</p>



<a name="272556122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272556122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272556122">(Feb 20 2022 at 01:28)</a>:</h4>
<p>When you make new branches like this, do you try and get the definition in and then prove basic facts about it all at once? Or first get the definition, wait till it merges in and then add them?</p>



<a name="272556154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272556154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272556154">(Feb 20 2022 at 01:29)</a>:</h4>
<p>I guess I only wonder because in the latter then people can start using the definition before you're done proving everything else...</p>



<a name="272556262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272556262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272556262">(Feb 20 2022 at 01:30)</a>:</h4>
<p>Well, you should prove at least enough to demonstrate that your definition is reasonable.</p>



<a name="272556412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272556412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272556412">(Feb 20 2022 at 01:33)</a>:</h4>
<p>Ok thanks for the tips</p>



<a name="272605489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272605489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272605489">(Feb 20 2022 at 17:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/Contributing.20to.20mathlib3/near/272555957">said</a>:</p>
<blockquote>
<p>I personally prefer the function version, because it emphasizes that there is no preferred order. And also it seems pretty convenient to prove the multinomial formula.</p>
</blockquote>
<p>I suspect it's easiest to prove things initially with the list version (precisely because it has an order) then bolt the function version on top.</p>
<p>There are identities involving adding and removing elements of this list, which is harder with functions, but lists are designed for this.</p>



<a name="272605569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272605569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272605569">(Feb 20 2022 at 17:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="367659">Callum Cassidy-Nolan</span> <a href="#narrow/stream/113489-new-members/topic/Contributing.20to.20mathlib3/near/272555968">said</a>:</p>
<blockquote>
<p>Ok, so in this case should I just make a new branch and work on it from there?</p>
</blockquote>
<p>I suggest making a new branch, <code>ccm_multinomial</code> or something. The current branch is old and has some stuff written by myself and <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> mixed together, and once analogues of everything in the old branch end up in mathlib, it can be deleted.</p>



<a name="272605664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272605664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272605664">(Feb 20 2022 at 17:35)</a>:</h4>
<p>One workflow I do: have a primary branch for development, then for each PR create a new branch with some small chunk (smaller is better). If anyone wonders where your PRs are going, you can point to the primary branch to help justify your design.</p>



<a name="272605727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272605727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272605727">(Feb 20 2022 at 17:36)</a>:</h4>
<p>And then as those PRs are merged, you can keep merging master into your primary branch.</p>



<a name="272605934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272605934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272605934">(Feb 20 2022 at 17:40)</a>:</h4>
<p>I should say what the reason was for using lists with the multinomial coefficient: it gives you reasonably good notation without any additional work. <code>multinomial [a, b]</code> is perfect for applications like <code>∑ p in nat.antidiagonal n, multinomial [p.1, p.2] * x^p.1 * y^p.2</code>, while being able to generalize to larger numbers of terms. (Like, if we had higher antidiagonals, <code>∑ p in nat.antidiagonal₃ n, multinomial [p.1, p.2, p.3] * x^p.1 * y^p.1 * z^p.3</code>)</p>
<p>Indexed families aren't so easily constructed.</p>



<a name="272709337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272709337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272709337">(Feb 21 2022 at 16:24)</a>:</h4>
<p>Thanks for the tips about that. I managed to get my branch going and I'll try to rebuild using the list version first, Also I see stuff like this at the top of the files:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Copyright</span> <span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="mi">2021</span> <span class="n">Ya</span><span class="bp">ë</span><span class="n">l</span> <span class="n">Dillies.</span> <span class="n">All</span> <span class="n">rights</span> <span class="n">reserved.</span>
<span class="n">Released</span> <span class="n">under</span> <span class="n">Apache</span> <span class="mi">2</span><span class="bp">.</span><span class="mi">0</span> <span class="n">license</span> <span class="n">as</span> <span class="n">described</span> <span class="k">in</span> <span class="n">the</span> <span class="n">file</span> <span class="n">LICENSE.</span>
<span class="n">Authors</span><span class="o">:</span> <span class="n">Ya</span><span class="bp">ë</span><span class="n">l</span> <span class="n">Dillies</span>
</code></pre></div>
<p>How does this work?</p>



<a name="272709731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272709731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272709731">(Feb 21 2022 at 16:28)</a>:</h4>
<p>Have you read the <a href="https://leanprover-community.github.io/contribute/index.html">contribution guidelines</a>? It links to a <a href="https://leanprover-community.github.io/contribute/style.html">style guide</a> which describes what should go in the header, etc.</p>



<a name="272710372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272710372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272710372">(Feb 21 2022 at 16:34)</a>:</h4>
<p>Thanks, I just read it</p>



<a name="272711525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272711525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272711525">(Feb 21 2022 at 16:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Contributing.20to.20mathlib3/near/272605569">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="367659">Callum Cassidy-Nolan</span> <a href="#narrow/stream/113489-new-members/topic/Contributing.20to.20mathlib3/near/272555968">said</a>:</p>
<blockquote>
<p>Ok, so in this case should I just make a new branch and work on it from there?</p>
</blockquote>
<p>I suggest making a new branch, <code>ccm_multinomial</code> or something. The current branch is old and has some stuff written by myself and <span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> mixed together, and once analogues of everything in the old branch end up in mathlib, it can be deleted.</p>
</blockquote>
<p>I put all that code in the old merge in and fix all the errors in it (not that many), should I put your and Kevin's names at the top of the file using apache lisence?</p>



<a name="272711723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272711723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272711723">(Feb 21 2022 at 16:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Contributing.20to.20mathlib3/near/272284212">said</a>:</p>
<blockquote>
<p>If anyone wants to work on this, here's a possible definition of the generalized binomial coefficient for ℚ-algebras. There's part of a proof that it coincides with <code>nat.choose</code> for natural numbers, though maybe it can be generalized to ℚ-algebras in general.</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ring.basic</span>
<span class="kn">import</span> <span class="n">algebra.algebra.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">def</span> <span class="n">binomial</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">ℚ</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">x</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">x</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">((</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">•</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">binomial</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">•</span> <span class="mi">1</span><span class="o">)</span> <span class="n">n</span>

<span class="kd">lemma</span> <span class="n">binomial_eq</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">binomial</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">nat.choose</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span> <span class="n">generalizing</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">binomial</span><span class="o">],</span>
  <span class="n">cases</span> <span class="n">m</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">binomial</span><span class="o">],</span>
    <span class="c1">-- (↑n + 1)⁻¹ • 0 = 0</span>
    <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">binomial</span><span class="o">,</span> <span class="n">ih</span><span class="o">],</span>
    <span class="n">norm_cast</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">nat.succ_mul_choose_eq</span><span class="o">],</span>
    <span class="c1">-- (↑(n + 1))⁻¹ • ↑(m.succ.choose n.succ * n.succ) = ↑(m.succ.choose n.succ)</span>
    <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="c1">-- maybe?</span>
<span class="kd">lemma</span> <span class="n">binomial_eq'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">ℚ</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">binomial</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">nat.choose</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div><br>
</p>
</blockquote>
<p>What does the <code>•</code> symbol do?</p>



<a name="272713631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Contributing%20to%20mathlib3/near/272713631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Contributing.20to.20mathlib3.html#272713631">(Feb 21 2022 at 17:01)</a>:</h4>
<p>This is multiplication by scalars. In Lean 3, multiplication is homogeneous: in <code>a*b</code>  you need <code>a</code> and <code>b</code> to have the same type. So if you want to multiply, say a vector <code>v</code> with some real number <code>a</code> then  you write <code>a • v</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
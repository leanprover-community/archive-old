---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html">Why doesn't dunfold work here?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="208056725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208056725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208056725">(Aug 26 2020 at 06:26)</a>:</h4>
<p>I have the following:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span>
<span class="c1">--import data.equiv</span>
<span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">group_action</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span><span class="bp">.</span><span class="n">hom</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">G</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">h</span><span class="o">:</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>

<span class="kn">open</span> <span class="n">equiv</span>
<span class="kn">open</span> <span class="n">function</span>

<span class="n">def</span> <span class="n">cayley</span> <span class="o">(</span><span class="n">G</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">h</span><span class="o">:</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">perm</span> <span class="n">G</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="k">let</span> <span class="n">f</span><span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">perm</span> <span class="n">G</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">g1</span><span class="o">:</span><span class="n">G</span><span class="o">,</span> <span class="k">by</span>
        <span class="o">{</span>
            <span class="k">let</span> <span class="n">p</span><span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="o">:=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">g</span><span class="o">,</span> <span class="n">g1</span> <span class="bp">*</span> <span class="n">g</span><span class="o">),</span>
            <span class="k">let</span> <span class="n">pinv</span><span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="o">:=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">g</span><span class="o">,</span> <span class="n">g1</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">g</span><span class="o">),</span>
            <span class="k">have</span> <span class="n">hleftinv</span><span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">left_inverse</span> <span class="n">pinv</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="k">by</span>
                <span class="o">{</span>
                    <span class="n">dunfold</span> <span class="n">left_inverse</span><span class="o">,</span>
                    <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
                    <span class="n">dunfold</span> <span class="n">p</span><span class="o">,</span>


                <span class="o">},</span>
            <span class="k">have</span> <span class="n">hrightinv</span><span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">right_inverse</span> <span class="n">pinv</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span><span class="o">,</span>
            <span class="n">exact</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">mk</span> <span class="n">p</span> <span class="n">pinv</span> <span class="n">hleftinv</span> <span class="n">hrightinv</span><span class="o">,</span>
        <span class="o">},</span>
    <span class="k">have</span> <span class="n">h1</span><span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h2</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span><span class="o">,</span>
    <span class="n">exact</span> <span class="bp">⟨</span> <span class="n">f</span><span class="o">,</span> <span class="n">h1</span><span class="o">,</span> <span class="n">h2</span> <span class="bp">⟩</span>
<span class="kn">end</span>
</code></pre></div>


<p>Hovering above <code>intro x,</code> gives me the goal state</p>
<div class="codehilite"><pre><span></span><code><span class="n">G</span><span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span>
<span class="n">h</span><span class="o">:</span> <span class="n">group</span> <span class="n">G</span>
<span class="n">g1</span><span class="o">:</span> <span class="n">G</span>
<span class="n">p</span><span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">g1</span> <span class="bp">*</span> <span class="n">g</span>
<span class="n">pinv</span><span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">g1</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">g</span>
<span class="n">x</span><span class="o">:</span> <span class="n">G</span>
<span class="err">⊢</span> <span class="n">pinv</span> <span class="o">(</span><span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span>
</code></pre></div>


<p>I want to unfold  <code>pinv (p x)</code>, but <code>dunfold p</code> gives me <code>unknown declaration 'p'</code>, even though clearly <code>p</code> is part of the assumptions. <br>
Also, just applying the <code>group</code> tactic doesn't work either, to my surprise. It reduces the goal to  <code>pinv (p x) * x ^ -1 = 1</code>.<br>
<code>library_search</code> does work by the way, but I don't understand why the previous things don't.</p>



<a name="208058348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208058348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208058348">(Aug 26 2020 at 06:59)</a>:</h4>
<p><code>dsimp [p]</code> works fine. I tend not to use <code>dunfold</code> much.</p>



<a name="208059421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208059421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208059421">(Aug 26 2020 at 07:17)</a>:</h4>
<p>I've noticed that <code>dunfold</code> doesn't work with <code>let</code>-bound local definitions.  I'm not sure why.</p>
<p>A workaround that might be worth knowing in case <code>dsimp</code> doesn't work is <code>set</code>, which lets you define an equation, too:</p>
<div class="codehilite"><pre><span></span><code><span class="n">set</span> <span class="n">p</span><span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="o">:=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">g</span><span class="o">,</span> <span class="n">g1</span> <span class="bp">*</span> <span class="n">g</span><span class="o">)</span> <span class="k">with</span> <span class="n">hp</span><span class="o">,</span>
</code></pre></div>


<p>and then you can do <code>rw hp</code>.  Another thing worth knowing is <code>delta</code> to expand definitions, though it doesn't work here for some reason.</p>



<a name="208066658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208066658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208066658">(Aug 26 2020 at 08:54)</a>:</h4>
<p>I'm actually getting another error on this: The phrase<code>have h1: f 1 = 1, from sorry</code> doesn't give any  errors, but I get an error when I write <code>have h1: (f 1).to_fun = 1, from sorry</code>, namely:</p>
<div class="codehilite"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span> <span class="n">for</span>
<span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">group</span> <span class="n">G</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">perm</span> <span class="n">G</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">g1</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span>
    <span class="k">let</span> <span class="n">p</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">g1</span> <span class="bp">*</span> <span class="n">g</span><span class="o">,</span>
        <span class="n">pinv</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">g1</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">g</span>
    <span class="k">in</span> <span class="o">{</span><span class="n">to_fun</span> <span class="o">:=</span> <span class="n">p</span><span class="o">,</span> <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">pinv</span><span class="o">,</span> <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span> <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">}</span>
<span class="err">⊢</span> <span class="n">has_one</span> <span class="o">(</span><span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">group</span> <span class="n">G</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">perm</span> <span class="n">G</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">g1</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span>
    <span class="k">let</span> <span class="n">p</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">g1</span> <span class="bp">*</span> <span class="n">g</span><span class="o">,</span>
        <span class="n">pinv</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">g1</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">g</span>
    <span class="k">in</span> <span class="o">{</span><span class="n">to_fun</span> <span class="o">:=</span> <span class="n">p</span><span class="o">,</span> <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">pinv</span><span class="o">,</span> <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span> <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">}</span>
<span class="err">⊢</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">perm</span> <span class="n">G</span>
</code></pre></div>


<p>I don't understand this error.</p>



<a name="208071861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208071861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208071861">(Aug 26 2020 at 09:54)</a>:</h4>
<div class="codehilite"><pre><span></span><code>failed to synthesize type class instance for
G : Type ?,
_inst_1 : group G,
f : G → perm G :=
  λ (g1 : G),
    let p : G → G := λ (g : G), g1 * g,
        pinv : G → G := λ (g : G), g1⁻¹ * g
    in {to_fun := p, inv_fun := pinv, left_inv := _, right_inv := _}
⊢ has_one (G → G)
</code></pre></div>


<blockquote>
<p>I don't understand this error.</p>
</blockquote>
<p>It means that you asked Lean for a term called <code>1</code> of type <code>G → G</code> and it doesn't know what you mean.</p>



<a name="208071930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208071930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208071930">(Aug 26 2020 at 09:55)</a>:</h4>
<p>Half your problem is that you are making definitions using tactic mode.</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">cayley</span> <span class="o">(</span><span class="n">G</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">h</span><span class="o">:</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">perm</span> <span class="n">G</span> <span class="o">:=</span>
<span class="k">begin</span>
</code></pre></div>


<p>this is a bad move. You're constructing a term, not a proof. You should create the structure using the usual <code>{ field1 := value1, field2 := value2, ...}</code> structure creation syntax.</p>



<a name="208075365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208075365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208075365">(Aug 26 2020 at 10:34)</a>:</h4>
<p>I'm not sure that "don't use tactic mode to make definitions" is an absolute rule. It is true that some tactics can make gross terms, and in particular it's easy to accidentally make terms that aren't definitionally what you expected them to be. Moreover using <code>simp</code> and <code>rw</code> when making definitions is likely to introduce <code>eq.rec</code> in your definition terms and you'll be sad later.</p>
<p>But still I use tactic mode all the time when "exploring" how to make a definition; nearly always I golf it away afterwards to be sure I've done what I thought I was doing, but it can still be helpful.</p>



<a name="208087855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208087855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208087855">(Aug 26 2020 at 13:04)</a>:</h4>
<p>A guess why tactic mode is bad for constructing non-<code>Prop</code> terms: <code>Prop</code> has propositional extentionality, so we don't care about the proof, and hence the "mess" that a tactic block leaves behind is not something we care about, but for definitions, where we are gonna have to "open it up" later, it's a problem?</p>



<a name="208087929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208087929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208087929">(Aug 26 2020 at 13:05)</a>:</h4>
<p>That's part of it but this should really be directed not at tactics in general but at specific tactics like <code>rw</code>, <code>simp</code>, <code>linarith</code> etc.</p>



<a name="208087987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208087987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208087987">(Aug 26 2020 at 13:05)</a>:</h4>
<p>Another reason is simply that if you make a definition then you will need to know later what the body of the definition actually is, and using tactics might make it harder to understand that</p>



<a name="208088180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208088180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208088180">(Aug 26 2020 at 13:07)</a>:</h4>
<p>For example, if you are going to later unfold the definition in the course of some proof, then the actual proof term is going to appear in your proof state anyways</p>



<a name="208088713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208088713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208088713">(Aug 26 2020 at 13:13)</a>:</h4>
<p>Does that apply to my code though? I only used non-trivial tactics in <code>Prop</code> terms.</p>



<a name="208088847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208088847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208088847">(Aug 26 2020 at 13:14)</a>:</h4>
<p>By the way, I've now turned it into a term mode definition, and now I'm getting the weird problem that it doesn't display a tactic goal state at all:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">Cayley</span> <span class="o">(</span><span class="n">G</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">perm</span> <span class="n">G</span> <span class="o">:=</span>
    <span class="k">let</span> <span class="n">f</span><span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">perm</span> <span class="n">G</span> <span class="o">:=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">g1</span><span class="o">:</span><span class="n">G</span><span class="o">,</span>
        <span class="k">let</span> <span class="n">p</span><span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="o">:=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">g</span><span class="o">,</span> <span class="n">g1</span> <span class="bp">*</span> <span class="n">g</span><span class="o">)</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">pinv</span><span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="o">:=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">g</span><span class="o">,</span> <span class="n">g1</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">g</span><span class="o">)</span> <span class="k">in</span>
        <span class="k">have</span> <span class="n">hleftinv</span><span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">left_inverse</span> <span class="n">pinv</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span><span class="o">,</span> <span class="n">inv_mul_cancel_left</span> <span class="n">g1</span> <span class="n">x</span><span class="o">),</span>
        <span class="k">have</span> <span class="n">hrightinv</span><span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">right_inverse</span> <span class="n">pinv</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">mul_right_inj</span> <span class="n">g1</span><span class="bp">⁻¹</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="o">(</span><span class="n">hleftinv</span> <span class="o">(</span><span class="n">pinv</span> <span class="n">x</span><span class="o">))),</span>
        <span class="n">equiv</span><span class="bp">.</span><span class="n">mk</span> <span class="n">p</span> <span class="n">pinv</span> <span class="n">hleftinv</span> <span class="n">hrightinv</span><span class="o">)</span> <span class="k">in</span>
    <span class="k">have</span> <span class="n">h1</span><span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span> <span class="k">from</span> <span class="k">by</span>
    <span class="o">{</span>
        <span class="n">dsimp</span> <span class="o">[</span><span class="n">f</span><span class="o">],</span>

    <span class="o">},</span>
    <span class="k">have</span> <span class="n">h2</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="k">fun</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">sorry</span><span class="o">,</span>

    <span class="bp">⟨</span> <span class="n">f</span><span class="o">,</span> <span class="n">h1</span><span class="o">,</span> <span class="n">h2</span> <span class="bp">⟩</span>
</code></pre></div>


<p>When I hover my mouse after <code>dsimp [f],</code> there is no goal state</p>



<a name="208089645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208089645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208089645">(Aug 26 2020 at 13:22)</a>:</h4>
<p>Oh this seems to be because I had the tactic display mode set to "widget". Weird.</p>



<a name="208090557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208090557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208090557">(Aug 26 2020 at 13:30)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span><span class="bp">.</span><span class="n">hom</span>

<span class="kn">open</span> <span class="n">equiv</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="n">def</span> <span class="n">Cayley</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">perm</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="n">group</span><span class="o">,</span>
    <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="n">group</span> <span class="o">},</span>
  <span class="n">map_one&#39;</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">ext</span><span class="o">,</span> <span class="n">simp</span><span class="o">},</span>
  <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">z</span><span class="o">,</span> <span class="n">exact</span> <span class="n">mul_assoc</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>



<a name="208090579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208090579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208090579">(Aug 26 2020 at 13:30)</a>:</h4>
<p>what is <code>by group</code>?</p>



<a name="208090612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208090612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208090612">(Aug 26 2020 at 13:31)</a>:</h4>
<p>the <code>group</code> tactic that Patrick wrote</p>



<a name="208090717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208090717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208090717">(Aug 26 2020 at 13:32)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">Cayley</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">perm</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="n">group</span><span class="o">,</span>
    <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="n">group</span> <span class="o">},</span>
  <span class="n">map_one&#39;</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">ext</span><span class="o">,</span> <span class="n">simp</span><span class="o">},</span>
  <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">group</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>



<a name="208090831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208090831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208090831">(Aug 26 2020 at 13:33)</a>:</h4>
<p>Now I'm trying to figure out how <code>perm G</code> is an instance of <code>has_one</code>, i.e. where this is defined. How do I figure this out?</p>



<a name="208090903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208090903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208090903">(Aug 26 2020 at 13:33)</a>:</h4>
<p>hmm, just saw Kevin's definition</p>



<a name="208090989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208090989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208090989">(Aug 26 2020 at 13:34)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">variable</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="o">(</span><span class="n">perm</span> <span class="n">G</span><span class="o">))</span> <span class="c1">-- monoid.to_has_one (perm G) : has_one (perm G)</span>
</code></pre></div>


<p>The one is coming from <code>monoid.to_has_one</code> and the monoid structure on <code>perm G</code></p>



<a name="208091633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208091633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208091633">(Aug 26 2020 at 13:39)</a>:</h4>
<p>Yes, since you're defining a structure, unless you intend to do it by applying another definition, it's generally convenient if the first character of your definition is <code>{</code></p>



<a name="208091839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208091839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208091839">(Aug 26 2020 at 13:40)</a>:</h4>
<p>although perhaps for my learning experience it would have been better not to give the whole definition? not sure.</p>



<a name="208092308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208092308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208092308">(Aug 26 2020 at 13:43)</a>:</h4>
<p>Is there a way to show the types of the elements of a structure as you're defining it? If I write a typing statement in </p>
<div class="codehilite"><pre><span></span><code><span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="n">group</span><span class="o">,</span>
      <span class="n">rightinv</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">right_inverse</span> <span class="n">to_inv</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="n">group</span> <span class="o">},</span>
</code></pre></div>


<p>Then it gives an error. It'd be helpful to see this so I don't have to rely on memory. Is the only way just to copy the definition into a comment?</p>



<a name="208092535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208092535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208092535">(Aug 26 2020 at 13:45)</a>:</h4>
<p>What is the error?</p>



<a name="208092640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208092640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208092640">(Aug 26 2020 at 13:46)</a>:</h4>
<p><code>invalid structure instance, ':=' expected</code></p>



<a name="208092733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208092733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208092733">(Aug 26 2020 at 13:47)</a>:</h4>
<p>perhaps fixing <code>rightinv</code> and <code>to_inv</code> will help</p>



<a name="208092755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208092755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208092755">(Aug 26 2020 at 13:47)</a>:</h4>
<p>Put a <code>_</code> as the definition and hover over it or however you do it in VS Code. Or is that the memory you want to avoid?</p>



<a name="208092776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208092776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208092776">(Aug 26 2020 at 13:47)</a>:</h4>
<p>but just putting <code>begin sorry end</code> after the <code>:=</code> will do it</p>



<a name="208093439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208093439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208093439">(Aug 26 2020 at 13:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F/near/208092733">said</a>:</p>
<blockquote>
<p>perhaps fixing <code>rightinv</code> and <code>to_inv</code> will help</p>
</blockquote>
<p>Sorry for that, no it doesn't.</p>



<a name="208093930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208093930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208093930">(Aug 26 2020 at 13:56)</a>:</h4>
<p>then just go for the <code>_</code> or <code>begin sorry end</code> option</p>



<a name="208094586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208094586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208094586">(Aug 26 2020 at 14:00)</a>:</h4>
<p>ok</p>



<a name="208095910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208095910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208095910">(Aug 26 2020 at 14:10)</a>:</h4>
<p>After the <code>ext</code> tactic, it generates the goal state:</p>
<div class="codehilite"><pre><span></span><code><span class="mi">1</span> <span class="n">goal</span>
<span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">group</span> <span class="n">G</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">G</span>
<span class="err">⊢</span> <span class="err">⇑</span><span class="o">{</span><span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">h</span><span class="o">,</span> <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="mi">1</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">h</span><span class="o">,</span> <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span> <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">}</span> <span class="n">x</span> <span class="bp">=</span> <span class="err">⇑</span><span class="mi">1</span> <span class="n">x</span>
</code></pre></div>


<p>Is this goal simply equivalent to <code>( λ(h : G), 1 * h) x = ( λ(h:G), h) x</code>, because of the coercion arrow <code>⇑</code>? I guess this is true because it says in the tutorial doc: <code>Finally, ⇑f and ↥S are notations for coe_fn f and coe_sort S</code></p>



<a name="208101893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208101893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208101893">(Aug 26 2020 at 14:51)</a>:</h4>
<p>You can use <code>unfold_coes</code> to unfold the coercions and <code>dsimp</code> to simplify afterwards</p>



<a name="208103812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208103812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208103812">(Aug 26 2020 at 15:03)</a>:</h4>
<p>Great!</p>



<a name="208105593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208105593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208105593">(Aug 26 2020 at 15:15)</a>:</h4>
<p>Actually, I don't understand why this <code>map_one' := by {ext, simp},</code> proof works, in particular the <code>ext</code> part: The <code>ext</code> tactic seems to (apart from applying the principle of functional extentionality) turn the goal of showing that the entire structure is the same, to just showing that <code>to_fun</code> is the same. Don't we also need to prove that <code>inv_fun</code> is the same? I guess I can accept that we don't need to prove the two properties are the same, because of propositional extentionality (though we're not actually invoking that, so I'm still not sure why that works).</p>



<a name="208106129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208106129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208106129">(Aug 26 2020 at 15:19)</a>:</h4>
<p>The <code>ext</code> tactic is much more general than that.</p>



<a name="208106286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208106286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208106286">(Aug 26 2020 at 15:20)</a>:</h4>
<p>The goal I'm proving with <code>by {ext, simp}</code> is some statement that f(1)=1, it's an equality of functions, so ext uses functional extensionality.</p>



<a name="208107836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208107836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208107836">(Aug 26 2020 at 15:30)</a>:</h4>
<p>But strictly speaking, it's an equality of "functions with additional structure", right? In particular, there are two functions that we need to show equality of, namely <code>to_fun</code> and <code>inv_inv</code>. We can deduce <code>inv_inv</code> from <code>to_fun</code>, but how does <code>ext</code> know this? did we have to teach this to <code>ext</code> explicitly and specifically for the typeclass <code>equiv</code>?</p>



<a name="208108108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208108108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208108108">(Aug 26 2020 at 15:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284606">Chris M</span> <a href="#narrow/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F/near/208107836">said</a>:</p>
<blockquote>
<p>But strictly speaking, it's an equality of "functions with additional structure", right? </p>
</blockquote>
<p>Yes, but the <code>ext</code> tactic knows that it suffices to prove the two functions are equal. <code>ext</code> is doing a lot.</p>



<a name="208108418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208108418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208108418">(Aug 26 2020 at 15:35)</a>:</h4>
<div class="codehilite"><pre><span></span><code>  <span class="n">map_one&#39;</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">show_term</span> <span class="o">{</span><span class="n">ext</span><span class="o">},</span> <span class="n">simp</span><span class="o">},</span>
</code></pre></div>


<p>shows that <code>ext</code> is using <code>perm.ext</code>, and <code>perm.ext</code> is the statement that if the "to_fun" functions coincide on all inputs, then the equivs are equal. <code>ext</code> is using this because <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.ext">docs#equiv.perm.ext</a> is tagged with <code>ext</code> in data.equiv.basic.</p>



<a name="208129727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208129727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208129727">(Aug 26 2020 at 18:30)</a>:</h4>
<p>As a side-note: The weird thing is that this gives me <code>map_one' := by { refine perm.ext (λ (x : G), _[x]), simp},</code>, which gives me the error <code>placeholders '_' cannot be used where a function is expected</code></p>



<a name="208129838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208129838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208129838">(Aug 26 2020 at 18:31)</a>:</h4>
<p>What are you expecting with <code>_[x]</code>? I'm not familiar with that notation.  What happens if you replace it with just <code>_</code>?</p>



<a name="208130089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208130089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208130089">(Aug 26 2020 at 18:33)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> , to be clear, this is what <code>show_term {ext}</code> gives me, I didn't adjust anything about it and I am not familiar with the notation either. You're right, replacing it with <code>_</code> makes it work.</p>



<a name="208130223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208130223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208130223">(Aug 26 2020 at 18:34)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> , Regarding the <code>ext</code> tactic though. Thanks, this clarifies a lot :).</p>



<a name="208130234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208130234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208130234">(Aug 26 2020 at 18:34)</a>:</h4>
<p>An unfortunate property of the pretty printer is that what it prints is not always what Lean accepts as source code.</p>



<a name="208130379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208130379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208130379">(Aug 26 2020 at 18:35)</a>:</h4>
<p>I'm curious, what if you do <code>set_option pp.proofs true</code> at the top level?  Does it still print as <code>_[x]</code>?  I think it might be hiding a "proof" with an underscore, but that  proof is a metavariable.</p>



<a name="208130607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208130607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208130607">(Aug 26 2020 at 18:37)</a>:</h4>
<p>Doesn't change anything. (I placed it directly above the definition of <code>cayley</code>).</p>



<a name="208131063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208131063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208131063">(Aug 26 2020 at 18:40)</a>:</h4>
<p>You should just put <code>_</code> there instead of <code>_[x]</code></p>



<a name="208131137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208131137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris M <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208131137">(Aug 26 2020 at 18:41)</a>:</h4>
<p>Yes I did that after Kyle Miller's suggestion and it worked</p>



<a name="208135041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Why%20doesn%27t%20dunfold%20work%20here%3F/near/208135041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F.html#208135041">(Aug 26 2020 at 19:13)</a>:</h4>
<p>I just used show_term to see which function Lean had applied. <code>show_term {ext}</code> is a great way to start moving from a tactic proof to a term proof</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
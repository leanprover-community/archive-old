---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html">Finite field extension is obtained by adjoining basis</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="265956077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265956077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Monnet <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265956077">(Dec 23 2021 at 21:47)</a>:</h4>
<p>Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi mathvariant="normal">/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">E/K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> be a finite field extension, and let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>v</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">v_1,\ldots, v_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> be a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>-basis for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>. I would like to show that the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> generate <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> as a field over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>. I have stated this as the following lemma. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">field_theory.galois</span>
<span class="kn">import</span> <span class="n">data.set.basic</span>
<span class="kn">import</span> <span class="n">algebra.group.basic</span>

<span class="n">open_locale</span> <span class="n">classical</span>


<span class="kd">lemma</span> <span class="n">gen_by_basis</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span>
<span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="n">intermediate_field</span> <span class="n">K</span> <span class="n">L</span><span class="o">}</span> <span class="o">(</span><span class="n">h_findim</span> <span class="o">:</span> <span class="n">finite_dimensional</span> <span class="n">K</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
<span class="n">E</span> <span class="bp">=</span> <span class="n">intermediate_field.adjoin</span> <span class="n">K</span> <span class="o">(</span><span class="n">finset.univ.image</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="bp">↥</span><span class="n">E</span> <span class="n">L</span><span class="o">)</span> <span class="bp">∘</span>
<span class="n">finite_dimensional.fin_basis</span> <span class="n">K</span> <span class="n">E</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Ideally I'd like to prove the statement in its current form, because it works in the context of a larger proof, but if I've stated it in the "wrong" way, I'd be grateful for help fixing that too.</p>



<a name="265961912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265961912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265961912">(Dec 23 2021 at 23:16)</a>:</h4>
<p>I think the statement's fine, although I would be tempted to put the more complex term on the left because this is the convention (<code>simp</code> lemmas simplify the LHS to the RHS). I think I'd go for <code>apply le_antisymm</code> as the first line.</p>



<a name="265968856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265968856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265968856">(Dec 24 2021 at 01:32)</a>:</h4>
<p><span class="user-mention" data-user-id="460212">@Sebastian Monnet</span> What is the larger result that you are trying to prove?</p>



<a name="265968880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265968880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265968880">(Dec 24 2021 at 01:32)</a>:</h4>
<p>You could just use <code>set.range</code> instead of <code>finset.univ.image</code>. Here's one way:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">field_theory.galois</span>
<span class="kn">import</span> <span class="n">data.set.basic</span>
<span class="kn">import</span> <span class="n">algebra.group.basic</span>

<span class="n">open_locale</span> <span class="n">classical</span>


<span class="kd">lemma</span> <span class="n">gen_by_basis</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span>
<span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="n">intermediate_field</span> <span class="n">K</span> <span class="n">L</span><span class="o">}</span> <span class="o">(</span><span class="n">h_findim</span> <span class="o">:</span> <span class="n">finite_dimensional</span> <span class="n">K</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
<span class="n">E</span> <span class="bp">=</span> <span class="n">intermediate_field.adjoin</span> <span class="n">K</span> <span class="o">(</span><span class="n">set.range</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="bp">↥</span><span class="n">E</span> <span class="n">L</span><span class="o">)</span> <span class="bp">∘</span>
<span class="n">finite_dimensional.fin_basis</span> <span class="n">K</span> <span class="n">E</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="gr">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">intermediate_field.adjoin_le_iff</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">l</span> <span class="n">hl</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_range</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">]</span> <span class="n">at</span> <span class="n">hl</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hl</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="k">let</span> <span class="n">e</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finite_dimensional.fin_basis</span> <span class="n">K</span> <span class="bp">↥</span><span class="n">E</span><span class="o">)</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">e.2</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="265968990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265968990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265968990">(Dec 24 2021 at 01:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="253861">Thomas Browning</span> <a href="#narrow/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis/near/265968856">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="460212">Sebastian Monnet</span> What is the larger result that you are trying to prove?</p>
</blockquote>
<p>He's defining the Krull topology on Galois groups.</p>



<a name="265969094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265969094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265969094">(Dec 24 2021 at 01:37)</a>:</h4>
<p>I guess I'm wondering what the result one level up is. When I was working in field theory, working with bases was very painful, but there were usually nice ways to work around them.</p>



<a name="265969246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265969246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265969246">(Dec 24 2021 at 01:41)</a>:</h4>
<p>It's the definition of the normal closure of an intermediate field E in an extension L/K as the subfield of L obtained by adjoining all the roots of the min polys of a basis.</p>



<a name="265969259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265969259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265969259">(Dec 24 2021 at 01:41)</a>:</h4>
<p>I mean, it's probably not even the normal closure in any sense, if L/K isn't normal</p>



<a name="265969315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265969315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265969315">(Dec 24 2021 at 01:42)</a>:</h4>
<p>Ah, I see. You could also adjoin all roots of all minimal polynomials, but maybe that's not as nice to work with.</p>



<a name="265969324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265969324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265969324">(Dec 24 2021 at 01:42)</a>:</h4>
<p>then it's not clear that if E/K is findim then NC(E)/K is</p>



<a name="265991202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265991202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Monnet <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265991202">(Dec 24 2021 at 09:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="253861">Thomas Browning</span> <a href="#narrow/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis/near/265969315">said</a>:</p>
<blockquote>
<p>Ah, I see. You could also adjoin all roots of all minimal polynomials, but maybe that's not as nice to work with.</p>
</blockquote>
<p>So, the point is that given a finite subextension extension <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi mathvariant="normal">/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">E/K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> of some extension <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi mathvariant="normal">/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">L/K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>, I need another finite subextension <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi mathvariant="normal">/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">N/K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> such that for every <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>-algebra equivalence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>:</mo><mi>L</mi><mo>→</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\sigma:L \to L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>, we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\sigma(E) \subseteq N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>. I have defined <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> by adjoining the roots in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> of the product of minimum polynomials of a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> basis for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>, and now I'm trying to prove that indeed <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\sigma(E) \subseteq L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>. In order to do that, I need the fact that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> is generated by its basis, from which it follows that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma(E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> is generated by the image of the basis. I have almost the whole proof, dependent on this sorried lemma and also one other detail that I'm currently working on.</p>



<a name="265992047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265992047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265992047">(Dec 24 2021 at 10:12)</a>:</h4>
<p><span class="user-mention" data-user-id="460212">@Sebastian Monnet</span> In your example, you are picking an arbitrary basis using choice using the finite-dimensionality assumption. I think it might be better to include an arbitrary basis in your assumptions.</p>



<a name="265992097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265992097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265992097">(Dec 24 2021 at 10:13)</a>:</h4>
<p>In general, there should be a lemma saying that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi mathvariant="normal">/</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">B/A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord mathnormal">A</span></span></span></span> is generated by <code>s</code> as a module, then it's also generated by <code>s</code> as algebra (or intermediate field, when this applies).</p>



<a name="265992145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265992145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265992145">(Dec 24 2021 at 10:14)</a>:</h4>
<p>So I think you can generalise your statement a bit, which might also make it easier to prove.</p>



<a name="265994809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265994809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Monnet <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265994809">(Dec 24 2021 at 11:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis/near/265992047">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="460212">Sebastian Monnet</span> In your example, you are picking an arbitrary basis using choice using the finite-dimensionality assumption. I think it might be better to include an arbitrary basis in your assumptions.</p>
</blockquote>
<p>Yeah that's a good point. I was hoping that lean would be just fixing a basis once and for all somewhere, but I have no idea what's going on under the hood</p>



<a name="265994908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265994908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Monnet <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265994908">(Dec 24 2021 at 11:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis/near/265992097">said</a>:</p>
<blockquote>
<p>In general, there should be a lemma saying that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi mathvariant="normal">/</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">B/A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord mathnormal">A</span></span></span></span> is generated by <code>s</code> as a module, then it's also generated by <code>s</code> as algebra (or intermediate field, when this applies).</p>
</blockquote>
<p>Good idea. Looking through the library now :)</p>



<a name="265996585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265996585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265996585">(Dec 24 2021 at 11:44)</a>:</h4>
<p>This normal-closure-like construction should probably have its own definition and API. Right now I'm not even 100% sure that the definition above gives a well-defined object ie independent of choice of basis. Right now Sebastian is only using the construction as a temporary measure. There's a good notion of algebraic closure of an intermediate field in a bigger field but I don't know if there's a good definition of normal closure. My vague worry is that the normal closure of a sub-intermediate field equipped with a different basis might not be contained in the normal closure of the bigger field, as Sebastian has defined it (subfield generated by roots of min polys of a basis)</p>



<a name="265997562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265997562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265997562">(Dec 24 2021 at 12:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis/near/265968990">said</a>:</p>
<blockquote>
<p>He's defining the Krull topology on Galois groups.</p>
</blockquote>
<p>Can you remind me why you need normal closure for this? I might be missing something obvious. But I think you only need to know what finite Galois subextensions are to define this topology, right?</p>



<a name="265997990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265997990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265997990">(Dec 24 2021 at 12:11)</a>:</h4>
<p>That's correct, but he's also proving that Gal(L/E) is open if E/K is finite (basically as a proof that he's defined the right topology) and to do this he is using the theory of group filter bases (which Patrick set up for us in the perfectoid project and which is now in mathlib) and it apparently shows up in the axioms there.</p>



<a name="265998113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265998113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265998113">(Dec 24 2021 at 12:14)</a>:</h4>
<p>There's a cheap method for getting the topology of the form "these sets should be open, now look at the group topology they generate" but with group topologies it turns out not to be true in general that the sup of the group topologies making given sets open still has all those given sets open, there was extensive discussion about this point last week</p>



<a name="265998242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265998242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265998242">(Dec 24 2021 at 12:17)</a>:</h4>
<p>At the end of the day we want to prove the Galois correspondence for infinite extensions but I had not realised that we have still not proved that for finite extensions, the subgroup is normal iff the subfield is normal, and this construction could also be regarded as a step in the direction towards proving this</p>



<a name="265998335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265998335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265998335">(Dec 24 2021 at 12:19)</a>:</h4>
<p>Yeah, that seems like good target on the way to the infinite gc</p>



<a name="265999431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/265999431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#265999431">(Dec 24 2021 at 12:42)</a>:</h4>
<p>Interestingly, Sebastian is going to end up putting a topology on Aut_K(L) for an arbitrary extension of fields L/K. It coincides with the Krull topology in the case that the extension is Galois</p>



<a name="266000508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/266000508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#266000508">(Dec 24 2021 at 13:03)</a>:</h4>
<p>I now wonder whether instead of working with <code>intermediate_field</code>s he could have worked with an arbitrary extension of commutative rings B/A and used subrings which were fg or Noetherian as A-modules for the basis of open sets</p>



<a name="266010931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/266010931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Monnet <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#266010931">(Dec 24 2021 at 16:06)</a>:</h4>
<p>I'm still pretty stuck on this. I've reduced the statement to the following lemma. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">subalg_le_gen_by_basis</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span>
<span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="n">intermediate_field</span> <span class="n">K</span> <span class="n">L</span><span class="o">}</span> <span class="o">(</span><span class="n">h_findim</span> <span class="o">:</span> <span class="n">finite_dimensional</span> <span class="n">K</span> <span class="n">E</span><span class="o">)</span>
<span class="o">(</span><span class="n">b</span> <span class="o">:=</span> <span class="n">finite_dimensional.fin_basis</span> <span class="n">K</span> <span class="bp">↥</span><span class="n">E</span><span class="o">)</span>
<span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">L</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finset.image</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="bp">↥</span><span class="n">E</span> <span class="n">L</span><span class="o">)</span> <span class="bp">∘</span> <span class="n">b</span><span class="o">)</span> <span class="n">finset.univ</span><span class="o">))</span> <span class="o">:</span>
<span class="n">E.to_subalgebra</span> <span class="bp">≤</span> <span class="n">algebra.adjoin</span> <span class="n">K</span> <span class="n">S</span> <span class="o">:=</span>
<span class="kd">begin</span>
   <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
   <span class="n">change</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">E</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
   <span class="k">let</span> <span class="n">x'</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">E</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩,</span>
   <span class="k">have</span> <span class="n">hx'</span> <span class="o">:=</span> <span class="n">basis.mem_span</span> <span class="n">b</span> <span class="n">x'</span><span class="o">,</span>
   <span class="n">apply</span> <span class="n">algebra.span_le_adjoin</span> <span class="n">K</span> <span class="n">S</span><span class="o">,</span>
   <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>As <span class="user-mention" data-user-id="112680">@Johan Commelin</span> suggested, I used a lemma relating being generated as an algebra to being generated as a module, but now I basically have type-theoretic issues. Currently the hypothesis <code>hx'</code> is basically the same as the goal, but I need to map from <code>↥E</code> to <code>L</code>. I tried mapping to <code>L</code> with something like </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="bp">↥</span><span class="n">E</span> <span class="n">L</span><span class="o">)</span> <span class="n">x'</span> <span class="bp">∈</span> <span class="n">submodule.algebra_map</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="bp">↥</span><span class="n">E</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">submodule.span</span> <span class="n">K</span> <span class="o">(</span><span class="n">set.range</span> <span class="bp">⇑</span><span class="n">b</span><span class="o">))</span>
</code></pre></div>
<p>but this didn't work. I'm at a bit of a loss here, so I'd really appreciate any help!</p>



<a name="266011497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/266011497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#266011497">(Dec 24 2021 at 16:19)</a>:</h4>
<p>opt param lets you do something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">subalg_le_gen_by_basis</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="k">show</span> <span class="n">finite_dimensional</span> <span class="n">ℚ</span> <span class="o">(</span><span class="bp">⊤</span> <span class="o">:</span> <span class="n">intermediate_field</span> <span class="n">ℚ</span> <span class="n">ℂ</span><span class="o">),</span> <span class="k">from</span> <span class="gr">sorry</span><span class="o">)</span> <span class="n">_</span> <span class="o">{},</span>
</code></pre></div>
<p>replace ℂ with something that's actually fin-dim over ℚ and you clearly have a contradiction</p>



<a name="266011503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/266011503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#266011503">(Dec 24 2021 at 16:19)</a>:</h4>
<p>I think you ned to write the definition of <code>S</code> by hand</p>



<a name="266011656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/266011656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Monnet <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#266011656">(Dec 24 2021 at 16:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis/near/266011503">said</a>:</p>
<blockquote>
<p>I think you ned to write the definition of <code>S</code> by hand</p>
</blockquote>
<p>What do you mean by this? As in I need to just put <code>(finset.univ.image ((algebra_map ↥E L) ∘
finite_dimensional.fin_basis K E))</code> every time I've written <code>S</code>?</p>



<a name="266011666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/266011666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#266011666">(Dec 24 2021 at 16:22)</a>:</h4>
<p>yeah</p>



<a name="266011937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/266011937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#266011937">(Dec 24 2021 at 16:28)</a>:</h4>
<p>Or have "hs : S = ..."</p>



<a name="266011963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/266011963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#266011963">(Dec 24 2021 at 16:29)</a>:</h4>
<p>Such helper hypotheses usually work much better than relying on opt_param like (b := ...)</p>



<a name="266011993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/266011993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#266011993">(Dec 24 2021 at 16:29)</a>:</h4>
<p>this seems like a much more palatable goal:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">subalg_le_gen_by_basis</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span>
<span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="n">intermediate_field</span> <span class="n">K</span> <span class="n">L</span><span class="o">}</span> <span class="o">(</span><span class="n">h_findim</span> <span class="o">:</span> <span class="n">finite_dimensional</span> <span class="n">K</span> <span class="n">E</span><span class="o">)</span>
<span class="o">(</span><span class="n">b</span> <span class="o">:=</span> <span class="n">finite_dimensional.fin_basis</span> <span class="n">K</span> <span class="bp">↥</span><span class="n">E</span><span class="o">)</span> <span class="o">:</span>
<span class="n">E.to_subalgebra</span> <span class="bp">≤</span> <span class="n">algebra.adjoin</span> <span class="n">K</span> <span class="o">(</span><span class="n">finset.image</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="bp">↥</span><span class="n">E</span> <span class="n">L</span><span class="o">)</span> <span class="bp">∘</span> <span class="n">b</span><span class="o">)</span> <span class="n">finset.univ</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
   <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
   <span class="n">change</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">E</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
   <span class="k">let</span> <span class="n">x'</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">E</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩,</span>
   <span class="k">have</span> <span class="n">hx'</span> <span class="o">:=</span> <span class="n">basis.mem_span</span> <span class="n">b</span> <span class="n">x'</span><span class="o">,</span>
   <span class="n">apply</span> <span class="n">algebra.span_le_adjoin</span> <span class="n">K</span> <span class="n">_</span><span class="o">,</span>
   <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">function.comp_app</span><span class="o">,</span> <span class="n">finset.coe_image</span><span class="o">,</span> <span class="n">finset.coe_univ</span><span class="o">,</span> <span class="n">set.image_univ</span><span class="o">],</span>
   <span class="n">rw</span> <span class="n">set.range_comp</span><span class="o">,</span>
   <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="266014230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/266014230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Monnet <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#266014230">(Dec 24 2021 at 17:16)</a>:</h4>
<p><span class="user-mention" data-user-id="284160">@Eric Rodriguez</span>  yes, that is much more palatable, thank you. I've progressed a little further and now have this: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">subalg_le_gen_by_basis'</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span>
<span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="n">intermediate_field</span> <span class="n">K</span> <span class="n">L</span><span class="o">}</span> <span class="o">(</span><span class="n">h_findim</span> <span class="o">:</span> <span class="n">finite_dimensional</span> <span class="n">K</span> <span class="n">E</span><span class="o">)</span>
<span class="o">(</span><span class="n">b</span> <span class="o">:=</span> <span class="n">finite_dimensional.fin_basis</span> <span class="n">K</span> <span class="bp">↥</span><span class="n">E</span><span class="o">)</span> <span class="o">:</span>
<span class="n">E.to_subalgebra</span> <span class="bp">≤</span> <span class="n">algebra.adjoin</span> <span class="n">K</span> <span class="o">(</span><span class="n">finset.image</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="bp">↥</span><span class="n">E</span> <span class="n">L</span><span class="o">)</span> <span class="bp">∘</span> <span class="n">b</span><span class="o">)</span> <span class="n">finset.univ</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
   <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
   <span class="n">change</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">E</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
   <span class="k">let</span> <span class="n">x'</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">E</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩,</span>
   <span class="k">have</span> <span class="n">hx'</span> <span class="o">:=</span> <span class="n">basis.mem_span</span> <span class="n">b</span> <span class="n">x'</span><span class="o">,</span>
   <span class="n">apply</span> <span class="n">algebra.span_le_adjoin</span> <span class="n">K</span> <span class="n">_</span><span class="o">,</span>
   <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">function.comp_app</span><span class="o">,</span> <span class="n">finset.coe_image</span><span class="o">,</span> <span class="n">finset.coe_univ</span><span class="o">,</span> <span class="n">set.image_univ</span><span class="o">],</span>
   <span class="n">rw</span> <span class="n">set.range_comp</span><span class="o">,</span>
   <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="o">(</span><span class="n">E.val</span> <span class="bp">''</span> <span class="n">set.range</span> <span class="bp">⇑</span><span class="n">b</span><span class="o">)</span> <span class="bp">=</span>
   <span class="o">(</span><span class="bp">⇑</span><span class="o">(</span><span class="n">algebra_map</span> <span class="bp">↥</span><span class="n">E</span> <span class="n">L</span><span class="o">)</span> <span class="bp">''</span> <span class="n">set.range</span> <span class="bp">⇑</span><span class="n">b</span><span class="o">),</span>
   <span class="o">{</span>
     <span class="n">ext</span> <span class="n">y</span><span class="o">,</span>
     <span class="n">split</span><span class="o">,</span>
     <span class="o">{</span>
        <span class="n">intro</span> <span class="n">hy</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">hy</span><span class="o">,</span>
     <span class="o">},</span>
     <span class="o">{</span>
       <span class="n">intro</span> <span class="n">hy</span><span class="o">,</span>
       <span class="n">exact</span> <span class="n">hy</span><span class="o">,</span>
     <span class="o">},</span>
   <span class="o">},</span>
   <span class="n">rw</span> <span class="bp">←</span> <span class="n">h2</span><span class="o">,</span>
   <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>What I'd like to do now is </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">submodule.span</span> <span class="n">K</span> <span class="o">((</span><span class="n">E.val</span><span class="o">)</span> <span class="bp">''</span> <span class="o">(</span><span class="n">set.range</span> <span class="bp">⇑</span><span class="n">b</span><span class="o">))</span> <span class="bp">=</span>
   <span class="n">submodule.map</span> <span class="o">(</span><span class="n">E.val</span><span class="o">)</span> <span class="o">(</span><span class="n">submodule.span</span> <span class="n">K</span> <span class="o">(</span><span class="n">set.range</span> <span class="bp">⇑</span><span class="n">b</span><span class="o">))</span>
</code></pre></div>
<p>but I can't because <code>E.val</code> is not the right kind of map. It's a <code>K</code>-algebra map and not a semilinear map over <code>K</code>. Do you have any idea how to coerce <code>E.val</code> into the form I need?</p>



<a name="266014311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/266014311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#266014311">(Dec 24 2021 at 17:18)</a>:</h4>
<p><code>ext y, split, {intro hy, exact hy}, {intro hy, exact hy}</code> is just a very long way of saying <code>refl</code> :-)</p>



<a name="266014332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/266014332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Monnet <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#266014332">(Dec 24 2021 at 17:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis/near/266014311">said</a>:</p>
<blockquote>
<p><code>ext y, split, {intro hy, exact hy}, {intro hy, exact hy}</code> is just a very long way of saying <code>refl</code> :-)</p>
</blockquote>
<p>Good point</p>



<a name="266014501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/266014501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#266014501">(Dec 24 2021 at 17:23)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">submodule.span</span> <span class="n">K</span> <span class="o">((</span><span class="n">E.val</span><span class="o">)</span> <span class="bp">''</span> <span class="o">(</span><span class="n">set.range</span> <span class="bp">⇑</span><span class="n">b</span><span class="o">))</span> <span class="bp">=</span>
   <span class="n">submodule.map</span> <span class="o">(</span><span class="n">E.val</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">submodule.span</span> <span class="n">K</span> <span class="o">(</span><span class="n">set.range</span> <span class="bp">⇑</span><span class="n">b</span><span class="o">)),</span>
</code></pre></div>
<p>seems to work for your h3.</p>



<a name="266014629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Finite%20field%20extension%20is%20obtained%20by%20adjoining%20basis/near/266014629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis.html#266014629">(Dec 24 2021 at 17:26)</a>:</h4>
<p>(I guess there's a coercion from K-algebra ring maps to K-linear module maps, and linear things are semilinear; I don't quite understand linear algebra in Lean any more ;-) )</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
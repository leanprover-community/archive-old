---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Some.20olympiad.20formalisations.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html">Some olympiad formalisations</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="194557725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/194557725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#194557725">(Apr 18 2020 at 18:30)</a>:</h4>
<p>As a first exercise in formalisation after Kevin's natural number game and Lean maths challenges, I tried <a href="https://github.com/jsm28/bmo2-2020-lean" title="https://github.com/jsm28/bmo2-2020-lean">formalising solutions</a> to some problems from this year's <a href="https://bmos.ukmt.org.uk/home/bmo2-2020.pdf" title="https://bmos.ukmt.org.uk/home/bmo2-2020.pdf">British Mathematical Olympiad round 2</a>. A couple of questions that arose from this. (a) In the course of those formalisations I found I wanted various trivial lemmas that I couldn't locate in mathlib, but that seemed of more general relevance than just those particular olympiad problems; see p1_lemmas.lean, p3_lemmas.lean and p4_lemmas.lean at the link. Are some of those actually in mathlib in a different form, or do any of them belong there? (b) The proof of problem 3 (p3.lean) got very bogged down proving trivialities. Are there key Lean tricks I'm missing that could make it, say, five times shorter (which would still be longer than either of the other proofs there)?</p>



<a name="194559223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/194559223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#194559223">(Apr 18 2020 at 19:08)</a>:</h4>
<p>Thanks for mentioning this stuff here Joseph, I know you told me about it weeks ago but I've been focusing on other things.</p>



<a name="194568695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/194568695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#194568695">(Apr 18 2020 at 23:20)</a>:</h4>
<p>I only briefly skimmed your lemmas, but mostly these look useful and appropriate for mathlib.</p>



<a name="194568698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/194568698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#194568698">(Apr 18 2020 at 23:20)</a>:</h4>
<p>I'd double check on some of the simpler ones that <code>library_search</code> doesn't find any matches.</p>



<a name="194568704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/194568704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#194568704">(Apr 18 2020 at 23:21)</a>:</h4>
<p>and then start PR'ing them. It's probably best to do them in small chunks, as it makes it more likely that the relevant reviewer who knows the file the lemmas belong in will have time to check them.</p>



<a name="194568708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/194568708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#194568708">(Apr 18 2020 at 23:22)</a>:</h4>
<p>(But my first impression is that everything was written nicely, and had good mathlib-style names, so PRing should be pretty straightforward, beyond looking for existing matches.)</p>



<a name="194603866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/194603866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#194603866">(Apr 19 2020 at 15:47)</a>:</h4>
<p>OK, I've filed PR  <a href="https://github.com/leanprover-community/mathlib/issues/2460" title="https://github.com/leanprover-community/mathlib/issues/2460">#2460</a> for some of the modular arithmetic lemmas after checking with <code>library_search</code>. Though as <code>library_search</code> is very sensitive to the exact form in which a lemma is stated, it's quite possible something very similar is already present. (E.g. at one point in doing these formalisations I wanted the name of the lemma that turns out to be <code>nat.add_mul_div_right</code>, but because I had the additions the other way round, <code>library_search</code> didn't find it.) I left out one of the modular arithmetic lemmas from this PR, both because it's more complicated and because I got a mysterious timeout after updating to the latest Lean and mathlib. Why does this code timeout on <code>use</code> (but not if <code>existsi</code> is used instead, or with different imports)? This is with Lean 3.9.0, mathlib commit 99245b33741b6b3adc6832858c88e7b0ce2de519, and didn't appear with Lean 3.8.0, mathlib commit d2db3e831a8f8e20564e7c702409bd3bdda691f5.</p>
<div class="codehilite"><pre><span></span><span class="c1">-- This import is needed; the timeout does not appear with &quot;import tactic&quot; instead.</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">int</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">lemma</span> <span class="n">mod_mul_eq_cases</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">hbpos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hcpos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hmod</span> <span class="o">:</span> <span class="n">n</span> <span class="err">%</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">d</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">d</span> <span class="bp">∧</span> <span class="n">d</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">∧</span> <span class="n">n</span> <span class="err">%</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">use</span> <span class="o">((</span><span class="n">n</span> <span class="err">%</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">))</span> <span class="bp">/</span> <span class="n">b</span><span class="o">),</span> <span class="c1">-- Times out (works with &quot;existsi&quot;)</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>



<a name="195620616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195620616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195620616">(Apr 28 2020 at 20:15)</a>:</h4>
<p>Having got a first few batches of lemmas intro mathlib, a couple of followup questions.</p>
<ol>
<li>One of the lemmas I have is one where the statement seems reasonable for mathlib, but the proof I have surely isn't.</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">cardinality</span>

<span class="c">/-</span><span class="cm">- Any open interval of reals is uncountable. -/</span>
<span class="kn">lemma</span> <span class="n">not_countable_real_Ioo</span> <span class="o">{</span><span class="n">k1</span> <span class="n">k2</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">k1</span> <span class="bp">&lt;</span> <span class="n">k2</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">¬</span> <span class="n">set</span><span class="bp">.</span><span class="n">countable</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">Ioo</span> <span class="n">k1</span> <span class="n">k2</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>


<p>The proof I have (in p4_lemmas.lean) deducing this from <code>not_countable_real</code> is about as long as the whole of <code>data.real.cardinality</code> once you include the auxiliary lemmas. Maybe someone can see a much simpler proof of this and can PR that to mathlib instead?</p>
<ol start="2">
<li>I only formalised solutions to three of the four problems on the paper because the other one is geometry and mathlib doesn't have any Euclidean geometry. I know there have been various attempts at Euclidean geometry in Lean, are there any plans to add it (at least basic definitions) to mathlib? (I tend to think the natural starting point is the <a href="https://en.wikipedia.org/wiki/Euclidean_space#Technical_definition" title="https://en.wikipedia.org/wiki/Euclidean_space#Technical_definition">definition</a> of a Euclidean space as an affine space whose associated vector space is a finite-dimensional real inner product space. mathlib has real inner product spaces, but not affine spaces.)</li>
</ol>



<a name="195622197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195622197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195622197">(Apr 28 2020 at 20:27)</a>:</h4>
<p>For 1, it would be nice to know that an open interval is homeomorphic to ℝ anyways, from which the uncountability follows. (Maybe <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> knows whether we have this already?)</p>



<a name="195622357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195622357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195622357">(Apr 28 2020 at 20:28)</a>:</h4>
<p>For 2, I don't know of any plans to add Euclidean geometry to mathlib. But PRs are welcome!</p>



<a name="195622504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195622504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195622504">(Apr 28 2020 at 20:29)</a>:</h4>
<p>Not having affine spaces is really really sad, especially now calculus is very advanced in the wrong direction (using linear spaces everywhere instead of affine spaces)</p>



<a name="195622510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195622510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195622510">(Apr 28 2020 at 20:29)</a>:</h4>
<p>For 1. I would guess that it is not too hard to show that the interval <code>Ioo a b</code> is uncountable if the unit interval <code>Ioo 0 1</code> is.</p>



<a name="195622601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195622601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195622601">(Apr 28 2020 at 20:30)</a>:</h4>
<p>I tried to define affine spaces a very very long time ago, but I never managed to get elaboration to cooperate.</p>



<a name="195622655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195622655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195622655">(Apr 28 2020 at 20:30)</a>:</h4>
<p>And we know that <code>exp</code> is injective. So <code>R</code> injects into the positive reals. That's also only a couple of lines.</p>



<a name="195622762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195622762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195622762">(Apr 28 2020 at 20:31)</a>:</h4>
<p>Then you apply negation, and another <code>exp</code>.</p>



<a name="195622789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195622789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195622789">(Apr 28 2020 at 20:31)</a>:</h4>
<p>We know that exp is monotone as well, I htink.</p>



<a name="195623114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195623114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195623114">(Apr 28 2020 at 20:34)</a>:</h4>
<p>Library-wise I don't think we should look for a tricky proof. We need to make sure we have an bijection from R to any nonempty open interval</p>



<a name="195623282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195623282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195623282">(Apr 28 2020 at 20:35)</a>:</h4>
<p>The library should have (a) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>≅</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 1) \cong (a, b)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> for any <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a &lt; b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>, (b) <a href="https://en.wikipedia.org/wiki/Sigmoid_function" title="https://en.wikipedia.org/wiki/Sigmoid_function">https://en.wikipedia.org/wiki/Sigmoid_function</a> or similar.</p>



<a name="195623442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195623442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195623442">(Apr 28 2020 at 20:36)</a>:</h4>
<p>Hmmm, didn't <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> do the sigmoid function, or something similar?</p>



<a name="195623475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195623475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195623475">(Apr 28 2020 at 20:36)</a>:</h4>
<p>Assuming of course <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≅</mo></mrow><annotation encoding="application/x-tex">\cong</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.589em;vertical-align:0em;"></span><span class="mrel">≅</span></span></span></span> means diffemorphism.</p>



<a name="195623483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195623483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195623483">(Apr 28 2020 at 20:36)</a>:</h4>
<p>Oh I guess I always thought that the sigmoid function specifically meant what that page calls the logistic function, but the point is we should have at least one such function which also has some other utility.</p>



<a name="195623725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195623725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195623725">(Apr 28 2020 at 20:38)</a>:</h4>
<p>Oooh, I was thinking of</p>
<div class="codehilite"><pre><span></span><code>src/analysis/calculus/specific_functions.lean:
The real function `exp_neg_inv_glue` given by `x ↦ exp (-1/x)` for `x &gt; 0` and `0`
</code></pre></div>



<a name="195623732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195623732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195623732">(Apr 28 2020 at 20:38)</a>:</h4>
<p>There is <code>exp_neg_inv_glue</code>, but this is a bit different (and more difficult)</p>



<a name="195623869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195623869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195623869">(Apr 28 2020 at 20:40)</a>:</h4>
<p>But <code>exp_neg_inv_glue</code> would also do the trick, right?</p>



<a name="195623879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195623879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195623879">(Apr 28 2020 at 20:40)</a>:</h4>
<p>For 2, one has to think about how to formalise a general Euclidean geometry question. If it says something like "Let ABC be a triangle, now construct D,E,F,G,H and prove that ABDH all lie on a circle" then you can either use a coordinate approach or a synthetic approach. There has been a lot of work towards getting the synthetic approach to work in a theorem prover, including some serious stuff done in Coq (<a href="https://mathoverflow.net/questions/337558/automatically-solving-olympiad-geometry-problems" title="https://mathoverflow.net/questions/337558/automatically-solving-olympiad-geometry-problems">some links here</a>). I had a student formalise a load of stuff in Lean <a href="https://github.com/ImperialCollegeLondon/xena-UROP-2018/tree/master/src/Geometry" title="https://github.com/ImperialCollegeLondon/xena-UROP-2018/tree/master/src/Geometry">here</a> but they didn't document what they did so the code is impenetrable.</p>



<a name="195623977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195623977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195623977">(Apr 28 2020 at 20:41)</a>:</h4>
<p>I don't think we have the sigmoid (and I just learned this name). But it would be very easy to do.</p>



<a name="195623991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195623991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195623991">(Apr 28 2020 at 20:41)</a>:</h4>
<p>And then we can claim Lean does AI</p>



<a name="195624014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195624014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195624014">(Apr 28 2020 at 20:41)</a>:</h4>
<p>Sébastien, this fancy sigmoid name is AI</p>



<a name="195631489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195631489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alastair Horn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195631489">(Apr 28 2020 at 21:47)</a>:</h4>
<p>I'm interested in formalising (e.g. olympiad) Euclidean geometry in Lean and I would love to learn from/contribute to any project related to this, something like Geocoq perhaps?</p>



<a name="195632945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195632945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195632945">(Apr 28 2020 at 21:58)</a>:</h4>
<p>Geocoq is synthetic, right?</p>



<a name="195632988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195632988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195632988">(Apr 28 2020 at 21:58)</a>:</h4>
<p>I was going to have a student look at this this summer but my plans are now a bit up in the air.</p>



<a name="195633036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195633036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195633036">(Apr 28 2020 at 21:59)</a>:</h4>
<p>It's one thing formalising the theorems, it's another to make the tactics which prove them automatically</p>



<a name="195634375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195634375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alastair Horn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195634375">(Apr 28 2020 at 22:10)</a>:</h4>
<p>Assuming I understand what synthetic is, then yes I believe it is since it's based off Tarski's axioms</p>



<a name="195634377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195634377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195634377">(Apr 28 2020 at 22:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/Some.20olympiad.20formalisations/near/195623869" title="#narrow/stream/113489-new-members/topic/Some.20olympiad.20formalisations/near/195623869">said</a>:</p>
<blockquote>
<p>But <code>exp_neg_inv_glue</code> would also do the trick, right?</p>
</blockquote>
<p>It does one trick (via Cantor-Schroeder-Bernstein) but not all tricks.</p>



<a name="195635728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195635728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alastair Horn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195635728">(Apr 28 2020 at 22:22)</a>:</h4>
<p>I suppose a synthetic approach wouldn't be appropriate for mathlib, since nothing else would really depend on it. Though synthetic would presumably be the logical choice for a formalisation of Olympiad geometry.</p>



<a name="195645126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195645126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195645126">(Apr 29 2020 at 00:11)</a>:</h4>
<p>After writing the definition in terms of affine spaces, a natural starting point to make it usable might include proving lots of basic geometrical facts (both n-dimensional and 2-dimensional), including Tarski's axioms. At that point you could use either approach for proving further geometrical results. (To do coordinate proofs you'd also want functions of the form "choose a frame with these properties", like "let A be (0, 0) and B be (c, 0)".) Of course the reverse direction (constructing an affine space over a real inner product space from a structure satisfying Tarski's axioms) is also a theorem that could be proved.</p>



<a name="195645432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195645432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195645432">(Apr 29 2020 at 00:16)</a>:</h4>
<p>I tend to find combinatorial geometry more interesting than the "here's a construction for a long sequence of points" type of problem, and synthetic geometry reasoning seems less often relevant for combinatorial problems.</p>



<a name="195645688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/195645688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#195645688">(Apr 29 2020 at 00:21)</a>:</h4>
<p>I haven't tried defining any type classes in Lean, so don't know what would go wrong in a naive attempt to implement the definition of affine spaces and define Euclidean spaces on top of that. (But implementing it in terms of additive group actions would run into mathlib not having additive group actions, and I certainly don't understand the to_additive machinery for converting things between multiplicative and additive groups.)</p>



<a name="197858180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197858180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197858180">(May 17 2020 at 16:57)</a>:</h4>
<p>I tried writing definitions of affine and Euclidean spaces (in the <a href="https://github.com/jsm28/bmo2-2020-lean">same repository</a> as before), to see if I could get to the point of being able to state and prove the geometry problem on the paper I was formalising.</p>
<p>Although I proved very little to do with affine spaces, Lean didn't seem to have any particular problems with the definitions once I made types explicit in more places than might be ideal (otherwise it can't e.g. deduce the correct type of vectors for a subtraction of points to produce a vector). Should some such minimal definitions of affine and Euclidean spaces (whether or not these particular definitions) go in mathlib as a basis for any further work people wish to do in that area, even if many basic things people would want when using the definitions are likely missing?</p>
<p>But I ran into type class issues working with Euclidean spaces. I have a <code>metric_space</code> instance for affine spaces over normed spaces, but Lean won't deduce a metric space structure for Euclidean spaces from that. Here's a simplified self-contained example.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">normed_space</span><span class="bp">.</span><span class="n">real_inner_product</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basis</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="n">class</span> <span class="n">has_vadd</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">vadd</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">P</span><span class="o">)</span>
<span class="o">(</span><span class="n">vsub</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span>

<span class="n">def</span> <span class="n">vadd</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_vadd</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">has_vadd</span><span class="bp">.</span><span class="n">vadd</span>
<span class="n">def</span> <span class="n">vsub</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_vadd</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">has_vadd</span><span class="bp">.</span><span class="n">vsub</span>

<span class="kn">infix</span> <span class="bp">`+</span><span class="err">ᵥ</span><span class="bp">`</span><span class="o">:</span><span class="mi">65</span> <span class="o">:=</span> <span class="n">vadd</span>
<span class="kn">infix</span> <span class="bp">`-</span><span class="err">ᵥ</span><span class="bp">`</span><span class="o">:</span><span class="mi">65</span> <span class="o">:=</span> <span class="n">vsub</span>

<span class="n">class</span> <span class="n">affine_space</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span>
    <span class="o">[</span><span class="n">vector_space</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">has_vadd</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">vadd_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">v1</span> <span class="n">v2</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">p</span> <span class="bp">+</span><span class="err">ᵥ</span> <span class="n">v1</span> <span class="bp">+</span><span class="err">ᵥ</span> <span class="n">v2</span> <span class="bp">=</span> <span class="n">p</span> <span class="bp">+</span><span class="err">ᵥ</span> <span class="o">(</span><span class="n">v1</span> <span class="bp">+</span> <span class="n">v2</span><span class="o">))</span>
<span class="o">(</span><span class="n">vadd_vsub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p1</span> <span class="n">p2</span> <span class="o">:</span> <span class="n">P</span><span class="o">),</span> <span class="n">p1</span> <span class="bp">+</span><span class="err">ᵥ</span> <span class="o">(</span><span class="n">p2</span> <span class="bp">-</span><span class="err">ᵥ</span> <span class="n">p1</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p2</span><span class="o">)</span>
<span class="o">(</span><span class="n">vsub_vadd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">p</span> <span class="bp">+</span><span class="err">ᵥ</span> <span class="n">v</span> <span class="bp">-</span><span class="err">ᵥ</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">v</span><span class="o">)</span>

<span class="kn">instance</span> <span class="n">affine_space_has_dist</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_field</span> <span class="n">k</span><span class="o">]</span>
    <span class="o">[</span><span class="n">normed_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">has_vadd</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">affine_space</span> <span class="n">k</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_dist</span> <span class="n">P</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">dist</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="err">∥</span><span class="o">(</span><span class="n">x</span> <span class="bp">-</span><span class="err">ᵥ</span> <span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span><span class="err">∥</span> <span class="o">}</span>

<span class="n">class</span> <span class="n">euclidean_vector_space</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">inner_product_space</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">finite_dimensional</span> <span class="n">ℝ</span> <span class="n">V</span><span class="o">]</span>

<span class="n">class</span> <span class="n">euclidean_affine_space</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">inner_product_space</span> <span class="n">V</span><span class="o">]</span>
    <span class="o">[</span><span class="n">finite_dimensional</span> <span class="n">ℝ</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">euclidean_vector_space</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">has_vadd</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span>
    <span class="o">[</span><span class="n">affine_space</span> <span class="n">ℝ</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">inner_product_space</span> <span class="n">V</span><span class="o">]</span>
    <span class="o">[</span><span class="n">finite_dimensional</span> <span class="n">ℝ</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">euclidean_vector_space</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">has_vadd</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span>
    <span class="o">[</span><span class="n">S</span> <span class="o">:</span> <span class="n">affine_space</span> <span class="n">ℝ</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">euclidean_affine_space</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span>

<span class="kn">instance</span> <span class="n">euclidean_affine_space_has_dist</span> <span class="o">:</span> <span class="n">has_dist</span> <span class="n">P</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">affine_space_has_dist</span> <span class="n">ℝ</span> <span class="n">V</span> <span class="n">P</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">S</span>
</code></pre></div>


<p>And this is the error from that last instance (where the <code>@</code> and naming the affine space instance are just to get a more verbose error):</p>
<div class="codehilite"><pre><span></span><code><span class="mi">37</span><span class="o">:</span><span class="mi">59</span><span class="o">:</span> <span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">affine_space_has_dist</span> <span class="n">ℝ</span> <span class="n">V</span> <span class="n">P</span>
<span class="n">term</span>
  <span class="n">S</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">affine_space</span> <span class="n">ℝ</span> <span class="n">V</span> <span class="n">P</span> <span class="n">real</span><span class="bp">.</span><span class="n">field</span> <span class="o">(</span><span class="bp">@</span><span class="n">inner_product_space</span><span class="bp">.</span><span class="n">to_add_comm_group</span> <span class="n">V</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">inner_product_space</span><span class="bp">.</span><span class="n">to_module</span> <span class="n">V</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)</span>
    <span class="bp">_</span><span class="n">inst_4</span>
    <span class="bp">_</span><span class="n">inst_5</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">affine_space</span> <span class="n">ℝ</span> <span class="n">V</span> <span class="n">P</span> <span class="o">(</span><span class="bp">@</span><span class="n">normed_field</span><span class="bp">.</span><span class="n">to_field</span> <span class="n">ℝ</span> <span class="n">normed_field</span><span class="bp">.</span><span class="n">normed_field</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">normed_group</span><span class="bp">.</span><span class="n">to_add_comm_group</span> <span class="n">V</span> <span class="o">(</span><span class="bp">@</span><span class="n">inner_product_space_is_normed_group</span> <span class="n">V</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">normed_space</span><span class="bp">.</span><span class="n">to_module</span> <span class="n">ℝ</span> <span class="n">V</span> <span class="n">normed_field</span><span class="bp">.</span><span class="n">normed_field</span> <span class="o">(</span><span class="bp">@</span><span class="n">inner_product_space_is_normed_group</span> <span class="n">V</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">inner_product_space_is_normed_space</span> <span class="n">V</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">))</span>
    <span class="bp">_</span><span class="n">inst_4</span>
    <span class="bp">_</span><span class="n">inst_5</span>
</code></pre></div>


<p>What's the right way to get those instances to match up, without causing problems later? (The metric space instance itself seems quite fragile; it "works" in the form I have it in the repository, in the sense that Lean accepts the proofs of metric space axioms, but if I have a slightly different set of type class instances visible when it's defined I get problems with e.g. <code>norm_zero</code> not working because the two sides of the equation have found different paths to <code>add_comm_group</code> and <code>has_zero</code>.)</p>



<a name="197858957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197858957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197858957">(May 17 2020 at 17:12)</a>:</h4>
<p>Would it be an idea to add the metric to the definition of euclidean space?</p>



<a name="197858965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197858965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197858965">(May 17 2020 at 17:12)</a>:</h4>
<p>Just like the definition of a metric space includes an entire topology</p>



<a name="197858979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197858979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197858979">(May 17 2020 at 17:13)</a>:</h4>
<p>You could then define a custom "minimalist" constructor that builds all the "redundant" info from some core data</p>



<a name="197859112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197859112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197859112">(May 17 2020 at 17:16)</a>:</h4>
<p>There are two separate issues issues. First the issue of affine spaces. You don't include the minimal test case: are you able to define affine maps between affine spaces (without having <code>@</code> all over the place)?</p>



<a name="197859121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197859121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197859121">(May 17 2020 at 17:16)</a>:</h4>
<p>I was trying to make it more general, since the metric space structure doesn't need anything more than a norm on the underlying vector space so can apply to affine spaces that aren't Euclidean spaces. But I can see if a less general version works.</p>



<a name="197859142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197859142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197859142">(May 17 2020 at 17:17)</a>:</h4>
<p>Affine maps are on the long list of things that obviously ought to be added for a more complete implementation of affine spaces.</p>



<a name="197859227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197859227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197859227">(May 17 2020 at 17:18)</a>:</h4>
<p>Then the metric space issue. Here Johan already explained the main trick, but there are a lot more details  at <a href="https://hal.inria.fr/hal-02463336v2/document">https://hal.inria.fr/hal-02463336v2/document</a></p>



<a name="197859241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197859241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197859241">(May 17 2020 at 17:18)</a>:</h4>
<p>Joseph, I strongly recommend you try to define affine maps very soon. This is a cruel test.</p>



<a name="197859334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197859334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197859334">(May 17 2020 at 17:20)</a>:</h4>
<p>The problem I think is that <code>inner_product_space.to_module </code> and <code>normed_space.to_module</code> are making different module structures.</p>



<a name="197860775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197860775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197860775">(May 17 2020 at 17:50)</a>:</h4>
<p>I've added a definition of affine maps (and the composition of two affine maps, but not tried to do anything more with them).</p>



<a name="197860942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197860942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197860942">(May 17 2020 at 17:54)</a>:</h4>
<p>I'd define <code>def Point := real × real</code> and introduce <code>inner_product_space</code> on it.</p>



<a name="197860952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197860952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197860952">(May 17 2020 at 17:54)</a>:</h4>
<p>I tried this long before the fashion of bundled maps began, so maybe things are easier now (although you will face coercion to function hell if you go that way). I also used <code>+</code> without subscript at that time. Maybe this was too much for Lean.</p>



<a name="197861033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197861033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197861033">(May 17 2020 at 17:56)</a>:</h4>
<p>Then define lines, circles etc, and prove standard properties.</p>



<a name="197865218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197865218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197865218">(May 17 2020 at 19:33)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>, including the distance and a requirement that it agrees with the norm worked for defining Euclidean spaces (and then deducing a metric space instance on them, rather than needing to bundle everything about the metric space properties in the Euclidean space definition).</p>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span>, I'm trying to implement the abstract definition of a Euclidean space from Wikipedia. I then have an instance <code>euclidean_affine_space (fin n → ℝ) (fin n → ℝ)</code> to put an n-dimensional Euclidean space structure on <code>fin n → ℝ</code>. Yes, concepts such as lines (= affine subspaces of dimension 1), circles etc. will need defining to do much geometry.</p>



<a name="197865370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197865370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197865370">(May 17 2020 at 19:37)</a>:</h4>
<p>What's wrong with a real inner product space?</p>



<a name="197865397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197865397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197865397">(May 17 2020 at 19:37)</a>:</h4>
<p>I do at least now have Pythagoras (one entry on the hundred-theorems list) for three points in a Euclidean affine space.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">dist_square_eq_dist_square_add_dist_square_iff_angle_eq_pi_div_two</span> <span class="o">(</span><span class="n">p1</span> <span class="n">p2</span> <span class="n">p3</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">dist</span> <span class="n">p1</span> <span class="n">p3</span> <span class="bp">*</span> <span class="n">dist</span> <span class="n">p1</span> <span class="n">p3</span> <span class="bp">=</span> <span class="n">dist</span> <span class="n">p1</span> <span class="n">p2</span> <span class="bp">*</span> <span class="n">dist</span> <span class="n">p1</span> <span class="n">p2</span> <span class="bp">+</span> <span class="n">dist</span> <span class="n">p3</span> <span class="n">p2</span> <span class="bp">*</span> <span class="n">dist</span> <span class="n">p3</span> <span class="n">p2</span> <span class="bp">↔</span>
    <span class="err">∠</span> <span class="n">V</span> <span class="n">p1</span> <span class="n">p2</span> <span class="n">p3</span> <span class="bp">=</span> <span class="n">real</span><span class="bp">.</span><span class="n">pi</span> <span class="bp">/</span> <span class="mi">2</span> <span class="o">:=</span>
</code></pre></div>



<a name="197865467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197865467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197865467">(May 17 2020 at 19:38)</a>:</h4>
<p>This is true in any real inner product space</p>



<a name="197865568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197865568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197865568">(May 17 2020 at 19:40)</a>:</h4>
<p>Only that points and vectors between points are generally thought of as different things in geometry, i.e. it's more precisely typed to state geometry theorems in the Euclidean affine space context.</p>



<a name="197865675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197865675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197865675">(May 17 2020 at 19:43)</a>:</h4>
<p>What is your current definition?</p>



<a name="197865679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197865679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197865679">(May 17 2020 at 19:43)</a>:</h4>
<p>I mean, the main <code>class</code></p>



<a name="197865733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197865733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197865733">(May 17 2020 at 19:44)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm">- A `euclidean_vector_space V` is a finite-dimensional real inner</span>
<span class="cm">product space structure on the vectors `V`. -/</span>
<span class="n">class</span> <span class="n">euclidean_vector_space</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">inner_product_space</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">finite_dimensional</span> <span class="n">ℝ</span> <span class="n">V</span><span class="o">]</span>

<span class="c">/-</span><span class="cm">- A `euclidean_affine_space V P` is an affine space with points `P`</span>
<span class="cm">over a `euclidean_vector_space V`. We bundle the distance and require</span>
<span class="cm">it to be the same as results from the inner product. -/</span>
<span class="n">class</span> <span class="n">euclidean_affine_space</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">inner_product_space</span> <span class="n">V</span><span class="o">]</span>
    <span class="o">[</span><span class="n">finite_dimensional</span> <span class="n">ℝ</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">euclidean_vector_space</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">has_dist</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">has_vadd</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span>
    <span class="o">[</span><span class="n">affine_space</span> <span class="n">ℝ</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">dist_eq_norm_vsub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">P</span><span class="o">),</span> <span class="n">dist</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="err">∥</span><span class="o">(</span><span class="n">x</span> <span class="bp">-</span><span class="err">ᵥ</span> <span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span><span class="err">∥</span><span class="o">)</span>
</code></pre></div>



<a name="197865813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197865813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197865813">(May 17 2020 at 19:46)</a>:</h4>
<p>Note that many theorems will not need <code>finite_dimensional</code>.</p>



<a name="197865814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197865814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197865814">(May 17 2020 at 19:46)</a>:</h4>
<p>So I'd drop it.</p>



<a name="197865824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197865824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197865824">(May 17 2020 at 19:46)</a>:</h4>
<p>And add as an additional requirement on <code>V</code> when actually needed.</p>



<a name="197865884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197865884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197865884">(May 17 2020 at 19:48)</a>:</h4>
<p>It's part of the standard definition (that I took from Wikipedia), but I agree it will rarely be needed. Even things that need being finite-dimensional will often work in a finite-dimensional subspace of an infinite-dimensional space.</p>



<a name="197865916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197865916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197865916">(May 17 2020 at 19:49)</a>:</h4>
<p>Instead of a typeclass <code>euclidean_vector_space</code>,  you can define <code>euclidean_space n</code> to be <code>fin n → real</code> and introduce an <code>inner_product_space</code> instance on <code>euclidean_space n</code>.</p>



<a name="197865995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197865995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197865995">(May 17 2020 at 19:50)</a>:</h4>
<p>I don't understand why you say that Yury</p>



<a name="197865999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197865999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197865999">(May 17 2020 at 19:51)</a>:</h4>
<p>E.g. to define the circumcentre (in any number of dimensions) you need a finite affine-independent collection of points and can require the circumcentre to be in their affine span, rather than requiring n+1 points in a space that's n-dimensional.</p>



<a name="197866008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866008">(May 17 2020 at 19:51)</a>:</h4>
<p>We definitely want Euclidean spaces to have no preferred basis</p>



<a name="197866054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866054">(May 17 2020 at 19:52)</a>:</h4>
<p>And I also agree with Joseph that replacing affine spaces with artificial linear spaces is lame</p>



<a name="197866059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866059">(May 17 2020 at 19:52)</a>:</h4>
<p>And I'm very sad our calculus library is done in this artificial context</p>



<a name="197866070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866070">(May 17 2020 at 19:53)</a>:</h4>
<p>For  instance, we discussed affine charts on projective spaces. How would you define a linear space structure on them (without choosing bases everywhere)?</p>



<a name="197866073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866073">(May 17 2020 at 19:53)</a>:</h4>
<p>Probably you're right.</p>



<a name="197866113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866113">(May 17 2020 at 19:54)</a>:</h4>
<p>However we still to have the usual discussions about what should be parameters and what should be extended</p>



<a name="197866128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866128">(May 17 2020 at 19:55)</a>:</h4>
<p>What I want is to avoid requirement <code>[finite_dimensional ...]</code> in theorems that don't need it.</p>



<a name="197866136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866136">(May 17 2020 at 19:55)</a>:</h4>
<p>Sure</p>



<a name="197866138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866138">(May 17 2020 at 19:55)</a>:</h4>
<p>I'm happy to remove that requirement, it will just mean the definition isn't quite the same as the standard one.</p>



<a name="197866183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866183">(May 17 2020 at 19:56)</a>:</h4>
<p>I wonder if we can have some clever <code>abbreviation</code> here.</p>



<a name="197866189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866189">(May 17 2020 at 19:56)</a>:</h4>
<p>Wait, what's the difference between inner_product_space and euclidean_space then?</p>



<a name="197866194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866194">(May 17 2020 at 19:56)</a>:</h4>
<p>You should just work with <code>inner_product_space</code>, almost all of your theorems will be true in this broader setting.</p>



<a name="197866198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866198">(May 17 2020 at 19:57)</a>:</h4>
<p>Or we can avoid the words <code>euclidean_space</code> and use <code>inner_product_space</code></p>



<a name="197866203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866203">(May 17 2020 at 19:57)</a>:</h4>
<p>I was first!</p>



<a name="197866204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866204">(May 17 2020 at 19:57)</a>:</h4>
<p>If we remove the requirement, there wouldn't be <code>euclidean_vector_space</code> any more, but there would be <code>euclidean_affine_space</code>.</p>



<a name="197866205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866205">(May 17 2020 at 19:57)</a>:</h4>
<p>Why not <code>normed_affine_space</code>?</p>



<a name="197866249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866249">(May 17 2020 at 19:58)</a>:</h4>
<p>And you separately impose typeclass requirements on the underlying vector space.</p>



<a name="197866252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866252">(May 17 2020 at 19:58)</a>:</h4>
<p>As for <code>euclidean_affine_space</code>, couldn't you rather require that you have a normed space structure on the vector space, and that the distance on the affine space should come from this distance, but without requiring a priori that the distance is euclidean?</p>



<a name="197866257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866257">(May 17 2020 at 19:59)</a>:</h4>
<p>Yury, Patrick and I are saying exactly the same things in parallel. Maybe it's a hint that it's a natural design...</p>



<a name="197866279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866279">(May 17 2020 at 19:59)</a>:</h4>
<p>I must admit that I started with something else but now I agree that I was wrong.</p>



<a name="197866341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866341">(May 17 2020 at 20:00)</a>:</h4>
<p>Isn't the inner product a stronger requirement than being normed? And attempting to define the metric for an affine space over a general normed space, then apply it with the extra requirement of the inner product, ran into the type class issues discussed above.</p>



<a name="197866352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866352">(May 17 2020 at 20:01)</a>:</h4>
<p>No, if you add <code>[normed_space k V]</code> as an argument.</p>



<a name="197866364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866364">(May 17 2020 at 20:01)</a>:</h4>
<p>In this case you can later require <code>[inner_product_space V]</code> and Lean will deduce <code>[normed_space real V]</code> automatically.</p>



<a name="197866417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866417">(May 17 2020 at 20:02)</a>:</h4>
<p>And I guess <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> wants some basic theory to be done over any normed field.</p>



<a name="197866432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866432">(May 17 2020 at 20:03)</a>:</h4>
<p>And then we'll want an instance saying that a linear space is an affine space over itself and the world will collapse</p>



<a name="197866438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866438">(May 17 2020 at 20:03)</a>:</h4>
<p>Why?</p>



<a name="197866480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866480">(May 17 2020 at 20:04)</a>:</h4>
<p>But keep the bundled distance? Some other bits of theory (proving Tarski's axioms for betweenness) are for any affine space over an ordered field. I already have the instance that a vector space is an affine space over itself.</p>



<a name="197866495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866495">(May 17 2020 at 20:04)</a>:</h4>
<p>I don't why, it's simply we're already discussing a complicated class setup, and things are usually difficult.</p>



<a name="197866602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866602">(May 17 2020 at 20:07)</a>:</h4>
<p>To summarize, we need</p>
<ul>
<li><code>affine_space k V P</code>;</li>
<li><code>normed_affine_space k V P</code>.</li>
</ul>



<a name="197866664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866664">(May 17 2020 at 20:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="266253">Joseph Myers</span> <a href="#narrow/stream/113489-new-members/topic/Some.20olympiad.20formalisations/near/197866138">said</a>:</p>
<blockquote>
<p>I'm happy to remove that requirement, it will just mean the definition isn't quite the same as the standard one.</p>
</blockquote>
<p>I don't understand. Why is it important that your code is maximally close to the statement on wikipedia?</p>



<a name="197866770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866770">(May 17 2020 at 20:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> Looking back in this thread, I think that I understand what happened. I badly formulated what I wanted.</p>
<p>I never wanted the general theory to be written for <code>fin n → real</code> only. But we need a model Euclidean space sometimes, and once we drop the <code>euclidean_space</code> typeclass (and write the general theory for an <code>inner_product_space</code>) it seems natural to reuse this name as a type tag on <code>fin n → real</code>.</p>



<a name="197866781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866781">(May 17 2020 at 20:11)</a>:</h4>
<p>ok</p>



<a name="197866897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866897">(May 17 2020 at 20:14)</a>:</h4>
<p><span class="user-mention" data-user-id="252300">@Jalex Stark</span> Each place where a definition means something different from the conventional mathematical meaning of a phrase is a potential source of confusion. In this case there probably isn't much scope for confusion (and we can't avoid cases where different sources use the same phrase with different meanings and we have to pick one).</p>



<a name="197866923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866923">(May 17 2020 at 20:15)</a>:</h4>
<p>I don't think "the string of words you can find most easily on wikipedia" and "the conventional mathematical meaning" are terribly related</p>



<a name="197866930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866930">(May 17 2020 at 20:15)</a>:</h4>
<p>"the conventional mathematical meaning" of something is never fully captured by one formal definition</p>



<a name="197866971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866971">(May 17 2020 at 20:16)</a>:</h4>
<p>in terms of mathlib, it's captured by an API with several equivalent definitions at the core</p>



<a name="197866982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197866982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197866982">(May 17 2020 at 20:16)</a>:</h4>
<p>in terms of "mathematics done without computers" it's captured by sociological phenomena that are fuzzier than concrete sentences on paper</p>
<p>namely the practice of doing and teaching mathematics</p>



<a name="197867770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197867770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197867770">(May 17 2020 at 20:38)</a>:</h4>
<p>Defining <code>normed_affine_space</code> (with bundled dist) results in much the same type class issues as above.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">normed_space</span><span class="bp">.</span><span class="n">real_inner_product</span>

<span class="n">class</span> <span class="n">has_vadd</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">vadd</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">P</span><span class="o">)</span>
<span class="o">(</span><span class="n">vsub</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span>

<span class="n">def</span> <span class="n">vadd</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_vadd</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">has_vadd</span><span class="bp">.</span><span class="n">vadd</span>
<span class="n">def</span> <span class="n">vsub</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_vadd</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">has_vadd</span><span class="bp">.</span><span class="n">vsub</span>

<span class="kn">infix</span> <span class="bp">`+</span><span class="err">ᵥ</span><span class="bp">`</span><span class="o">:</span><span class="mi">65</span> <span class="o">:=</span> <span class="n">vadd</span>
<span class="kn">infix</span> <span class="bp">`-</span><span class="err">ᵥ</span><span class="bp">`</span><span class="o">:</span><span class="mi">65</span> <span class="o">:=</span> <span class="n">vsub</span>

<span class="n">class</span> <span class="n">affine_space</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span>
    <span class="o">[</span><span class="n">vector_space</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">has_vadd</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">vadd_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">v1</span> <span class="n">v2</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">p</span> <span class="bp">+</span><span class="err">ᵥ</span> <span class="n">v1</span> <span class="bp">+</span><span class="err">ᵥ</span> <span class="n">v2</span> <span class="bp">=</span> <span class="n">p</span> <span class="bp">+</span><span class="err">ᵥ</span> <span class="o">(</span><span class="n">v1</span> <span class="bp">+</span> <span class="n">v2</span><span class="o">))</span>
<span class="o">(</span><span class="n">vadd_vsub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p1</span> <span class="n">p2</span> <span class="o">:</span> <span class="n">P</span><span class="o">),</span> <span class="n">p1</span> <span class="bp">+</span><span class="err">ᵥ</span> <span class="o">(</span><span class="n">p2</span> <span class="bp">-</span><span class="err">ᵥ</span> <span class="n">p1</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p2</span><span class="o">)</span>
<span class="o">(</span><span class="n">vsub_vadd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">p</span> <span class="bp">+</span><span class="err">ᵥ</span> <span class="n">v</span> <span class="bp">-</span><span class="err">ᵥ</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">v</span><span class="o">)</span>

<span class="n">class</span> <span class="n">normed_affine_space</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">V</span><span class="o">]</span>
    <span class="o">[</span><span class="n">normed_space</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">has_dist</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">has_vadd</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">affine_space</span> <span class="n">k</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">dist_eq_norm_vsub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">P</span><span class="o">),</span> <span class="n">dist</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="err">∥</span><span class="o">(</span><span class="n">x</span> <span class="bp">-</span><span class="err">ᵥ</span> <span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span><span class="err">∥</span><span class="o">)</span>

<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">all</span> <span class="n">true</span>

<span class="n">class</span> <span class="n">euclidean_affine_space</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">inner_product_space</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">P</span><span class="o">]</span>
    <span class="o">[</span><span class="n">has_dist</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">has_vadd</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">affine_space</span> <span class="n">ℝ</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_affine_space</span> <span class="n">ℝ</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span>
</code></pre></div>


<p>Errors:</p>
<div class="codehilite"><pre><span></span><code><span class="mi">26</span><span class="o">:</span><span class="mi">55</span><span class="o">:</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span> <span class="n">for</span>
<span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="n">l_1</span><span class="o">,</span>
<span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="n">l_2</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">inner_product_space</span><span class="bp">.</span><span class="o">{</span><span class="err">?</span><span class="n">l_1</span><span class="o">}</span> <span class="n">V</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">nonempty</span><span class="bp">.</span><span class="o">{</span><span class="err">?</span><span class="n">l_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">P</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_3</span> <span class="o">:</span> <span class="n">has_dist</span><span class="bp">.</span><span class="o">{</span><span class="err">?</span><span class="n">l_2</span><span class="o">}</span> <span class="n">P</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_4</span> <span class="o">:</span> <span class="n">has_vadd</span><span class="bp">.</span><span class="o">{</span><span class="err">?</span><span class="n">l_1</span> <span class="err">?</span><span class="n">l_2</span><span class="o">}</span> <span class="n">V</span> <span class="n">P</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_5</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">affine_space</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="err">?</span><span class="n">l_1</span> <span class="err">?</span><span class="n">l_2</span><span class="o">}</span> <span class="n">real</span> <span class="n">V</span> <span class="n">P</span> <span class="n">real</span><span class="bp">.</span><span class="n">field</span> <span class="o">(</span><span class="bp">@</span><span class="n">inner_product_space</span><span class="bp">.</span><span class="n">to_add_comm_group</span><span class="bp">.</span><span class="o">{</span><span class="err">?</span><span class="n">l_1</span><span class="o">}</span> <span class="n">V</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">inner_product_space</span><span class="bp">.</span><span class="n">to_module</span><span class="bp">.</span><span class="o">{</span><span class="err">?</span><span class="n">l_1</span><span class="o">}</span> <span class="n">V</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)</span>
    <span class="bp">_</span><span class="n">inst_2</span>
    <span class="bp">_</span><span class="n">inst_4</span>
<span class="err">⊢</span> <span class="bp">@</span><span class="n">affine_space</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="err">?</span><span class="n">l_1</span> <span class="err">?</span><span class="n">l_2</span><span class="o">}</span> <span class="n">real</span> <span class="n">V</span> <span class="n">P</span> <span class="o">(</span><span class="bp">@</span><span class="n">normed_field</span><span class="bp">.</span><span class="n">to_field</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">real</span> <span class="n">normed_field</span><span class="bp">.</span><span class="n">normed_field</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">normed_group</span><span class="bp">.</span><span class="n">to_add_comm_group</span><span class="bp">.</span><span class="o">{</span><span class="err">?</span><span class="n">l_1</span><span class="o">}</span> <span class="n">V</span> <span class="o">(</span><span class="bp">@</span><span class="n">inner_product_space_is_normed_group</span><span class="bp">.</span><span class="o">{</span><span class="err">?</span><span class="n">l_1</span><span class="o">}</span> <span class="n">V</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">normed_space</span><span class="bp">.</span><span class="n">to_module</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span> <span class="err">?</span><span class="n">l_1</span><span class="o">}</span> <span class="n">real</span> <span class="n">V</span> <span class="n">normed_field</span><span class="bp">.</span><span class="n">normed_field</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">inner_product_space_is_normed_group</span><span class="bp">.</span><span class="o">{</span><span class="err">?</span><span class="n">l_1</span><span class="o">}</span> <span class="n">V</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">inner_product_space_is_normed_space</span><span class="bp">.</span><span class="o">{</span><span class="err">?</span><span class="n">l_1</span><span class="o">}</span> <span class="n">V</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">))</span>
    <span class="bp">_</span><span class="n">inst_2</span>
    <span class="bp">_</span><span class="n">inst_4</span>
</code></pre></div>



<a name="197868051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197868051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197868051">(May 17 2020 at 20:45)</a>:</h4>
<p>You could go for</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">normed_space</span><span class="bp">.</span><span class="n">real_inner_product</span>

<span class="n">class</span> <span class="n">has_vadd</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">vadd</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">P</span><span class="o">)</span>
<span class="o">(</span><span class="n">vsub</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span>

<span class="n">def</span> <span class="n">vadd</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_vadd</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">has_vadd</span><span class="bp">.</span><span class="n">vadd</span>
<span class="n">def</span> <span class="n">vsub</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_vadd</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">has_vadd</span><span class="bp">.</span><span class="n">vsub</span>

<span class="kn">infix</span> <span class="bp">`+</span><span class="err">ᵥ</span><span class="bp">`</span><span class="o">:</span><span class="mi">65</span> <span class="o">:=</span> <span class="n">vadd</span>
<span class="kn">infix</span> <span class="bp">`-</span><span class="err">ᵥ</span><span class="bp">`</span><span class="o">:</span><span class="mi">65</span> <span class="o">:=</span> <span class="n">vsub</span>

<span class="n">class</span> <span class="n">affine_space</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span>
    <span class="o">[</span><span class="n">vector_space</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">has_vadd</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">vadd_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">v1</span> <span class="n">v2</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">p</span> <span class="bp">+</span><span class="err">ᵥ</span> <span class="n">v1</span> <span class="bp">+</span><span class="err">ᵥ</span> <span class="n">v2</span> <span class="bp">=</span> <span class="n">p</span> <span class="bp">+</span><span class="err">ᵥ</span> <span class="o">(</span><span class="n">v1</span> <span class="bp">+</span> <span class="n">v2</span><span class="o">))</span>
<span class="o">(</span><span class="n">vadd_vsub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p1</span> <span class="n">p2</span> <span class="o">:</span> <span class="n">P</span><span class="o">),</span> <span class="n">p1</span> <span class="bp">+</span><span class="err">ᵥ</span> <span class="o">(</span><span class="n">p2</span> <span class="bp">-</span><span class="err">ᵥ</span> <span class="n">p1</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p2</span><span class="o">)</span>
<span class="o">(</span><span class="n">vsub_vadd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">p</span> <span class="bp">+</span><span class="err">ᵥ</span> <span class="n">v</span> <span class="bp">-</span><span class="err">ᵥ</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">v</span><span class="o">)</span>

<span class="n">class</span> <span class="n">normed_affine_space</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">V</span><span class="o">]</span>
    <span class="o">[</span><span class="n">normed_space</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">has_vadd</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">P</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">affine_space</span> <span class="n">k</span> <span class="n">V</span> <span class="n">P</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">dist_eq_norm_vsub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">P</span><span class="o">),</span> <span class="n">dist</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="err">∥</span><span class="o">(</span><span class="n">x</span> <span class="bp">-</span><span class="err">ᵥ</span> <span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span><span class="err">∥</span><span class="o">)</span>

<span class="n">class</span> <span class="n">euclidean_affine_space</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">inner_product_space</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">P</span><span class="o">]</span>
    <span class="o">[</span><span class="n">metric_space</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">has_vadd</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_affine_space</span> <span class="n">ℝ</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span>
</code></pre></div>



<a name="197868096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197868096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197868096">(May 17 2020 at 20:46)</a>:</h4>
<p>What's the difference?</p>



<a name="197868107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197868107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197868107">(May 17 2020 at 20:46)</a>:</h4>
<p>That one assumes the metric space structure rather than proving that the distance defines one.</p>



<a name="197868117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197868117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197868117">(May 17 2020 at 20:47)</a>:</h4>
<p>The differences are that I have assumed that there is a metric space structure on <code>P</code>, not just a distance (so that you get the topology and everything), and that <code>normed_affine_space</code> now extends <code>affine_space</code>.</p>



<a name="197868147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197868147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197868147">(May 17 2020 at 20:47)</a>:</h4>
<p>A simple rule is that, if a typeclass does not depend on more type arguments than a previous typeclass, then it should extend it, not take it as a parameter.</p>



<a name="197868194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197868194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197868194">(May 17 2020 at 20:48)</a>:</h4>
<p>BTW, <code>affine_space</code> should extend <code>has_vadd</code>. Also I'd avoid <code>def vadd</code>. You can use <code>has_vadd.vadd</code> in notation instead.</p>



<a name="197868207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197868207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197868207">(May 17 2020 at 20:48)</a>:</h4>
<p>It's not always a perfect rule, but quite often it's a good one.</p>



<a name="197868219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197868219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197868219">(May 17 2020 at 20:49)</a>:</h4>
<p>No, <code>affine_space</code> should not extend <code>has_vadd</code> as there is an additional type parameter, the field.</p>



<a name="197868228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197868228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197868228">(May 17 2020 at 20:49)</a>:</h4>
<p>I always forget about this.</p>



<a name="197868234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197868234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197868234">(May 17 2020 at 20:49)</a>:</h4>
<p>I mean, the fact that we can't <code>extend</code> in this case.</p>



<a name="197868281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197868281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197868281">(May 17 2020 at 20:50)</a>:</h4>
<p>I never understood it in the first place. I am just hoping that it will all be easier in lean 4</p>



<a name="197868307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197868307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197868307">(May 17 2020 at 20:50)</a>:</h4>
<p>All I know is that there are experts here who can tell me how to set things up with the definitions, and then the theorems I'm ok with</p>



<a name="197868308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197868308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197868308">(May 17 2020 at 20:50)</a>:</h4>
<p>The main issue with your definition, though, is that it's not the usual definition of an affine space. For instance, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> with the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> action acting by addition on the first coordinate is an affine space in your sense.</p>



<a name="197868320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197868320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197868320">(May 17 2020 at 20:51)</a>:</h4>
<p>What is <code>vsub</code>?</p>



<a name="197868331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197868331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197868331">(May 17 2020 at 20:51)</a>:</h4>
<p>No, I'm wrong, because of your <code>vsub</code>, sorry.</p>



<a name="197868370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197868370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197868370">(May 17 2020 at 20:52)</a>:</h4>
<p>Shouldn't an affine space be "a faithful and transitive group action by the additive group of a vector space"?</p>



<a name="197868382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197868382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197868382">(May 17 2020 at 20:53)</a>:</h4>
<p>The full version (as opposed to the MWE) has comments explaining that it's defined directly since mathlib doesn't have additive group actions (and also <code>vadd_zero</code> isn't needed as an axiom because with this definition it can be deduced from the other axioms).</p>



<a name="197868461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197868461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197868461">(May 17 2020 at 20:55)</a>:</h4>
<p>If <code>vadd</code> and <code>vsub</code> only show up in the definition of an affine space, I don't know if you should have a separate class for them as you do, or if you should bundle them in the definition. The only drawback I can see is when you want to see an affine complex space as an affine real space, sharing the same <code>vadd</code> and <code>vsub</code>.</p>



<a name="197868521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197868521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197868521">(May 17 2020 at 20:56)</a>:</h4>
<p>I think if they're defined as part of <code>affine_space</code> I then can't use the notation within that definition? That was why I defined them separately.</p>



<a name="197869141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197869141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197869141">(May 17 2020 at 21:11)</a>:</h4>
<p>Thinking back about this, you should define an affine space with respect to an <code>add_comm_group</code>, not with respect to a <code>vector_space</code>: your axioms don't involve the field action. And a normed affine space should be with respect to a <code>normed_group</code>.</p>



<a name="197869393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197869393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197869393">(May 17 2020 at 21:17)</a>:</h4>
<p>Once I define affine subspaces and affine maps, the vector space becomes relevant. Should I still define <code>affine_space</code> as a torsor of a group action of an <code>add_comm_group</code> and then only introduce the field and vector space for those later definitions?</p>



<a name="197869806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197869806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197869806">(May 17 2020 at 21:29)</a>:</h4>
<p>Yeah, why not. I remember when we defined group actions and the computer scientists looked at us and said "you don't mention inverses -- define monoid actions instead".</p>



<a name="197870050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197870050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197870050">(May 17 2020 at 21:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="266253">Joseph Myers</span> <a href="#narrow/stream/113489-new-members/topic/Some.20olympiad.20formalisations/near/197869393">said</a>:</p>
<blockquote>
<p>Once I define affine subspaces and affine maps, the vector space becomes relevant. Should I still define <code>affine_space</code> as a torsor of a group action of an <code>add_comm_group</code> and then only introduce the field and vector space for those later definitions?</p>
</blockquote>
<p>Yes, I think so. Then it means that you can extend <code>has_vadd</code> instead of taking it as a parameter, as you are not introducing new types into the game.</p>



<a name="197870547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197870547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197870547">(May 17 2020 at 21:47)</a>:</h4>
<p>OK, I've rearranged things along those lines. With <code>normed_affine_space</code> extending <code>affine_space</code> (both of them not depending on a field any more) and <code>euclidean_affine_space</code> extending <code>normed_affine_space</code>, it now works for <code>normed_affine_space</code> and thus <code>euclidean_affine_space</code> to bundle only <code>[has_dist P]</code> rather than the full metric space structure, with the metric space properties of the distance then being proved as an instance for any <code>normed_affine_space</code>.</p>



<a name="197870632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197870632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197870632">(May 17 2020 at 21:49)</a>:</h4>
<p>Should any of this be PRed to mathlib, or is further work needed there first? I can think of at least four separate pieces: (a) affine spaces; (b) normed affine spaces; (c) the geometrical definitions and results (such as angles and Pythagoras) that are proved for real inner product spaces as an intermediate step to proving them for Euclidean affine spaces; (d) Euclidean affine spaces and corresponding geometrical results.</p>



<a name="197870677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197870677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197870677">(May 17 2020 at 21:50)</a>:</h4>
<blockquote>
<p>Should any of this be PRed to mathlib?</p>
</blockquote>
<p>You can start by opening a PR with what you already have.</p>



<a name="197870718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197870718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197870718">(May 17 2020 at 21:51)</a>:</h4>
<p>I suppose affine spaces go in linear_algebra/affine_space.lean and normed affine spaces in something like analysis/normed_space/affine.lean?</p>



<a name="197871000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197871000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197871000">(May 17 2020 at 21:58)</a>:</h4>
<p>Does "affine space" here mean torsor for an arbitrary additive group?</p>



<a name="197871020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197871020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197871020">(May 17 2020 at 21:59)</a>:</h4>
<p>I only partly followed the conversation here.</p>



<a name="197871029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197871029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197871029">(May 17 2020 at 21:59)</a>:</h4>
<p>That seems to be the conclusion</p>



<a name="197871080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197871080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197871080">(May 17 2020 at 22:00)</a>:</h4>
<p>A commutative additive group is what we arrived at. I don't think that much actually depends on the commutative part, but if you remove that then you have to deal with left and right torsors (and the <code>+ᵥ</code> and <code>-ᵥ</code> notation becomes even less applicable).</p>



<a name="197871106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197871106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197871106">(May 17 2020 at 22:01)</a>:</h4>
<p>Then it should be called something like <code>add_torsor</code> and go under ... <code>algebra</code>?</p>



<a name="197871163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197871163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197871163">(May 17 2020 at 22:02)</a>:</h4>
<p>Or <code>add_comm_torsor</code> since some bits do use commutativity?</p>



<a name="197871229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197871229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197871229">(May 17 2020 at 22:02)</a>:</h4>
<p>The docstring should mention affine spaces.</p>



<a name="197871303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197871303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197871303">(May 17 2020 at 22:04)</a>:</h4>
<p>If at some point someone wants torsors for a nonabelian group, the group law will probably not be <code>+</code>.</p>



<a name="197871383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197871383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197871383">(May 17 2020 at 22:06)</a>:</h4>
<p>Come to think of it, do we have general group actions on sets? I forget</p>



<a name="197871388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197871388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197871388">(May 17 2020 at 22:06)</a>:</h4>
<p>Only multiplicative actions, not additive.</p>



<a name="197872871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197872871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197872871">(May 17 2020 at 22:45)</a>:</h4>
<p>Filed PR <a href="https://github.com/leanprover-community/mathlib/issues/2720">#2720</a> with the first piece (torsors of additive commutative group actions).</p>



<a name="197929063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Some%20olympiad%20formalisations/near/197929063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Some.20olympiad.20formalisations.html#197929063">(May 18 2020 at 12:50)</a>:</h4>
<p><span class="user-mention" data-user-id="266253">@Joseph Myers</span> Sorry for the outdated style guidelines. I've PR'd an update over here: <a href="https://github.com/leanprover-community/leanprover-community.github.io/pull/21">https://github.com/leanprover-community/leanprover-community.github.io/pull/21</a><br>
(And thanks for pointing out that they were out of date <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span>)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html">proving lemmas about infi</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="257913843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20lemmas%20about%20infi/near/257913843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html#257913843">(Oct 17 2021 at 12:10)</a>:</h4>
<p>What's the proper way to induct on a <code>fintype</code>? I'm trying to prove a lemma like the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.tropical.basic</span>
<span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">S</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>
<span class="kn">open</span> <span class="n">tropical</span>

<span class="kd">lemma</span> <span class="n">trop_infi</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">with_top</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">trop</span> <span class="o">(</span><span class="bp">⨅</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">S</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">S</span><span class="o">),</span> <span class="n">trop</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="257915284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20lemmas%20about%20infi/near/257915284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html#257915284">(Oct 17 2021 at 12:33)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.trunc_rec_empty_option">docs#fintype.trunc_rec_empty_option</a>?</p>



<a name="257915611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20lemmas%20about%20infi/near/257915611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html#257915611">(Oct 17 2021 at 12:39)</a>:</h4>
<p>That's close, but I am not sure how to deconstruct or generalize S here to employ that or <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.induction_empty_option">docs#fintype.induction_empty_option</a>.</p>



<a name="257915956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20lemmas%20about%20infi/near/257915956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html#257915956">(Oct 17 2021 at 12:45)</a>:</h4>
<p>Why don't you write that in terms of a finset instead?</p>



<a name="257916119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20lemmas%20about%20infi/near/257916119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html#257916119">(Oct 17 2021 at 12:47)</a>:</h4>
<p><code>infi</code> is only defined as over an indexed type.</p>



<a name="257916135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20lemmas%20about%20infi/near/257916135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html#257916135">(Oct 17 2021 at 12:48)</a>:</h4>
<p>or do you mean a doubly-coerced finset?</p>



<a name="257916721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20lemmas%20about%20infi/near/257916721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html#257916721">(Oct 17 2021 at 12:55)</a>:</h4>
<p>Oh nevermind, that's <code>inf</code> not <code>prod</code>. But you might still have an easier time with something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">trop_infi</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">with_top</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">trop</span> <span class="o">(</span><span class="n">Sup</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">))</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">trop</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">s.eq_empty_or_nonempty</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="gr">sorry</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">finset.sup'_eq_cSup_image</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="257917310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20lemmas%20about%20infi/near/257917310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html#257917310">(Oct 17 2021 at 13:03)</a>:</h4>
<p>Oh, I mean Inf not Sup</p>



<a name="257917436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20lemmas%20about%20infi/near/257917436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html#257917436">(Oct 17 2021 at 13:05)</a>:</h4>
<p>But anyway, prove the version about <code>finset.inf'</code> first</p>



<a name="257917841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20lemmas%20about%20infi/near/257917841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html#257917841">(Oct 17 2021 at 13:10)</a>:</h4>
<p>A mathematician wouldn't induct on a fintype, they'd induct on the size of a fintype (because mathematicians only know about induction on nat). Why not prove "for all n, fintype.card X = n -&gt; (what you want)"</p>



<a name="257918188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20lemmas%20about%20infi/near/257918188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html#257918188">(Oct 17 2021 at 13:15)</a>:</h4>
<p>Alternatively prove it for <code>fin n</code> and then prove it moves along bijections</p>



<a name="257991406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20lemmas%20about%20infi/near/257991406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html#257991406">(Oct 18 2021 at 08:05)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">trop_inf</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">trop</span> <span class="o">(</span><span class="n">a</span> <span class="bp">⊓</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">trop</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">trop</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">trop_finset_inf</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">with_top</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">trop</span> <span class="o">(</span><span class="n">s.inf</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">trop</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">s</span> <span class="n">using</span> <span class="n">finset.cons_induction</span> <span class="k">with</span> <span class="n">a</span> <span class="n">s</span> <span class="n">ha</span> <span class="n">ih</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">ih</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">trop_Inf_image</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">with_top</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">trop</span> <span class="o">(</span><span class="n">Inf</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">))</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">trop</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">s.eq_empty_or_nonempty</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">finset.inf'_eq_cInf_image</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span> <span class="n">finset.inf'_eq_inf</span><span class="o">,</span> <span class="n">trop_finset_inf</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">trop_infi</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">with_top</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">trop</span> <span class="o">(</span><span class="bp">⨅</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">S</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">S</span><span class="o">),</span> <span class="n">trop</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">infi</span><span class="o">,</span> <span class="bp">←</span><span class="n">set.image_univ</span><span class="o">,</span> <span class="bp">←</span><span class="n">finset.coe_univ</span><span class="o">,</span> <span class="n">trop_Inf_image</span><span class="o">]</span>
</code></pre></div>



<a name="257997178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20lemmas%20about%20infi/near/257997178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html#257997178">(Oct 18 2021 at 09:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/proving.20lemmas.20about.20infi/near/257917841">said</a>:</p>
<blockquote>
<p>A mathematician wouldn't induct on a fintype</p>
</blockquote>
<p>Fixed</p>



<a name="257997578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20lemmas%20about%20infi/near/257997578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html#257997578">(Oct 18 2021 at 09:04)</a>:</h4>
<p>It would be nice to have some general notion of what it means for a <code>fintype</code>/<code>finset</code> operation to be an n-ary version of a binary operation with unit, and what it means for a function to carry one such operation to another, because the structure of arguments like these are all the same.</p>



<a name="258022420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20lemmas%20about%20infi/near/258022420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html#258022420">(Oct 18 2021 at 12:44)</a>:</h4>
<p>It also has to be a commutative operation. Wouldn't the notion be foldr for lists, and then fold and mapped fold for multisets and finsets? One issue we have is that not all multiset fold specializations exist in list (compare multiset.inf vs list.minimum). Also, finset big ops have an additional implied map/image step, compared to multisets. So the general notion could be some sort of metaprogram, that taking a proof of the "correct binary behavior", generates the associated list, multiset, finset, and fintype lemmas.</p>



<a name="258023450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20lemmas%20about%20infi/near/258023450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html#258023450">(Oct 18 2021 at 12:51)</a>:</h4>
<p>Associative, commutative, and with-identity operation; we'd need to unify <code>monoid</code>, <code>add_monoid</code>, and <code>semilattice_inf_bot</code> I think (or translate in a meta-program)</p>



<a name="258060223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20lemmas%20about%20infi/near/258060223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html#258060223">(Oct 18 2021 at 16:45)</a>:</h4>
<p>Can't the <code>is_commutative</code> class be used for that generalisation?</p>



<a name="258060631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/proving%20lemmas%20about%20infi/near/258060631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/proving.20lemmas.20about.20infi.html#258060631">(Oct 18 2021 at 16:47)</a>:</h4>
<p>The generalization I'm referring to would be followed by generalizing <code>monoid_hom A B</code> to something like <code>monoid_hom A B (⊓) (+)</code> or <code>monoid_hom A B (⊓) ⊥ (+) 0</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
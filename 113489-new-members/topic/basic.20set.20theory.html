---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/basic.20set.20theory.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/basic.20set.20theory.html">basic set theory</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="214895108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basic%20set%20theory/near/214895108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Castilho <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/basic.20set.20theory.html#214895108">(Oct 28 2020 at 20:44)</a>:</h4>
<p>Hi, am student from Brazil trying to learn a bit more about lean and am having same difficulties in using some theorems from Mathlib, in particular this one: <br>
how would I use set.union_diff_left to solve something like this in tactic mode</p>
<p>example : (t ∪ s) \ s ⊆ t \ s</p>
<p>thx for the help</p>



<a name="214897100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basic%20set%20theory/near/214897100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Peattie <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/basic.20set.20theory.html#214897100">(Oct 28 2020 at 21:01)</a>:</h4>
<p>Hey Pedro, you might find <a href="https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks">#backticks</a> and <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> useful when you're asking questions <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>. I think it's more natural to prove your example with <code>set.union_diff_right</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.basic</span>

<span class="kd">universe</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">t</span> <span class="bp">∪</span> <span class="n">s</span><span class="o">)</span> <span class="bp">\</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">t</span> <span class="bp">\</span> <span class="n">s</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">eq.subset</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">set.union_diff_right</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>

<p>But if you wanted to use <code>set.union_diff_left</code>, you could do something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.basic</span>

<span class="kd">universe</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">t</span> <span class="bp">∪</span> <span class="n">s</span><span class="o">)</span> <span class="bp">\</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">t</span> <span class="bp">\</span> <span class="n">s</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">eq.subset</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">set.union_comm</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">set.union_diff_left</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>

<p>Also, if you use the <code>hint</code> tactic you can see that you can prove the statement with <code>intro, finish</code> too</p>



<a name="214921095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basic%20set%20theory/near/214921095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Castilho <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/basic.20set.20theory.html#214921095">(Oct 29 2020 at 02:49)</a>:</h4>
<p>But using finish wouldn't be considered cheating in such a simple proof? hahaha <br>
by the way thx for the help, Alex</p>



<a name="214929218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basic%20set%20theory/near/214929218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/basic.20set.20theory.html#214929218">(Oct 29 2020 at 05:56)</a>:</h4>
<p>The whole point of tactics like finish is to save humans from having to write mathematically trivial proofs</p>



<a name="215820970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basic%20set%20theory/near/215820970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/basic.20set.20theory.html#215820970">(Nov 06 2020 at 09:18)</a>:</h4>
<p>Although writing mathematically trivial proofs is probably good practice for getting to grips with how lean works</p>



<a name="245848710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basic%20set%20theory/near/245848710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Esteban Estupinan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/basic.20set.20theory.html#245848710">(Jul 13 2021 at 16:14)</a>:</h4>
<p>lean has helped me in writting better proofs. Someone could  give me an idea how to continue this proof or how can I use h? Thank you for your answers</p>



<a name="245848785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basic%20set%20theory/near/245848785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Esteban Estupinan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/basic.20set.20theory.html#245848785">(Jul 13 2021 at 16:15)</a>:</h4>
<div class="codehilite" data-code-language="import"><pre><span></span><code>open set

variable {α : Type*}
variables (A B C : set α)

theorem t1 (h: A \ B ⊆ C): A \ C ⊆ B :=
begin
  assume x,
  intro h1,
  cases h1 with ha hc,

end ```
</code></pre></div>



<a name="245849293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basic%20set%20theory/near/245849293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/basic.20set.20theory.html#245849293">(Jul 13 2021 at 16:19)</a>:</h4>
<p>I'm guessing you don't want lemmas from Mathlib for this. So if you want to prove this "yourself", then perhaps unfolding the definition of <code>\</code> might help:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">t1</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">A</span> <span class="bp">\</span> <span class="n">B</span> <span class="bp">⊆</span> <span class="n">C</span><span class="o">):</span> <span class="n">A</span> <span class="bp">\</span> <span class="n">C</span> <span class="bp">⊆</span> <span class="n">B</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">ha</span> <span class="n">hc</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[(</span><span class="bp">\</span><span class="o">),</span> <span class="n">set.diff</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>

<span class="kd">end</span>
</code></pre></div>
<p>You can unfold any notation using <code>simp [(&lt;notation&gt;)]</code>. So if you also want to unfold the <code>⊆</code> you could write:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">simp</span> <span class="n">only</span> <span class="o">[(</span><span class="bp">⊆</span><span class="o">),</span> <span class="n">set.subset</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
</code></pre></div>



<a name="245849600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basic%20set%20theory/near/245849600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Esteban Estupinan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/basic.20set.20theory.html#245849600">(Jul 13 2021 at 16:21)</a>:</h4>
<p>yes exactly, not using mathlib lemmas, prove by myself</p>



<a name="245849818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basic%20set%20theory/near/245849818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/basic.20set.20theory.html#245849818">(Jul 13 2021 at 16:23)</a>:</h4>
<p>It's not cheating to use <code>set.mem_diff</code> in that proof - if you're using mathlib's definitions, then it's totally fair game to use mathlibs lemmas that tell you what they unfold to.</p>



<a name="245850003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basic%20set%20theory/near/245850003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/basic.20set.20theory.html#245850003">(Jul 13 2021 at 16:24)</a>:</h4>
<p>If you use <code>dsimp [set.mem_diff]</code> that ensures you're not using a lemma which is "cheating" (ie, one that actually contains a proof)</p>



<a name="245855379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basic%20set%20theory/near/245855379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Esteban Estupinan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/basic.20set.20theory.html#245855379">(Jul 13 2021 at 17:04)</a>:</h4>
<p>thank you, unfold is a practical tool in this case, first time I use it. I see  some facts that can use to proof from the unfold but sincerely I do not know how start. how can I link the unfold facts with the cases from and elimination of the first hypothesis?</p>



<a name="245855384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basic%20set%20theory/near/245855384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Esteban Estupinan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/basic.20set.20theory.html#245855384">(Jul 13 2021 at 17:04)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">t1</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">A</span> <span class="bp">\</span> <span class="n">B</span> <span class="bp">⊆</span> <span class="n">C</span><span class="o">):</span> <span class="n">A</span> <span class="bp">\</span> <span class="n">C</span> <span class="bp">⊆</span> <span class="n">B</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">ha</span> <span class="n">hc</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[(</span><span class="bp">\</span><span class="o">),</span> <span class="n">set.diff</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[(</span><span class="bp">⊆</span><span class="o">),</span> <span class="n">set.subset</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>

<span class="kd">end</span>
</code></pre></div>



<a name="245864680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basic%20set%20theory/near/245864680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/basic.20set.20theory.html#245864680">(Jul 13 2021 at 18:09)</a>:</h4>
<p>You might want to allow yourself <code>dsimp only [mem_sep_eq] at h</code> now.  <code>mem_sep_eq</code> is a lemma that is the definitionally true -- it's a tautology.</p>
<p>You can also have the same effect by using <code>change</code>, but that requires you to know the definitions:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">change</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">C</span> <span class="n">at</span> <span class="n">h</span>
</code></pre></div>



<a name="245997206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basic%20set%20theory/near/245997206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Esteban Estupinan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/basic.20set.20theory.html#245997206">(Jul 14 2021 at 18:04)</a>:</h4>
<p>thank you Kyle for supply me tactics. Now really I have the idea to  complete a proof of transitive law for inclusion for sets. By change tactic I m using only x variable. My idea is more less this. like I have x is in set R, i 'have' x in set S and like i 'have' x in set S, I conclude that x is in T set and finish the proof. I tried to use apply, have-from, intro, but all these put error in the code.</p>



<a name="245997275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basic%20set%20theory/near/245997275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Esteban Estupinan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/basic.20set.20theory.html#245997275">(Jul 14 2021 at 18:05)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">t1</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">⊆</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">⊆</span> <span class="n">T</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[(</span><span class="bp">⊆</span><span class="o">),</span> <span class="n">set.subset</span><span class="o">]</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">change</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[(</span><span class="bp">⊆</span><span class="o">),</span> <span class="n">set.subset</span><span class="o">]</span> <span class="n">at</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">change</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">T</span> <span class="n">at</span> <span class="n">h2</span><span class="o">,</span>



<span class="kd">end</span>
</code></pre></div>



<a name="245998472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basic%20set%20theory/near/245998472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/basic.20set.20theory.html#245998472">(Jul 14 2021 at 18:14)</a>:</h4>
<p>Hint: use the <code>apply</code> tactic.  <code>apply h2</code> is a good next step.</p>



<a name="245998564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basic%20set%20theory/near/245998564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/basic.20set.20theory.html#245998564">(Jul 14 2021 at 18:15)</a>:</h4>
<p>That's a proof in the "reverse direction."  If you want to go in the "forward direction," a good next step is <code>specialize h1 x h</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
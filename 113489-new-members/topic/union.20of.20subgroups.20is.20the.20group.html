---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html">union of subgroups is the group</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="246955695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/246955695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#246955695">(Jul 23 2021 at 09:10)</a>:</h4>
<div class="codehilite" data-code-language="import"><pre><span></span><code>import group_theory.coset
import data.fintype.basic
import group_theory.order_of_element

variables {G : Type} [fintype G] [group G]
variables (H : subgroup G) [fintype H]

open function

@[ext] structure partition (α : Type) :=
(C : set (set α))
(Hnonempty : ∀ X ∈ C, (X : set α).nonempty)
(Hcover : ∀ a, ∃ X ∈ C, a ∈ X)
(Hdisjoint : ∀ X Y ∈ C, (X ∩ Y : set α).nonempty → X = Y)

lemma lagrange (P : partition G) (h: ∀ X, X ∈ P.C → ∃ (g : G), X = left_coset g H ) :
fintype.card H ∣ fintype.card G := --the size of the subgroup H divides the size of the group G
begin
  exact card_subgroup_dvd_card H,
end
--lmao I don't need any of
--`(P : partition G) (h: ∀ X, X ∈ P.C → ∃ (g : G), X = left_coset g H )`
--this is very annoying

#check left_coset
lemma lagrange_long {k : ℕ} (P : partition G)
(h: ∀ X, X ∈ P.C → ∃ (g : G), X = left_coset g H) {γ : fin k → G}
{h₁ : bijective γ}
{h₂ : ∀ (i j : fin k), left_coset (γ i) H ≠ left_coset (γ j) H}
{h₃ : (⋃(i : fin k), left_coset (γ i) H) = G}:
fintype.card H ∣ fintype.card G := --the size of the subgroup H divides the size of the group G
begin
  --partition G into left cosets of H `done`]
  let L := (⋃(i : fin k), left_coset (γ i) H),

  --G is finite, so exists g₁, g₂, ..., gₖ s.t. g₁H, ..., gₖH partition G,
  --Then |G| = |g₁H| + |g₂H| + ... + |gₖH|
  --         = |H| + |H| + ... |H|
  --         = k|H|, k is number of distinct left cosets of H in H
  --Thus |H| divides |G| and the goal is fulfilled
  sorry,
end
</code></pre></div>
<p>I have an error in the hypothesis h₃, where I want to state that the union of all the subgroups make up the entire group, but I cannot use equality because there is a mismatch between set G and G itself. How can I get around this?</p>



<a name="246955743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/246955743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#246955743">(Jul 23 2021 at 09:11)</a>:</h4>
<p>Ignore the <code>let L</code> statement in the proof, have decided to create the union as a hypothesis in the beginning instead.</p>



<a name="246955976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/246955976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#246955976">(Jul 23 2021 at 09:14)</a>:</h4>
<p>Can you fix the first line of your code so that it says <code> ``` </code> and not <code> ```import tactic</code>? <code> ``` </code> has to be on its own line, otherwise it interprets <code>import tactic</code> as the language to use for highlighting</p>



<a name="246956133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/246956133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#246956133">(Jul 23 2021 at 09:16)</a>:</h4>
<blockquote>
<p>How can I get around this?</p>
</blockquote>
<p>The RHS should be <del><code>set.univ G</code></del> <strong><code>set.univ</code> </strong>, ie "the set of all elements in G"</p>



<a name="246956417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/246956417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#246956417">(Jul 23 2021 at 09:20)</a>:</h4>
<p>Ah I see, I remember reading that, thank you!</p>



<a name="246956720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/246956720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#246956720">(Jul 23 2021 at 09:24)</a>:</h4>
<p>I have another type mismatch between set.univ G being a Prop and returning true and needing a set G. I think I can find the fix for this though, no worries.</p>



<a name="246956821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/246956821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#246956821">(Jul 23 2021 at 09:25)</a>:</h4>
<p>Such as perhaps <code>(set.univ : set G)</code>.</p>



<a name="246956933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/246956933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#246956933">(Jul 23 2021 at 09:26)</a>:</h4>
<p>Yes, you're right: <a href="https://leanprover-community.github.io/mathlib_docs/find/set.univ">docs#set.univ</a></p>



<a name="246956957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/246956957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#246956957">(Jul 23 2021 at 09:27)</a>:</h4>
<p><code>set.univ</code> by itself should work, it can work out <code>set G</code> from the LHS</p>



<a name="247073322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247073322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247073322">(Jul 24 2021 at 12:53)</a>:</h4>
<p>Is there a way then to prove that <code>fintype.card G = fintype.card (set.univ : set G)</code>? Seems almost trivial to say the size of a finite group is the same size as the subgroup with all the elements of the group.</p>



<a name="247073425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247073425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247073425">(Jul 24 2021 at 12:55)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.fintype.card</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">fintype.card</span> <span class="n">G</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">library_search</span>
</code></pre></div>



<a name="247073586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247073586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247073586">(Jul 24 2021 at 12:59)</a>:</h4>
<p>PS I would write it the other way around -- the more complex statement on the left.</p>



<a name="247188812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247188812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247188812">(Jul 26 2021 at 11:09)</a>:</h4>
<p>When I end up with a goal like <code>fintype.card ↥H ∣ fintype.card ↥set.univ</code>, all I want to do is dismantle the coercions that are popping up. There was the other topic where someone unfolded the coercion, but what I'm getting from that doesn't feel like guidance I know how to use.<br>
<a href="/user_uploads/3121/RrxZ4MdsqNqbU0lMn5JgZzh1/image.png">image.png</a> <br>
I'll keep hacking away and maybe try another approach but have been stuck with these for a while.</p>
<div class="message_inline_image"><a href="/user_uploads/3121/RrxZ4MdsqNqbU0lMn5JgZzh1/image.png" title="image.png"><img src="/user_uploads/3121/RrxZ4MdsqNqbU0lMn5JgZzh1/image.png"></a></div>



<a name="247190201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247190201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247190201">(Jul 26 2021 at 11:28)</a>:</h4>
<p>can you post a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>? this seems like the canonical way to talk about the cardinality of a subgroup, unless maybe it's <code>finset.card (H : set G)</code></p>



<a name="247190221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247190221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247190221">(Jul 26 2021 at 11:28)</a>:</h4>
<p><del>there's also <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.card_univ">docs#finset.card_univ</a> to help you on the right</del></p>



<a name="247190704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247190704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247190704">(Jul 26 2021 at 11:35)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">group_theory.coset</span>
<span class="kn">import</span> <span class="n">data.fintype.basic</span>
<span class="kn">import</span> <span class="n">group_theory.order_of_element</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">H</span><span class="o">]</span>

<span class="kn">open</span> <span class="n">function</span>

<span class="kd">@[ext]</span> <span class="kd">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">Hnonempty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">C</span><span class="o">,</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span>
<span class="o">(</span><span class="n">Hcover</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">C</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">Hdisjoint</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">∈</span> <span class="n">C</span><span class="o">,</span> <span class="o">(</span><span class="n">X</span> <span class="bp">∩</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">lagrange</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">X</span><span class="o">,</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P.C</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">left_coset</span> <span class="n">g</span> <span class="n">H</span> <span class="o">)</span> <span class="o">:</span>
<span class="n">fintype.card</span> <span class="n">H</span> <span class="bp">∣</span> <span class="n">fintype.card</span> <span class="n">G</span> <span class="o">:=</span> <span class="c1">--the size of the subgroup H divides the size of the group G</span>
<span class="kd">begin</span>
  <span class="n">exact</span> <span class="n">card_subgroup_dvd_card</span> <span class="n">H</span><span class="o">,</span>
<span class="kd">end</span>
<span class="c1">--lmao I don't need any of</span>
<span class="c1">--`(P : partition G) (h: ∀ X, X ∈ P.C → ∃ (g : G), X = left_coset g H )`</span>
<span class="c1">--this is very annoying</span>

<span class="kd">lemma</span> <span class="n">lagrange_long</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">X</span><span class="o">,</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P.C</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">left_coset</span> <span class="n">g</span> <span class="n">H</span><span class="o">)</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">G</span><span class="o">}</span>
<span class="o">{</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">γ</span><span class="o">}</span>
<span class="o">{</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span> <span class="bp">≠</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">j</span><span class="o">)</span> <span class="n">H</span><span class="o">}</span>
<span class="o">{</span><span class="n">h₃</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)}:</span>
<span class="n">fintype.card</span> <span class="n">H</span> <span class="bp">∣</span> <span class="n">fintype.card</span> <span class="n">G</span> <span class="o">:=</span> <span class="c1">--the size of the subgroup H divides the size of the group G</span>
<span class="kd">begin</span>
  <span class="c1">--partition G into left cosets of H `done`</span>

  <span class="c1">--G is finite, so exists g₁, g₂, ..., gₖ s.t. g₁H, ..., gₖH partition G `done?`</span>

  <span class="k">have</span> <span class="n">h₄</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">G</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">fintype.of_equiv_card</span> <span class="o">(</span><span class="n">equiv.set.univ</span> <span class="n">G</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">h₄</span><span class="o">,</span>


  <span class="c1">--Then |G| = |g₁H| + |g₂H| + ... + |gₖH|</span>
  <span class="c1">--         = |H| + |H| + ... |H|</span>
  <span class="c1">--         = k|H|, k is number of distinct left cosets of H in H</span>
  <span class="c1">--Thus |H| divides |G| and the goal is fulfilled</span>
<span class="kd">end</span>
</code></pre></div>



<a name="247190817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247190817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247190817">(Jul 26 2021 at 11:36)</a>:</h4>
<p>My next goal was to have <code>fintype.card G</code> to be equal to <code>fintype.card</code> of the union of the left cosets, and see if I could then split that up into a sum since the cosets are disjoint and there are a finite number of cosets.</p>



<a name="247190837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247190837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247190837">(Jul 26 2021 at 11:36)</a>:</h4>
<p>Although I'm not convinced I've found something in mathlib yet that I could use as a finite sum.</p>



<a name="247191038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247191038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247191038">(Jul 26 2021 at 11:39)</a>:</h4>
<blockquote>
<p>My next goal was to ....</p>
</blockquote>
<p>Can you state this goal as a <code>have</code>?</p>



<a name="247191197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247191197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247191197">(Jul 26 2021 at 11:41)</a>:</h4>
<p>I gave that an attempt, but it I was a bit stuck using any hypotheses to rw and I don't think library_search yielded a result.</p>



<a name="247191257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247191257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247191257">(Jul 26 2021 at 11:42)</a>:</h4>
<p>Ideally I would now be able to use h₃ to rewrite and achieve the goal I said but there is the difference of the coercion.</p>



<a name="247194009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247194009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247194009">(Jul 26 2021 at 12:15)</a>:</h4>
<p>Do you understand the difference between a type and a term? Do you understand the difference between fintype and finset? Do you understand the difference between fintype.card and finset.card?</p>



<a name="247194122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247194122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247194122">(Jul 26 2021 at 12:17)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.card_coe">docs#fintype.card_coe</a></p>



<a name="247194308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247194308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247194308">(Jul 26 2021 at 12:19)</a>:</h4>
<p>Do you have a lemma that the cardinality of left cosets is the same? Do you know of a lemma that says that the cardinality of a bUnion of disjoint finsets is the sum of their cardinalities?</p>



<a name="247199739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247199739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247199739">(Jul 26 2021 at 13:12)</a>:</h4>
<p>The difference is not just the coercion, one is about set.univ while the other is about finset.univ</p>



<a name="247200477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247200477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247200477">(Jul 26 2021 at 13:19)</a>:</h4>
<p>I mean, do we actually have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">G</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">exact</span> <span class="n">fintype.of_equiv_card</span> <span class="o">(</span><span class="n">equiv.set.univ</span> <span class="n">G</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
<span class="kd">end</span>
</code></pre></div>
<p>? this is <code>library_search</code>'s  best effort</p>



<a name="247201630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247201630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247201630">(Jul 26 2021 at 13:27)</a>:</h4>
<p>Note that in the mwe we just used that lemma to introduce the coercion in the first place</p>



<a name="247201666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247201666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247201666">(Jul 26 2021 at 13:27)</a>:</h4>
<p>But that's probably a fine simp lemma to add</p>



<a name="247446120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247446120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247446120">(Jul 28 2021 at 11:17)</a>:</h4>
<p>Hello again.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">group_theory.coset</span>
<span class="kn">import</span> <span class="n">data.set.basic</span>
<span class="kn">import</span> <span class="n">group_theory.order_of_element</span>
<span class="kn">import</span> <span class="n">data.equiv.basic</span>
<span class="kn">import</span> <span class="n">data.fintype.basic</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">H</span><span class="o">]</span>

<span class="kn">open</span> <span class="n">function</span>

<span class="kd">@[ext]</span> <span class="kd">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">Hnonempty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">C</span><span class="o">,</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span>
<span class="o">(</span><span class="n">Hcover</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">C</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">Hdisjoint</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">∈</span> <span class="n">C</span><span class="o">,</span> <span class="o">(</span><span class="n">X</span> <span class="bp">∩</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">lagrange</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">X</span><span class="o">,</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P.C</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">left_coset</span> <span class="n">g</span> <span class="n">H</span> <span class="o">)</span> <span class="o">:</span>
<span class="n">fintype.card</span> <span class="n">H</span> <span class="bp">∣</span> <span class="n">fintype.card</span> <span class="n">G</span> <span class="o">:=</span> <span class="c1">--the size of the subgroup H divides the size of the group G</span>
<span class="kd">begin</span>
  <span class="n">exact</span> <span class="n">card_subgroup_dvd_card</span> <span class="n">H</span><span class="o">,</span>
<span class="kd">end</span>
<span class="c1">--lmao I don't need any of</span>
<span class="c1">--`(P : partition G) (h: ∀ X, X ∈ P.C → ∃ (g : G), X = left_coset g H )`</span>
<span class="c1">--this is very annoying</span>

<span class="k">#check</span> <span class="n">quotient_group.left_rel</span> <span class="n">H</span>
<span class="c1">-- `The equivalence relation corresponding to the partition of a group by left cosets of a subgroup.`</span>





<span class="kd">lemma</span> <span class="n">lagrange_long</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">H</span><span class="o">]</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">X</span><span class="o">,</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P.C</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">left_coset</span> <span class="n">g</span> <span class="n">H</span><span class="o">)</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">G</span><span class="o">}</span>
<span class="o">{</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span> <span class="bp">≠</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">j</span><span class="o">)</span> <span class="n">H</span><span class="o">}</span>
<span class="o">{</span><span class="n">h₃</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="n">set.univ</span><span class="o">}:</span>
<span class="n">fintype.card</span> <span class="n">H</span> <span class="bp">∣</span> <span class="n">fintype.card</span> <span class="n">G</span> <span class="o">:=</span> <span class="c1">--the size of the subgroup H divides the size of the group G</span>
<span class="kd">begin</span>
  <span class="c1">--partition G into left cosets of H `done`</span>

  <span class="c1">--G is finite, so exists g₁, g₂, ..., gₖ s.t. g₁H, ..., gₖH partition G `done?`</span>

  <span class="k">have</span> <span class="n">h₄</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="n">set.univ</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">G</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">fintype.of_equiv_card</span> <span class="o">(</span><span class="n">equiv.set.univ</span> <span class="n">G</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">h₄</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">P</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">dvd_of_mul_left_eq</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">k</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₁</span> <span class="o">:</span> <span class="n">coe_sort</span> <span class="n">set.univ</span> <span class="bp">=</span> <span class="n">coe_sort</span> <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">congr_arg</span> <span class="n">coe_sort</span> <span class="n">h₃.symm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="c1">--rw ← h₃,</span>

  <span class="c1">-- I am going to need a lemma here to say the finite union of disjoint sets</span>
  <span class="c1">-- has the same size as the sum of the sizes of each set</span>

  <span class="c1">-- also, is there a way for me to use the left_cosets to make the partition</span>
  <span class="c1">-- instead of saying there is a partition and stating that each block</span>
  <span class="c1">-- is equal to some left</span>


  <span class="c">/-</span><span class="cm">have : {R // equivalence R} ≃ partition G,</span>
<span class="cm">  exact i_need_this G (left_coset_equiv set.univ),-/</span>



  <span class="c1">--have : equivalence (left_coset_equiv set.univ) ≃ partition G,</span>
  <span class="c1">--have h₅ : fintype.card (⋃(i : fin k), left_coset (γ i) H) = fintype.card set.univ,</span>

  <span class="c1">--Then |G| = |g₁H| + |g₂H| + ... + |gₖH|</span>
  <span class="c1">--         = |H| + |H| + ... |H|</span>
  <span class="c1">--         = k|H|, k is number of distinct left cosets of H in H</span>
  <span class="c1">--Thus |H| divides |G| and the goal is fulfilled</span>
<span class="kd">end</span>










<span class="kd">lemma</span> <span class="n">lagrange_long2</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">H</span><span class="o">]</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">lft_cos_prtn</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">=</span> <span class="n">quotient_group.left_rel</span> <span class="n">H</span><span class="o">){</span> <span class="n">γ</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">G</span><span class="o">}</span>
<span class="o">{</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span> <span class="bp">≠</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">j</span><span class="o">)</span> <span class="n">H</span><span class="o">}</span>
<span class="o">{</span><span class="n">h₃</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="n">set.univ</span><span class="o">}:</span>
<span class="n">fintype.card</span> <span class="n">H</span> <span class="bp">∣</span> <span class="n">fintype.card</span> <span class="n">G</span> <span class="o">:=</span> <span class="c1">--the size of the subgroup H divides the size of the group G</span>
<span class="kd">begin</span>
  <span class="c1">--partition G into left cosets of H `done`</span>

  <span class="c1">--G is finite, so exists g₁, g₂, ..., gₖ s.t. g₁H, ..., gₖH partition G `done?`</span>

  <span class="k">have</span> <span class="n">h₄</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="n">set.univ</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">G</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">fintype.of_equiv_card</span> <span class="o">(</span><span class="n">equiv.set.univ</span> <span class="n">G</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">h₄</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">dvd_of_mul_left_eq</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">k</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₁</span> <span class="o">:</span> <span class="n">coe_sort</span> <span class="n">set.univ</span> <span class="bp">=</span> <span class="n">coe_sort</span> <span class="o">(</span><span class="bp">⋃</span><span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="n">H</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">congr_arg</span> <span class="n">coe_sort</span> <span class="n">h₃.symm</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">quotient_group.left_rel</span> <span class="n">at</span> <span class="n">lft_cos_prtn</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
  <span class="c1">--rw ← h₃,</span>

  <span class="c1">-- I am going to need a lemma here to say the finite union of disjoint sets</span>
  <span class="c1">-- has the same size as the sum of the sizes of each set</span>

  <span class="c1">-- also, is there a way for me to use the left_cosets to make the partition</span>
  <span class="c1">-- instead of saying there is a partition and stating that each block</span>
  <span class="c1">-- is equal to some left</span>


  <span class="c">/-</span><span class="cm">have : {R // equivalence R} ≃ partition G,</span>
<span class="cm">  exact i_need_this G (left_coset_equiv set.univ),-/</span>



  <span class="c1">--have : equivalence (left_coset_equiv set.univ) ≃ partition G,</span>
  <span class="c1">--have h₅ : fintype.card (⋃(i : fin k), left_coset (γ i) H) = fintype.card set.univ,</span>

  <span class="c1">--Then |G| = |g₁H| + |g₂H| + ... + |gₖH|</span>
  <span class="c1">--         = |H| + |H| + ... |H|</span>
  <span class="c1">--         = k|H|, k is number of distinct left cosets of H in H</span>
  <span class="c1">--Thus |H| divides |G| and the goal is fulfilled</span>
<span class="kd">end</span>
</code></pre></div>
<p>In <code>lagrange_long</code>, I am pushing forward with saying there is a partition and giving the partition a property, and I've added an extra hypothesis with a <code>coe_sort</code>, but am unable to use <code>rw h₁</code>. Does coe_sort send to different places? I'm rereading Yakov Pechersky's comment a lot to look for a better understanding, and am looking to understand the error I see. Is this just not a road I can travel down?</p>



<a name="247446217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247446217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247446217">(Jul 28 2021 at 11:18)</a>:</h4>
<p>Can you show the goal state and error message where <code>rw h₁</code> fails?</p>



<a name="247446857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247446857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247446857">(Jul 28 2021 at 11:26)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rewrite</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">motive</span> <span class="n">is</span> <span class="n">not</span> <span class="n">type</span> <span class="n">correct</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">_a</span> <span class="o">:</span> <span class="n">has_coe_to_sort.S</span> <span class="o">(</span><span class="n">set</span> <span class="n">G</span><span class="o">)),</span>
    <span class="n">k</span> <span class="bp">*</span> <span class="n">fintype.card</span> <span class="bp">↥</span><span class="n">H</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="bp">↥</span><span class="n">set.univ</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span> <span class="bp">*</span> <span class="n">fintype.card</span> <span class="bp">↥</span><span class="n">H</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">_a</span><span class="o">)</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">G</span><span class="o">,</span>
<span class="n">_inst_2</span> <span class="o">:</span> <span class="n">group</span> <span class="n">G</span><span class="o">,</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">,</span>
<span class="n">_inst_3</span> <span class="n">_inst_4</span> <span class="o">:</span> <span class="n">fintype</span> <span class="bp">↥</span><span class="n">H</span><span class="o">,</span>
<span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">γ</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">G</span><span class="o">,</span>
<span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↑</span><span class="n">H</span> <span class="bp">≠</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">j</span><span class="o">)</span> <span class="bp">↑</span><span class="n">H</span><span class="o">,</span>
<span class="n">h₃</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↑</span><span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="n">set.univ</span><span class="o">,</span>
<span class="n">h₄</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="bp">↥</span><span class="n">set.univ</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">G</span><span class="o">,</span>
<span class="n">P_C</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">G</span><span class="o">),</span>
<span class="n">P_Hnonempty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">),</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P_C</span> <span class="bp">→</span> <span class="n">X.nonempty</span><span class="o">,</span>
<span class="n">P_Hcover</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P_C</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">X</span><span class="o">,</span>
<span class="n">P_Hdisjoint</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">),</span> <span class="n">X</span> <span class="bp">∈</span> <span class="n">P_C</span> <span class="bp">→</span> <span class="n">Y</span> <span class="bp">∈</span> <span class="n">P_C</span> <span class="bp">→</span> <span class="o">(</span><span class="n">X</span> <span class="bp">∩</span> <span class="n">Y</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">),</span>
    <span class="n">X</span> <span class="bp">∈</span> <span class="o">{</span><span class="n">C</span> <span class="o">:=</span> <span class="n">P_C</span><span class="o">,</span> <span class="n">Hnonempty</span> <span class="o">:=</span> <span class="n">P_Hnonempty</span><span class="o">,</span> <span class="n">Hcover</span> <span class="o">:=</span> <span class="n">P_Hcover</span><span class="o">,</span> <span class="n">Hdisjoint</span> <span class="o">:=</span> <span class="n">P_Hdisjoint</span><span class="o">}</span><span class="bp">.</span><span class="n">C</span> <span class="bp">→</span>
    <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">left_coset</span> <span class="n">g</span> <span class="bp">↑</span><span class="n">H</span><span class="o">),</span>
<span class="n">h₁</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">set.univ</span> <span class="bp">=</span> <span class="bp">↥⋃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↑</span><span class="n">H</span>
<span class="bp">⊢</span> <span class="n">k</span> <span class="bp">*</span> <span class="n">fintype.card</span> <span class="bp">↥</span><span class="n">H</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="bp">↥</span><span class="n">set.univ</span>
</code></pre></div>



<a name="247446918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247446918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247446918">(Jul 28 2021 at 11:27)</a>:</h4>
<p>It's likely that the two <code>set.univ</code>s refer to different types - both <code>(set.univ : set nat)</code> and <code>(set.univ : set unit)</code> will show as the same in the goal view. If you hover over them in the goal view, it will tell you which <code>set.univ</code> is being used.</p>



<a name="247447029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247447029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247447029">(Jul 28 2021 at 11:28)</a>:</h4>
<p>Using <code>simp_rw</code> may also solve the problem</p>



<a name="247453479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247453479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247453479">(Jul 28 2021 at 12:47)</a>:</h4>
<p>Btw, your assumptions are inconsistent:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">have</span> <span class="o">:</span> <span class="n">false</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="n">rfl</span><span class="bp">|</span><span class="n">this</span> <span class="o">:=</span> <span class="n">nat.eq_zero_or_pos</span> <span class="n">k</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">haveI</span> <span class="o">:</span> <span class="n">is_empty</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="n">fin.is_empty</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">0</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↑</span><span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">∅</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="n">set.ext_iff</span><span class="o">,</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">not_exists</span><span class="o">,</span> <span class="n">set.mem_empty_eq</span><span class="o">,</span> <span class="n">set.mem_Union</span><span class="o">,</span> <span class="n">iff_false</span><span class="o">],</span>
        <span class="n">intros</span> <span class="n">x</span> <span class="n">i</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">fin.is_empty.elim</span> <span class="n">i</span> <span class="o">},</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">]</span> <span class="n">at</span> <span class="n">h₃</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:</span> <span class="n">is_empty</span> <span class="n">G</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">finset.univ_eq_empty'</span><span class="o">,</span> <span class="n">finset.univ_eq_empty</span><span class="o">,</span> <span class="bp">←</span><span class="n">set.univ_eq_empty_iff</span><span class="o">,</span> <span class="n">h₃</span><span class="o">],</span> <span class="o">},</span>
      <span class="n">exact</span> <span class="n">this.elim'</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">h₂</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">this</span><span class="o">⟩</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">this</span><span class="o">⟩</span> <span class="o">}</span> <span class="o">},</span>
</code></pre></div>



<a name="247453892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247453892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247453892">(Jul 28 2021 at 12:51)</a>:</h4>
<p>I assume h₂ should have an <code>i ≠ j</code> in it?</p>



<a name="247456068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247456068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247456068">(Jul 28 2021 at 13:10)</a>:</h4>
<p>Probably better stated as injectivity of the fun i, left_coset (gamma i) H</p>



<a name="247458816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247458816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247458816">(Jul 28 2021 at 13:32)</a>:</h4>
<p>Ah, that's a shame, did originally have <code>{h₁ : injective γ}</code> but removed it in case it was superfluous information, was going to look into readding it once I needed it.<br>
Have also addressed <code>{h₂ : ∀ (i j : fin k), i ≠ j → left_coset (γ i) H ≠ left_coset (γ j) H}</code>, I think that is better.<br>
I will look at <br>
<span class="user-mention silent" data-user-id="307953">Ruben Van de Velde</span> <a href="#narrow/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group/near/247453479">said</a>:</p>
<blockquote>
<p>Btw, your assumptions are inconsistent:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">have</span> <span class="o">:</span> <span class="n">false</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="n">rfl</span><span class="bp">|</span><span class="n">this</span> <span class="o">:=</span> <span class="n">nat.eq_zero_or_pos</span> <span class="n">k</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">haveI</span> <span class="o">:</span> <span class="n">is_empty</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="n">fin.is_empty</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">0</span><span class="o">),</span> <span class="n">left_coset</span> <span class="o">(</span><span class="n">γ</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↑</span><span class="n">H</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">∅</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="n">set.ext_iff</span><span class="o">,</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">not_exists</span><span class="o">,</span> <span class="n">set.mem_empty_eq</span><span class="o">,</span> <span class="n">set.mem_Union</span><span class="o">,</span> <span class="n">iff_false</span><span class="o">],</span>
        <span class="n">intros</span> <span class="n">x</span> <span class="n">i</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">fin.is_empty.elim</span> <span class="n">i</span> <span class="o">},</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">]</span> <span class="n">at</span> <span class="n">h₃</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:</span> <span class="n">is_empty</span> <span class="n">G</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">finset.univ_eq_empty'</span><span class="o">,</span> <span class="n">finset.univ_eq_empty</span><span class="o">,</span> <span class="bp">←</span><span class="n">set.univ_eq_empty_iff</span><span class="o">,</span> <span class="n">h₃</span><span class="o">],</span> <span class="o">},</span>
      <span class="n">exact</span> <span class="n">this.elim'</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">h₂</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">this</span><span class="o">⟩</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">this</span><span class="o">⟩</span> <span class="o">}</span> <span class="o">},</span>
</code></pre></div><br>
</p>
</blockquote>
<p>to see if there is another thing that does not work here.</p>
<p>I am considering working backwards from the proof of lagrange's theorem in mathlib and seeing what it is made out of.</p>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group/near/247446918">said</a>:</p>
<blockquote>
<p>It's likely that the two <code>set.univ</code>s refer to different types - both <code>(set.univ : set nat)</code> and <code>(set.univ : set unit)</code> will show as the same in the goal view. If you hover over them in the goal view, it will tell you which <code>set.univ</code> is being used.</p>
</blockquote>
<p>I have no idea why, but I do not get any information when I hover in the infoview.</p>



<a name="247458957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247458957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247458957">(Jul 28 2021 at 13:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group/near/247456068">said</a>:</p>
<blockquote>
<p>Probably better stated as injectivity of the fun i, left_coset (gamma i) H</p>
</blockquote>
<p>This function you mean is <code>{γ : fin k → G}</code>, correct?</p>



<a name="247459520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247459520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247459520">(Jul 28 2021 at 13:37)</a>:</h4>
<p>No, the function Yakov means is the one they stated,. Yakov is suggesting<code>h₂ : function.injective (λ i, left_coset (γ i) H)</code>, which is easier to work with than your corrected <code>h₂</code> but otherwise equivalent.</p>



<a name="247464525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/union%20of%20subgroups%20is%20the%20group/near/247464525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Laraia <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/union.20of.20subgroups.20is.20the.20group.html#247464525">(Jul 28 2021 at 14:15)</a>:</h4>
<p>Ah I understand. Thank you!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
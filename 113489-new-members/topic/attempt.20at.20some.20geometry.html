---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/attempt.20at.20some.20geometry.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html">attempt at some geometry</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="185127850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185127850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Earnshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185127850">(Jan 08 2020 at 16:08)</a>:</h4>
<p>as an exercise I wanted to try proving some theorems from Artin's <em>Geometric Algebra</em>, but I quickly hit a wall -- maybe due to being weak on the basics, maybe due to infelicitous transcription of the axioms. here is what I have so far, but as you can see I did not make much progress on the first lemma, just unsure how to proceed! apologies for the very vague 'question' but any tips or pointers would be appreciated.</p>
<div class="codehilite"><pre><span></span>-- constants of types subsume the usual statement of a theory&#39;s signature and axioms
constants Pt Ln : Sort
constant belongs : Pt → Ln → Prop
constant parallel : Ln → Ln → Prop

-- Artin def 2.1: can and ought we to formulate this as a term of type parallel l₁ l₂? this should be a definition not an axiom - is &#39;constant&#39; appropriate?
constant eq_or_no_common_pt_implies_parallel (l₁ l₂ : Ln) : (l₁ = l₂ ∨ ¬∃ p : Pt, belongs p l₁ ∧ belongs p l₂) → parallel l₁ l₂

-- Artin axiom 1: distinct points determine unique line
constant unique_ln_bw_two_pts (p₁ p₂ : Pt) : (p₁ ≠ p₂) → ∃ p₁p₂ : Ln, belongs p₁ p₁p₂ ∧ belongs p₂ p₁p₂ ∧ (∀ l : Ln, belongs p₁ l ∧ belongs p₂ l → p₁p₂ = l)
-- Artin axiom 2: exists unique parallel
constant exists_parallel (p : Pt) (l : Ln) : (∃ l₁ : Ln, parallel l l₁ ∧ belongs p l₁)
constant unique_parallel (p : Pt) (l l₁ l₂ : Ln) : (parallel l l₁ ∧ parallel l l₂ ∧ belongs p l₁ ∧ belongs p l₁) → l₁ = l₂

lemma line_parallel_to_itself (l : Ln) : reflexive parallel :=
begin
  have h₁ := eq_or_no_common_pt_implies_parallel l l,
  have h₂ := eq.refl l,
  sorry
end

theorem parallel_is_equivalence : equivalence parallel :=
begin
  -- split,
  -- exact line_parallel_to_itself,
end
</pre></div>



<a name="185128089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185128089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185128089">(Jan 08 2020 at 16:10)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">line_parallel_to_itself</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">:</span> <span class="n">reflexive</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">l</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">eq_or_no_common_pt_implies_parallel</span><span class="o">,</span>
  <span class="n">left</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>



<a name="185128158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185128158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185128158">(Jan 08 2020 at 16:11)</a>:</h4>
<p><span class="user-mention" data-user-id="247064">@Matt Earnshaw</span> In general people tend to avoid <code>constant</code> completely, except for little demo purposes.</p>



<a name="185128171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185128171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185128171">(Jan 08 2020 at 16:11)</a>:</h4>
<p>[note that I have proved it like a computer scientist -- I wrote the proof backwards]</p>



<a name="185128333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185128333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185128333">(Jan 08 2020 at 16:12)</a>:</h4>
<p>But for testing things out, it's fine. And in that cases your "axioms" should also be encoded as <code>constant</code>s</p>



<a name="185128416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185128416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185128416">(Jan 08 2020 at 16:14)</a>:</h4>
<p>A different option would be to turn all your <code>constant</code>s into <code>variable</code>s, and maybe make some of them <em>implicit</em> (using <code>{}</code>)</p>



<a name="185128520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185128520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185128520">(Jan 08 2020 at 16:14)</a>:</h4>
<p>In the end, if you move away from <code>constant</code>, your best bet would be to bundle all your data and axioms into a <code>structure</code></p>



<a name="185128684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185128684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185128684">(Jan 08 2020 at 16:16)</a>:</h4>
<p><span class="user-mention" data-user-id="247064">@Matt Earnshaw</span> You have a typo in the <code>unique_parallel</code> axiom. You ask that <code>l1</code> is parallel to <code>l</code> twice.</p>



<a name="185128712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185128712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185128712">(Jan 08 2020 at 16:16)</a>:</h4>
<p>Also, can't you just ask that <code>l1</code> is parallel to <code>l2</code>, and leave <code>l</code> completely out of the picture?</p>



<a name="185128876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185128876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185128876">(Jan 08 2020 at 16:18)</a>:</h4>
<p>Another remark: usually it's better to not use <code>\and</code> in assumptions, but to just state the clauses as separate assumptions. That makes it easier to use the lemma/axiom</p>



<a name="185135377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185135377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Earnshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185135377">(Jan 08 2020 at 17:22)</a>:</h4>
<p>thanks both, this is very helpful already. now I am trying to make headway on the symmetry part of the equivalence relation proof.  It seem necessary to introduce the converse <code>constant parallel_implies_eq_or_no_common_pt (l₁ l₂ : Ln) : parallel l₁ l₂ → (l₁ = l₂ ∨ ¬∃ p : Pt, belongs p l₁ ∧ belongs p l₂)</code> (which finally <em>defines</em> parallel). then</p>
<div class="codehilite"><pre><span></span>lemma symmetric_parallel : symmetric parallel :=
begin
  intros l₁ l₂ h,
  have x := (parallel_implies_eq_or_no_common_pt l₁ l₂) h,
  cases x,
  rw x,
  apply line_parallel_to_itself,
end
</pre></div>


<p>with context</p>
<div class="codehilite"><pre><span></span>l₁ l₂ : Ln,
h : parallel l₁ l₂,
x : ¬∃ (p : Pt), belongs p l₁ ∧ belongs p l₂
⊢ parallel l₂ l₁
</pre></div>


<p>now what I <em>want</em> to do is use <code>and.symm</code> to swap the terms in <code>x</code>, but am stuck there.</p>



<a name="185143048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185143048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185143048">(Jan 08 2020 at 18:41)</a>:</h4>
<p>I'm sure this can be golfed (note that I imported <code>logic.basic</code> (for <code>not_exists</code>) and <code>tactic.basic</code> (for <code>rintro</code>) from mathlib):</p>
<div class="codehilite"><pre><span></span><span class="kn">constant</span> <span class="n">parallel_implies_eq_or_no_common_pt</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">:</span> <span class="n">parallel</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="bp">→</span> <span class="o">(</span><span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span> <span class="bp">∨</span> <span class="bp">¬∃</span> <span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">,</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₂</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">symmetric_parallel</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">(</span><span class="n">parallel_implies_eq_or_no_common_pt</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">line_parallel_to_itself</span> <span class="n">l₂</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">eq_or_no_common_pt_implies_parallel</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">not_exists</span><span class="o">]</span> <span class="n">at</span> <span class="n">x</span> <span class="err">⊢</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="n">x&#39;</span> <span class="bp">⟨</span><span class="n">h₁</span><span class="o">,</span><span class="n">h₂</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">x</span> <span class="n">x&#39;</span> <span class="bp">⟨</span><span class="n">h₂</span><span class="o">,</span><span class="n">h₁</span><span class="bp">⟩</span><span class="o">,</span>  <span class="o">},</span>
<span class="kn">end</span>
</pre></div>



<a name="185145475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185145475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185145475">(Jan 08 2020 at 19:04)</a>:</h4>
<p><span class="user-mention" data-user-id="247064">@Matt Earnshaw</span> Shouldn't <code>parallel</code> actually be a definition, as in:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">parallel</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">¬∃</span> <span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">,</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₂</span><span class="o">)</span>
</pre></div>



<a name="185147046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185147046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Earnshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185147046">(Jan 08 2020 at 19:19)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> thanks that's helpful. think I have the transitivity proof down now</p>



<a name="185147126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185147126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Earnshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185147126">(Jan 08 2020 at 19:20)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> yes, it should be, thanks. makes things neater</p>



<a name="185148312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185148312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185148312">(Jan 08 2020 at 19:32)</a>:</h4>
<p><span class="user-mention" data-user-id="247064">@Matt Earnshaw</span> This is what I have atm:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="c1">-- constants of types subsume the usual statement of a theory&#39;s signature and axioms</span>
<span class="kn">constants</span> <span class="n">Pt</span> <span class="n">Ln</span> <span class="o">:</span> <span class="n">Sort</span>
<span class="kn">constant</span> <span class="n">belongs</span> <span class="o">:</span> <span class="n">Pt</span> <span class="bp">→</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="n">def</span> <span class="n">parallel</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">¬∃</span> <span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">,</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₂</span><span class="o">)</span>

<span class="c1">-- Artin axiom 1: distinct points determine unique line</span>
<span class="kn">constant</span> <span class="n">unique_ln_bw_two_pts</span> <span class="o">(</span><span class="n">p₁</span> <span class="n">p₂</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">p₁</span> <span class="bp">≠</span> <span class="n">p₂</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">p₁p₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">belongs</span> <span class="n">p₁</span> <span class="n">p₁p₂</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p₂</span> <span class="n">p₁p₂</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">l</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">belongs</span> <span class="n">p₁</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p₂</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">p₁p₂</span> <span class="bp">=</span> <span class="n">l</span><span class="o">)</span>
<span class="c1">-- Artin axiom 2: exists unique parallel</span>
<span class="kn">constant</span> <span class="n">exists_parallel</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">l₁</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">parallel</span> <span class="n">l</span> <span class="n">l₁</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span><span class="o">)</span>
<span class="kn">constant</span> <span class="n">unique_parallel</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">parallel</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">(</span><span class="n">hp₁</span> <span class="o">:</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span><span class="o">)</span> <span class="o">(</span><span class="n">hp₂</span> <span class="o">:</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span>

<span class="kn">lemma</span> <span class="n">parallel_refl</span> <span class="o">:</span> <span class="n">reflexive</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">l</span><span class="o">,</span>
  <span class="n">left</span><span class="o">,</span>
  <span class="n">refl</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">parallel_symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rintros</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|</span><span class="n">h</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">parallel_refl</span> <span class="bp">_</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span>
    <span class="n">contrapose</span><span class="bp">!</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">exists_imp_exists</span> <span class="bp">_</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">and</span><span class="bp">.</span><span class="n">symm</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">parallel_trans</span> <span class="o">:</span> <span class="n">transitive</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rintros</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|</span><span class="n">h₁₂</span><span class="o">)</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|</span><span class="n">h₂₃</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">parallel_refl</span> <span class="bp">_</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">parallel_is_equivalence</span> <span class="o">:</span> <span class="n">equivalence</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">parallel_refl</span><span class="o">,</span> <span class="n">parallel_symm</span><span class="o">,</span> <span class="n">parallel_trans</span><span class="bp">⟩</span>
</pre></div>



<a name="185148373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185148373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185148373">(Jan 08 2020 at 19:33)</a>:</h4>
<p>I'm using some tactics that aren't in core. But I think the help cutting through boilerplate.</p>



<a name="185148787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185148787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Earnshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185148787">(Jan 08 2020 at 19:37)</a>:</h4>
<p>that gives me <code>contrapose only applies to nondependent arrows between decidable props</code>, though I am satisfied with the following (but still good to see alternatives)</p>
<div class="codehilite"><pre><span></span>lemma parallel_symmetric : symmetric parallel :=
begin
  intros l₁ l₂ h,
  cases h,
  { rw h,
    left,
    refl },
  { right,
    exact h },
end
</pre></div>



<a name="185149058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185149058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185149058">(Jan 08 2020 at 19:40)</a>:</h4>
<p>Look at the other lines I added to the top</p>



<a name="185149078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185149078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185149078">(Jan 08 2020 at 19:41)</a>:</h4>
<p><code>noncomputable theory</code> and <code>open_locale classical</code></p>



<a name="185149205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185149205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185149205">(Jan 08 2020 at 19:42)</a>:</h4>
<p>How can <code>right, exact h</code> close that goal? You need to apply symmetry somewhere.</p>



<a name="185149309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185149309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Earnshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185149309">(Jan 08 2020 at 19:43)</a>:</h4>
<p>ah I see</p>



<a name="185149437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185149437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Earnshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185149437">(Jan 08 2020 at 19:45)</a>:</h4>
<p>hm, I suppose it's only working due to tactic magic - in which case I prefer yours</p>



<a name="185149727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185149727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185149727">(Jan 08 2020 at 19:48)</a>:</h4>
<p>But you are only using basic tactics, so there shouldn't be any magic at all.</p>



<a name="185149770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185149770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185149770">(Jan 08 2020 at 19:48)</a>:</h4>
<p>But I agree that lean seems to be happy with it</p>



<a name="185150120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185150120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185150120">(Jan 08 2020 at 19:53)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span> <span class="n">Q</span> <span class="bp">∧</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">h</span>
</pre></div>


<p>doesn't work. So I really don't get why your version does work. Maybe something with the existential, but it's still weird</p>



<a name="185150966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185150966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185150966">(Jan 08 2020 at 20:01)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">parallel_trans</span> <span class="o">:</span> <span class="n">transitive</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rintros</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|</span><span class="n">h₁₂</span><span class="o">)</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|</span><span class="n">h₂₃</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">parallel_refl</span> <span class="bp">_</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">by_cases</span> <span class="n">h₁₃</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₃</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">subst</span> <span class="n">h₁₃</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">parallel_refl</span> <span class="bp">_</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">right</span><span class="o">,</span>
      <span class="n">contrapose</span><span class="bp">!</span> <span class="n">h₁₃</span><span class="o">,</span>
      <span class="n">rcases</span> <span class="n">h₁₃</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp₁</span><span class="o">,</span> <span class="n">hp₂</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">unique_parallel</span> <span class="n">p</span> <span class="n">l₂</span><span class="o">,</span>
      <span class="n">all_goals</span>
      <span class="o">{</span> <span class="n">try</span> <span class="o">{</span><span class="n">right</span><span class="o">},</span> <span class="n">assumption</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>The last line of the proof abuses the weird behaviour that I don't understand</p>



<a name="185152739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185152739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185152739">(Jan 08 2020 at 20:21)</a>:</h4>
<blockquote>
<p>that gives me <code>contrapose only applies to nondependent arrows between decidable props</code>, though I am satisfied with the following (but still good to see alternatives)</p>
</blockquote>
<p>lemma parallel_symmetric : symmetric parallel :=<br>
begin<br>
  intros l₁ l₂ h,<br>
  cases h,<br>
  { rw h,<br>
    left,<br>
    refl },<br>
  { right,<br>
    exact h },<br>
end</p>
<div class="codehilite"><pre><span></span>
</pre></div>


<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Do you understand what's going on?</p>



<a name="185153554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185153554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185153554">(Jan 08 2020 at 20:31)</a>:</h4>
<p>oh wow, that was a real wtf</p>



<a name="185153582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185153582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185153582">(Jan 08 2020 at 20:31)</a>:</h4>
<p>the problem is</p>
<div class="codehilite"><pre><span></span><span class="kn">constants</span> <span class="n">Pt</span> <span class="n">Ln</span> <span class="o">:</span> <span class="n">Sort</span>
</pre></div>



<a name="185153595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185153595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185153595">(Jan 08 2020 at 20:31)</a>:</h4>
<p><code>Sort = Prop</code></p>



<a name="185153674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185153674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185153674">(Jan 08 2020 at 20:32)</a>:</h4>
<p>therefore <code>l₁</code> and <code>l₂</code> are two proofs of the proposition <code>Ln</code> and are hence equal by proof irrelevance</p>



<a name="185153876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185153876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185153876">(Jan 08 2020 at 20:34)</a>:</h4>
<p>Wow, indeed <code>#check Pt</code> gives <code>Pt : Prop</code>.</p>



<a name="185154571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185154571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185154571">(Jan 08 2020 at 20:42)</a>:</h4>
<p>Aha, that's sneaky</p>



<a name="185154767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185154767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185154767">(Jan 08 2020 at 20:45)</a>:</h4>
<p><span class="user-mention" data-user-id="247064">@Matt Earnshaw</span> The solution is to change <code>Sort</code> into <code>Type</code></p>



<a name="185155905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185155905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185155905">(Jan 08 2020 at 20:57)</a>:</h4>
<p>Or presumably a change to <code>Sort u</code> would also solve this.</p>



<a name="185156128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185156128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185156128">(Jan 08 2020 at 20:59)</a>:</h4>
<p>I would suggest <code>Type u</code> instead</p>



<a name="185156448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185156448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185156448">(Jan 08 2020 at 21:03)</a>:</h4>
<blockquote>
<p>Or presumably a change to <code>Sort u</code> would also solve this.</p>
</blockquote>
<p>That would still allow <code>Prop</code> if <code>u = 0</code></p>



<a name="185156629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185156629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185156629">(Jan 08 2020 at 21:05)</a>:</h4>
<p>Yes, but presumably the invalid proof still stops working...</p>



<a name="185157299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185157299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185157299">(Jan 08 2020 at 21:11)</a>:</h4>
<p>It will, but if you try to do any constructions they won't be able to live in the same universe <code>Sort u</code> in all likelihood, they will have to live in <code>Sort (max 1 u)</code> or similar and that will be inconvenient. (This is why most type constructors like <code>list</code> work on <code>Type u</code> instead of <code>Sort u</code>.)</p>



<a name="185160627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185160627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Earnshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185160627">(Jan 08 2020 at 21:48)</a>:</h4>
<p>aha</p>



<a name="185182091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185182091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185182091">(Jan 09 2020 at 04:10)</a>:</h4>
<p>Aside from the typo that Johan already pointed out, there's actually another issue with the type of <code>unique_parallel</code>: </p>
<div class="codehilite"><pre><span></span><span class="kn">constant</span> <span class="n">unique_parallel</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">parallel</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">(</span><span class="n">hp₁</span> <span class="o">:</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span><span class="o">)</span> <span class="o">(</span><span class="n">hp₂</span> <span class="o">:</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span>
</pre></div>


<p>This says that given a point <code>p</code>, two parallel lines <code>l₁</code> and <code>l₂</code> passing through <code>p</code> must be equal to each other. However, Artin phrased axiom 2 this way: "Given a point <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> and a line <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>, there exists one and only one line <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> lies on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> and such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∥</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">m\parallel l</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>." In particular, note that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> does not have to belong to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>. Here's a minimal fix:</p>
<div class="codehilite"><pre><span></span><span class="kn">constant</span> <span class="n">unique_parallel</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">parallel</span> <span class="n">l</span> <span class="n">l₁</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">parallel</span> <span class="n">l</span> <span class="n">l₂</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hp₁</span> <span class="o">:</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span><span class="o">)</span> <span class="o">(</span><span class="n">hp₂</span> <span class="o">:</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span>
</pre></div>


<p>Here's Johan's snippet updated with the <code>Type*</code> fix and the fix above, as well as a proof of <code>parallel_trans</code>. I also made a few parameters implicit with curly braces:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="c1">-- constants of types subsume the usual statement of a theory&#39;s signature and axioms</span>
<span class="kn">constants</span> <span class="n">Pt</span> <span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span>
<span class="kn">constant</span> <span class="n">belongs</span> <span class="o">:</span> <span class="n">Pt</span> <span class="bp">→</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="n">def</span> <span class="n">parallel</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">¬∃</span> <span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">,</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₂</span><span class="o">)</span>

<span class="c1">-- Artin axiom 1: distinct points determine unique line</span>
<span class="kn">constant</span> <span class="n">unique_ln_bw_two_pts</span> <span class="o">{</span><span class="n">p₁</span> <span class="n">p₂</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">p₁</span> <span class="bp">≠</span> <span class="n">p₂</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">p₁p₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">belongs</span> <span class="n">p₁</span> <span class="n">p₁p₂</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p₂</span> <span class="n">p₁p₂</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">l</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">belongs</span> <span class="n">p₁</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p₂</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">p₁p₂</span> <span class="bp">=</span> <span class="n">l</span><span class="o">)</span>
<span class="c1">-- Artin axiom 2: exists unique parallel</span>
<span class="kn">constant</span> <span class="n">exists_parallel</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">l₁</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">parallel</span> <span class="n">l</span> <span class="n">l₁</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span><span class="o">)</span>
<span class="kn">constant</span> <span class="n">unique_parallel</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">parallel</span> <span class="n">l</span> <span class="n">l₁</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">parallel</span> <span class="n">l</span> <span class="n">l₂</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hp₁</span> <span class="o">:</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span><span class="o">)</span> <span class="o">(</span><span class="n">hp₂</span> <span class="o">:</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span>

<span class="kn">lemma</span> <span class="n">parallel_refl</span> <span class="o">:</span> <span class="n">reflexive</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">l</span><span class="o">,</span>
  <span class="n">left</span><span class="o">,</span>
  <span class="n">refl</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">parallel_symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rintros</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|</span><span class="n">h</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">parallel_refl</span> <span class="bp">_</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span>
    <span class="n">contrapose</span><span class="bp">!</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">exists_imp_exists</span> <span class="bp">_</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">and</span><span class="bp">.</span><span class="n">symm</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">parallel_trans</span> <span class="o">:</span> <span class="n">transitive</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="n">h₁₂</span> <span class="n">h₂₃</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">H</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">p</span><span class="o">,</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₃</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">H</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">h₃</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₃</span> <span class="o">:=</span> <span class="n">unique_parallel</span> <span class="o">(</span><span class="n">parallel_symm</span> <span class="n">h₁₂</span><span class="o">)</span> <span class="n">h₂₃</span> <span class="n">h₁</span> <span class="n">h₃</span><span class="o">,</span>
    <span class="n">subst</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">parallel_refl</span> <span class="n">l₁</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">H</span><span class="o">,</span> <span class="o">},</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">parallel_is_equivalence</span> <span class="o">:</span> <span class="n">equivalence</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">parallel_refl</span><span class="o">,</span> <span class="n">parallel_symm</span><span class="o">,</span> <span class="n">parallel_trans</span><span class="bp">⟩</span>
</pre></div>



<a name="185182238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185182238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185182238">(Jan 09 2020 at 04:15)</a>:</h4>
<p>also I think all of these should be structure / class instead of constants</p>



<a name="185182310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185182310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185182310">(Jan 09 2020 at 04:17)</a>:</h4>
<p>How would you set it up?</p>



<a name="185188035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185188035">(Jan 09 2020 at 06:59)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="n">class</span> <span class="n">has_parallel</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">parallel</span> <span class="o">:</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kn">infix</span> <span class="bp">`</span> <span class="err">∥</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">has_parallel</span><span class="bp">.</span><span class="n">parallel</span>

<span class="n">class</span> <span class="n">pre_geometry</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">has_mem</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="bp">.</span>

<span class="kn">instance</span> <span class="n">pre_geometry</span><span class="bp">.</span><span class="n">has_parallel</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">pre_geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_parallel</span> <span class="n">Ln</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">L₁</span> <span class="n">L₂</span><span class="o">,</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">L₂</span> <span class="bp">∨</span> <span class="bp">¬∃</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₁</span> <span class="bp">∧</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₂</span><span class="bp">⟩</span>

<span class="n">class</span> <span class="n">geometry</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">pre_geometry</span> <span class="n">Pt</span> <span class="n">Ln</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_unique_ln_bw_two_pts</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p₁</span> <span class="n">p₂</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">},</span> <span class="n">p₁</span> <span class="bp">≠</span> <span class="n">p₂</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p₁</span> <span class="err">∈</span> <span class="n">L</span> <span class="bp">∧</span> <span class="n">p₂</span> <span class="err">∈</span> <span class="n">L</span><span class="o">)</span>
<span class="o">(</span><span class="n">exists_unique_parallel</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">),</span> <span class="bp">∃!</span> <span class="n">L&#39;</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L&#39;</span> <span class="bp">∧</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L&#39;</span><span class="o">)</span>

<span class="kn">section</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">pre_geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
<span class="n">include</span> <span class="n">Pt</span>

<span class="bp">@</span><span class="o">[</span><span class="n">refl</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">refl</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">:</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L</span> <span class="o">:=</span>
<span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">symm</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">symm</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₁</span> <span class="o">:=</span>
<span class="n">or</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">h</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="err">∘</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp1</span><span class="o">,</span> <span class="n">hp2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">h</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp2</span><span class="o">,</span> <span class="n">hp1</span><span class="bp">⟩</span>
<span class="kn">end</span>
</pre></div>



<a name="185188262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185188262">(Jan 09 2020 at 07:05)</a>:</h4>
<p>Nice (-;</p>



<a name="185188603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185188603">(Jan 09 2020 at 07:14)</a>:</h4>
<p>Kenny, I'm not sure if one can prove transitivity now</p>



<a name="185188608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185188608">(Jan 09 2020 at 07:14)</a>:</h4>
<p>It seems one needs the crazy version of unique parallel for that</p>



<a name="185188686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185188686">(Jan 09 2020 at 07:16)</a>:</h4>
<p>I haven't been following this discussion</p>



<a name="185188687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185188687">(Jan 09 2020 at 07:16)</a>:</h4>
<p>what are the axioms now?</p>



<a name="185188827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185188827">(Jan 09 2020 at 07:20)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> </p>
<div class="codehilite"><pre><span></span><span class="kn">constant</span> <span class="n">unique_parallel</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">parallel</span> <span class="n">l</span> <span class="n">l₁</span> <span class="bp">∧</span> <span class="n">parallel</span> <span class="n">l</span> <span class="n">l₂</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span><span class="o">)</span> <span class="bp">→</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span>
</pre></div>



<a name="185188830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185188830">(Jan 09 2020 at 07:20)</a>:</h4>
<p>I thought you could kick out the line <code>l</code>. But only once you know transivity...</p>



<a name="185188886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185188886">(Jan 09 2020 at 07:22)</a>:</h4>
<p>isn't that covered by my <code>exists_unique_parallel</code>?</p>



<a name="185188894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185188894">(Jan 09 2020 at 07:22)</a>:</h4>
<p>I didn't try too hard, but I couldn't write down a proof immediately</p>



<a name="185188997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185188997">(Jan 09 2020 at 07:24)</a>:</h4>
<p>isn't that what it says?</p>



<a name="185189069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185189069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185189069">(Jan 09 2020 at 07:26)</a>:</h4>
<p>I don't see how</p>



<a name="185189079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185189079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185189079">(Jan 09 2020 at 07:27)</a>:</h4>
<p>Sorry, I'm confused. I think I understand now</p>



<a name="185189379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185189379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185189379">(Jan 09 2020 at 07:35)</a>:</h4>
<p>/me should learn what <code>exists_unique</code> means</p>



<a name="185189391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185189391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185189391">(Jan 09 2020 at 07:35)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">section</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
<span class="n">include</span> <span class="n">Pt</span>

<span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">trans</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">L₃</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂₃</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₃</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₃</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">by_cases</span> <span class="n">h₁₃</span> <span class="o">:</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">L₃</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">left</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="n">rcases</span> <span class="n">h₁₂</span> <span class="k">with</span> <span class="n">rfl</span><span class="bp">|</span><span class="n">h₁₂</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="n">rcases</span> <span class="n">h₂₃</span> <span class="k">with</span> <span class="n">rfl</span><span class="bp">|</span><span class="n">h₂₃</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="n">right</span><span class="o">,</span> <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">H₁</span><span class="o">,</span> <span class="n">H₂</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h₁₃</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">geometry</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">p</span> <span class="n">L₂</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">H₁</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="bp">⟨</span><span class="n">H₂</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">symmetry</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
<span class="kn">end</span>

<span class="kn">end</span>
</pre></div>



<a name="185189694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185189694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185189694">(Jan 09 2020 at 07:43)</a>:</h4>
<p>yay</p>



<a name="185189741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185189741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185189741">(Jan 09 2020 at 07:44)</a>:</h4>
<p>Alternatively:</p>
<div class="codehilite"><pre><span></span><span class="kn">section</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
<span class="n">include</span> <span class="n">Pt</span>

<span class="bp">@</span><span class="o">[</span><span class="n">refl</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">refl</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">:</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L</span> <span class="o">:=</span>
<span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">symm</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">symm</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₁</span> <span class="o">:=</span>
<span class="n">or</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">h</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="err">∘</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp1</span><span class="o">,</span> <span class="n">hp2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">h</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp2</span><span class="o">,</span> <span class="n">hp1</span><span class="bp">⟩</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">trans</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">L₃</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂₃</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₃</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₃</span> <span class="o">:=</span> <span class="k">begin</span>
  <span class="n">by_cases</span> <span class="n">H</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₁</span> <span class="bp">∧</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₃</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">H</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">h₃</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">L₃</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span>
      <span class="n">rcases</span> <span class="n">geometry</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">p</span> <span class="n">L₂</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">L</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">hp</span><span class="o">,</span> <span class="n">hL</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">h</span><span class="err">ᵤ</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">hL₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">h</span><span class="err">ᵤ</span> <span class="n">L₁</span> <span class="bp">⟨</span><span class="n">h₁</span><span class="o">,</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">symm</span> <span class="n">Pt</span> <span class="n">Ln</span> <span class="n">h₁₂</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">hL₁₃</span> <span class="o">:</span> <span class="n">L₃</span> <span class="bp">=</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">h</span><span class="err">ᵤ</span> <span class="n">L₃</span> <span class="bp">⟨</span><span class="n">h₃</span><span class="o">,</span> <span class="n">h₂₃</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">hL₁₂</span><span class="o">,</span> <span class="n">hL₁₃</span><span class="o">],</span>
    <span class="o">},</span>
    <span class="n">subst</span> <span class="n">this</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H</span><span class="o">,</span> <span class="o">},</span>
<span class="kn">end</span>
</pre></div>



<a name="185190025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185190025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185190025">(Jan 09 2020 at 07:51)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">trans</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">L₃</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂₃</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₃</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₃</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">classical</span><span class="bp">.</span><span class="n">or_iff_not_imp_right</span><span class="bp">.</span><span class="n">mpr</span><span class="o">,</span> <span class="n">rw</span> <span class="n">not_not</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">H₁</span><span class="o">,</span> <span class="n">H₂</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">geometry</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">p</span> <span class="n">L₂</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">H₁</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="bp">⟨</span><span class="n">H₂</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">symmetry</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">assumption</span> <span class="o">},</span>
<span class="kn">end</span>
</pre></div>



<a name="185191352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185191352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185191352">(Jan 09 2020 at 08:17)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">trans</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">L₃</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂₃</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₃</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₃</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">),</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₁</span> <span class="bp">∧</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₃</span><span class="o">)</span> <span class="bp">→</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">L₃</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">classical</span><span class="bp">.</span><span class="n">or_iff_not_imp_right</span><span class="bp">.</span><span class="n">mpr</span><span class="o">,</span> <span class="n">rwa</span> <span class="n">not_not</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">H₁</span><span class="o">,</span> <span class="n">H₂</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">geometry</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">p</span> <span class="n">L₂</span><span class="o">)</span><span class="bp">;</span> <span class="n">finish</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>I wish there was a hammer that would kill the second line.</p>



<a name="185191530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185191530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185191530">(Jan 09 2020 at 08:21)</a>:</h4>
<p>The following script really captures the essentials of the proof, I think:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">jmc_wishes</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">L₃</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂₃</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₃</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₃</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">),</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₁</span> <span class="bp">∧</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₃</span><span class="o">)</span> <span class="bp">→</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">L₃</span><span class="o">,</span> <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">H₁</span><span class="o">,</span> <span class="n">H₂</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">L&#39;</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">),</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L&#39;</span> <span class="bp">∧</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L&#39;</span> <span class="o">:=</span> <span class="n">geometry</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">p</span> <span class="n">L₂</span><span class="o">,</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>The <code>sorry</code>s should be filled in with a 1-word hammer tactic.</p>



<a name="185191898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185191898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185191898">(Jan 09 2020 at 08:28)</a>:</h4>
<p>In honor of Kenny's term proofs of <code>refl</code> and <code>symm</code>, I present this monstrosity:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">trans_t</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">L₃</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂₃</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₃</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₃</span> <span class="o">:=</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">em</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₁</span> <span class="bp">∧</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₃</span><span class="o">))</span><span class="bp">.</span><span class="n">elim</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">h₃</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="err">$</span>
      <span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">geometry</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">p</span> <span class="n">L₂</span><span class="o">)</span>
        <span class="bp">⟨</span><span class="n">h₁</span><span class="o">,</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">symm</span> <span class="n">Pt</span> <span class="n">Ln</span> <span class="n">h₁₂</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">h₃</span><span class="o">,</span> <span class="n">h₂₃</span><span class="bp">⟩</span><span class="o">)</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span>
</pre></div>



<a name="185192158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185192158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185192158">(Jan 09 2020 at 08:32)</a>:</h4>
<p>I changed the definition of parallel:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="n">class</span> <span class="n">has_parallel</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">parallel</span> <span class="o">:</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kn">infix</span> <span class="bp">`</span> <span class="err">∥</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">has_parallel</span><span class="bp">.</span><span class="n">parallel</span>

<span class="n">class</span> <span class="n">pre_geometry</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">has_mem</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="bp">.</span>

<span class="kn">instance</span> <span class="n">pre_geometry</span><span class="bp">.</span><span class="n">has_parallel</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">pre_geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_parallel</span> <span class="n">Ln</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">L₁</span> <span class="n">L₂</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">),</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₁</span> <span class="bp">∧</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₂</span><span class="o">)</span> <span class="bp">→</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">L₂</span><span class="bp">⟩</span>

<span class="n">class</span> <span class="n">geometry</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">pre_geometry</span> <span class="n">Pt</span> <span class="n">Ln</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_unique_ln_bw_two_pts</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p₁</span> <span class="n">p₂</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">},</span> <span class="n">p₁</span> <span class="bp">≠</span> <span class="n">p₂</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p₁</span> <span class="err">∈</span> <span class="n">L</span> <span class="bp">∧</span> <span class="n">p₂</span> <span class="err">∈</span> <span class="n">L</span><span class="o">)</span>
<span class="o">(</span><span class="n">exists_unique_parallel</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">),</span> <span class="bp">∃!</span> <span class="n">L&#39;</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L&#39;</span> <span class="bp">∧</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L&#39;</span><span class="o">)</span>

<span class="kn">section</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">pre_geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
<span class="n">include</span> <span class="n">Pt</span>

<span class="bp">@</span><span class="o">[</span><span class="n">refl</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">refl</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">:</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">symm</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">symm</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₁</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="bp">⟩</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
<span class="kn">end</span>

<span class="kn">section</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
<span class="n">include</span> <span class="n">Pt</span>

<span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">trans</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">L₃</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂₃</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₃</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₃</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">H₁</span><span class="o">,</span> <span class="n">H₂</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">geometry</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">p</span> <span class="n">L₂</span><span class="o">),</span>
  <span class="n">all_goals</span> <span class="o">{</span> <span class="n">split</span><span class="bp">;</span> <span class="n">assumption</span> <span class="bp">&lt;|&gt;</span> <span class="n">symmetry</span><span class="bp">;</span> <span class="n">assumption</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">end</span>
</pre></div>



<a name="185192311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185192311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185192311">(Jan 09 2020 at 08:34)</a>:</h4>
<p>That lets you remove the <code>noncomputable theory</code> and <code>open_locale classical</code>.</p>



<a name="185192344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185192344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185192344">(Jan 09 2020 at 08:35)</a>:</h4>
<p>Ooh, maybe I should revert my change...</p>



<a name="185192881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185192881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185192881">(Jan 09 2020 at 08:43)</a>:</h4>
<p>Using namespaces:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="n">class</span> <span class="n">has_parallel</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">parallel</span> <span class="o">:</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kn">infix</span> <span class="bp">`</span> <span class="err">∥</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">has_parallel</span><span class="bp">.</span><span class="n">parallel</span>

<span class="n">class</span> <span class="n">pre_geometry</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">has_mem</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="bp">.</span>

<span class="kn">instance</span> <span class="n">pre_geometry</span><span class="bp">.</span><span class="n">has_parallel</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">pre_geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_parallel</span> <span class="n">Ln</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">L₁</span> <span class="n">L₂</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">),</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₁</span> <span class="bp">∧</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₂</span><span class="o">)</span> <span class="bp">→</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">L₂</span><span class="bp">⟩</span>

<span class="n">class</span> <span class="n">geometry</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">pre_geometry</span> <span class="n">Pt</span> <span class="n">Ln</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_unique_ln_bw_two_pts</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p₁</span> <span class="n">p₂</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">},</span> <span class="n">p₁</span> <span class="bp">≠</span> <span class="n">p₂</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p₁</span> <span class="err">∈</span> <span class="n">L</span> <span class="bp">∧</span> <span class="n">p₂</span> <span class="err">∈</span> <span class="n">L</span><span class="o">)</span>
<span class="o">(</span><span class="n">exists_unique_parallel</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">),</span> <span class="bp">∃!</span> <span class="n">L&#39;</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L&#39;</span> <span class="bp">∧</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L&#39;</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">has_parallel</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">pre_geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
<span class="n">include</span> <span class="n">Pt</span>

<span class="bp">@</span><span class="o">[</span><span class="n">refl</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">refl</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">:</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">symm</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">symm</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₁</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="bp">⟩</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>

<span class="kn">end</span> <span class="n">has_parallel</span>

<span class="kn">namespace</span> <span class="n">has_parallel</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
<span class="n">include</span> <span class="n">Pt</span>

<span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">trans</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">L₃</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂₃</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₃</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₃</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">H₁</span><span class="o">,</span> <span class="n">H₂</span><span class="bp">⟩</span><span class="o">,</span>
<span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">geometry</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">p</span> <span class="n">L₂</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">H₁</span><span class="o">,</span> <span class="n">h₁₂</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">H₂</span><span class="o">,</span> <span class="n">h₂₃</span><span class="bp">⟩</span>

<span class="kn">end</span> <span class="n">has_parallel</span>
</pre></div>



<a name="185193026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185193026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185193026">(Jan 09 2020 at 08:45)</a>:</h4>
<p>mario the linter says <code>pre_geometry.has_parallel</code> is bad</p>



<a name="185193062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185193062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185193062">(Jan 09 2020 at 08:45)</a>:</h4>
<p>Did I goof up?</p>



<a name="185193159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185193159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185193159">(Jan 09 2020 at 08:46)</a>:</h4>
<p>it's a bit tricky; you can't infer that instance because <code>Pt</code> is dangling</p>



<a name="185193197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185193197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185193197">(Jan 09 2020 at 08:47)</a>:</h4>
<p>I think you should bundle a geometry and extract <code>Pt</code> and <code>Ln</code> components</p>



<a name="185193209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185193209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185193209">(Jan 09 2020 at 08:47)</a>:</h4>
<p>Makes sense</p>



<a name="185194139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185194139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185194139">(Jan 09 2020 at 09:00)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Something like?</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">pre_geometry</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">[</span><span class="n">has_mem</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
</pre></div>



<a name="185194260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185194260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185194260">(Jan 09 2020 at 09:02)</a>:</h4>
<blockquote>
<p>it's a bit tricky; you can't infer that instance because <code>Pt</code> is dangling</p>
</blockquote>
<p>I was thinking of using <code>out_param</code></p>



<a name="185194741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185194741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185194741">(Jan 09 2020 at 09:11)</a>:</h4>
<p>I guess that for potential "applications" that might be better.</p>



<a name="185194796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185194796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185194796">(Jan 09 2020 at 09:12)</a>:</h4>
<p>I currently have:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="n">class</span> <span class="n">has_parallel</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">parallel</span> <span class="o">:</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kn">infix</span> <span class="bp">`</span> <span class="err">∥</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">has_parallel</span><span class="bp">.</span><span class="n">parallel</span>

<span class="kn">structure</span> <span class="n">pre_geometry</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">[</span><span class="n">has_mem</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>

<span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">pre_geometry</span><span class="bp">.</span><span class="n">has_mem</span>

<span class="kn">instance</span> <span class="n">pre_geometry</span><span class="bp">.</span><span class="n">has_parallel</span> <span class="o">{</span><span class="err">Ω</span> <span class="o">:</span> <span class="n">pre_geometry</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_parallel</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Ln</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">L₁</span> <span class="n">L₂</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Pt</span><span class="o">),</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₁</span> <span class="bp">∧</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₂</span><span class="o">)</span> <span class="bp">→</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">L₂</span><span class="bp">⟩</span>

<span class="n">class</span> <span class="n">geometry</span> <span class="kn">extends</span> <span class="n">pre_geometry</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_unique_ln_bw_two_pts</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p₁</span> <span class="n">p₂</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">},</span> <span class="n">p₁</span> <span class="bp">≠</span> <span class="n">p₂</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p₁</span> <span class="err">∈</span> <span class="n">L</span> <span class="bp">∧</span> <span class="n">p₂</span> <span class="err">∈</span> <span class="n">L</span><span class="o">)</span>
<span class="o">(</span><span class="n">exists_unique_parallel</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">),</span> <span class="bp">∃!</span> <span class="n">L&#39;</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L&#39;</span> <span class="bp">∧</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L&#39;</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">has_parallel</span>
<span class="kn">variables</span> <span class="o">{</span><span class="err">Ω</span> <span class="o">:</span> <span class="n">pre_geometry</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">refl</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">refl</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Ln</span><span class="o">}</span> <span class="o">:</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">symm</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">symm</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="o">:</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₁</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="bp">⟩</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>

<span class="kn">end</span> <span class="n">has_parallel</span>

<span class="kn">namespace</span> <span class="n">has_parallel</span>
<span class="kn">variables</span> <span class="o">{</span><span class="err">Ω</span> <span class="o">:</span> <span class="n">geometry</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">trans</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">L₃</span> <span class="o">:</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂₃</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₃</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₃</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">H₁</span><span class="o">,</span> <span class="n">H₂</span><span class="bp">⟩</span><span class="o">,</span>
<span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">geometry</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">p</span> <span class="n">L₂</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">H₁</span><span class="o">,</span> <span class="n">h₁₂</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">H₂</span><span class="o">,</span> <span class="n">h₂₃</span><span class="bp">⟩</span>

<span class="kn">end</span> <span class="n">has_parallel</span>
</pre></div>


<p>I don't really like the <code>Ω.Ln</code> etc...</p>



<a name="185195161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185195161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185195161">(Jan 09 2020 at 09:18)</a>:</h4>
<p>would <code>Ln Ω</code> make you feel better?</p>



<a name="185195214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185195214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185195214">(Jan 09 2020 at 09:19)</a>:</h4>
<p>Not that much ...</p>



<a name="185195297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185195297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185195297">(Jan 09 2020 at 09:20)</a>:</h4>
<p>Maybe <code>Ω</code> should be a parameter?</p>



<a name="185195632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185195632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185195632">(Jan 09 2020 at 09:25)</a>:</h4>
<p>maybe we should build an example</p>



<a name="185215812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185215812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Earnshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185215812">(Jan 09 2020 at 14:24)</a>:</h4>
<p>it's helpful to see experienced folk grappling with this. need to learn typeclasses and structures properly to totally get it but this is neat. -- <span class="user-mention" data-user-id="112680">@Johan Commelin</span> in your most recent version above is it possible to write down equivalence as a term of  type <code>equivalence ...</code>? (I tried like <code>equivalence parallel</code> in the has_parallel namespace but it seems not quite right)</p>



<a name="185218688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185218688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185218688">(Jan 09 2020 at 14:54)</a>:</h4>
<p><span class="user-mention" data-user-id="247064">@Matt Earnshaw</span> Voila:</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">has_parallel</span>
<span class="kn">open</span> <span class="n">parallel</span>
<span class="kn">variables</span> <span class="o">{</span><span class="err">Ω</span> <span class="o">:</span> <span class="n">geometry</span><span class="o">}</span>

<span class="kn">lemma</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">equivalence</span> <span class="o">:</span> <span class="n">equivalence</span> <span class="o">(</span><span class="n">infer_instance</span> <span class="o">:</span> <span class="n">has_parallel</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Ln</span><span class="o">)</span><span class="bp">.</span><span class="n">parallel</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">h₁</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h₂</span><span class="bp">⟩</span>

<span class="kn">end</span> <span class="n">has_parallel</span>
</pre></div>



<a name="185218793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185218793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185218793">(Jan 09 2020 at 14:55)</a>:</h4>
<p>Because I <code>open parallel</code>, I can just write <code>refl</code> instead of <code>parallel.refl</code> in the proof.</p>



<a name="185226097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185226097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Earnshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185226097">(Jan 09 2020 at 16:05)</a>:</h4>
<p>thanks. that starts to look a bit inelegant but i won't worry about it at this stage. trying to push on with Theorem 2.2 concerning pencils of parallel lines. as a test I tried the following:</p>
<div class="codehilite"><pre><span></span>def pencil (l : Ω.Ln) := {m : Ω.Ln | l ∥ m}

lemma pencil_of_line_contains_line (l : Ω.Ln) : l ∈ pencil l := parallel.refl
</pre></div>


<p>which works, but I don't really understand how lean figures out that <code>parallel.refl</code> is a term of <code>l ∈ pencil l</code> ?</p>



<a name="185226841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185226841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185226841">(Jan 09 2020 at 16:12)</a>:</h4>
<p><code>set Ln</code> is the type of predicates on <code>Ln</code>, i.e. functions from <code>Ln</code> to <code>Prop</code>. In particular <code>x ∈ { y | P }</code> means the same thing as <code>P x</code>. Thus <code>l ∈ pencil l</code> translates to <code>l ∥ l</code>.</p>
<p>(edit: I thought there was some discussion of this in TPiL or Logic &amp; Proof but I didn't see any. However, the start of <a href="https://github.com/leanprover-community/lean/blob/master/library/init/data/set.lean" target="_blank" title="https://github.com/leanprover-community/lean/blob/master/library/init/data/set.lean">init.logic</a> is fairly readable.)</p>



<a name="185227288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185227288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185227288">(Jan 09 2020 at 16:16)</a>:</h4>
<p><span class="user-mention" data-user-id="247064">@Matt Earnshaw</span> I should note that <code>equivalence</code> isn't used that much in mathlib. On the other hand, the three lemmas tagged with <code>@[refl]</code>, <code>@[symm]</code> and <code>@[trans]</code> are very useful.</p>



<a name="185227363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185227363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185227363">(Jan 09 2020 at 16:17)</a>:</h4>
<p>For quotients by equivalence relations, we use <code>setoid</code>, but you don't want that here</p>



<a name="185242904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185242904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Earnshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185242904">(Jan 09 2020 at 18:52)</a>:</h4>
<p>didn't complete Thm 2.2 yet but for the next part it looks like it would be useful to have notation for the unique line between points. so far:</p>
<div class="codehilite"><pre><span></span>def plus (p q : Ω.Pt) {neq : p ≠ q} : Ω.Ln := begin
  have h₁ := Ω.exists_unique_ln_bw_two_pts,
  have h₂ := h₁ neq,
  sorry
end
</pre></div>


<p>this gives me unique existence as an hypothesis but stuck on how to eliminate</p>



<a name="185244659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185244659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185244659">(Jan 09 2020 at 19:09)</a>:</h4>
<p>Use <code>exists_of_exists_unique</code></p>



<a name="185244669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185244669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185244669">(Jan 09 2020 at 19:09)</a>:</h4>
<p>After that use <code>choose</code></p>



<a name="185244777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185244777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185244777">(Jan 09 2020 at 19:10)</a>:</h4>
<p>For several reasons, it is usually better to use term-mode for definitions, and use tactic mode only for proofs</p>



<a name="185244859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185244859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185244859">(Jan 09 2020 at 19:11)</a>:</h4>
<p>So once you have finished this definition, you can try to use <code>classical.some _</code> for the definition.</p>



<a name="185244917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185244917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185244917">(Jan 09 2020 at 19:12)</a>:</h4>
<p>(Btw, do you already know that a point exists? Do you know that more than 1 point exists?)</p>



<a name="185244927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185244927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185244927">(Jan 09 2020 at 19:12)</a>:</h4>
<p>Usually such axioms are added, right?</p>



<a name="185245639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185245639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185245639">(Jan 09 2020 at 19:20)</a>:</h4>
<p>"Axiom 3: There exist three distinct points A, B, C such that C does not lie on the line A + B. We also say that there exist three non-collinear points."</p>
<p>(Not sure how legal this link is, but see <a href="https://archive.org/details/geometricalgebra033556mbp/page/n63" target="_blank" title="https://archive.org/details/geometricalgebra033556mbp/page/n63">https://archive.org/details/geometricalgebra033556mbp/page/n63</a>)</p>



<a name="185245924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185245924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Earnshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185245924">(Jan 09 2020 at 19:23)</a>:</h4>
<p>right, I wrote this as <code>(exists_three_noncollinear : ∀ (L : Ln), ∃ (a b c : Pt), ¬(a ∈ L ∧ b ∈ L ∧ c ∈ L)</code>, but having the plus notation might give a form that is easier to reason with.</p>



<a name="185246001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185246001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Earnshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185246001">(Jan 09 2020 at 19:24)</a>:</h4>
<p>in fact what is wrote is wrong because need to specify distinctness</p>



<a name="185246476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185246476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185246476">(Jan 09 2020 at 19:29)</a>:</h4>
<p>I think the plus notation can work, if you have a statement of the form</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">exists_ln_of_pt_of_pt</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">:</span> <span class="err">\</span><span class="n">exists</span> <span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">x</span> <span class="err">\</span><span class="k">in</span> <span class="n">L</span> <span class="err">\</span><span class="n">and</span> <span class="n">y</span> <span class="err">\</span><span class="k">in</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>



<a name="185246752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185246752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185246752">(Jan 09 2020 at 19:31)</a>:</h4>
<p>Then you can define</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">add</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ln</span> <span class="o">:=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="o">(</span><span class="n">exists_ln_of_pt_of_pt</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="err">\</span><span class="n">Omega</span><span class="bp">.</span><span class="n">Pt</span> <span class="o">:=</span> <span class="err">\</span><span class="bp">&lt;</span><span class="n">add</span><span class="err">\</span><span class="bp">&gt;</span>

<span class="kn">lemma</span> <span class="n">left_mem_add</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="err">\</span><span class="k">in</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="o">(</span><span class="n">exists_ln_of_pt_of_pt</span> <span class="n">x</span> <span class="n">y</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span>

<span class="kn">lemma</span> <span class="n">right_mem_add</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">:</span> <span class="n">y</span> <span class="err">\</span><span class="k">in</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="o">(</span><span class="n">exists_ln_of_pt_of_pt</span> <span class="n">x</span> <span class="n">y</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span>
</pre></div>



<a name="185246755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185246755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185246755">(Jan 09 2020 at 19:32)</a>:</h4>
<p>Here's how <span class="user-mention" data-user-id="120256">@Ali Sever</span> did it last year: <a href="https://github.com/ImperialCollegeLondon/xena-UROP-2018/blob/master/src/Geometry/axioms.lean" target="_blank" title="https://github.com/ImperialCollegeLondon/xena-UROP-2018/blob/master/src/Geometry/axioms.lean">https://github.com/ImperialCollegeLondon/xena-UROP-2018/blob/master/src/Geometry/axioms.lean</a></p>



<a name="185264245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185264245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185264245">(Jan 09 2020 at 22:39)</a>:</h4>
<p>Sadly you'll have to use another symbol since <code>has_add.add</code> has expected type <code>a -&gt; a -&gt; a</code> (and this is built into core), but you want <code>Pt -&gt; Pt -&gt; Ln</code>.</p>



<a name="185283751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185283751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185283751">(Jan 10 2020 at 05:32)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">ext</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">ring</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="n">class</span> <span class="n">has_parallel</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">parallel</span> <span class="o">:</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kn">infix</span> <span class="bp">`</span> <span class="err">∥</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">has_parallel</span><span class="bp">.</span><span class="n">parallel</span>

<span class="kn">structure</span> <span class="n">pre_geometry</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">[</span><span class="n">has_mem</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>

<span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">pre_geometry</span><span class="bp">.</span><span class="n">has_mem</span>

<span class="kn">instance</span> <span class="n">pre_geometry</span><span class="bp">.</span><span class="n">has_parallel</span> <span class="o">{</span><span class="err">Ω</span> <span class="o">:</span> <span class="n">pre_geometry</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_parallel</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Ln</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">L₁</span> <span class="n">L₂</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Pt</span><span class="o">),</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₁</span> <span class="bp">∧</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₂</span><span class="o">)</span> <span class="bp">→</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">L₂</span><span class="bp">⟩</span>

<span class="n">class</span> <span class="n">geometry</span> <span class="kn">extends</span> <span class="n">pre_geometry</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_unique_ln_bw_two_pts</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p₁</span> <span class="n">p₂</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">},</span> <span class="n">p₁</span> <span class="bp">≠</span> <span class="n">p₂</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p₁</span> <span class="err">∈</span> <span class="n">L</span> <span class="bp">∧</span> <span class="n">p₂</span> <span class="err">∈</span> <span class="n">L</span><span class="o">)</span>
<span class="o">(</span><span class="n">exists_unique_parallel</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">),</span> <span class="bp">∃!</span> <span class="n">L&#39;</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L&#39;</span> <span class="bp">∧</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L&#39;</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">has_parallel</span>
<span class="kn">variables</span> <span class="o">{</span><span class="err">Ω</span> <span class="o">:</span> <span class="n">pre_geometry</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">refl</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">refl</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Ln</span><span class="o">}</span> <span class="o">:</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">symm</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">symm</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="o">:</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₁</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="bp">⟩</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>

<span class="kn">end</span> <span class="n">has_parallel</span>

<span class="kn">namespace</span> <span class="n">has_parallel</span>
<span class="kn">variables</span> <span class="o">{</span><span class="err">Ω</span> <span class="o">:</span> <span class="n">geometry</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">trans</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">L₃</span> <span class="o">:</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂₃</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₃</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₃</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">H₁</span><span class="o">,</span> <span class="n">H₂</span><span class="bp">⟩</span><span class="o">,</span>
<span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">geometry</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">p</span> <span class="n">L₂</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">H₁</span><span class="o">,</span> <span class="n">h₁₂</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">H₂</span><span class="o">,</span> <span class="n">h₂₃</span><span class="bp">⟩</span>

<span class="kn">end</span> <span class="n">has_parallel</span>

<span class="n">def</span> <span class="n">affine_plane</span><span class="bp">.</span><span class="n">pre</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">k</span><span class="o">]</span> <span class="o">:</span> <span class="n">pre_geometry</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">Pt</span> <span class="o">:=</span> <span class="n">k</span> <span class="bp">×</span> <span class="n">k</span><span class="o">,</span>
  <span class="n">Ln</span> <span class="o">:=</span> <span class="o">(</span><span class="n">k</span> <span class="bp">×</span> <span class="n">k</span><span class="o">)</span> <span class="err">⊕</span> <span class="n">k</span><span class="o">,</span> <span class="c1">-- it is kP^2 - [0:0:1]</span>
  <span class="c1">-- x+by=c or y=c</span>
  <span class="n">has_mem</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">p</span> <span class="n">L</span><span class="o">,</span> <span class="n">sum</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">L</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">bc</span><span class="o">,</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">bc</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">*</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">bc</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span><span class="o">,</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">c</span><span class="o">)</span><span class="bp">⟩</span> <span class="o">}</span>

<span class="kn">theorem</span> <span class="n">affine_plane</span><span class="bp">.</span><span class="n">exists_unique_ln_bw_two_pts</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">k</span><span class="o">]</span>
  <span class="o">{</span><span class="n">p₁</span> <span class="n">p₂</span> <span class="o">:</span> <span class="o">(</span><span class="n">affine_plane</span><span class="bp">.</span><span class="n">pre</span> <span class="n">k</span><span class="o">)</span><span class="bp">.</span><span class="n">Pt</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p₁</span> <span class="bp">≠</span> <span class="n">p₂</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃!</span> <span class="n">L</span> <span class="o">:</span> <span class="o">(</span><span class="n">affine_plane</span><span class="bp">.</span><span class="n">pre</span> <span class="n">k</span><span class="o">)</span><span class="bp">.</span><span class="n">Ln</span><span class="o">,</span> <span class="n">p₁</span> <span class="err">∈</span> <span class="n">L</span> <span class="bp">∧</span> <span class="n">p₂</span> <span class="err">∈</span> <span class="n">L</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="n">or</span><span class="bp">.</span><span class="n">cases_on</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">em</span> <span class="o">(</span><span class="n">p₁</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">p₂</span><span class="bp">.</span><span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="bp">⟨</span><span class="n">sum</span><span class="bp">.</span><span class="n">inr</span> <span class="n">p₁</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">h</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">L</span> <span class="n">hL</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hL</span> <span class="k">with</span> <span class="n">hpL1</span> <span class="n">hpL2</span><span class="o">,</span> <span class="n">cases</span> <span class="n">L</span> <span class="k">with</span> <span class="n">bc</span> <span class="n">c</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">change</span> <span class="bp">_</span> <span class="bp">=</span> <span class="bp">_</span> <span class="n">at</span> <span class="n">hpL1</span><span class="o">,</span> <span class="n">change</span> <span class="bp">_</span> <span class="bp">=</span> <span class="bp">_</span> <span class="n">at</span> <span class="n">hpL2</span><span class="o">,</span> <span class="n">change</span> <span class="bp">_</span> <span class="bp">=</span> <span class="bp">_</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">rw</span> <span class="n">h</span> <span class="n">at</span> <span class="n">hpL1</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">absurd</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">ext</span> <span class="o">(</span><span class="n">add_right_cancel</span> <span class="o">(</span><span class="n">hpL1</span><span class="bp">.</span><span class="n">trans</span> <span class="n">hpL2</span><span class="bp">.</span><span class="n">symm</span><span class="o">))</span> <span class="n">h</span><span class="o">)</span> <span class="n">hp</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">congr_arg</span> <span class="bp">_</span> <span class="n">hpL1</span><span class="bp">.</span><span class="n">symm</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="n">p₁</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">p₂</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">mt</span> <span class="n">eq_of_sub_eq_zero</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">refine</span> <span class="bp">⟨</span><span class="n">sum</span><span class="bp">.</span><span class="n">inl</span> <span class="o">((</span><span class="n">p₂</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">-</span> <span class="n">p₁</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="bp">/</span> <span class="o">(</span><span class="n">p₁</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">p₂</span><span class="bp">.</span><span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="n">p₂</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">*</span> <span class="n">p₁</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">p₁</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">*</span> <span class="n">p₂</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="bp">/</span> <span class="o">(</span><span class="n">p₁</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">p₂</span><span class="bp">.</span><span class="mi">2</span><span class="o">)),</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">L</span> <span class="n">hL</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">change</span> <span class="n">p₁</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">+</span> <span class="o">(</span><span class="n">p₂</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">-</span> <span class="n">p₁</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="bp">/</span> <span class="o">(</span><span class="n">p₁</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">p₂</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="bp">*</span> <span class="n">p₁</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="o">(</span><span class="n">p₂</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">*</span> <span class="n">p₁</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">p₁</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">*</span> <span class="n">p₂</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="bp">/</span> <span class="o">(</span><span class="n">p₁</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">p₂</span><span class="bp">.</span><span class="mi">2</span><span class="o">),</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">div_mul_eq_mul_div</span><span class="o">,</span> <span class="n">add_div_eq_mul_add_div</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">this</span><span class="o">],</span> <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span> <span class="n">ring</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">change</span> <span class="n">p₂</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">+</span> <span class="o">(</span><span class="n">p₂</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">-</span> <span class="n">p₁</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="bp">/</span> <span class="o">(</span><span class="n">p₁</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">p₂</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="bp">*</span> <span class="n">p₂</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="o">(</span><span class="n">p₂</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">*</span> <span class="n">p₁</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">p₁</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">*</span> <span class="n">p₂</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="bp">/</span> <span class="o">(</span><span class="n">p₁</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">p₂</span><span class="bp">.</span><span class="mi">2</span><span class="o">),</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">div_mul_eq_mul_div</span><span class="o">,</span> <span class="n">add_div_eq_mul_add_div</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">this</span><span class="o">],</span> <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span> <span class="n">ring</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">hL</span> <span class="k">with</span> <span class="n">hpL1</span> <span class="n">hpL2</span><span class="o">,</span> <span class="n">cases</span> <span class="n">L</span> <span class="k">with</span> <span class="n">bc</span> <span class="n">c</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">cases</span> <span class="n">bc</span> <span class="k">with</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">change</span> <span class="n">p₁</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">p₁</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">c</span> <span class="n">at</span> <span class="n">hpL1</span><span class="o">,</span> <span class="n">change</span> <span class="n">p₂</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">p₂</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">c</span> <span class="n">at</span> <span class="n">hpL2</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">hb</span> <span class="o">:=</span> <span class="n">hpL1</span><span class="bp">.</span><span class="n">trans</span> <span class="n">hpL2</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">eq_sub_iff_add_eq&#39;</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">,</span> <span class="n">add_sub_assoc</span><span class="o">,</span> <span class="err">←</span> <span class="n">sub_eq_iff_eq_add&#39;</span><span class="o">,</span> <span class="err">←</span> <span class="n">mul_sub</span><span class="o">,</span> <span class="err">←</span> <span class="n">eq_div_iff_mul_eq</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">this</span><span class="o">]</span> <span class="n">at</span> <span class="n">hb</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">hb</span><span class="o">,</span> <span class="n">div_mul_eq_mul_div</span><span class="o">,</span> <span class="n">add_div_eq_mul_add_div</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">this</span><span class="o">]</span> <span class="n">at</span> <span class="n">hpL1</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">hb</span><span class="o">,</span> <span class="err">←</span> <span class="n">hpL1</span><span class="o">],</span> <span class="n">congr&#39;</span> <span class="mi">3</span><span class="o">,</span> <span class="n">ring</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">absurd</span> <span class="o">(</span><span class="n">hpL1</span><span class="bp">.</span><span class="n">trans</span> <span class="n">hpL2</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span> <span class="n">h</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>
<span class="c">/-</span><span class="cm"> p₁.1 + b p₁.2 = c</span>
<span class="cm">   p₂.1 + b p₂.2 = c</span>
<span class="cm">   c = p₁.1 + b p₁.2</span>
<span class="cm">   p₁.1 + b p₁.2 = p₂.1 + b p₂.2</span>
<span class="cm">   b = (p₂.1 - p₁.1) / (p₁.2 - p₂.2)</span>
<span class="cm">   c = (p₁.1 * (p₁.2 - p₂.2) + (p₂.1 - p₁.1) * p₁.2) / (p₁.2 - p₂.2)</span>
<span class="cm">   c = (p₁.1 * p₁.2 - p₁.1 * p₂.2 + p₂.1 * p₁.2 - p₁.1 * p₁.2) / (p₁.2 - p₂.2)</span>
<span class="cm">   c = (p₂.1 * p₁.2 - p₁.1 * p₂.2) / (p₁.2 - p₂.2)</span>
<span class="cm">-/</span>

<span class="kn">theorem</span> <span class="n">affine_plane</span><span class="bp">.</span><span class="n">pre</span><span class="bp">.</span><span class="n">parallel</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">k</span><span class="o">]</span> <span class="o">(</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="o">:</span> <span class="o">(</span><span class="n">affine_plane</span><span class="bp">.</span><span class="n">pre</span> <span class="n">k</span><span class="o">)</span><span class="bp">.</span><span class="n">Ln</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">b</span> <span class="n">c</span> <span class="n">c&#39;</span> <span class="o">:</span> <span class="n">k</span><span class="o">,</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">sum</span><span class="bp">.</span><span class="n">inl</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">L₂</span> <span class="bp">=</span> <span class="n">sum</span><span class="bp">.</span><span class="n">inl</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c&#39;</span><span class="o">))</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">c</span> <span class="n">c&#39;</span> <span class="o">:</span> <span class="n">k</span><span class="o">,</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">sum</span><span class="bp">.</span><span class="n">inr</span> <span class="n">c</span> <span class="bp">∧</span> <span class="n">L₂</span> <span class="bp">=</span> <span class="n">sum</span><span class="bp">.</span><span class="n">inr</span> <span class="n">c&#39;</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">classical</span><span class="o">,</span> <span class="n">by_cases</span> <span class="n">hL</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₁</span> <span class="bp">∧</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₂</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">specialize</span> <span class="n">h</span> <span class="n">hL</span><span class="o">,</span> <span class="n">subst</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">L₁</span> <span class="k">with</span> <span class="n">bc</span> <span class="n">c</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">cases</span> <span class="n">bc</span> <span class="k">with</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">}</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">L₁</span> <span class="k">with</span> <span class="n">bc</span> <span class="n">c</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">L₂</span> <span class="k">with</span> <span class="n">bc&#39;</span> <span class="n">c&#39;</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">cases</span> <span class="n">bc</span> <span class="k">with</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">cases</span> <span class="n">bc&#39;</span> <span class="k">with</span> <span class="n">b&#39;</span> <span class="n">c&#39;</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b&#39;</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">by_contra</span> <span class="n">hb</span><span class="o">,</span> <span class="k">have</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">-</span> <span class="n">b&#39;</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">sub_ne_zero_of_ne</span> <span class="n">hb</span><span class="o">,</span>
          <span class="n">apply</span> <span class="n">hL</span><span class="o">,</span> <span class="n">refine</span> <span class="bp">⟨</span><span class="o">((</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c&#39;</span> <span class="bp">-</span> <span class="n">b&#39;</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span><span class="bp">/</span><span class="o">(</span><span class="n">b</span> <span class="bp">-</span> <span class="n">b&#39;</span><span class="o">),</span> <span class="o">(</span><span class="n">c</span> <span class="bp">-</span> <span class="n">c&#39;</span><span class="o">)</span> <span class="bp">/</span> <span class="o">(</span><span class="n">b</span> <span class="bp">-</span> <span class="n">b&#39;</span><span class="o">)),</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
          <span class="o">{</span> <span class="n">change</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c&#39;</span> <span class="bp">-</span> <span class="n">b&#39;</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">/</span> <span class="o">(</span><span class="n">b</span> <span class="bp">-</span> <span class="n">b&#39;</span><span class="o">)</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="o">((</span><span class="n">c</span> <span class="bp">-</span> <span class="n">c&#39;</span><span class="o">)</span> <span class="bp">/</span> <span class="o">(</span><span class="n">b</span> <span class="bp">-</span> <span class="n">b&#39;</span><span class="o">))</span> <span class="bp">=</span> <span class="n">c</span><span class="o">,</span>
            <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">mul_div_assoc</span><span class="o">,</span> <span class="err">←</span> <span class="n">add_div</span><span class="o">,</span> <span class="n">div_eq_iff_mul_eq</span> <span class="n">this</span><span class="o">],</span> <span class="n">ring</span> <span class="o">},</span>
          <span class="o">{</span> <span class="n">change</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c&#39;</span> <span class="bp">-</span> <span class="n">b&#39;</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">/</span> <span class="o">(</span><span class="n">b</span> <span class="bp">-</span> <span class="n">b&#39;</span><span class="o">)</span> <span class="bp">+</span> <span class="n">b&#39;</span> <span class="bp">*</span> <span class="o">((</span><span class="n">c</span> <span class="bp">-</span> <span class="n">c&#39;</span><span class="o">)</span> <span class="bp">/</span> <span class="o">(</span><span class="n">b</span> <span class="bp">-</span> <span class="n">b&#39;</span><span class="o">))</span> <span class="bp">=</span> <span class="n">c&#39;</span><span class="o">,</span>
            <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">mul_div_assoc</span><span class="o">,</span> <span class="err">←</span> <span class="n">add_div</span><span class="o">,</span> <span class="n">div_eq_iff_mul_eq</span> <span class="n">this</span><span class="o">],</span> <span class="n">ring</span> <span class="o">}</span> <span class="o">},</span>
        <span class="n">subst</span> <span class="n">hb</span><span class="o">,</span> <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">cases</span> <span class="n">bc</span> <span class="k">with</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">refine</span> <span class="n">hL</span><span class="bp">.</span><span class="n">elim</span> <span class="bp">⟨</span><span class="o">(</span><span class="n">c</span> <span class="bp">-</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c&#39;</span><span class="o">,</span> <span class="n">c&#39;</span><span class="o">),</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">change</span> <span class="n">c</span> <span class="bp">-</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c&#39;</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c&#39;</span> <span class="bp">=</span> <span class="n">c</span><span class="o">,</span> <span class="n">rw</span> <span class="n">sub_add_cancel</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">change</span> <span class="n">c&#39;</span> <span class="bp">=</span> <span class="n">c&#39;</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">cases</span> <span class="n">bc&#39;</span> <span class="k">with</span> <span class="n">b&#39;</span> <span class="n">c&#39;</span><span class="o">,</span> <span class="n">refine</span> <span class="n">hL</span><span class="bp">.</span><span class="n">elim</span> <span class="bp">⟨</span><span class="o">(</span><span class="n">c&#39;</span> <span class="bp">-</span> <span class="n">b&#39;</span> <span class="bp">*</span> <span class="n">c</span><span class="o">,</span> <span class="n">c</span><span class="o">),</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">change</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">c</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">change</span> <span class="n">c&#39;</span> <span class="bp">-</span> <span class="n">b&#39;</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b&#39;</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">c&#39;</span><span class="o">,</span> <span class="n">rw</span> <span class="n">sub_add_cancel</span> <span class="o">}</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">}</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">(</span><span class="bp">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">c&#39;</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="bp">|</span> <span class="bp">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">c&#39;</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp1</span><span class="o">,</span> <span class="n">hp2</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">c&#39;</span> <span class="o">:=</span> <span class="n">hp1</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">trans</span> <span class="n">hp2</span><span class="o">,</span> <span class="n">rw</span> <span class="n">this</span> <span class="o">},</span>
    <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">c&#39;</span> <span class="o">:=</span> <span class="n">hp1</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">trans</span> <span class="n">hp2</span><span class="o">,</span> <span class="n">rw</span> <span class="n">this</span> <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>
<span class="c">/-</span><span class="cm"> x + by = c</span>
<span class="cm">   x + b&#39;y = c&#39;</span>
<span class="cm">   y = (c - c&#39;) / (b - b&#39;)</span>
<span class="cm">   x = c - by = (cb - cb&#39; - bc + bc&#39;) / (b - b&#39;) = (bc&#39; - b&#39;c) / (b - b&#39;)</span>

<span class="cm">   x + by = c</span>
<span class="cm">   y = c&#39;</span>
<span class="cm">-/</span>

<span class="c1">-- this is &quot;computable&quot;</span>
<span class="kn">theorem</span> <span class="n">affine_plane</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">k</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="o">(</span><span class="n">affine_plane</span><span class="bp">.</span><span class="n">pre</span> <span class="n">k</span><span class="o">)</span><span class="bp">.</span><span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="o">(</span><span class="n">affine_plane</span><span class="bp">.</span><span class="n">pre</span> <span class="n">k</span><span class="o">)</span><span class="bp">.</span><span class="n">Ln</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃!</span> <span class="n">L&#39;</span> <span class="o">:</span> <span class="o">(</span><span class="n">affine_plane</span><span class="bp">.</span><span class="n">pre</span> <span class="n">k</span><span class="o">)</span><span class="bp">.</span><span class="n">Ln</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L&#39;</span> <span class="bp">∧</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L&#39;</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">L</span> <span class="k">with</span> <span class="n">bc</span> <span class="n">c</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">bc</span> <span class="k">with</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">refine</span> <span class="bp">⟨</span><span class="n">sum</span><span class="bp">.</span><span class="n">inl</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="o">),</span> <span class="bp">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">L</span> <span class="n">hL</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">affine_plane</span><span class="bp">.</span><span class="n">pre</span><span class="bp">.</span><span class="n">parallel</span><span class="o">,</span> <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">hL</span> <span class="k">with</span> <span class="n">hpL</span> <span class="n">hL</span><span class="o">,</span> <span class="n">rw</span> <span class="n">affine_plane</span><span class="bp">.</span><span class="n">pre</span><span class="bp">.</span><span class="n">parallel</span> <span class="n">at</span> <span class="n">hL</span><span class="o">,</span>
      <span class="n">rcases</span> <span class="n">hL</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">b&#39;</span><span class="o">,</span> <span class="n">c&#39;</span><span class="o">,</span> <span class="n">c&#39;&#39;</span><span class="o">,</span> <span class="bp">⟨⟩</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="bp">|</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">⟨⟩</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
      <span class="n">change</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">c&#39;&#39;</span> <span class="n">at</span> <span class="n">hpL</span><span class="o">,</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">hpL</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="bp">⟨</span><span class="n">sum</span><span class="bp">.</span><span class="n">inr</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">L</span> <span class="n">hL</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">affine_plane</span><span class="bp">.</span><span class="n">pre</span><span class="bp">.</span><span class="n">parallel</span><span class="o">,</span> <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">hL</span> <span class="k">with</span> <span class="n">hpL</span> <span class="n">hL</span><span class="o">,</span> <span class="n">rw</span> <span class="n">affine_plane</span><span class="bp">.</span><span class="n">pre</span><span class="bp">.</span><span class="n">parallel</span> <span class="n">at</span> <span class="n">hL</span><span class="o">,</span>
      <span class="n">rcases</span> <span class="n">hL</span> <span class="k">with</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">⟨⟩</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="bp">|</span> <span class="bp">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">c&#39;</span><span class="o">,</span> <span class="bp">⟨⟩</span><span class="o">,</span> <span class="bp">⟨⟩⟩</span><span class="o">,</span>
      <span class="n">change</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">c&#39;</span> <span class="n">at</span> <span class="n">hpL</span><span class="o">,</span> <span class="n">rw</span> <span class="n">hpL</span> <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">affine_plane</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">k</span><span class="o">]</span> <span class="o">:</span> <span class="n">geometry</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">exists_unique_ln_bw_two_pts</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">affine_plane</span><span class="bp">.</span><span class="n">exists_unique_ln_bw_two_pts</span> <span class="n">k</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">exists_unique_parallel</span> <span class="o">:=</span> <span class="n">affine_plane</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">k</span><span class="o">,</span>
  <span class="bp">..</span> <span class="o">(</span><span class="n">affine_plane</span><span class="bp">.</span><span class="n">pre</span> <span class="n">k</span><span class="o">)</span> <span class="o">}</span>
</pre></div>



<a name="185283755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185283755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185283755">(Jan 10 2020 at 05:32)</a>:</h4>
<p>yay the affine plane is a geometry</p>



<a name="185678159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185678159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185678159">(Jan 15 2020 at 08:36)</a>:</h4>
<p><span class="user-mention" data-user-id="254058">@Marc Masdeu</span> We had a discussion about axiomatic geometry in this thread about a week ago <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="185678185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185678185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185678185">(Jan 15 2020 at 08:37)</a>:</h4>
<p>Might contain some relevant bits. (Now I will start reading your post <span aria-label="oops" class="emoji emoji-1f643" role="img" title="oops">:oops:</span>.) Oooh, and welcome by the way <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span></p>



<a name="185678365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185678365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185678365">(Jan 15 2020 at 08:40)</a>:</h4>
<blockquote>
<p>Might contain some relevant bits. (Now I will start reading your post <span aria-label="oops" class="emoji emoji-1f643" role="img" title="oops">:oops:</span>.) Oooh, and welcome by the way <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span></p>
</blockquote>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> thank you! I had seen the thread, but couldn't find any <code>\exists !</code> statement. This will be useful for when I try to make things nice and Lean-ish.</p>



<a name="185693660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185693660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185693660">(Jan 15 2020 at 12:44)</a>:</h4>
<p>My student <span class="user-mention" data-user-id="120256">@Ali Sever</span> ploughed through loads of this stuff in Lean! A link is somewhere in one of the threads ;-)</p>



<a name="185702348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185702348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ali Sever <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185702348">(Jan 15 2020 at 14:31)</a>:</h4>
<p>I'll try to make summary of what I did and how my code works.</p>



<a name="185704812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185704812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Masdeu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#185704812">(Jan 15 2020 at 14:54)</a>:</h4>
<blockquote>
<p>I'll try to make summary of what I did and how my code works.</p>
</blockquote>
<p>That would be great! Thanks</p>



<a name="186188540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/186188540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Earnshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#186188540">(Jan 21 2020 at 14:38)</a>:</h4>
<p>coming back to this, i need to get back to proofs but for now am playing with the code that was produced above and trying other ways of setting it up, to get a feel for basics. </p>
<p>Kenny had instead had a <code>structure</code> that was a bit like a "structure" in model-theoretic terms and then defined a class extending that it that turned the "structure" into a "theory". would it be misleading to think along these model-theoretic lines as a rule of thumb for using <code>structure</code> and <code>class</code>?</p>
<p>My first thought was that defining a <code>class</code> <code>has_parallel</code> seems like overkill because I'm only expecting one type to use it, so I just added <code>parallel</code> to my <code>structure</code>. But then to define it, it seems like I have to introduce a constant, which seems ugly?</p>
<div class="codehilite"><pre><span></span>structure abstract_affine : Type 1 :=
(Pt : Type)
(Ln : Type)
(parallel : Ln → Ln → Prop) (infix ` ∥ `:50 := parallel)
[has_mem : has_mem Pt Ln]
(exists_unique_ln_bw_two_pts : ∀ {p₁ p₂ : Pt}, p₁ ≠ p₂ → ∃! L : Ln, p₁ ∈ L ∧ p₂ ∈ L)
(exists_unique_parallel : ∀ (p : Pt) (L : Ln), ∃! L&#39; : Ln, p ∈ L&#39; ∧ L ∥ L&#39;)
(exists_three_noncollinear : ∀ (L : Ln), ∃ (a b c : Pt) (a ≠ b) (b ≠ c), ¬(a ∈ L ∧ b ∈ L ∧ c ∈ L))

constant Ω : abstract_affine

attribute [instance] abstract_affine.has_mem

-- Artin def 2.1
def Ω.parallel (l₁ l₂ : Ω.Ln) := l₁ = l₂ ∨ (¬∃ p : Ω.Pt, p ∈ l₁ ∧ p ∈ l₂)
infix ` ∥ `:50 := Ω.parallel

@[refl] theorem parallel.refl {L : Ω.Ln} : L ∥ L := begin
  left,
  refl,
end
</pre></div>



<a name="186188829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/186188829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Earnshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#186188829">(Jan 21 2020 at 14:40)</a>:</h4>
<p>also, it's a way off but my goal originally was to prove an equivalence of categories of models of abstract affine planes and of skew fields (/ planes-with-pappus and fields). But perhaps it is more apt to prove "equality of types"? Is that a done thing?</p>



<a name="186189946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/186189946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#186189946">(Jan 21 2020 at 14:51)</a>:</h4>
<p>The only difference between class and structure is to do with how the arguments are inferred. If you define a class, then when you pass an argument of that type to a function, you will expect Lean to infer that argument using Type class inference. So for example, we don't want to have to provide explicitly the ring structure on the reals every time we use it, so <code>ring</code> is a class. The downside of this is that I can't easily talk about multiple elements of the type <code>ring R</code>, which is fine, because there's usually only one ring structure on a given type that I want to consider. </p>
<p>The model theoretic analogy is a very loose one, you can have Propositions as part of both structures and classes.</p>



<a name="186190088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/186190088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#186190088">(Jan 21 2020 at 14:52)</a>:</h4>
<p>My suggested setup is the following</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">abstract_affine</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">parallel</span> <span class="o">:</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="kn">infix</span> <span class="bp">`</span> <span class="err">∥</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">parallel</span><span class="o">)</span>
<span class="o">[</span><span class="n">has_mem</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
<span class="o">(</span><span class="n">exists_unique_ln_bw_two_pts</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p₁</span> <span class="n">p₂</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">},</span> <span class="n">p₁</span> <span class="bp">≠</span> <span class="n">p₂</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p₁</span> <span class="err">∈</span> <span class="n">L</span> <span class="bp">∧</span> <span class="n">p₂</span> <span class="err">∈</span> <span class="n">L</span><span class="o">)</span>
<span class="o">(</span><span class="n">exists_unique_parallel</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">),</span> <span class="bp">∃!</span> <span class="n">L&#39;</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L&#39;</span> <span class="bp">∧</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L&#39;</span><span class="o">)</span>
<span class="o">(</span><span class="n">exists_three_noncollinear</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="bp">≠</span> <span class="n">c</span><span class="o">),</span> <span class="bp">¬</span><span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">L</span> <span class="bp">∧</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">L</span> <span class="bp">∧</span> <span class="n">c</span> <span class="err">∈</span> <span class="n">L</span><span class="o">))</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">Pt</span> <span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">abstract_affine</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
</pre></div>



<a name="186190375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/186190375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#186190375">(Jan 21 2020 at 14:55)</a>:</h4>
<p>You should always use <code>variable</code> instead of constant. With the variable keyword you will be proving things in the generality of all <code>abstract_affine</code> spaces. <code>constant</code> adds an axiom that there is an <code>abstract_affine</code> space, but then all the theorems you prove will only apply to the constant you added, and not to an arbitrary affine space.</p>



<a name="186190560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/186190560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Earnshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#186190560">(Jan 21 2020 at 14:57)</a>:</h4>
<blockquote>
<p>You should always use <code>variable</code> instead of constant. With the variable keyword you will be proving things in the generality of all <code>abstract_affine</code> spaces. <code>constant</code> adds an axiom that there is an <code>abstract_affine</code> space, but then all the theorems you prove will only apply to the constant you added, and not to an arbitrary affine space.</p>
</blockquote>
<p>ah yes, should know this by now, good reminder</p>



<a name="186191993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/186191993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Earnshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#186191993">(Jan 21 2020 at 15:12)</a>:</h4>
<blockquote>
<p>My suggested setup is the following</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">abstract_affine</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">parallel</span> <span class="o">:</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="kn">infix</span> <span class="bp">`</span> <span class="err">∥</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">parallel</span><span class="o">)</span>
<span class="o">[</span><span class="n">has_mem</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
<span class="o">(</span><span class="n">exists_unique_ln_bw_two_pts</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p₁</span> <span class="n">p₂</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">},</span> <span class="n">p₁</span> <span class="bp">≠</span> <span class="n">p₂</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p₁</span> <span class="err">∈</span> <span class="n">L</span> <span class="bp">∧</span> <span class="n">p₂</span> <span class="err">∈</span> <span class="n">L</span><span class="o">)</span>
<span class="o">(</span><span class="n">exists_unique_parallel</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">),</span> <span class="bp">∃!</span> <span class="n">L&#39;</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L&#39;</span> <span class="bp">∧</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L&#39;</span><span class="o">)</span>
<span class="o">(</span><span class="n">exists_three_noncollinear</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="bp">≠</span> <span class="n">c</span><span class="o">),</span> <span class="bp">¬</span><span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">L</span> <span class="bp">∧</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">L</span> <span class="bp">∧</span> <span class="n">c</span> <span class="err">∈</span> <span class="n">L</span><span class="o">))</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">Pt</span> <span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">abstract_affine</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
</pre></div>


</blockquote>
<p>in this setup I cannot figure out how one then defines parallelism</p>



<a name="186192206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/186192206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Earnshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/attempt.20at.20some.20geometry.html#186192206">(Jan 21 2020 at 15:13)</a>:</h4>
<p>the rest of what you said is also helpful, thanks. I see why it makes more sense to use a class here</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
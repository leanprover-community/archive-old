---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html">multiset : convert prod of pow to pow of sum</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="266787284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266787284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266787284">(Jan 04 2022 at 09:42)</a>:</h4>
<p>Does this exist somewhere in Mathlib ? Should it be added ?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">multiset.prod_pow_eq_pow_sum</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">multiset.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">a</span><span class="bp">^</span><span class="n">n</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">^</span> <span class="o">(</span><span class="n">m.sum</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">multiset.induction_on</span> <span class="n">m</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">m</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span><span class="n">pow_add</span><span class="o">])</span>
</code></pre></div>
<p>Two questions  by the way: </p>
<p>1) <code>multiset.sum</code> requires that one works in a <code>comm_monoid</code> (for obvious reasons), but here all objects involved belong to the commutative submonoid generated by <code>a</code>, so something should work for any <code>monoid M</code>, but what?</p>
<p>2) I expected to be able to use <code>multiset.prod_hom</code>. If <code>M</code> is a monoid, what is mathematically a member of <code>ℕ →* M</code> ?</p>



<a name="266787367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266787367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266787367">(Jan 04 2022 at 09:42)</a>:</h4>
<p>Might <a href="https://github.com/leanprover-community/mathlib/pull/10907">#10907</a> help? (I don't think so, because you're going from additive to multiplicative and those new lemmas each stay in the same world)</p>



<a name="266787676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266787676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266787676">(Jan 04 2022 at 09:46)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/powers_hom">docs#powers_hom</a> is the closest <code>monoid_hom</code></p>



<a name="266787717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266787717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266787717">(Jan 04 2022 at 09:46)</a>:</h4>
<p>Is <a href="https://leanprover-community.github.io/mathlib_docs/find/multiset.noncomm_prod">docs#multiset.noncomm_prod</a> the generalization you were looking for?</p>



<a name="266788912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266788912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266788912">(Jan 04 2022 at 09:59)</a>:</h4>
<p>Yes, it should be part of that, but I don't manage to make this work.<br>
(On the other hand, I am really appalled at the idea that <code>multiplicative \nat \to* M</code>is not a morphism from <code>\nat</code> as a multiplicative monoid to <code>M</code>.)</p>



<a name="266789455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266789455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266789455">(Jan 04 2022 at 10:05)</a>:</h4>
<p>What do mean by "ℕ as a multiplicative monoid" if not <code>multiplicative ℕ</code>? Do you just mean ℕ?</p>



<a name="266789558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266789558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266789558">(Jan 04 2022 at 10:06)</a>:</h4>
<p><span class="user-mention" data-user-id="130609">@Antoine Chambert-Loir</span> Don't you just want <code>ℕ →* M</code>?</p>



<a name="266789634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266789634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266789634">(Jan 04 2022 at 10:07)</a>:</h4>
<p><code>multiplicative ℕ</code> is the monoid of symbols <code>{x^n | n ∈ ℕ}</code>. With multiplication <code>x^m * x^n = x^(m+n)</code>.</p>



<a name="266789687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266789687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266789687">(Jan 04 2022 at 10:07)</a>:</h4>
<p>Or maybe I'm misunderstanding what you want...</p>



<a name="266790816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266790816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266790816">(Jan 04 2022 at 10:20)</a>:</h4>
<p><code>multiplicative nat</code> means "treat nat as a monoid with group law which is mathematically <code>+</code> but now which is written with notation <code>*</code>"</p>



<a name="266791316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266791316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266791316">(Jan 04 2022 at 10:25)</a>:</h4>
<p>If you talk to me of “ℕ as a multiplicative monoid”, I will understand nonnegative integers with product.</p>



<a name="266791623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266791623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266791623">(Jan 04 2022 at 10:29)</a>:</h4>
<p>I had tried Johan's suggestion, but I got this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">test</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→*</span> <span class="n">M</span><span class="o">}</span>  <span class="o">:</span>  <span class="o">(</span><span class="n">multiset.map</span> <span class="n">f</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">m.sum</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">multiset.prod_hom</span> <span class="o">,</span>
<span class="c1">-- needs to prove ⇑f m.prod = ⇑f m.sum</span>
<span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="266791638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266791638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266791638">(Jan 04 2022 at 10:29)</a>:</h4>
<p><code>refl</code>!</p>



<a name="266791641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266791641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266791641">(Jan 04 2022 at 10:29)</a>:</h4>
<p>"ℕ as a multiplicative monoid' is just called ℕ in mathlib</p>



<a name="266791764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266791764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266791764">(Jan 04 2022 at 10:31)</a>:</h4>
<p>No not refl, this lemma looks false to me</p>



<a name="266791787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266791787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266791787">(Jan 04 2022 at 10:31)</a>:</h4>
<p>-&gt;* means "preserves multiplication"</p>



<a name="266791889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266791889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266791889">(Jan 04 2022 at 10:32)</a>:</h4>
<p><code>multiplicative X</code> means "turn this additive monoid into a multiplicative monoid by defining multiplication to be addition"</p>



<a name="266791903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266791903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266791903">(Jan 04 2022 at 10:32)</a>:</h4>
<p>• <code>ℕ</code> is a <code>monoid</code> and an <code>add_monoid</code>.<br>
• <code>multiplicative ℕ</code> is the additive monoid <code>ℕ</code>, but viewed as multiplicative monoid, so with notation <code>*</code>.<br>
• <code>additive ℕ</code> is the multiplicative monoid <code>ℕ</code>, but viewed as additive monoid, so with notation <code>+</code>.</p>



<a name="266792292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266792292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266792292">(Jan 04 2022 at 10:36)</a>:</h4>
<p>I am not sure if this will help, but <code>multiplicative ℕ</code>is Lean's way of dealing with, for instance, the submonoid of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><msub><mi>L</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi mathvariant="double-struck">Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">SL_2(\mathbb{Z})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbb">Z</span><span class="mclose">)</span></span></span></span> generated by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\begin{pmatrix} 1 &amp; 1 \\ 0 &amp; 1 \end{pmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span>.  The submonoid is isomorphic to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">N</mi><mo separator="true">,</mo><mo>+</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(ℕ, +)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord amsrm">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">+</span><span class="mclose">)</span></span></span></span>, but the group operation is multiplication.</p>
<p>I hope that this helps!</p>



<a name="266793403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266793403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266793403">(Jan 04 2022 at 10:49)</a>:</h4>
<p>This is irrelevant to my question, but how does one summon<code>ℕ</code> as a monoid with <em>multiplication</em> of integers ?</p>



<a name="266793446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266793446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266793446">(Jan 04 2022 at 10:50)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/nat.comm_monoid">docs#nat.comm_monoid</a> (assuming you mean multiplication of naturals, not multiplication of integers)</p>



<a name="266793554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266793554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266793554">(Jan 04 2022 at 10:51)</a>:</h4>
<p><span class="user-mention" data-user-id="130609">@Antoine Chambert-Loir</span> By doing nothing. That's the default.</p>



<a name="266793675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266793675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266793675">(Jan 04 2022 at 10:52)</a>:</h4>
<p>In informal maths, we infer <em>a lot</em> about what's going on, by choosing suggestive notation. You can quickly drive someone crazy by using <code>▸</code> and <code>↑</code> as the two binary operations in a random ring.</p>



<a name="266793697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266793697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266793697">(Jan 04 2022 at 10:52)</a>:</h4>
<p>To counter this, in mathlib you can <em>only</em> use <code>*</code> and <code>+</code> for ring operations.</p>



<a name="266793723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266793723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266793723">(Jan 04 2022 at 10:52)</a>:</h4>
<p>This is unfortunate, because it means you cannot use <code>∘</code> for endomorphism rings.</p>



<a name="266793731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266793731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266793731">(Jan 04 2022 at 10:53)</a>:</h4>
<p>But in practice, this seems to be only a minor downside.</p>



<a name="266793936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266793936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266793936">(Jan 04 2022 at 10:55)</a>:</h4>
<p>The other two downsides are:</p>
<ol>
<li>you have to develop the theory of monoids and groups twice: once for <code>*</code> and once for <code>+</code>. But the tactic <code>to_additive</code> takes care of the duplication, so it's not a very big problem</li>
<li>you cannot have group/monoid homomorphisms <code>G → H</code> if <code>G</code> uses <code>*</code>-notation and <code>H</code> uses <code>+</code>-notation. This is where the "switch notation" type wrappers <code>additive</code> and <code>multiplicative</code> come in. Because you can have a <code>*</code>-preserving monoid hom <code>G →* multiplicative H</code>.</li>
</ol>



<a name="266793951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266793951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266793951">(Jan 04 2022 at 10:55)</a>:</h4>
<p>Altogether, I find this philosophically very unsatisfactory. But in practice it works very well.</p>



<a name="266794045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266794045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266794045">(Jan 04 2022 at 10:56)</a>:</h4>
<p>I've spent many hours dreaming about a better way to tackle the issue. But if you try to do the "mathematically" correct thing, I can never save the nice notation that we have now. And giving up <code>+</code> and <code>*</code> seems too big a price to pay.</p>



<a name="266794101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266794101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266794101">(Jan 04 2022 at 10:57)</a>:</h4>
<p>So, long story short. By default <code>+</code> on <code>ℕ</code> means the addition you are used to. And <code>*</code> means the multiplication that you expect.</p>



<a name="266794137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266794137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266794137">(Jan 04 2022 at 10:57)</a>:</h4>
<p>And Lean can handle both at the same time, because it has two duplicated hierarchies of semigroups/monoids/groups: one for <code>+</code> and one for <code>*</code>.</p>



<a name="266796476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266796476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266796476">(Jan 04 2022 at 11:22)</a>:</h4>
<p>And, importantly here, when you’re using <code>nat</code> in a way that uses its multiplicative structure you can just write <code>nat</code> and Lean knows what you mean — right?</p>



<a name="266796722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266796722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stuart Presnell <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266796722">(Jan 04 2022 at 11:24)</a>:</h4>
<p>i.e. you don’t write something like <code>(nat, *, 1)</code></p>



<a name="266797213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266797213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266797213">(Jan 04 2022 at 11:31)</a>:</h4>
<p>OK. I understand that  if I talk about <code>multiplicative \nat</code> (as a monoid), I get natural numbers and the law is addition written <code>*</code>, while if a talk about <code>\nat</code> (again as a monoid), I get natural numbers with multiplication denoted <code>*</code>.</p>



<a name="266797398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266797398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266797398">(Jan 04 2022 at 11:33)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> What I find unsatisfactory is the use of the adjective <code>multiplicative</code> to mean the opposite of what (I believe) we (I) would say in math. Otherwise, I think I understand the issues you describe.</p>



<a name="266797473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266797473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266797473">(Jan 04 2022 at 11:34)</a>:</h4>
<p>Maybe <code>multiplicatively</code>and <code>additively</code>would be better. But I'm nothing here to revert terminology.</p>



<a name="266798336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266798336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266798336">(Jan 04 2022 at 11:45)</a>:</h4>
<p><span class="user-mention" data-user-id="130609">@Antoine Chambert-Loir</span> That makes sense.</p>



<a name="266798396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266798396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266798396">(Jan 04 2022 at 11:45)</a>:</h4>
<p>I guess, in a context where a type doesn't have both notations yet, it would be less confusing. Say, you have some abstract additive group <code>G</code>. Then <code>multiplicative G</code> is probably unambiguous.</p>



<a name="266823373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266823373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266823373">(Jan 04 2022 at 15:46)</a>:</h4>
<p>What's going on here?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.big_operators.basic</span>
<span class="kn">import</span> <span class="n">algebra.group_power.lemmas</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">prod_pow_eq_pow_sum</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">multiset.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">a</span><span class="bp">^</span><span class="n">n</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">^</span> <span class="n">m.sum</span> <span class="o">:=</span>
<span class="c1">-- multiset.induction_on m (by simp) (λ n m h, by simp [h,pow_add])</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">multiset.prod_hom</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">α</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">m.map</span> <span class="n">multiplicative.of_add</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">powers_hom</span> <span class="n">α</span> <span class="n">a</span><span class="o">,</span>  <span class="c1">-- exact fails</span>
  <span class="n">dunfold</span> <span class="n">multiplicative.mul_one_class</span> <span class="n">has_one.one</span><span class="o">,</span>  <span class="c1">-- fails without this</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>Why do I have to unfold <code>has_one.one</code> to get lean to see the instances are equal?</p>



<a name="266824564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266824564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266824564">(Jan 04 2022 at 15:55)</a>:</h4>
<p>(mwe'd at <a href="#narrow/stream/113488-general/topic/Diamond.20in.20multiplicative.20nat/near/266824443">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Diamond.20in.20multiplicative.20nat/near/266824443</a>)</p>



<a name="266831542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266831542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266831542">(Jan 04 2022 at 16:37)</a>:</h4>
<p><code>ext, refl</code> works after the <code>convert</code>, so this is something to do with equality of structures. If you make the terms involved directly then it seems to work fine:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">X</span> <span class="o">:</span> <span class="n">mul_one_class.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="o">(</span><span class="n">multiplicative.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span>
    <span class="bp">@</span><span class="n">monoid.to_mul_one_class.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span>
      <span class="o">(</span><span class="n">multiplicative.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">comm_monoid.to_monoid.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="o">(</span><span class="n">multiplicative.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">multiplicative.comm_monoid.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.add_comm_monoid</span><span class="o">)),</span>

  <span class="k">let</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">mul_one_class.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="o">(</span><span class="n">multiplicative.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span>
    <span class="bp">@</span><span class="n">multiplicative.mul_one_class.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">add_monoid.to_add_zero_class.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.add_monoid</span><span class="o">),</span>

  <span class="k">let</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">mul_one_class.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="o">(</span><span class="n">multiplicative.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">mul_one_class.mk.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="o">(</span><span class="n">multiplicative.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">coe_fn.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">equiv.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="n">multiplicative.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span><span class="o">))</span>
     <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">equiv.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="n">multiplicative.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span><span class="o">)),</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">multiplicative.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span><span class="o">)</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">equiv.has_coe_to_fun.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="n">multiplicative.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span><span class="o">))</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">multiplicative.of_add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span><span class="o">)</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">has_zero.zero.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">add_zero_class.to_has_zero.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">add_monoid.to_add_zero_class.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.add_monoid</span><span class="o">))))</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">has_mul.mul.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="o">(</span><span class="n">multiplicative.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span><span class="o">)</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">multiplicative.has_mul.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">add_zero_class.to_has_add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">add_monoid.to_add_zero_class.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.add_monoid</span><span class="o">))))</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">multiplicative.mul_one_class._proof_1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">add_monoid.to_add_zero_class.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.add_monoid</span><span class="o">))</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">multiplicative.mul_one_class._proof_2.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">add_monoid.to_add_zero_class.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.add_monoid</span><span class="o">)),</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Z</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">=</span> <span class="n">Z</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span>
  <span class="n">trivial</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="266833014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/multiset%20%3A%20convert%20prod%20of%20pow%20to%20pow%20of%20sum/near/266833014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/multiset.20.3A.20convert.20prod.20of.20pow.20to.20pow.20of.20sum.html#266833014">(Jan 04 2022 at 16:48)</a>:</h4>
<p>Reid's diagnosis in the other thread is that this is an elaborator bug</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type.html">Working with homemade inductive type</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="237753606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20homemade%20inductive%20type/near/237753606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Kempster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type.html#237753606">(May 07 2021 at 01:10)</a>:</h4>
<p>Hi all. I'm trying to prove the correctness of the definition of the union of two ε-NFAs, but I've gotten stuck. This should be an MWE, if you paste it in the middle of <code>src/computability/epsilon_nfa.lean</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">sum</span>

<span class="kd">inductive</span> <span class="n">union_step</span> <span class="o">(</span><span class="n">M'</span> <span class="o">:</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="n">σ'</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">⊕</span> <span class="n">σ'</span><span class="o">)</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="o">(</span><span class="n">option</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">⊕</span> <span class="n">σ'</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">start</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">σ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">M.start</span><span class="o">)</span> <span class="o">:</span> <span class="n">union_step</span> <span class="n">none</span> <span class="n">none</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">inl</span> <span class="n">s</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">start'</span> <span class="o">(</span><span class="n">s'</span> <span class="o">:</span> <span class="n">σ'</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s'</span> <span class="bp">∈</span> <span class="n">M'.start</span><span class="o">)</span> <span class="o">:</span> <span class="n">union_step</span> <span class="n">none</span> <span class="n">none</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">inr</span> <span class="n">s'</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">step</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">σ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M.step</span> <span class="n">s</span> <span class="n">a</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">union_step</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">inl</span> <span class="n">s</span><span class="o">))</span> <span class="n">a</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">inl</span> <span class="n">t</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">step'</span> <span class="o">(</span><span class="n">s'</span> <span class="n">t'</span> <span class="o">:</span> <span class="n">σ'</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M'.step</span> <span class="n">s'</span> <span class="n">a</span> <span class="n">t'</span><span class="o">)</span> <span class="o">:</span> <span class="n">union_step</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">inr</span> <span class="n">s'</span><span class="o">))</span> <span class="n">a</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">inr</span> <span class="n">t'</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">union</span> <span class="o">(</span><span class="n">M'</span> <span class="o">:</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="n">σ'</span><span class="o">)</span> <span class="o">:</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="o">(</span><span class="n">option</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">⊕</span> <span class="n">σ'</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">step</span> <span class="o">:=</span> <span class="n">union_step</span> <span class="n">M</span> <span class="n">M'</span><span class="o">,</span>
  <span class="n">start</span> <span class="o">:=</span> <span class="o">{</span><span class="n">none</span><span class="o">},</span>
  <span class="n">accept</span> <span class="o">:=</span> <span class="o">{(</span><span class="n">some</span> <span class="o">(</span><span class="n">inl</span> <span class="n">s</span><span class="o">))</span> <span class="bp">|</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">M.accept</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">{(</span><span class="n">some</span> <span class="o">(</span><span class="n">inr</span> <span class="n">s'</span><span class="o">))</span> <span class="bp">|</span> <span class="n">s'</span> <span class="bp">∈</span> <span class="n">M'.accept</span><span class="o">}</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">union_step_once</span> <span class="o">(</span><span class="n">M'</span> <span class="o">:</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="n">σ'</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">M.union</span> <span class="n">M'</span><span class="o">)</span><span class="bp">.</span><span class="n">step</span> <span class="n">none</span> <span class="n">none</span> <span class="bp">=</span> <span class="o">{(</span><span class="n">some</span> <span class="o">(</span><span class="n">inl</span> <span class="n">s</span><span class="o">))</span> <span class="bp">|</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">M.start</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">{(</span><span class="n">some</span> <span class="o">(</span><span class="n">inr</span> <span class="n">s'</span><span class="o">))</span> <span class="bp">|</span> <span class="n">s'</span> <span class="bp">∈</span> <span class="n">M'.start</span><span class="o">}</span>
  <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">union</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="c1">-- cases union_step, -- here?</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Within union_step_once we end up with a state like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
  <span class="n">σ</span> <span class="n">σ'</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">M</span> <span class="o">:</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="n">σ</span><span class="o">,</span>
  <span class="n">M'</span> <span class="o">:</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="n">σ'</span><span class="o">,</span>
  <span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span>
  <span class="bp">⊢</span> <span class="n">M.union_step</span> <span class="n">M'</span> <span class="n">none</span> <span class="n">none</span> <span class="bp">=</span>
      <span class="o">{</span><span class="n">_x</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">⊕</span> <span class="n">σ'</span><span class="o">)</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">σ</span><span class="o">),</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">M.start</span> <span class="bp">∧</span> <span class="n">some</span> <span class="o">(</span><span class="n">inl</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">_x</span><span class="o">}</span> <span class="bp">∪</span>
        <span class="o">{</span><span class="n">_x</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">⊕</span> <span class="n">σ'</span><span class="o">)</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">s'</span> <span class="o">:</span> <span class="n">σ'</span><span class="o">),</span> <span class="n">s'</span> <span class="bp">∈</span> <span class="n">M'.start</span> <span class="bp">∧</span> <span class="n">some</span> <span class="o">(</span><span class="n">inr</span> <span class="n">s'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">_x</span><span class="o">}</span>
</code></pre></div>
<p>The <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> is that I want to obtain the fact that <code>M.union_step M' none none</code> must either be <code>(some (inl s))</code> or <code>(some (inr s'))</code> by the definition of <code>union_step</code>. I would have thought <code>cases</code> or something similar to it would have helped, but no matter what I do, I end up with an error like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">cases</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">it</span> <span class="n">is</span> <span class="n">not</span> <span class="n">applicable</span> <span class="n">to</span> <span class="n">the</span> <span class="n">given</span> <span class="n">hypothesis</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="n">σ</span> <span class="n">σ'</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">,</span>
<span class="n">M</span> <span class="o">:</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="n">σ</span><span class="o">,</span>
<span class="n">M'</span> <span class="o">:</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="n">σ'</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span>
<span class="n">_x</span> <span class="o">:</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="n">σ</span> <span class="bp">→</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="n">σ'</span> <span class="bp">→</span> <span class="n">option</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">⊕</span> <span class="n">σ'</span><span class="o">)</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="o">(</span><span class="n">option</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">⊕</span> <span class="n">σ'</span><span class="o">))</span>
<span class="bp">⊢</span> <span class="n">_x</span> <span class="n">M</span> <span class="n">M'</span> <span class="n">none</span> <span class="n">none</span> <span class="bp">=</span>
    <span class="o">{</span><span class="n">_x</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">⊕</span> <span class="n">σ'</span><span class="o">)</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">σ</span><span class="o">),</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">M.start</span> <span class="bp">∧</span> <span class="n">some</span> <span class="o">(</span><span class="n">inl</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">_x</span><span class="o">}</span> <span class="bp">∪</span>
      <span class="o">{</span><span class="n">_x</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">⊕</span> <span class="n">σ'</span><span class="o">)</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">s'</span> <span class="o">:</span> <span class="n">σ'</span><span class="o">),</span> <span class="n">s'</span> <span class="bp">∈</span> <span class="n">M'.start</span> <span class="bp">∧</span> <span class="n">some</span> <span class="o">(</span><span class="n">inr</span> <span class="n">s'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">_x</span><span class="o">}</span>
</code></pre></div>
<p>and I'm not sure why. The cases tactic is apparently not applicable, but the <code>_x</code> substitution you can see in the state looks reasonable. It looks even more reasonable when you do something like <code>cases M.union_step M' none none</code>, but the same error occurs.</p>
<p>How do I prove my <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a>, and how do I work with this inductive type in general? In fact, have I even defined it correctly? Thanks :)</p>



<a name="237755055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20homemade%20inductive%20type/near/237755055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type.html#237755055">(May 07 2021 at 01:31)</a>:</h4>
<p>By the way, <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> means that you should make it work in a free standing file, which imports <code>computability.epsilon_nfa</code> and has the necessary namespace and variable declarations</p>



<a name="237755453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20homemade%20inductive%20type/near/237755453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type.html#237755453">(May 07 2021 at 01:36)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">computability.epsilon_NFA</span>
<span class="kn">open</span> <span class="n">sum</span>
<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">σ</span> <span class="n">σ'</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="n">σ</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">ε_NFA</span>

<span class="kd">inductive</span> <span class="n">union_step</span> <span class="o">(</span><span class="n">M'</span> <span class="o">:</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="n">σ'</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">⊕</span> <span class="n">σ'</span><span class="o">)</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="o">(</span><span class="n">option</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">⊕</span> <span class="n">σ'</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">start</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">σ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">M.start</span><span class="o">)</span> <span class="o">:</span> <span class="n">union_step</span> <span class="n">none</span> <span class="n">none</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">inl</span> <span class="n">s</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">start'</span> <span class="o">(</span><span class="n">s'</span> <span class="o">:</span> <span class="n">σ'</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s'</span> <span class="bp">∈</span> <span class="n">M'.start</span><span class="o">)</span> <span class="o">:</span> <span class="n">union_step</span> <span class="n">none</span> <span class="n">none</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">inr</span> <span class="n">s'</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">step</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">σ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M.step</span> <span class="n">s</span> <span class="n">a</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">union_step</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">inl</span> <span class="n">s</span><span class="o">))</span> <span class="n">a</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">inl</span> <span class="n">t</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">step'</span> <span class="o">(</span><span class="n">s'</span> <span class="n">t'</span> <span class="o">:</span> <span class="n">σ'</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M'.step</span> <span class="n">s'</span> <span class="n">a</span> <span class="n">t'</span><span class="o">)</span> <span class="o">:</span> <span class="n">union_step</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">inr</span> <span class="n">s'</span><span class="o">))</span> <span class="n">a</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">inr</span> <span class="n">t'</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">union</span> <span class="o">(</span><span class="n">M'</span> <span class="o">:</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="n">σ'</span><span class="o">)</span> <span class="o">:</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="o">(</span><span class="n">option</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">⊕</span> <span class="n">σ'</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">step</span> <span class="o">:=</span> <span class="n">union_step</span> <span class="n">M</span> <span class="n">M'</span><span class="o">,</span>
  <span class="n">start</span> <span class="o">:=</span> <span class="o">{</span><span class="n">none</span><span class="o">},</span>
  <span class="n">accept</span> <span class="o">:=</span> <span class="o">{(</span><span class="n">some</span> <span class="o">(</span><span class="n">inl</span> <span class="n">s</span><span class="o">))</span> <span class="bp">|</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">M.accept</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">{(</span><span class="n">some</span> <span class="o">(</span><span class="n">inr</span> <span class="n">s'</span><span class="o">))</span> <span class="bp">|</span> <span class="n">s'</span> <span class="bp">∈</span> <span class="n">M'.accept</span><span class="o">}</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">union_step_once</span> <span class="o">(</span><span class="n">M'</span> <span class="o">:</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="n">σ'</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">M.union</span> <span class="n">M'</span><span class="o">)</span><span class="bp">.</span><span class="n">step</span> <span class="n">none</span> <span class="n">none</span> <span class="bp">=</span> <span class="o">{(</span><span class="n">some</span> <span class="o">(</span><span class="n">inl</span> <span class="n">s</span><span class="o">))</span> <span class="bp">|</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">M.start</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">{(</span><span class="n">some</span> <span class="o">(</span><span class="n">inr</span> <span class="n">s'</span><span class="o">))</span> <span class="bp">|</span> <span class="n">s'</span> <span class="bp">∈</span> <span class="n">M'.start</span><span class="o">}</span>
  <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">union</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="c1">-- cases union_step, -- here?</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">ε_NFA</span>
</code></pre></div>



<a name="237755785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20homemade%20inductive%20type/near/237755785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type.html#237755785">(May 07 2021 at 01:41)</a>:</h4>
<p>You are proving an equality of sets, so you need to apply extensionality and split into the two implication directions. In each case you then get an inductive hypothesis that you can destructure to get the two cases.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">union_step_once</span> <span class="o">(</span><span class="n">M'</span> <span class="o">:</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="n">σ'</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">M.union</span> <span class="n">M'</span><span class="o">)</span><span class="bp">.</span><span class="n">step</span> <span class="n">none</span> <span class="n">none</span> <span class="bp">=</span> <span class="o">{(</span><span class="n">some</span> <span class="o">(</span><span class="n">inl</span> <span class="n">s</span><span class="o">))</span> <span class="bp">|</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">M.start</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">{(</span><span class="n">some</span> <span class="o">(</span><span class="n">inr</span> <span class="n">s'</span><span class="o">))</span> <span class="bp">|</span> <span class="n">s'</span> <span class="bp">∈</span> <span class="n">M'.start</span><span class="o">}</span>
  <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">union</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">(⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="bp">|</span> <span class="n">_</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="bp">|</span> <span class="n">_</span><span class="o">),</span>
    <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
    <span class="o">{</span> <span class="gr">sorry</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">(⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩),</span>
    <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
    <span class="o">{</span> <span class="gr">sorry</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="237757112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20homemade%20inductive%20type/near/237757112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Kempster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type.html#237757112">(May 07 2021 at 02:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type/near/237755785">said</a>:</p>
<blockquote>
<p>You are proving an equality of sets, so you need to apply extensionality and split into the two implication directions. In each case you then get an inductive hypothesis that you can destructure to get the two cases.</p>
</blockquote>
<p>Thank you for the reply! However I'm afraid this leaves me with more questions than it answers.</p>
<p>The original question still applies. All the sorries still involve <code>union_step</code>, which is the main point of my post; I don't know how to destructure it.</p>
<p>I spent a bunch of time trying to understand <code>rcases</code> the other day, and although I made some progress, I can't <em>fully</em> claim to understand the line <code>rintro (⟨s, h⟩ | _ | ⟨s, h⟩ | _)</code> here. I hesitate to ask you to explain this, though, because I think I <em>partially</em> understand it, and can generally fake it until I make it when it comes to rcases nowadays.</p>



<a name="237757699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20homemade%20inductive%20type/near/237757699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type.html#237757699">(May 07 2021 at 02:07)</a>:</h4>
<blockquote>
<p>The original question still applies. All the sorries still involve union_step, which is the main point of my post; I don't know how to destructure it.</p>
</blockquote>
<p>The version of <code>cases union_step</code> in my code is <code>rintro (⟨s, h⟩ | _ | ⟨s, h⟩ | _),</code>, which you can also write <code>intro h, cases h</code></p>



<a name="237757763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20homemade%20inductive%20type/near/237757763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type.html#237757763">(May 07 2021 at 02:08)</a>:</h4>
<p>the point being that you don't case on the <em>type</em> <code>union_step</code> but rather a variable whose type is <code>union_step</code>, in this case <code>h</code></p>



<a name="237758101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20homemade%20inductive%20type/near/237758101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type.html#237758101">(May 07 2021 at 02:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="401024">Matt Kempster</span> <a href="#narrow/stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type/near/237757112">said</a>:</p>
<blockquote>
<p>I spent a bunch of time trying to understand <code>rcases</code> the other day, and although I made some progress, I can't <em>fully</em> claim to understand the line <code>rintro (⟨s, h⟩ | _ | ⟨s, h⟩ | _)</code> here. I hesitate to ask you to explain this, though, because I think I <em>partially</em> understand it, and can generally fake it until I make it when it comes to rcases nowadays.</p>
</blockquote>
<p>The <code>rintro</code> line can be expanded as I said to <code>intro H, rcases H with ⟨s, h⟩ | _ | ⟨s, h⟩ | _</code>. The contents of the pattern there correspond to the four constructors of the inductive type <code>union_step</code>. Two of them are impossible due to the parameters, but <code>rcases</code> requires that you put something there anyway so that's the <code>_</code> cases. The other two need names for the arguments to the constructors, which we are calling <code>s, h</code> here. We are left with two goals for the two non-impossible cases, and <code>s, h</code> are new variables introduced in each of them.</p>
<p>You can do the same thing with plain <code>cases</code>, but the bindings are less structured so it looks like <code>intro H, cases H with s h _ _ s h _ _</code> or something like that.</p>



<a name="237758196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20homemade%20inductive%20type/near/237758196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type.html#237758196">(May 07 2021 at 02:14)</a>:</h4>
<p>Actually there is a typo, the two impossible cases are cases 3 and 4, not 2 and 4, so it should actually read <code>rintro (⟨s, h⟩ | ⟨s, h⟩ | _ | _),</code></p>



<a name="237759112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20homemade%20inductive%20type/near/237759112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type.html#237759112">(May 07 2021 at 02:27)</a>:</h4>
<p>by the way, I think your NFA has one more state than necessary:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">union_step</span> <span class="o">(</span><span class="n">M'</span> <span class="o">:</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="n">σ'</span><span class="o">)</span> <span class="o">:</span> <span class="n">σ</span> <span class="bp">⊕</span> <span class="n">σ'</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">⊕</span> <span class="n">σ'</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">left</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">σ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M.step</span> <span class="n">s</span> <span class="n">a</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">union_step</span> <span class="o">(</span><span class="n">inl</span> <span class="n">s</span><span class="o">)</span> <span class="n">a</span> <span class="o">(</span><span class="n">inl</span> <span class="n">t</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">right</span> <span class="o">(</span><span class="n">s'</span> <span class="n">t'</span> <span class="o">:</span> <span class="n">σ'</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M'.step</span> <span class="n">s'</span> <span class="n">a</span> <span class="n">t'</span><span class="o">)</span> <span class="o">:</span> <span class="n">union_step</span> <span class="o">(</span><span class="n">inr</span> <span class="n">s'</span><span class="o">)</span> <span class="n">a</span> <span class="o">(</span><span class="n">inr</span> <span class="n">t'</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">union</span> <span class="o">(</span><span class="n">M'</span> <span class="o">:</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="n">σ'</span><span class="o">)</span> <span class="o">:</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">⊕</span> <span class="n">σ'</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">step</span> <span class="o">:=</span> <span class="n">union_step</span> <span class="n">M</span> <span class="n">M'</span><span class="o">,</span>
  <span class="n">start</span> <span class="o">:=</span> <span class="n">sum.elim</span> <span class="n">M.start</span> <span class="n">M'.start</span><span class="o">,</span>
  <span class="n">accept</span> <span class="o">:=</span> <span class="n">sum.elim</span> <span class="n">M.accept</span> <span class="n">M'.accept</span> <span class="o">}</span>
</code></pre></div>



<a name="237759162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20homemade%20inductive%20type/near/237759162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Kempster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type.html#237759162">(May 07 2021 at 02:28)</a>:</h4>
<p>Aha! With the typo explained, I think I am starting to understand this now.</p>
<p>However I still require some hand-holding <span aria-label="persevere" class="emoji emoji-1f623" role="img" title="persevere">:persevere:</span> I'm not at all sure how to proceed here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">union_step_once</span> <span class="o">(</span><span class="n">M'</span> <span class="o">:</span> <span class="n">ε_NFA</span> <span class="n">α</span> <span class="n">σ'</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">M.union</span> <span class="n">M'</span><span class="o">)</span><span class="bp">.</span><span class="n">step</span> <span class="n">none</span> <span class="n">none</span> <span class="bp">=</span> <span class="o">{(</span><span class="n">some</span> <span class="o">(</span><span class="n">inl</span> <span class="n">s</span><span class="o">))</span> <span class="bp">|</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">M.start</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">{(</span><span class="n">some</span> <span class="o">(</span><span class="n">inr</span> <span class="n">s'</span><span class="o">))</span> <span class="bp">|</span> <span class="n">s'</span> <span class="bp">∈</span> <span class="n">M'.start</span><span class="o">}</span>
  <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">(⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="bp">|</span> <span class="n">_</span> <span class="bp">|</span> <span class="n">_</span><span class="o">),</span>
    <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
    <span class="o">{</span> <span class="gr">sorry</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">(⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩),</span>
    <span class="o">{</span>
      <span class="c">/-</span><span class="cm"></span>
<span class="cm">        α : Type u,</span>
<span class="cm">        σ σ' : Type v,</span>
<span class="cm">        M : ε_NFA α σ,</span>
<span class="cm">        M' : ε_NFA α σ',</span>
<span class="cm">        x : list α,</span>
<span class="cm">        s : σ,</span>
<span class="cm">        h : s ∈ M.start</span>
<span class="cm">        ⊢ some (inl s) ∈ (M.union M').step none none</span>
<span class="cm">      -/</span>
      <span class="gr">sorry</span> <span class="o">},</span>
    <span class="o">{</span> <span class="gr">sorry</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>Once again it is the union_step that is causing me pain. I have tried doing things like <code>let S :=  (M.union M').step none none</code> and <code>cases S...</code> but I'm hitting the same issue as before. This means I have some sort of conceptual misunderstanding.</p>
<p>Where do I begin on this side of the proof?</p>



<a name="237759286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20homemade%20inductive%20type/near/237759286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type.html#237759286">(May 07 2021 at 02:30)</a>:</h4>
<p>what you want there is <code>apply union_step.start,</code>, although <code>constructor</code> will magically pick the right constructor to use</p>



<a name="237759309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20homemade%20inductive%20type/near/237759309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type.html#237759309">(May 07 2021 at 02:30)</a>:</h4>
<p>In order to construct elements of an inductive type we use the constructors</p>



<a name="237759365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20homemade%20inductive%20type/near/237759365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type.html#237759365">(May 07 2021 at 02:31)</a>:</h4>
<p>In this case we want to prove  <code>(M.union M').step none none (some (inl s))</code> and that's literally the statement of <code>union_step.start</code>, except it needs <code>s ∈ M.start</code> which we have in the context</p>



<a name="237759376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20homemade%20inductive%20type/near/237759376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type.html#237759376">(May 07 2021 at 02:31)</a>:</h4>
<p>so <code>exact union_step.start _ h</code> works</p>



<a name="237760068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20with%20homemade%20inductive%20type/near/237760068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Kempster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20with.20homemade.20inductive.20type.html#237760068">(May 07 2021 at 02:42)</a>:</h4>
<p>Ahhh! This is all starting to make sense here. I don't have much else to add for now other than "it makes sense I think", so thank you!!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
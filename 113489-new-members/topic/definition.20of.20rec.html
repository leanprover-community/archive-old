---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/definition.20of.20rec.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html">definition of rec</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="210657558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210657558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fames Yasd <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210657558">(Sep 20 2020 at 09:18)</a>:</h4>
<p>I'm working on the chapter "inductive types" in "theorem proving in lean"<br>
And I was thinking for several hours trying to understand the definition of weekday.rec and how it can be used to define and evaluate functions such as "number_of_day" in the example below but I can not get it.<br>
I think I understood it in the case when C goes from weekday to Prop so I can see how it can be used to prove properties about weekdays but in the case with "number_of_day" I have no idea what C is. I have tried with C that has type weekday-&gt;Type and for each d : weekday returns nat but it's not working.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">weekday</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">sunday</span> <span class="o">:</span> <span class="n">weekday</span>
<span class="bp">|</span> <span class="n">monday</span> <span class="o">:</span> <span class="n">weekday</span>
<span class="bp">|</span> <span class="n">tuesday</span> <span class="o">:</span> <span class="n">weekday</span>
<span class="bp">|</span> <span class="n">wednesday</span> <span class="o">:</span> <span class="n">weekday</span>
<span class="bp">|</span> <span class="n">thursday</span> <span class="o">:</span> <span class="n">weekday</span>
<span class="bp">|</span> <span class="n">friday</span> <span class="o">:</span> <span class="n">weekday</span>
<span class="bp">|</span> <span class="n">saturday</span> <span class="o">:</span> <span class="n">weekday</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">weekday</span><span class="bp">.</span><span class="n">rec</span>

<span class="n">def</span> <span class="n">number_of_day</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">weekday</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="n">weekday</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">d</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">number_of_day</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">number_of_day</span> <span class="n">weekday</span><span class="bp">.</span><span class="n">sunday</span>
</code></pre></div>



<a name="210658044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210658044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210658044">(Sep 20 2020 at 09:33)</a>:</h4>
<p>basically the type of the output can depend on the weekday</p>



<a name="210658047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210658047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210658047">(Sep 20 2020 at 09:33)</a>:</h4>
<p>i.e. it is a function on the weekday</p>



<a name="210658050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210658050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210658050">(Sep 20 2020 at 09:33)</a>:</h4>
<p>i.e. a function <code>weekday -&gt; Type*</code></p>



<a name="210658095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210658095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210658095">(Sep 20 2020 at 09:34)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">implicit</span> <span class="n">true</span>
<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">structure_projections</span> <span class="n">false</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">number_of_day</span>
</code></pre></div>



<a name="210658265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210658265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210658265">(Sep 20 2020 at 09:41)</a>:</h4>
<p>Have you checked the type of weekday.rec_on with <code>#check @weekday.rec_on</code>? It's a function, so checking its type will tell you where it goes from and to</p>



<a name="210658504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210658504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fames Yasd <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210658504">(Sep 20 2020 at 09:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span><br>
yes, I checked the type, I don't understand how it's working<br>
look</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">weekday</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">sunday</span> <span class="o">:</span> <span class="n">weekday</span>
<span class="bp">|</span> <span class="n">monday</span> <span class="o">:</span> <span class="n">weekday</span>
<span class="bp">|</span> <span class="n">tuesday</span> <span class="o">:</span> <span class="n">weekday</span>
<span class="bp">|</span> <span class="n">wednesday</span> <span class="o">:</span> <span class="n">weekday</span>
<span class="bp">|</span> <span class="n">thursday</span> <span class="o">:</span> <span class="n">weekday</span>
<span class="bp">|</span> <span class="n">friday</span> <span class="o">:</span> <span class="n">weekday</span>
<span class="bp">|</span> <span class="n">saturday</span> <span class="o">:</span> <span class="n">weekday</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">weekday</span><span class="bp">.</span><span class="n">rec</span>

<span class="n">def</span> <span class="n">number_of_day</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">weekday</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="n">weekday</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">d</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">number_of_day</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">number_of_day</span> <span class="n">weekday</span><span class="bp">.</span><span class="n">sunday</span>

<span class="n">def</span> <span class="n">number_of_day2</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">weekday</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">weekday</span><span class="o">),</span>
<span class="bp">@</span><span class="n">weekday</span><span class="bp">.</span><span class="n">rec_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="bp">_</span><span class="n">x</span> <span class="o">:</span> <span class="n">weekday</span><span class="o">),</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="n">d</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span>


<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">implicit</span> <span class="n">true</span>
<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">structure_projections</span> <span class="n">false</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">number_of_day</span>

<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">weekday</span><span class="bp">.</span><span class="n">rec_on</span>
</code></pre></div>


<p>I copypasted the definition from "number_of_day" to "number_of_day2" and it's not working!</p>



<a name="210658571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210658571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210658571">(Sep 20 2020 at 09:50)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">number_of_day2</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">weekday</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">weekday</span><span class="bp">.</span><span class="n">rec_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="bp">_</span><span class="n">x</span> <span class="o">:</span> <span class="n">weekday</span><span class="o">),</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="n">d</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span>
</code></pre></div>



<a name="210658595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210658595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fames Yasd <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210658595">(Sep 20 2020 at 09:52)</a>:</h4>
<p>why does it show an incorrect definition?</p>



<a name="210658635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210658635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210658635">(Sep 20 2020 at 09:52)</a>:</h4>
<p>can you copy the error?</p>



<a name="210658644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210658644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210658644">(Sep 20 2020 at 09:52)</a>:</h4>
<p>when you print it, it moves everything after the colon</p>



<a name="210658647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210658647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fames Yasd <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210658647">(Sep 20 2020 at 09:52)</a>:</h4>
<p>on both of them it says</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">number_of_day</span> <span class="o">:</span> <span class="n">weekday</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">weekday</span><span class="o">),</span> <span class="bp">@</span><span class="n">weekday</span><span class="bp">.</span><span class="n">rec_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="bp">_</span><span class="n">x</span> <span class="o">:</span> <span class="n">weekday</span><span class="o">),</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="n">d</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span>
</code></pre></div>



<a name="210658649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210658649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210658649">(Sep 20 2020 at 09:52)</a>:</h4>
<p>look at the printed result carefully</p>



<a name="210658661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210658661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fames Yasd <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210658661">(Sep 20 2020 at 09:53)</a>:</h4>
<p>I think I see</p>



<a name="210658705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210658705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fames Yasd <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210658705">(Sep 20 2020 at 09:54)</a>:</h4>
<p>okay, can you explain how does it compute with this definition?</p>



<a name="210658706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210658706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fames Yasd <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210658706">(Sep 20 2020 at 09:54)</a>:</h4>
<p>like why</p>
<div class="codehilite"><pre><span></span><code> <span class="bp">#</span><span class="n">reduce</span> <span class="n">number_of_day</span> <span class="n">weekday</span><span class="bp">.</span><span class="n">sunday</span>
</code></pre></div>


<p>gives 1<br>
where does this follow from</p>



<a name="210658980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210658980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210658980">(Sep 20 2020 at 10:02)</a>:</h4>
<p>have you checked the type of <code>weekday.rec_on</code>?</p>



<a name="210659657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210659657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fames Yasd <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210659657">(Sep 20 2020 at 10:24)</a>:</h4>
<p>yes, </p>
<div class="codehilite"><pre><span></span><code><span class="n">weekday</span><span class="bp">.</span><span class="n">rec_on</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">weekday</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">weekday</span><span class="o">),</span>
    <span class="n">C</span> <span class="n">weekday</span><span class="bp">.</span><span class="n">sunday</span> <span class="bp">→</span>
    <span class="n">C</span> <span class="n">weekday</span><span class="bp">.</span><span class="n">monday</span> <span class="bp">→</span>
    <span class="n">C</span> <span class="n">weekday</span><span class="bp">.</span><span class="n">tuesday</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">weekday</span><span class="bp">.</span><span class="n">wednesday</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">weekday</span><span class="bp">.</span><span class="n">thursday</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">weekday</span><span class="bp">.</span><span class="n">friday</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">weekday</span><span class="bp">.</span><span class="n">saturday</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">n</span>
</code></pre></div>



<a name="210659728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210659728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210659728">(Sep 20 2020 at 10:27)</a>:</h4>
<p>so 1 corresponds to sunday</p>



<a name="210660414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210660414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fames Yasd <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210660414">(Sep 20 2020 at 10:45)</a>:</h4>
<p>I can only see that at the step when we are defining the function,<br>
I guess C weekday.sunday  is the same as nat so  we have a function from nat to something and we give it 1 to proceed to that something, in the similar way we give 2,3...7 and then we finally receice that our function has type weekday-&gt;nat<br>
formally I see that 1,2,3,..7 helps us to type-check to receive the needed type of our function<br>
that's what I get<br>
I don't get how it searches for 1 when we give sunday to it.<br>
maybe I can't wrap my mind around it because we are only dealing with the function type of .rec we don't know how .rec it acts on its type, I don't know<br>
I need some step by step explanation, <br>
we give sunday to our function, what happens to it first?</p>



<a name="210661431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210661431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210661431">(Sep 20 2020 at 11:06)</a>:</h4>
<p><span class="user-mention" data-user-id="216358">@Fames Yasd</span> what's happening is that <code>weekday.rec_on weekday.sunday A B C D E F G</code> reduces to <code>A</code></p>



<a name="210661735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210661735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fames Yasd <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210661735">(Sep 20 2020 at 11:13)</a>:</h4>
<p>so it's kinda given, ok</p>



<a name="210661744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210661744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fames Yasd <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210661744">(Sep 20 2020 at 11:13)</a>:</h4>
<p>thanks</p>



<a name="210664253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210664253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210664253">(Sep 20 2020 at 12:16)</a>:</h4>
<p>When you define an inductive type, lean generates a computation rule for each constructor. When you apply the recursor to an argument,  Lean will look at what constructor the argument is from and reduce the term using the corresponding rule.<br>
There might be a way to get Lean to show you the comp rule using meta.</p>



<a name="210664264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210664264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210664264">(Sep 20 2020 at 12:17)</a>:</h4>
<p>Pretty much it just does case analysis internally.</p>



<a name="210664535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210664535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fames Yasd <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210664535">(Sep 20 2020 at 12:23)</a>:</h4>
<p>wait, no, this is not ok<br>
how is one supposed to know what a function defined with .rec will do?<br>
For example,</p>
<div class="codehilite"><pre><span></span><code><span class="kn">namespace</span> <span class="n">my_space</span>

<span class="kn">inductive</span> <span class="n">nat</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span>

<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span>

<span class="n">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="bp">@</span><span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">nat</span><span class="o">)</span> <span class="n">n</span>
<span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="o">))</span>

<span class="kn">open</span> <span class="n">my_space</span><span class="bp">.</span><span class="n">nat</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">f</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="o">)</span>

<span class="n">def</span> <span class="n">f&#39;</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">zero</span>

<span class="kn">end</span> <span class="n">my_space</span>
</code></pre></div>


<p>Here, I have defined a function f:nat -&gt; nat that will map all natural number to zero, but I'm not sure that I have defined it the right way.<br>
I mean it seems to output zero at 1 that makes me think I have defined it the right way<br>
It's probably can be proven for it to be equal to f' too.<br>
After that there are no more questions but if it can be done that way, why would I need .rec anyway? Proving that it equals to another function is not an option.<br>
There must be some underlying rules that say exactly what nat.rec_on does.<br>
Like I am 100% sure about f type, it's nat-&gt;nat<br>
I am not sure about how it acts though.</p>



<a name="210664681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210664681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210664681">(Sep 20 2020 at 12:26)</a>:</h4>
<p>Yes, and you can see what they are from this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">C</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">rfl</span> <span class="o">:</span> <span class="bp">@</span><span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">C</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="n">z</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">rfl</span> <span class="o">:</span> <span class="bp">@</span><span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">C</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">z</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">s</span> <span class="n">n</span> <span class="o">(</span><span class="bp">@</span><span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">C</span> <span class="n">n</span> <span class="n">z</span> <span class="n">s</span><span class="o">))</span>
</code></pre></div>



<a name="210664745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210664745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210664745">(Sep 20 2020 at 12:28)</a>:</h4>
<p>The equations in the last two lines are the computation rules for <code>nat</code>, and because <code>rfl</code> checks at these types, they must be definitional equalities.</p>



<a name="210666126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210666126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210666126">(Sep 20 2020 at 12:58)</a>:</h4>
<p>maybe use the equation compiler instead of <code>rec</code></p>



<a name="210669766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210669766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210669766">(Sep 20 2020 at 14:40)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">they_are_equal</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f&#39;</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">funext</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="210711906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210711906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fames Yasd <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210711906">(Sep 21 2020 at 08:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span><br>
thanks, without them I don't think I would've figured out the definition of add<br>
I still can't figure out why<br>
<code>add m (succ n) </code> does not reduce to <code> succ add m n</code> but they can be proven to be equal with refl<br>
Still, where did you get these rules from?<br>
Is there some source where one can look general rules or some more information about inductive types?</p>



<a name="210718937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210718937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210718937">(Sep 21 2020 at 09:33)</a>:</h4>
<p>You can look at section 2.6 and in particular 2.6.4 of <a href="https://github.com/digama0/lean-type-theory/releases/download/v1.0/main.pdf">https://github.com/digama0/lean-type-theory/releases/download/v1.0/main.pdf</a>, but really, it's easiest to say:<br>
when you apply a recursor to a constructor, then a computation rule applies that reduces it to "the obvious thing",<br>
and just learn from examples what that obvious thing is (though there's really only one sensible possibility).</p>



<a name="210719177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210719177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210719177">(Sep 21 2020 at 09:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="216358">Fames Yasd</span> <a href="#narrow/stream/113489-new-members/topic/definition.20of.20rec/near/210711906">said</a>:</p>
<blockquote>
<p>I still can't figure out why<br>
<code>add m (succ n) </code> does not reduce to <code> succ add m n</code> but they can be proven to be equal with refl</p>
</blockquote>
<p>Are you sure you have this right? If two things can be proven equal with refl then they should reduce to the same thing, and <code>succ (add m n)</code> doesn't reduce.</p>



<a name="210724417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210724417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fames Yasd <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210724417">(Sep 21 2020 at 10:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/definition.20of.20rec/near/210719177">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="216358">Fames Yasd</span> <a href="#narrow/stream/113489-new-members/topic/definition.20of.20rec/near/210711906">said</a>:</p>
<blockquote>
<p>I still can't figure out why<br>
<code>add m (succ n) </code> does not reduce to <code> succ add m n</code> but they can be proven to be equal with refl</p>
</blockquote>
<p>Are you sure you have this right? If two things can be proven equal with refl then they should reduce to the same thing, and <code>succ (add m n)</code> doesn't reduce.</p>
</blockquote>
<p>I have here </p>
<div class="codehilite"><pre><span></span><code><span class="kn">namespace</span> <span class="n">my_space</span>

<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">implicit</span> <span class="n">true</span>
<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">structure_projections</span> <span class="n">false</span>

<span class="kn">inductive</span> <span class="n">nat</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span>

<span class="kn">open</span> <span class="n">my_space</span><span class="bp">.</span><span class="n">nat</span>

<span class="kn">definition</span> <span class="n">add</span> <span class="o">:</span> <span class="n">my_space</span><span class="bp">.</span><span class="n">nat</span> <span class="bp">→</span> <span class="n">my_space</span><span class="bp">.</span><span class="n">nat</span> <span class="bp">→</span> <span class="n">my_space</span><span class="bp">.</span><span class="n">nat</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
<span class="bp">@</span><span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">nat</span><span class="o">)</span> <span class="n">n</span> <span class="n">m</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">my_space</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">y</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">add</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">C</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="o">)</span>
<span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>

<span class="kn">variable</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>


<span class="kn">theorem</span> <span class="n">add_zero</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">add</span> <span class="n">m</span> <span class="n">zero</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">theorem</span> <span class="n">add_succ</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">add</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">add</span> <span class="n">m</span> <span class="n">zero</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">add</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">end</span> <span class="n">my_space</span>
</code></pre></div>


<p>The last two theorems are somehow proved with rfl (I'm not sure how it works)<br>
but only the first reduce command reduces to what it should reduce to</p>



<a name="210724823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210724823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210724823">(Sep 21 2020 at 10:38)</a>:</h4>
<p>No, they both reduce--though I forgot that <code>succ (add m n)</code> reduces by replacing <code>add</code> by its definition.</p>



<a name="210724846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210724846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210724846">(Sep 21 2020 at 10:39)</a>:</h4>
<p>But if you just look at the first part of the output for <code>#reduce add m (succ n)</code>, it's <code>succ</code> not <code>add</code>.</p>



<a name="210725299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210725299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210725299">(Sep 21 2020 at 10:45)</a>:</h4>
<p>If you understand the equation compiler, you will understand <code>rec</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">namespace</span> <span class="n">my_space</span>

<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">implicit</span> <span class="n">true</span>
<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">structure_projections</span> <span class="n">false</span>

<span class="kn">inductive</span> <span class="n">nat</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span>

<span class="kn">open</span> <span class="n">my_space</span><span class="bp">.</span><span class="n">nat</span>

<span class="kn">definition</span> <span class="n">add</span> <span class="o">:</span> <span class="n">my_space</span><span class="bp">.</span><span class="n">nat</span> <span class="bp">→</span> <span class="n">my_space</span><span class="bp">.</span><span class="n">nat</span> <span class="bp">→</span> <span class="n">my_space</span><span class="bp">.</span><span class="n">nat</span>
<span class="bp">|</span> <span class="n">m</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span>     <span class="o">:=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="n">m</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">add_zero</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">add</span> <span class="n">m</span> <span class="n">zero</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">theorem</span> <span class="n">add_succ</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">add</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">add</span> <span class="n">m</span> <span class="n">zero</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">add</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">end</span> <span class="n">my_space</span>
</code></pre></div>



<a name="210726789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210726789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210726789">(Sep 21 2020 at 11:06)</a>:</h4>
<p>Isn't this kind of like "P and Q implies P"? These seem like foundational questions and in order to understand how the equation compiler works at a foundational level you have to understand <code>rec</code> and the computation rule first anyways.</p>



<a name="210727104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210727104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210727104">(Sep 21 2020 at 11:10)</a>:</h4>
<p>For me who basically learnt by osmosis, the equation compiler seems to be easier to understand than <code>rec</code>, and then <code>rec</code> is a lambda-calculus version of the equation compiler</p>



<a name="210728571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210728571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210728571">(Sep 21 2020 at 11:31)</a>:</h4>
<p>Right, that makes sense, but my impression (which could be wrong) is that <span class="user-mention" data-user-id="216358">@Fames Yasd</span> is specifically interested in how things work at a foundational level.</p>



<a name="210741993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/definition%20of%20rec/near/210741993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fames Yasd <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/definition.20of.20rec.html#210741993">(Sep 21 2020 at 13:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/definition.20of.20rec/near/210728571">said</a>:</p>
<blockquote>
<p>Right, that makes sense, but my impression (which could be wrong) is that <span class="user-mention silent" data-user-id="216358">Fames Yasd</span> is specifically interested in how things work at a foundational level.</p>
</blockquote>
<p>No, you are 100% correct.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>